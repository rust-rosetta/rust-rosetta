[
  {
    "local_code": "extern crate num;\n\nuse std::f64;\nuse std::iter::Map;\nuse std::ops::Range;\n\ntype DoorIter = Map<Range<u32>, fn(u32) -> DoorState>;\n\n#[derive(Debug, PartialEq)]\nenum DoorState {\n    Open,\n    Closed,\n}\n\n// This is an example of returning an iterator, this allows the caller to\n// choose if they want to allocate or just process as a stream.\nfn calculate_doors() -> DoorIter {\n    fn door_status(door_number: u32) -> DoorState {\n        let x = f64::from(door_number).sqrt();\n        if (x - x.round()).abs() < f64::EPSILON {\n            DoorState::Open\n        } else {\n            DoorState::Closed\n        }\n    }\n\n    (1u32..101).map(door_status as fn(u32) -> DoorState)\n}\n\nfn main() {\n    let doors = calculate_doors();\n    for (i, x) in doors.enumerate() {\n        println!(\"Door {} is {:?}\", i + 1, x);\n    }\n}\n\n#[test]\nfn solution() {\n    let doors = calculate_doors().collect::<Vec<DoorState>>();\n\n    // test that the doors with index corresponding to\n    // a perfect square are now open\n    for i in 1..11 {\n        assert_eq!(doors[i * i - 1], DoorState::Open);\n    }\n}\n//! this is the unoptimized version that performs all 100\n//! passes, as per the original description of the problem\n\nfn main() {\n    // states for the 100 doors\n    // uses a vector of booleans,\n    // where state==false means the door is closed\n    let mut doors = [false; 100];\n    solve(&mut doors);\n\n    for (idx, door) in doors.iter().enumerate() {\n        println!(\"door {} open: {}\", idx + 1, door);\n    }\n}\n\n/// unoptimized solution for the 100 Doors problem,\n/// performs all 100 passes and mutates the vector with\n/// the states in place\nfn solve(doors: &mut [bool]) {\n    for pass in 1..101 {\n        let mut p = pass;\n        while p <= 100 {\n            // flip the state of the door\n            doors[p - 1] = !doors[p - 1];\n            p += pass;\n        }\n    }\n}\n\n#[test]\nfn solution() {\n    let mut doors = [false; 100];\n    solve(&mut doors);\n\n    // test that the doors with index corresponding to\n    // a perfect square are now open\n    for i in 1..11 {\n        assert!(doors[i * i - 1]);\n    }\n}\n",
    "path": "tasks/_100-doors",
    "remote_code": "fn main() {\n    let mut door_open = [false; 100];\n    for pass in 1..101 {\n        let mut door = pass;\n        while door <= 100 {\n            door_open[door - 1] = !door_open[door - 1];\n            door += pass;\n        }\n    }\n    for (i, &is_open) in door_open.iter().enumerate() {\n        println!(\"Door {} is {}.\", i + 1, if is_open {\"open\"} else {\"closed\"});\n    }\n}",
    "title": "100 doors",
    "url": "http://rosettacode.org/wiki/100_doors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "100 prisoners",
    "url": "http://rosettacode.org/wiki/100_prisoners"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::collections::HashMap;\nuse std::fmt;\n\nuse rand::distributions::{Distribution, Standard};\nuse rand::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug)]\nenum Cell {\n    Card(usize),\n    Empty,\n}\n\n#[derive(Eq, PartialEq, Hash, Debug)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\nenum Action {\n    Move(Direction),\n    Quit,\n}\n\ntype Board = [Cell; 16];\nconst EMPTY: Board = [Cell::Empty; 16];\n\nstruct P15 {\n    board: Board,\n}\n\nimpl Distribution<P15> for Standard {\n    // TODO: make the board valid right from the start.\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> P15 {\n        let mut board = EMPTY;\n        for (i, cell) in board.iter_mut().enumerate().skip(1) {\n            *cell = Cell::Card(i);\n        }\n\n        board.shuffle(rng);\n\n        if !P15::is_valid(board) {\n            // random swap\n            // NOTE: because 16 is a power of two, we could use the faster\n            // modulo reduction (`n % 16`) without bias; `gen_range` is\n            // presented here for the general case.\n            let i = rng.gen_range(0, 16);\n            let mut j = rng.gen_range(0, 16);\n            while j == i {\n                j = rng.gen_range(0, 16);\n            }\n            board.swap(i, j);\n        }\n        debug_assert!(P15::is_valid(board));\n\n        P15 { board }\n    }\n}\n\nimpl P15 {\n    // TODO: optimize\n    fn is_valid(mut board: Board) -> bool {\n        let mut permutations = 0;\n\n        let pos = board.iter().position(|&cell| cell == Cell::Empty).unwrap();\n\n        if pos != 15 {\n            board.swap(pos, 15);\n            permutations += 1;\n        }\n\n        for i in 1..16 {\n            let pos = board\n                .iter()\n                .position(|&cell| matches!(cell, Cell::Card(value) if value == i))\n                .unwrap();\n\n            if pos + 1 != i {\n                board.swap(pos, i - 1);\n                permutations += 1;\n            }\n        }\n\n        permutations % 2 == 0\n    }\n\n    fn get_empty_position(&self) -> usize {\n        self.board.iter().position(|&c| c == Cell::Empty).unwrap()\n    }\n\n    fn get_moves(&self) -> HashMap<Direction, Cell> {\n        let mut moves = HashMap::new();\n        let i = self.get_empty_position();\n\n        if i > 3 {\n            moves.insert(Direction::Up, self.board[i - 4]);\n        }\n        if i % 4 != 0 {\n            moves.insert(Direction::Left, self.board[i - 1]);\n        }\n        if i < 12 {\n            moves.insert(Direction::Down, self.board[i + 4]);\n        }\n        if i % 4 != 3 {\n            moves.insert(Direction::Right, self.board[i + 1]);\n        }\n        moves\n    }\n\n    fn play(&mut self, direction: &Direction) {\n        let i = self.get_empty_position();\n        // This is safe because `ask_action` only returns legal moves\n        match *direction {\n            Direction::Up => self.board.swap(i, i - 4),\n            Direction::Left => self.board.swap(i, i - 1),\n            Direction::Right => self.board.swap(i, i + 1),\n            Direction::Down => self.board.swap(i, i + 4),\n        };\n    }\n\n    fn is_complete(&self) -> bool {\n        self.board.iter().enumerate().all(|(i, &cell)| match cell {\n            Cell::Card(value) => value == i + 1,\n            Cell::Empty => i == 15,\n        })\n    }\n}\n\nimpl fmt::Display for P15 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        writeln!(f, \"+----+----+----+----+\")?;\n        for (i, &cell) in self.board.iter().enumerate() {\n            match cell {\n                Cell::Card(value) => write!(f, \"| {:2} \", value)?,\n                Cell::Empty => write!(f, \"|    \")?,\n            };\n\n            if i % 4 == 3 {\n                writeln!(f, \"|\")?;\n                writeln!(f, \"+----+----+----+----+\")?;\n            }\n        }\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut p15: P15 = rand::random();\n\n    for turns in 1.. {\n        println!(\"{}\", p15);\n        match ask_action(&p15.get_moves()) {\n            Action::Move(direction) => {\n                p15.play(&direction);\n            }\n            Action::Quit => {\n                println!(\"Bye !\");\n                break;\n            }\n        }\n\n        if p15.is_complete() {\n            println!(\"Well done ! You won in {} turns\", turns);\n            break;\n        }\n    }\n}\n\nfn ask_action(moves: &HashMap<Direction, Cell>) -> Action {\n    use std::io::{self, Write};\n    use Action::*;\n    use Direction::*;\n\n    println!(\"Possible moves:\");\n\n    if let Some(&Cell::Card(value)) = moves.get(&Up) {\n        println!(\"\\tU) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Left) {\n        println!(\"\\tL) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Right) {\n        println!(\"\\tR) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Down) {\n        println!(\"\\tD) {}\", value);\n    }\n    println!(\"\\tQ) Quit\");\n    print!(\"Choose your move : \");\n    io::stdout().flush().unwrap();\n\n    let mut action = String::new();\n    io::stdin().read_line(&mut action).expect(\"read error\");\n    match action.to_uppercase().trim() {\n        \"U\" if moves.contains_key(&Up) => Move(Up),\n        \"L\" if moves.contains_key(&Left) => Move(Left),\n        \"R\" if moves.contains_key(&Right) => Move(Right),\n        \"D\" if moves.contains_key(&Down) => Move(Down),\n        \"Q\" => Quit,\n        _ => {\n            println!(\"Unknown action: {}\", action);\n            ask_action(moves)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn board_from_ints(ints: &[usize; 16]) -> Board {\n        let mut board = EMPTY;\n        for (cell, &int) in board.iter_mut().zip(ints.iter()) {\n            *cell = if int == 0 {\n                Cell::Empty\n            } else {\n                Cell::Card(int)\n            }\n        }\n        board\n    }\n\n    fn make_valid<R: Rng>(rng: &mut R, mut board: Board) -> Board {\n        // get 2 indices from a single random byte\n        let rand_byte = rng.gen::<u8>() as usize;\n        // modulo reduction for test speed\n        let i = rand_byte % 16;\n        let mut j = rand_byte >> (8 - 2);\n\n        while j == i {\n            j = rng.gen::<u8>() as usize % 16; // rng.gen_range(0, 16);\n        }\n        board.swap(i, j);\n        board\n    }\n\n    #[test]\n    fn board_creation() {\n        let p15: P15 = rand::random();\n        assert!(P15::is_valid(p15.board));\n    }\n\n    #[test]\n    fn board_validity() {\n        let mut rng = thread_rng();\n\n        fn assert_is_valid(ints: &[usize; 16]) {\n            let board = board_from_ints(ints);\n            assert!(P15::is_valid(board));\n        }\n\n        fn assert_is_not_valid<R: Rng>(rng: &mut R, ints: &[usize; 16]) {\n            let board = board_from_ints(ints);\n            assert!(!P15::is_valid(board));\n            assert!(P15::is_valid(make_valid(rng, board)));\n        }\n\n        assert_is_not_valid(\n            &mut rng,\n            &[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[13, 10, 11, 6, 5, 7, 4, 8, 1, 12, 14, 9, 3, 15, 2, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 14, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[2, 1, 3, 4, 5, 8, 7, 6, 9, 10, 12, 11, 15, 13, 14, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[4, 15, 7, 9, 3, 12, 1, 8, 5, 0, 11, 2, 13, 6, 10, 14],\n        );\n\n        assert_is_valid(&[7, 1, 3, 14, 6, 0, 4, 8, 5, 9, 13, 2, 12, 15, 11, 10]);\n        assert_is_valid(&[7, 9, 1, 14, 6, 0, 13, 10, 8, 3, 12, 4, 15, 5, 2, 11]);\n        assert_is_valid(&[15, 8, 9, 14, 5, 10, 1, 0, 12, 4, 3, 13, 11, 2, 7, 6]);\n        assert_is_valid(&[1, 12, 4, 8, 10, 7, 2, 11, 6, 3, 15, 14, 9, 13, 5, 0]);\n    }\n\n    #[test]\n    fn directions() {\n        fn get_puzzle_moves(ints: &[usize; 16]) -> HashMap<Direction, Cell> {\n            let board = board_from_ints(ints);\n            let puzzle = P15 { board };\n            puzzle.get_moves()\n        }\n\n        let mut test = HashMap::new();\n        test.insert(Direction::Up, Cell::Card(12));\n        test.insert(Direction::Left, Cell::Card(15));\n        let moves = get_puzzle_moves(&[13, 6, 8, 3, 1, 5, 2, 4, 9, 7, 10, 12, 14, 11, 15, 0]);\n        assert_eq!(moves, test);\n\n        let mut test = HashMap::new();\n        test.insert(Direction::Up, Cell::Card(12));\n        test.insert(Direction::Left, Cell::Card(14));\n        test.insert(Direction::Right, Cell::Card(8));\n        test.insert(Direction::Down, Cell::Card(15));\n        let moves = get_puzzle_moves(&[7, 12, 2, 1, 14, 0, 8, 13, 3, 15, 4, 6, 11, 5, 10, 9]);\n        assert_eq!(moves, test);\n    }\n\n    #[test]\n    fn victory() {\n        let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];\n        let board = board_from_ints(&input);\n        let puzzle = P15 { board };\n        assert!(puzzle.is_complete());\n    }\n}\n",
    "path": "tasks/_15-puzzle-game",
    "remote_code": "extern crate rand;\n \nuse std::collections::HashMap;\nuse std::fmt;\n \nuse rand::Rng;\nuse rand::seq::SliceRandom;\n \n#[derive(Copy, Clone, PartialEq, Debug)]\nenum Cell {\n    Card(usize),\n    Empty,\n}\n \n#[derive(Eq, PartialEq, Hash, Debug)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n \nenum Action {\n    Move(Direction),\n    Quit,\n}\n \ntype Board = [Cell; 16];\nconst EMPTY: Board = [Cell::Empty; 16];\n \nstruct P15 {\n    board: Board,\n}\n \nimpl P15 {\n    fn new() -> Self {\n        let mut board = EMPTY;\n        for (i, cell) in board.iter_mut().enumerate().skip(1) {\n            *cell = Cell::Card(i);\n        }\n \n        let mut rng = rand::thread_rng();\n \n        board.shuffle(&mut rng);\n        if !Self::is_valid(board) {\n            // random swap\n            let i = rng.gen_range(0, 16);\n            let mut j = rng.gen_range(0, 16);\n            while j == i {\n                j = rng.gen_range(0, 16);\n            }\n            board.swap(i, j);\n        }\n \n        Self { board }\n    }\n \n    fn is_valid(mut board: Board) -> bool {\n        // TODO: optimize\n        let mut permutations = 0;\n \n        let pos = board.iter().position(|&cell| cell == Cell::Empty).unwrap();\n \n        if pos != 15 {\n            board.swap(pos, 15);\n            permutations += 1;\n        }\n \n        for i in 1..16 {\n            let pos = board\n                .iter()\n                .position(|&cell| match cell {\n                    Cell::Card(value) if value == i => true,\n                    _ => false,\n                })\n                .unwrap();\n \n            if pos + 1 != i {\n                board.swap(pos, i - 1);\n                permutations += 1;\n            }\n        }\n \n        permutations % 2 == 0\n    }\n \n    fn get_empty_position(&self) -> usize {\n        self.board.iter().position(|&c| c == Cell::Empty).unwrap()\n    }\n \n    fn get_moves(&self) -> HashMap<Direction, Cell> {\n        let mut moves = HashMap::new();\n        let i = self.get_empty_position();\n \n        if i > 3 {\n            moves.insert(Direction::Up, self.board[i - 4]);\n        }\n        if i % 4 != 0 {\n            moves.insert(Direction::Left, self.board[i - 1]);\n        }\n        if i < 12 {\n            moves.insert(Direction::Down, self.board[i + 4]);\n        }\n        if i % 4 != 3 {\n            moves.insert(Direction::Right, self.board[i + 1]);\n        }\n        moves\n    }\n \n    fn play(&mut self, direction: &Direction) {\n        let i = self.get_empty_position();\n        // This is safe because `ask_action` only returns legal moves\n        match *direction {\n            Direction::Up => self.board.swap(i, i - 4),\n            Direction::Left => self.board.swap(i, i - 1),\n            Direction::Right => self.board.swap(i, i + 1),\n            Direction::Down => self.board.swap(i, i + 4),\n        };\n    }\n \n    fn is_complete(&self) -> bool {\n        self.board.iter().enumerate().all(|(i, &cell)| match cell {\n            Cell::Card(value) => value == i + 1,\n            Cell::Empty => i == 15,\n        })\n    }\n}\n \nimpl fmt::Display for P15 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        r#try!(write!(f, \"+----+----+----+----+\\n\"));\n        for (i, &cell) in self.board.iter().enumerate() {\n            match cell {\n                Cell::Card(value) => r#try!(write!(f, \"| {:2} \", value)),\n                Cell::Empty => r#try!(write!(f, \"|    \")),\n            }\n \n            if i % 4 == 3 {\n                r#try!(write!(f, \"|\\n\"));\n                r#try!(write!(f, \"+----+----+----+----+\\n\"));\n            }\n        }\n        Ok(())\n    }\n}\n \nfn main() {\n    let mut p15 = P15::new();\n \n    for turns in 1.. {\n        println!(\"{}\", p15);\n        match ask_action(&p15.get_moves()) {\n            Action::Move(direction) => {\n                p15.play(&direction);\n            }\n            Action::Quit => {\n                println!(\"Bye !\");\n                break;\n            }\n        }\n \n        if p15.is_complete() {\n            println!(\"Well done ! You won in {} turns\", turns);\n            break;\n        }\n    }\n}\n \nfn ask_action(moves: &HashMap<Direction, Cell>) -> Action {\n    use std::io::{self, Write};\n    use Action::*;\n    use Direction::*;\n \n    println!(\"Possible moves:\");\n \n    if let Some(&Cell::Card(value)) = moves.get(&Up) {\n        println!(\"\\tU) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Left) {\n        println!(\"\\tL) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Right) {\n        println!(\"\\tR) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Down) {\n        println!(\"\\tD) {}\", value);\n    }\n    println!(\"\\tQ) Quit\");\n    print!(\"Choose your move : \");\n    io::stdout().flush().unwrap();\n \n    let mut action = String::new();\n    io::stdin().read_line(&mut action).expect(\"read error\");\n    match action.to_uppercase().trim() {\n        \"U\" if moves.contains_key(&Up) => Move(Up),\n        \"L\" if moves.contains_key(&Left) => Move(Left),\n        \"R\" if moves.contains_key(&Right) => Move(Right),\n        \"D\" if moves.contains_key(&Down) => Move(Down),\n        \"Q\" => Quit,\n        _ => {\n            println!(\"Unknown action: {}\", action);\n            ask_action(moves)\n        }\n    }\n}",
    "title": "15 puzzle game",
    "url": "http://rosettacode.org/wiki/15_puzzle_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const NR: [i32; 16] = [3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3];\nconst NC: [i32; 16] = [3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2];\n\nconst I: u8 = 1;\nconst G: u8 = 8;\nconst E: u8 = 2;\nconst L: u8 = 4;\n\nstruct FifteenSolver {\n    n: usize,\n    limit: usize,\n    n0: [i32; 85],\n    n3: [u8; 85],\n    n4: [usize; 85],\n    n2: [u64; 85],\n}\n\nimpl FifteenSolver {\n    fn f_y(&mut self) -> bool {\n        if self.n2[self.n] == 0x123456789abcdef0 {\n            return true;\n        }\n        if self.n4[self.n] <= self.limit {\n            return self.f_n();\n        }\n        false\n    }\n\n    fn f_z(&mut self, w: u8) -> bool {\n        if w & I != 0 {\n            self.f_i();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & G != 0 {\n            self.f_g();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & E != 0 {\n            self.f_e();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & L != 0 {\n            self.f_l();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        false\n    }\n\n    fn f_n(&mut self) -> bool {\n        self.f_z(match self.n0[self.n] {\n            0 => match self.n3[self.n] {\n                b'l' => I,\n                b'u' => E,\n                _ => I + E,\n            },\n            3 => match self.n3[self.n] {\n                b'r' => I,\n                b'u' => L,\n                _ => I + L,\n            },\n            1 | 2 => match self.n3[self.n] {\n                b'l' => I + L,\n                b'r' => I + E,\n                b'u' => E + L,\n                _ => L + E + I,\n            },\n            12 => match self.n3[self.n] {\n                b'l' => G,\n                b'd' => E,\n                _ => E + G,\n            },\n            15 => match self.n3[self.n] {\n                b'r' => G,\n                b'd' => L,\n                _ => G + L,\n            },\n            13 | 14 => match self.n3[self.n] {\n                b'l' => G + L,\n                b'r' => E + G,\n                b'd' => E + L,\n                _ => G + E + L,\n            },\n            4 | 8 => match self.n3[self.n] {\n                b'l' => I + G,\n                b'u' => G + E,\n                b'd' => I + E,\n                _ => I + G + E,\n            },\n            7 | 11 => match self.n3[self.n] {\n                b'd' => I + L,\n                b'u' => G + L,\n                b'r' => I + G,\n                _ => I + G + L,\n            },\n            _ => match self.n3[self.n] {\n                b'd' => I + E + L,\n                b'l' => I + G + L,\n                b'r' => I + G + E,\n                b'u' => G + E + L,\n                _ => I + G + E + L,\n            },\n        })\n    }\n\n    fn f_i(&mut self) {\n        let g = (11 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] + 4;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a << 16);\n        self.n3[self.n + 1] = b'd';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NR[(a >> g) as usize] <= self.n0[self.n] / 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;;\n        }\n        self.n += 1;\n    }\n\n    fn f_g(&mut self) {\n        let g = (19 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] - 4;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a >> 16);\n        self.n3[self.n + 1] = b'u';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NR[(a >> g) as usize] >= self.n0[self.n] / 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn f_e(&mut self) {\n        let g = (14 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] + 1;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a << 4);\n        self.n3[self.n + 1] = b'r';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NC[(a >> g) as usize] <= self.n0[self.n] % 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn f_l(&mut self) {\n        let g = (16 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] - 1;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a >> 4);\n        self.n3[self.n + 1] = b'l';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NC[(a >> g) as usize] >= self.n0[self.n] % 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn new(n: i32, g: u64) -> Self {\n        let mut solver = FifteenSolver {\n            n: 0,\n            limit: 0,\n            n0: [0; 85],\n            n3: [0; 85],\n            n4: [0; 85],\n            n2: [0; 85],\n        };\n        solver.n0[0] = n;\n        solver.n2[0] = g;\n        solver\n    }\n\n    fn solve(&mut self) {\n        while !self.f_n() {\n            self.n = 0;\n            self.limit += 1;\n        }\n        println!(\n            \"Solution found in {} moves: {}\",\n            self.n,\n            std::str::from_utf8(&self.n3[1..=self.n]).unwrap()\n        );\n    }\n}\n\nfn main() {\n    FifteenSolver::new(8, 0xfe169b4c0a73d852).solve();\n}",
    "title": "15 puzzle solver",
    "url": "http://rosettacode.org/wiki/15_puzzle_solver"
  },
  {
    "local_code": "use std::convert::TryFrom;\nuse std::error::Error;\nuse std::io::{self, Write};\nuse std::ops::{Index, IndexMut};\n\nuse crossterm::{\n    cursor::{Hide, MoveTo, Show},\n    event::{self, Event, KeyCode},\n    execute, queue,\n    style::{Attribute, Color, Print, ResetColor, SetAttribute, SetForegroundColor},\n    terminal::{self, Clear, ClearType},\n};\nuse rand::prelude::*;\n\nconst GRID_DIMENSION: usize = 4;\n\n/// A key press.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nenum Key {\n    Up,\n    Left,\n    Down,\n    Right,\n    Quit,\n}\n\n#[derive(Debug, PartialEq)]\nenum State {\n    Playing,\n    Won,\n    Lost,\n}\n\n/// Error returned when the grid is full.\n#[derive(Debug)]\nstruct GridFullError;\n\n/// Error returned when no tiles were actually moved.\n#[derive(Debug)]\nstruct NoTilesMovedError;\n\n/// An optionally filled tile in the grid.\ntype Tile = Option<u32>;\n\n/// The set of game tiles.\n#[derive(Debug, PartialEq, Eq)]\nstruct Grid([[Tile; GRID_DIMENSION]; GRID_DIMENSION]);\n\nimpl Index<(usize, usize)> for Grid {\n    type Output = Tile;\n\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\n        &self.0[x][y]\n    }\n}\n\nimpl IndexMut<(usize, usize)> for Grid {\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\n        &mut self.0[x][y]\n    }\n}\n\nimpl Grid {\n    fn new() -> Self {\n        Grid([[None; GRID_DIMENSION]; GRID_DIMENSION])\n    }\n\n    fn is_move_available(&self) -> bool {\n        for x in 0..4 {\n            for y in 0..4 {\n                if self[(x, y)].is_none() {\n                    return true;\n                }\n                if x < 3 && self[(x + 1, y)] == self[(x, y)] {\n                    return true;\n                };\n                if x > 0 && self[(x - 1, y)] == self[(x, y)] {\n                    return true;\n                };\n                if y < 3 && self[(x, y + 1)] == self[(x, y)] {\n                    return true;\n                };\n                if y > 0 && self[(x, y - 1)] == self[(x, y)] {\n                    return true;\n                };\n            }\n        }\n        false\n    }\n\n    fn spawn_tile(&mut self) -> Result<(), GridFullError> {\n        if !self.is_move_available() {\n            return Err(GridFullError);\n        }\n\n        let mut rng = thread_rng();\n\n        loop {\n            // `GRID_DIMENSION` is a power of two so modulo reduction is\n            // unbiased. Because we only need 2 bits, we can just generate a\n            // `u8` and split the bits. This is faster than generating two\n            // `usize` values.\n            let r = rng.gen::<u8>() as usize;\n            let rand_tile = &mut self[(r % GRID_DIMENSION, r >> (8 - 2))];\n\n            if rand_tile.is_none() {\n                let tile = if rng.gen_bool(1.0 / 10.0) { 4 } else { 2 };\n                *rand_tile = Some(tile);\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Given a slice of tiles, shifts and merges the tiles towards the left end of the vector.\n    ///\n    /// Returns a tuple containing the new vector and the change in score.\n    fn merge(vector: &[Tile]) -> (Vec<Tile>, u32) {\n        // Remove intermediate empty tiles.\n        let mut shifted = vector.iter().filter_map(|&x| x).collect::<Vec<_>>();\n\n        // Merge tiles that are next to each other, leaving an empty space.\n        let mut score = 0;\n        for i in 0..shifted.len() {\n            if i + 1 < shifted.len() && shifted[i + 1] == shifted[i] {\n                shifted[i] *= 2;\n                shifted[i + 1] = 0;\n                score += shifted[i];\n            }\n        }\n\n        // Remove intermediate empty tiles\n        let mut shifted = shifted\n            .into_iter()\n            .filter(|&x| x != 0)\n            .map(Some)\n            .collect::<Vec<_>>();\n\n        // Fill remaining array.\n        let len = shifted.len();\n        shifted.extend(std::iter::repeat(None).take(GRID_DIMENSION - len));\n\n        (shifted, score)\n    }\n\n    /// Shift tiles left.\n    fn shift_left(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for row in 0..GRID_DIMENSION {\n            let tiles: Vec<_> = (0..GRID_DIMENSION).map(|col| self[(row, col)]).collect();\n\n            let (merged_row, row_score) = Grid::merge(&tiles);\n            score += row_score;\n            if !moved && tiles != merged_row {\n                moved = true;\n            }\n\n            for (col, tile) in merged_row.iter().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles up.\n    fn shift_up(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for col in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for row in 0..GRID_DIMENSION {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_col, col_score) = Grid::merge(&tiles);\n            score += col_score;\n            if !moved && tiles != merged_col {\n                moved = true;\n            }\n\n            for (row, tile) in merged_col.iter().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles down.\n    fn shift_down(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for col in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for row in (0..GRID_DIMENSION).rev() {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_col, col_score) = Grid::merge(&tiles);\n            score += col_score;\n            if !moved && tiles != merged_col {\n                moved = true;\n            }\n\n            for (row, tile) in merged_col.iter().rev().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles down.\n    fn shift_right(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for row in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for col in (0..GRID_DIMENSION).rev() {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_row, row_score) = Grid::merge(&tiles);\n            score += row_score;\n            if !moved && tiles != merged_row {\n                moved = true;\n            }\n\n            for (col, tile) in merged_row.iter().rev().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n}\n\nstruct Game {\n    grid: Grid,\n    state: State,\n    score: u32,\n}\n\nimpl Game {\n    fn new() -> Self {\n        let mut g = Game {\n            grid: Grid::new(),\n            state: State::Playing,\n            score: 0,\n        };\n\n        for _ in 0..2 {\n            g.grid.spawn_tile().unwrap();\n        }\n\n        g\n    }\n\n    fn step(&mut self, key: Key) {\n        match key {\n            key if self.state != State::Lost => {\n                let move_result = match key {\n                    Key::Up => self.grid.shift_up(),\n                    Key::Down => self.grid.shift_down(),\n                    Key::Left => self.grid.shift_left(),\n                    Key::Right => self.grid.shift_right(),\n                    _ => unreachable!(),\n                };\n\n                if let Ok(score) = move_result {\n                    self.add_score(score);\n                    self.grid.spawn_tile().unwrap();\n                }\n\n                if !self.grid.is_move_available() {\n                    self.state = State::Lost;\n                }\n            }\n            _ => (),\n        }\n    }\n\n    fn add_score(&mut self, score: u32) {\n        self.score += score;\n        if score == 2048 {\n            self.state = State::Won;\n        }\n    }\n}\n\nfn wait_key() -> crossterm::Result<Key> {\n    loop {\n        if let Event::Key(key) = event::read()? {\n            let key = match key.code {\n                KeyCode::Char('q') => Key::Quit,\n                KeyCode::Up => Key::Up,\n                KeyCode::Down => Key::Down,\n                KeyCode::Left => Key::Left,\n                KeyCode::Right => Key::Right,\n                _ => continue,\n            };\n\n            return Ok(key);\n        }\n    }\n}\n\nfn draw<W>(w: &mut W, game: &Game) -> crossterm::Result<()>\nwhere\n    W: Write,\n{\n    queue!(\n        w,\n        Hide,\n        Clear(ClearType::All),\n        MoveTo(16, 1),\n        Print(format!(\"Score: {}\", game.score)),\n    )?;\n\n    const CELL_WIDTH: u16 = 10;\n    const CELL_HEIGHT: u16 = 5;\n    const GRID_X_OFFSET: u16 = 0;\n    const GRID_Y_OFFSET: u16 = 2;\n\n    for row in 0u16..4 {\n        for col in 0u16..4 {\n            let tile = game.grid[(usize::from(row), usize::from(col))];\n            let x = 1 + GRID_X_OFFSET + col * CELL_WIDTH;\n            let y = GRID_Y_OFFSET + row * CELL_HEIGHT;\n\n            queue!(w, MoveTo(x, y), Print(\"┌────────┐\"))?;\n\n            for i in 1..=3 {\n                let y = y + i;\n                queue!(w, MoveTo(x, y), Print(\"│        │\"))?;\n            }\n\n            if let Some(value) = tile {\n                let text_x =\n                    x + CELL_WIDTH / 2 - (1 + u16::try_from(value.to_string().len()).unwrap() / 3);\n                let text_y = y + CELL_HEIGHT / 2;\n\n                queue!(\n                    w,\n                    MoveTo(text_x, text_y),\n                    SetAttribute(Attribute::Bold),\n                    SetForegroundColor(Color::White),\n                    Print(value),\n                    ResetColor,\n                )?;\n            }\n\n            queue!(w, MoveTo(x, y + 4), Print(\"└────────┘\"))?;\n        }\n    }\n\n    match game.state {\n        State::Won => queue!(w, MoveTo(16, 12), Print(\"You won!\"))?,\n        State::Lost => queue!(w, MoveTo(16, 12), Print(\"You lost!\"))?,\n        _ => (),\n    }\n\n    queue!(w, MoveTo(14, 22), Print(\"←,↑,→,↓ or q\"))?;\n\n    w.flush()?;\n\n    Ok(())\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let stdout = io::stdout();\n    let mut stdout = stdout.lock();\n    let mut game = Game::new();\n\n    terminal::enable_raw_mode()?;\n\n    loop {\n        draw(&mut stdout, &game)?;\n\n        let key = wait_key()?;\n        if let Key::Quit = key {\n            break;\n        }\n        game.step(key);\n    }\n\n    execute!(stdout, Show)?;\n    terminal::disable_raw_mode()?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Grid, GRID_DIMENSION};\n\n    #[test]\n    fn merge() {\n        let test_cases = [\n            ([None, None, None, None], [None, None, None, None]),\n            ([None, None, None, Some(2)], [Some(2), None, None, None]),\n            ([None, None, Some(2), Some(2)], [Some(4), None, None, None]),\n            ([None, Some(2), None, Some(2)], [Some(4), None, None, None]),\n            ([Some(2), None, None, Some(2)], [Some(4), None, None, None]),\n            ([Some(2), None, Some(2), None], [Some(4), None, None, None]),\n            (\n                [Some(2), Some(2), Some(2), None],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), None, Some(2), Some(2)],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), Some(2), None, Some(2)],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), Some(2), Some(2), Some(2)],\n                [Some(4), Some(4), None, None],\n            ),\n            (\n                [Some(4), Some(4), Some(2), Some(2)],\n                [Some(8), Some(4), None, None],\n            ),\n            (\n                [Some(2), Some(2), Some(4), Some(4)],\n                [Some(4), Some(8), None, None],\n            ),\n            (\n                [Some(8), None, Some(2), Some(2)],\n                [Some(8), Some(4), None, None],\n            ),\n            (\n                [Some(4), None, Some(2), Some(2)],\n                [Some(4), Some(4), None, None],\n            ),\n        ];\n\n        for &(candidate, expected) in &test_cases {\n            let (merged, _) = Grid::merge(&candidate);\n            assert_eq!(&merged, &expected);\n        }\n    }\n\n    #[test]\n    fn directions() {\n        let mut grid = Grid::new();\n        grid[(0, 0)] = Some(2);\n\n        grid.shift_right().unwrap();\n        assert_eq!(grid[(0, GRID_DIMENSION - 1)], Some(2));\n        println!(\"{:?}\", grid);\n\n        grid.shift_down().unwrap();\n        assert_eq!(grid[(GRID_DIMENSION - 1, GRID_DIMENSION - 1)], Some(2));\n        println!(\"{:?}\", grid);\n\n        grid.shift_left().unwrap();\n        println!(\"{:?}\", grid);\n        assert_eq!(grid[(GRID_DIMENSION - 1, 0)], Some(2));\n\n        grid.shift_up().unwrap();\n        assert_eq!(grid[(0, 0)], Some(2));\n    }\n\n    #[test]\n    fn non_greedy_movement() {\n        let mut grid = Grid::new();\n        for i in 0..4 {\n            grid[(0, i)] = Some(2);\n        }\n\n        grid.shift_right().unwrap();\n\n        let mut expected_grid = Grid::new();\n        expected_grid[(0, 2)] = Some(4);\n        expected_grid[(0, 3)] = Some(4);\n        assert_eq!(grid, expected_grid);\n    }\n\n    #[test]\n    fn move_direction_priority() {\n        let mut grid = Grid::new();\n        for i in 1..4 {\n            grid[(0, i)] = Some(2);\n        }\n\n        grid.shift_right().unwrap();\n\n        let mut expected_grid = Grid::new();\n        expected_grid[(0, 2)] = Some(2);\n        expected_grid[(0, 3)] = Some(4);\n        assert_eq!(grid, expected_grid);\n    }\n}\n",
    "path": "tasks/_2048",
    "remote_code": "\nuse std::io::{self,BufRead};\nextern crate rand;\n\nenum Usermove {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\nfn print_game(field :& [[u32;4];4] ){\n    println!(\"{:?}\",&field[0] );\n    println!(\"{:?}\",&field[1] );\n    println!(\"{:?}\",&field[2] );\n    println!(\"{:?}\",&field[3] );\n}\n\nfn get_usermove()-> Usermove {\n    let umove: Usermove ;\n    loop{\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).unwrap();\n\n        match input.chars().nth(0){\n            Some('a') =>{umove = Usermove::Left ;break },\n            Some('w') =>{umove = Usermove::Up   ;break },\n            Some('s') =>{umove = Usermove::Down ;break },\n            Some('d') =>{umove = Usermove::Right;break },\n            _   => {println!(\"input was {}: invalid character should be a,s,w or d \",input.chars().nth(0).unwrap());} ,\n        }\n    }\n    umove\n}\n\n//this function inplements the user moves.\n//for every element it looks if the element is zero\n// if the element is zero it looks against the direction of the movement if any\n//element is not zero then it will move it to the element its place then it will look for\n//a matching element\n//  if the element is not zero then it will look for a match if no match is found\n// then it will look for the next element\n\nfn do_game_step(step : &Usermove, field:&mut [[u32;4];4]){\n    match *step {\n        Usermove::Left =>{\n            for array in field{\n                for  col in 0..4 {\n                    for testcol in (col+1)..4 {\n                        if array[testcol] != 0 {\n                            if array[col] == 0 {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                            }\n                            else if array[col] == array[testcol] {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                                break;\n                            } else {\n                                break\n                            }\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Right=>{\n            for array in field{\n                for  col in (0..4).rev() {\n                    for testcol in (0..col).rev() {\n                        if array[testcol] != 0 {\n                            if array[col] == 0 {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                            }\n                            else if array[col] == array[testcol] {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Down   =>{\n            for col in 0..4 {\n                for row in (0..4).rev() {\n                    for testrow in (0..row).rev() {\n                        if field[testrow][col] != 0 {\n                            if field[row][col] == 0 {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                            } else if field[row][col] == field[testrow][col] {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Up =>{\n            for col in 0..4 {\n                for row in 0..4{\n                    for testrow in (row+1)..4 {\n                        if field[testrow][col] != 0 {\n                            if field[row][col] == 0 {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                            } else if field[row][col] == field[testrow][col] {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        },\n    }\n}\n\nfn spawn( field: &mut  [[u32;4];4]){\n    loop{\n        let x = rand::random::<usize>();\n        if field[x % 4][(x/4)%4] == 0 {\n            if x % 10 == 0 {\n                field[x % 4][(x/4)%4]= 4;\n            }else{\n                field[x % 4][(x/4)%4]= 2;\n            }\n            break;\n        }\n    }\n}\n\n\nfn main() {\n    let mut field : [[u32; 4];4] =  [[0;4];4];\n    let mut test : [[u32; 4];4] ;\n    'gameloop:loop {\n        //check if there is still an open space\n        test=field.clone();\n        spawn(&mut field);\n        //if all possible moves do not yield a change then there is no valid move left\n        //and it will be game over\n        for i in [Usermove::Up,Usermove::Down,Usermove::Left,Usermove::Right].into_iter(){\n            do_game_step(i, &mut test);\n            if test != field{\n                break;//found a valid move\n            }\n            match *i{\n                Usermove::Right=> {\n                    println!(\"No more valid move, you lose\");\n                    break 'gameloop;\n                },\n                _=>{},\n            }\n        }\n        print_game(&field);\n        println!(\"move the blocks\");\n\n        test=field.clone();\n        while test==field {\n            do_game_step(&get_usermove(), &mut field);\n        }\n\n        for row in field.iter(){\n            if row.iter().any(|x| *x == 2048){\n                print_game(&field );\n                println!(\"You Won!!\");\n                break;\n            }\n        }\n    }\n}\n",
    "title": "2048",
    "url": "http://rosettacode.org/wiki/2048"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "21 game",
    "url": "http://rosettacode.org/wiki/21_game"
  },
  {
    "local_code": "//! Implements with a recursive descent parser for a simple calculator (+ - * /) using the\n//! [shunting yard algorithm]. It follows operator precedence (i.e. 2 + 3 * 3 = 11), understands\n//! negation (-5 + 6 = 1), ignores whitespace and allows the use of parentheses.\n//!\n//! [shunting yard algorithm]: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm.\n\nextern crate rand;\n\nuse std::cmp::Ordering::{self, Greater};\nuse std::f32;\nuse std::iter::Peekable;\nuse std::str::CharIndices;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nfn main() {\n    use std::io;\n\n    let mut rng = rand::thread_rng();\n    let input = io::stdin();\n\n    loop {\n        let mut sample = Uniform::from(1..=9)\n            .sample_iter(&mut rng)\n            .take(4)\n            .collect::<Vec<_>>();\n\n        println!(\"make 24 by combining the following 4 numbers with + - * / or (q)uit\");\n        println!(\"{:?}\", sample);\n        let mut line = String::new();\n        let _ = input.read_line(&mut line).unwrap();\n        match line.trim() {\n            \"q\" => break,\n            input => {\n                if check_values(&mut sample, input) {\n                    match Parser::new(input).parse() {\n                        Ok(i) => {\n                            if (i - 24.0).abs() < f32::EPSILON {\n                                println!(\"you made it!\");\n                            } else {\n                                println!(\"you entered {}, try again!\", i);\n                            }\n                        }\n                        Err(s) => println!(\"{}\", s),\n                    };\n                } else {\n                    println!(\"unrecognized input, try again\")\n                }\n            }\n        }\n    }\n}\n\n/// Returns true if the entered expression uses the values contained in sample\npub fn check_values(sample: &mut [u32], input: &str) -> bool {\n    let lex = Lexer::new(input);\n\n    let mut numbers_used = lex\n        .filter_map(|(_, a)| match a {\n            Token::Int(i) => Some(i),\n            _ => None,\n        })\n        .collect::<Vec<u32>>();\n\n    numbers_used.sort_unstable();\n    sample.sort_unstable();\n    numbers_used == sample\n}\n\n/// the tokens that our parser is going to recognize\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub enum Token {\n    LParen,\n    RParen,\n    Plus,\n    Minus,\n    Slash,\n    Star,\n    Unknown,\n    Int(u32),\n}\n\nimpl Token {\n    /// are tokens associated to a binary operation?\n    fn is_binary(&self) -> bool {\n        matches!(\n            *self,\n            Token::Plus | Token::Minus | Token::Slash | Token::Star\n        )\n    }\n}\n\npub struct Lexer<'a> {\n    input: Peekable<CharIndices<'a>>,\n}\n\nimpl<'a> Lexer<'a> {\n    pub fn new(input: &str) -> Lexer {\n        Lexer {\n            input: input.char_indices().peekable(),\n        }\n    }\n\n    fn expect<I>(iter: &mut I, expected: &[Token]) -> Result<Token, String>\n    where\n        I: Iterator<Item = (usize, Token)>,\n    {\n        match iter.next() {\n            Some((_, a)) if expected.contains(&a) => Ok(a),\n            Some((n, other)) => Err(format!(\n                \"Parsing error: {:?} was unexpected at offset {}\",\n                other, n\n            )),\n            None => Err(\"unexpected end of token list\".into()),\n        }\n    }\n}\n\nimpl<'a> Iterator for Lexer<'a> {\n    type Item = (usize, Token);\n\n    fn next(&mut self) -> Option<(usize, Token)> {\n        if let Some((idx, c)) = self.input.by_ref().find(|&(_, c)| !c.is_whitespace()) {\n            let ret = match c {\n                '(' => Token::LParen,\n                ')' => Token::RParen,\n                '+' => Token::Plus,\n                '-' => Token::Minus,\n                '/' => Token::Slash,\n                '*' => Token::Star,\n                d @ '0'..='9' => {\n                    let mut val = d.to_digit(10).unwrap();\n                    while let Some(dg) = self\n                        .input\n                        .by_ref()\n                        .peek()\n                        .and_then(|&(_, di)| di.to_digit(10))\n                    {\n                        val = val * 10 + dg;\n                        self.input.by_ref().next();\n                    }\n                    Token::Int(val)\n                }\n                _ => Token::Unknown,\n            };\n            Some((idx, ret))\n        } else {\n            None\n        }\n    }\n}\n\n/// Operators are a \"higher level\" concept than tokens as they define the semantics of the\n/// expression language e.g. token \"Minus\" can correspond to the unary Neg Operator (-a) or to the\n/// binary Sub operator (a - b)\n#[derive(PartialEq, Eq, Copy, Clone, Debug)]\npub enum Operator {\n    Neg,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Sentinel,\n}\n\nimpl Operator {\n    fn precedence(&self) -> usize {\n        match *self {\n            Operator::Sentinel => 0,\n            Operator::Add | Operator::Sub => 1,\n            Operator::Neg => 2,\n            Operator::Mul | Operator::Div => 3,\n        }\n    }\n}\n\n/// Operator precedence for binary operators:\n/// * if x has higher precedence than y precedence for x > precedence for y\n/// * if x and y have equal precedence the first one has precedence\n/// e.g. in expression (4 / 2 * 2) operators * and / have the same precedence, but the operations\n/// must be performed in the order they appear (division first, multiplication second) otherwise\n/// results are different\nimpl PartialOrd for Operator {\n    fn partial_cmp(&self, other: &Operator) -> Option<Ordering> {\n        match (self.precedence(), other.precedence()) {\n            (a, b) if a == b => Some(Greater),\n            (a, b) => a.partial_cmp(&b),\n        }\n    }\n}\n\n/// Recursive descent parser with the shunting yard algorithm as explained in the crate\n/// documentation. I followed the names of the methods as closely as possible vs. the pseudo-code\n/// that illustrates the algorithm.\npub struct Parser<'a> {\n    operators: Vec<Operator>,\n    operands: Vec<f32>,\n    lexer: Peekable<Lexer<'a>>,\n}\n\nimpl<'a> Parser<'a> {\n    pub fn new(input: &str) -> Parser {\n        Parser {\n            operators: vec![],\n            operands: vec![],\n            lexer: Lexer::new(input).peekable(),\n        }\n    }\n\n    pub fn parse(&mut self) -> Result<f32, String> {\n        self.operators.push(Operator::Sentinel);\n        self.e()?;\n        self.operands\n            .last()\n            .cloned()\n            .ok_or_else(|| String::from(\"something went wrong, got no result\"))\n    }\n\n    fn e(&mut self) -> Result<(), String> {\n        self.p()?;\n        while let Some(&(_, x)) = self.lexer.by_ref().peek() {\n            if !x.is_binary() {\n                break;\n            }\n\n            let op = match x {\n                Token::Plus => Operator::Add,\n                Token::Minus => Operator::Sub,\n                Token::Star => Operator::Mul,\n                Token::Slash => Operator::Div,\n                // there are no other binary operators\n                _ => unreachable!(),\n            };\n            self.push_operator(op);\n\n            // Consume the peeked value\n            self.lexer.by_ref().next();\n            self.p()?;\n        }\n\n        while let Some(&op) = self.operators.last() {\n            if op == Operator::Sentinel {\n                return Ok(());\n            }\n            self.pop_operator();\n        }\n        unreachable!() // algorithm fail: reached the end without finding\n                       // the sentinel\n    }\n\n    fn p(&mut self) -> Result<(), String> {\n        match self.lexer.by_ref().next() {\n            Some((_, Token::Int(n))) => self.operands.push(n as f32),\n            Some((_, Token::LParen)) => {\n                self.operators.push(Operator::Sentinel);\n                self.e()?;\n                Lexer::expect(&mut self.lexer, &[Token::RParen])?;\n                self.operators.pop();\n            }\n            Some((_, Token::Minus)) => {\n                self.push_operator(Operator::Neg);\n                self.p()?;\n            }\n            Some((p, e)) => return Err(format!(\"unexpected token {:?} at pos {}\", e, p)),\n            _ => return Err(\"unexpected end of command\".to_string()),\n        }\n        Ok(())\n    }\n\n    fn pop_operator(&mut self) {\n        match self.operators.pop() {\n            Some(Operator::Add) => self.binary_op(|t1, t2| t1 + t2),\n            Some(Operator::Sub) => self.binary_op(|t1, t2| t1 - t2),\n            Some(Operator::Mul) => self.binary_op(|t1, t2| t1 * t2),\n            Some(Operator::Div) => self.binary_op(|t1, t2| t1 / t2),\n            Some(Operator::Neg) => self.unary_op(|t1| -t1),\n            _ => unreachable!(),\n        }\n    }\n\n    fn push_operator(&mut self, op: Operator) {\n        match self.operators.last() {\n            Some(&last_op) if last_op > op => self.pop_operator(),\n            _ => {}\n        }\n        self.operators.push(op);\n    }\n\n    #[inline]\n    fn binary_op<F>(&mut self, op: F)\n    where\n        F: Fn(f32, f32) -> f32,\n    {\n        match (self.operands.pop(), self.operands.pop()) {\n            (Some(t1), Some(t2)) => self.operands.push(op(t2, t1)),\n            _ => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn unary_op<F>(&mut self, op: F)\n    where\n        F: Fn(f32) -> f32,\n    {\n        match self.operands.pop() {\n            Some(t1) => self.operands.push(op(t1)),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::check_values;\n    use super::Operator::{Add, Div, Mul, Sub};\n    use super::Token::{Int, LParen, Plus, RParen, Slash, Star};\n    use super::{Lexer, Parser, Token};\n\n    #[test]\n    fn test_precedence() {\n        assert!(Mul > Add);\n        // Ordering matters for these pairs\n        assert!(Mul > Div);\n        assert!(Div > Mul);\n\n        assert!(Add > Sub);\n        assert!(Sub > Add);\n\n        assert!(!(Mul < Div));\n    }\n\n    #[test]\n    fn lexer_iter() {\n        // test read token and character's offset in the iterator\n        let t = |lex: &mut Lexer, exp_tok: Token, exp_pos: usize| {\n            assert_eq!(lex.next(), Some((exp_pos, exp_tok)));\n        };\n\n        let tok = &mut Lexer::new(\"  15 + 4\");\n        t(tok, Int(15), 2);\n        t(tok, Plus, 5);\n        let read = Lexer::expect(tok, &[LParen, Int(4), RParen]);\n        assert_eq!(read, Ok(Int(4)));\n\n        let mut tok = Lexer::new(\"\");\n        assert_eq!(tok.next(), None);\n\n        let tok = &mut Lexer::new(\"     \");\n        assert_eq!(tok.next(), None);\n\n        let tok = &mut Lexer::new(\"2 * (3+4/2)\");\n        t(tok, Int(2), 0);\n        t(tok, Star, 2);\n        t(tok, LParen, 4);\n        t(tok, Int(3), 5);\n        t(tok, Plus, 6);\n        t(tok, Int(4), 7);\n        t(tok, Slash, 8);\n        t(tok, Int(2), 9);\n        t(tok, RParen, 10);\n    }\n\n    #[test]\n    fn parse() {\n        fn t(input: &str, expected: Result<f32, String>) {\n            assert_eq!(Parser::new(input).parse(), expected)\n        }\n\n        t(\"2+2\", Ok(4.));\n        t(\"2+3*4\", Ok(14.));\n        t(\"4*(3+2)\", Ok(20.));\n        t(\"5/(3+2)*3\", Ok(3.));\n        t(\"2++12\", Err(\"unexpected token Plus at pos 2\".to_string()));\n        t(\"-2+12\", Ok(10.));\n        t(\"-2*(2+3)\", Ok(-10.));\n\n        // Testing precedence\n        t(\"4 / 2 * 2\", Ok(4.));\n        t(\"2 * 2 / 4\", Ok(1.));\n    }\n\n    #[test]\n    fn try_check_values() {\n        let m = &mut [1, 2, 3, 4];\n        assert!(check_values(m, \"1+3 -(4/2)\"));\n        // new testcase for #314\n        assert!(check_values(m, \"1+2+3+4\"));\n    }\n}\n//! Uses RPN expression\n\nextern crate rand;\n\nfn main() {\n    use rand::Rng;\n    use std::io::{self, Write};\n\n    let mut rng = rand::thread_rng();\n    let stdin = io::stdin();\n    let mut stdout = io::stdout();\n\n    // generating 4 numbers\n    let choices: Vec<u32> = (0..4).map(|_| rng.gen_range(1, 10)).collect();\n    println!(\"Make 24 with the following numbers\");\n\n    // start the game loop\n    let mut buffer = String::new();\n    loop {\n        println!(\n            \"Your numbers: {}, {}, {}, {}\",\n            choices[0], choices[1], choices[2], choices[3]\n        );\n        buffer.clear();\n        stdin.read_line(&mut buffer).expect(\"Failed to read line!\");\n        match check_input(&buffer[..], &choices[..]) {\n            Ok(()) => {\n                println!(\"Good job!\");\n                break;\n            }\n            Err(e) => println!(\"{}\", e),\n        }\n        print!(\"Try again? (y/n): \");\n        stdout.flush().unwrap();\n        buffer.clear();\n        stdin.read_line(&mut buffer).expect(\"Failed to read line!\");\n        if buffer.trim() != \"y\" {\n            break;\n        }\n    }\n}\n\nfn check_input(expr: &str, choices: &[u32]) -> Result<(), String> {\n    let mut stack: Vec<u32> = Vec::new();\n    for token in expr.split_whitespace() {\n        if is_operator(token) {\n            let (a, b) = (stack.pop(), stack.pop());\n            match (a, b) {\n                (Some(x), Some(y)) => stack.push(evaluate(y, x, token)),\n                (_, _) => return Err(\"Not a valid RPN expression!\".to_string()),\n            }\n        } else {\n            match token.parse::<u32>() {\n                Ok(n) => {\n                    // check if the number is valid\n                    if !choices.contains(&n) {\n                        return Err(format!(\"Cannot use {}\", n));\n                    }\n                    stack.push(n)\n                }\n                Err(_) => return Err(format!(\"Invalid input: {}\", token)),\n            }\n        }\n    }\n\n    let ans = stack.pop();\n    if !stack.is_empty() {\n        return Err(\"Not a valid RPN expression!\".to_string());\n    }\n    match ans {\n        Some(x) if x == 24 => Ok(()),\n        Some(x) => Err(format!(\"Wrong answer. Result: {}\", x)),\n        None => Err(\"Error encountered!\".to_string()),\n    }\n}\n\nfn evaluate(a: u32, b: u32, op: &str) -> u32 {\n    match op {\n        \"+\" => a + b,\n        \"-\" => a - b,\n        \"*\" => a * b,\n        \"/\" => a / b,\n        _ => unreachable!(),\n    }\n}\n\nfn is_operator(op: &str) -> bool {\n    [\"*\", \"-\", \"+\", \"/\"].contains(&op)\n}\n\n#[cfg(tests)]\nmod tests {\n    const v1: [u32; 4] = [4u32, 3, 6, 2];\n\n    #[test]\n    fn correct_result() {\n        assert_eq!(check_input(\"4 3 * 6 2 * +\", &v1), Ok(()));\n    }\n\n    #[test]\n    fn incorrect_result() {\n        assert_eq!(\n            check_input(\"4 3 * 2 6 + -\", &v1),\n            Err(\"Wrong answer. Result: 4\".to_string())\n        );\n    }\n\n    #[test]\n    fn wrong_numbers_in_input() {\n        assert_eq!(\n            check_input(\"4 5 + 6 2 * -\", &v1),\n            Err(\"Cannot use 5\".to_string())\n        );\n    }\n\n    #[test]\n    fn invalid_chars_in_input() {\n        assert_eq!(\n            check_input(\"4 ) + _ 2 * -\", &v1),\n            Err(\"Invalid input: )\".to_string())\n        );\n    }\n\n    fn invalid_rpn_expression() {\n        assert_eq!(\n            check_input(\"4 3 + 6 2 *\", &v1),\n            Err(\"Not a valid RPN expression!\".to_string())\n        );\n    }\n}\n//! Modeled after [the Scala solution]\n//!\n//! [the Scala solution]: http://rosettacode.org/wiki/24_game/Solve#Scala\n\nextern crate num;\nextern crate permutohedron;\n\nuse num::rational::{Ratio, Rational};\nuse num::traits::Zero;\nuse permutohedron::Heap;\n\n/// convenience macro to create a fixed-sized vector of rationals by writing `rational![1, 2, ...]`\n/// instead of `[Ratio::<isize>::from_integer(1), Ratio::<isize>::from_integer(2), ...]`\nmacro_rules! rationals(\n    ($($e:expr),+) => ([$(Ratio::<isize>::from_integer($e)),+])\n);\n\nfn main() {\n    let mut r = rationals![1, 3, 7, 9];\n    let sol = solve(&mut r, 24).unwrap_or_else(|| \"no solution found\".to_string());\n    println!(\"{}\", sol);\n}\n\n/// for a vector of rationals r, find the combination of arithmetic operations that yield\n/// `target_val` as a result (if such combination exists)\nfn solve(r: &mut [Rational], target_val: isize) -> Option<String> {\n    // need to sort because next_permutation()\n    // returns permutations in lexicographic order\n    r.sort();\n    loop {\n        let all_ops = compute_all_operations(r);\n        for &(res, ref ops) in &all_ops {\n            if res == Ratio::from_integer(target_val) {\n                return Some(ops.to_string());\n            }\n        }\n        let mut perm = Heap::new(r);\n        if perm.next_permutation() == None {\n            return None;\n        }\n    }\n}\n\n/// applies all the valid combinations of + - * and / to the numbers in l and for each combination\n/// creates a tuple with the result and the expression in String form returns all (result,\n/// expression in string form) results in a vector\nfn compute_all_operations(l: &[Rational]) -> Vec<(Rational, String)> {\n    match *l {\n        [] => vec![],\n        [x] => vec![(x, (format!(\"{}\", x)))],\n        [x, ref rest @ ..] => {\n            let mut rt = Vec::new();\n            for &(y, ref exp) in &compute_all_operations(rest) {\n                let mut sub = vec![(x * y, \"*\"), (x + y, \"+\"), (x - y, \"-\")];\n                if y != Zero::zero() {\n                    sub.push((x / y, \"/\"));\n                }\n                for &(z, op) in &sub {\n                    let aux = (z, (format!(\"({} {} {})\", x, op, exp)));\n                    rt.push(aux);\n                }\n            }\n            rt\n        }\n    }\n}\n\n#[test]\nfn test_rationals_macro() {\n    assert_eq!(\n        // without the rationals! macro\n        [\n            Ratio::from_integer(1),\n            Ratio::from_integer(2),\n            Ratio::from_integer(3),\n            Ratio::from_integer(4)\n        ],\n        // with the rationals! macro\n        (rationals![1, 2, 3, 4])\n    );\n}\n\n#[test]\n#[ignore]\nfn test_solve() {\n    let mut r = rationals![1, 3, 7, 9];\n    assert_eq!(solve(&mut r, 24), Some(\"(9 / (3 / (1 + 7)))\".to_string()));\n}\n",
    "path": "tasks/_24-game",
    "remote_code": "use std::io::{self,BufRead};\nextern crate rand;\nuse rand::Rng;\n\nfn op_type(x: char) -> i32{\n    match x {\n        '-' | '+' => return 1,\n        '/' | '*' => return 2,\n        '(' | ')' => return -1,\n        _   => return 0,\n    }\n}\n\nfn to_rpn(input: &mut String){\n\n    let mut rpn_string : String = String::new();\n    let mut rpn_stack : String = String::new();\n    let mut last_token = '#';\n    for token in input.chars(){\n        if token.is_digit(10) {\n            rpn_string.push(token);\n        }\n        else if op_type(token) == 0 {\n            continue;\n        }\n        else if op_type(token) > op_type(last_token) || token == '(' {\n                rpn_stack.push(token);\n                last_token=token;\n        }\n        else {\n            while let Some(top) = rpn_stack.pop() {\n                if top=='(' {\n                    break;\n                }\n                rpn_string.push(top);\n            }\n            if token != ')'{\n                rpn_stack.push(token);\n            }\n        }\n    }\n    while let Some(top) = rpn_stack.pop() {\n        rpn_string.push(top);\n    }\n\n    println!(\"you formula results in {}\", rpn_string);\n\n    *input=rpn_string;\n}\n\nfn calculate(input: &String, list : &mut [u32;4]) -> f32{\n    let mut stack : Vec<f32> = Vec::new();\n    let mut accumulator : f32 = 0.0;\n\n    for token in input.chars(){\n        if token.is_digit(10) {\n            let test = token.to_digit(10).unwrap() as u32;\n            match list.iter().position(|&x| x == test){\n                Some(idx) => list[idx]=10 ,\n                _         => println!(\" invalid digit: {} \",test),\n            }\n            stack.push(accumulator);\n            accumulator = test as f32;\n        }else{\n            let a = stack.pop().unwrap();\n            accumulator = match token {\n                '-' => a-accumulator,\n                '+' => a+accumulator,\n                '/' => a/accumulator,\n                '*' => a*accumulator,\n                _ => {accumulator},//NOP\n            };\n        }\n    }\n    println!(\"you formula results in {}\",accumulator);\n    accumulator\n}\n\nfn main() {\n\n    let mut rng = rand::thread_rng();\n    let mut list :[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];\n\n    println!(\"form 24 with using + - / * {:?}\",list);\n    //get user input\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    //convert to rpn\n    to_rpn(&mut input);\n    let result = calculate(&input, &mut list);\n\n    if list.iter().any(|&list| list !=10){\n        println!(\"and you used all numbers\");\n        match result {\n            24.0 => println!(\"you won\"),\n            _ => println!(\"but your formulla doesn't result in 24\"),\n        }\n    }else{\n        println!(\"you didn't use all the numbers\");\n    }\n\n}",
    "title": "24 game",
    "url": "http://rosettacode.org/wiki/24_game"
  },
  {
    "local_code": "//! Modeled after [the Scala solution]\n//!\n//! [the Scala solution]: http://rosettacode.org/wiki/24_game/Solve#Scala\n\nextern crate num;\nextern crate permutohedron;\n\nuse num::rational::{Ratio, Rational};\nuse num::traits::Zero;\nuse permutohedron::Heap;\n\n/// convenience macro to create a fixed-sized vector of rationals by writing `rational![1, 2, ...]`\n/// instead of `[Ratio::<isize>::from_integer(1), Ratio::<isize>::from_integer(2), ...]`\nmacro_rules! rationals(\n    ($($e:expr),+) => ([$(Ratio::<isize>::from_integer($e)),+])\n);\n\nfn main() {\n    let mut r = rationals![1, 3, 7, 9];\n    let sol = solve(&mut r, 24).unwrap_or_else(|| \"no solution found\".to_string());\n    println!(\"{}\", sol);\n}\n\n/// for a vector of rationals r, find the combination of arithmetic operations that yield\n/// `target_val` as a result (if such combination exists)\nfn solve(r: &mut [Rational], target_val: isize) -> Option<String> {\n    // need to sort because next_permutation()\n    // returns permutations in lexicographic order\n    r.sort();\n    loop {\n        let all_ops = compute_all_operations(r);\n        for &(res, ref ops) in &all_ops {\n            if res == Ratio::from_integer(target_val) {\n                return Some(ops.to_string());\n            }\n        }\n        let mut perm = Heap::new(r);\n        if perm.next_permutation() == None {\n            return None;\n        }\n    }\n}\n\n/// applies all the valid combinations of + - * and / to the numbers in l and for each combination\n/// creates a tuple with the result and the expression in String form returns all (result,\n/// expression in string form) results in a vector\nfn compute_all_operations(l: &[Rational]) -> Vec<(Rational, String)> {\n    match *l {\n        [] => vec![],\n        [x] => vec![(x, (format!(\"{}\", x)))],\n        [x, ref rest @ ..] => {\n            let mut rt = Vec::new();\n            for &(y, ref exp) in &compute_all_operations(rest) {\n                let mut sub = vec![(x * y, \"*\"), (x + y, \"+\"), (x - y, \"-\")];\n                if y != Zero::zero() {\n                    sub.push((x / y, \"/\"));\n                }\n                for &(z, op) in &sub {\n                    let aux = (z, (format!(\"({} {} {})\", x, op, exp)));\n                    rt.push(aux);\n                }\n            }\n            rt\n        }\n    }\n}\n\n#[test]\nfn test_rationals_macro() {\n    assert_eq!(\n        // without the rationals! macro\n        [\n            Ratio::from_integer(1),\n            Ratio::from_integer(2),\n            Ratio::from_integer(3),\n            Ratio::from_integer(4)\n        ],\n        // with the rationals! macro\n        (rationals![1, 2, 3, 4])\n    );\n}\n\n#[test]\n#[ignore]\nfn test_solve() {\n    let mut r = rationals![1, 3, 7, 9];\n    assert_eq!(solve(&mut r, 24), Some(\"(9 / (3 / (1 + 7)))\".to_string()));\n}\n",
    "path": "tasks/_24-game/solve",
    "remote_code": "#[derive(Clone, Copy, Debug)]\nenum Operator {\n    Sub,\n    Plus,\n    Mul,\n    Div,\n}\n\n#[derive(Clone, Debug)]\nstruct Factor {\n    content: String,\n    value: i32,\n}\n\nfn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {\n    let mut ret = Vec::new();\n    for l in left.iter() {\n        for r in right.iter() {\n            use Operator::*;\n            ret.push(match op {\n                Sub if l.value > r.value => Factor {\n                    content: format!(\"({} - {})\", l.content, r.content),\n                    value: l.value - r.value,\n                },\n                Plus => Factor {\n                    content: format!(\"({} + {})\", l.content, r.content),\n                    value: l.value + r.value,\n                },\n                Mul => Factor {\n                    content: format!(\"({} x {})\", l.content, r.content),\n                    value: l.value * r.value,\n                },\n                Div if l.value >= r.value && r.value > 0 && l.value % r.value == 0 => Factor {\n                    content: format!(\"({} / {})\", l.content, r.content),\n                    value: l.value / r.value,\n                },\n                _ => continue,\n            })\n        }\n    }\n    ret\n}\n\nfn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {\n    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {\n        use Operator::*;\n        if op.is_empty() {\n            return Vec::from(acc)\n        }\n        let mut ret = Vec::new();\n        let mono_factor = [Factor {\n            content: numbers[0].to_string(),\n            value: numbers[0],\n        }];\n        match op[0] {\n            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n            Div => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Sub => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),   \n        }\n        calc(&op[1..], &numbers[1..], &ret)\n    }\n    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])\n}\n\nfn solutions(numbers: [i32; 4]) -> Vec<Factor> {\n    use std::collections::hash_set::HashSet;\n    let mut ret = Vec::new();\n    let mut hash_set = HashSet::new();\n    \n    for ops in OpIter(0) {\n        for o in orders().iter() {\n            let numbers = apply_order(numbers, o);\n            let r = calc(ops, numbers);\n            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut numbers = Vec::new();\n    if let Some(input) = std::env::args().skip(1).next() {\n        for c in input.chars() {\n            if let Ok(n) = c.to_string().parse() {\n                numbers.push(n)\n            }\n            if numbers.len() == 4 {\n                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];\n                let solutions = solutions(numbers);\n                let len = solutions.len();\n                if len == 0 {\n                    println!(\"no solution for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                    return\n                }\n                println!(\"solutions for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                for s in solutions {\n                    println!(\"{}\", s.content)\n                }\n                println!(\"{} solutions found\", len);\n                return\n            }\n        }\n    } else {\n        println!(\"empty input\")\n    }\n}\n\n\nstruct OpIter (usize);\n\nimpl Iterator for OpIter {\n    type Item = [Operator; 3];\n    fn next(&mut self) -> Option<[Operator; 3]> {\n        use Operator::*;\n        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];\n        if self.0 >= 1 << 6 {\n            return None\n        }\n        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];\n        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];\n        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];\n        self.0 += 1;\n        Some([f1, f2, f3])\n    }\n}\n\nfn orders() -> [[usize; 4]; 24] {\n    [\n        [0, 1, 2, 3],\n        [0, 1, 3, 2],\n        [0, 2, 1, 3],\n        [0, 2, 3, 1],\n        [0, 3, 1, 2],\n        [0, 3, 2, 1],\n        [1, 0, 2, 3],\n        [1, 0, 3, 2],\n        [1, 2, 0, 3],\n        [1, 2, 3, 0],\n        [1, 3, 0, 2],\n        [1, 3, 2, 0],\n        [2, 0, 1, 3],\n        [2, 0, 3, 1],\n        [2, 1, 0, 3],\n        [2, 1, 3, 0],\n        [2, 3, 0, 1],\n        [2, 3, 1, 0],\n        [3, 0, 1, 2],\n        [3, 0, 2, 1],\n        [3, 1, 0, 2],\n        [3, 1, 2, 0],\n        [3, 2, 0, 1],\n        [3, 2, 1, 0]\n    ]\n}\n\nfn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {\n    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]\n}\n",
    "title": "24 game/Solve",
    "url": "http://rosettacode.org/wiki/24_game/Solve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#![feature(inclusive_range_syntax)]\n\nfn is_unique(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a != b && a != c && a != d && a != e && a != f && a != g &&\n    b != c && b != d && b != e && b != f && b != g &&\n    c != d && c != e && c != f && c != g &&\n    d != e && d != f && d != g &&\n    e != f && e != g &&\n    f != g\n}\n\nfn is_solution(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a + b == b + c + d &&\n        b + c + d == d + e + f &&\n        d + e + f == f + g\n}\n\nfn four_squares(low: u8, high: u8, unique: bool) -> Vec<Vec<u8>> {\n    let mut results: Vec<Vec<u8>> = Vec::new();\n\n    for a in low..=high {\n        for b in low..=high {\n            for c in low..=high {\n                for d in low..=high {\n                    for e in low..=high {\n                        for f in low..=high {\n                            for g in low..=high {\n                                if (!unique || is_unique(a, b, c, d, e, f, g)) &&\n                                    is_solution(a, b, c, d, e, f, g) {\n                                    results.push(vec![a, b, c, d, e, f, g]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    results\n}\n\nfn print_results(solutions: &Vec<Vec<u8>>) {\n    for solution in solutions {\n        println!(\"{:?}\", solution)\n    }\n}\n\nfn print_results_summary(solutions: usize, low: u8, high: u8, unique: bool) {\n    let uniqueness = if unique {\n        \"unique\"\n    } else {\n        \"non-unique\"\n    };\n    println!(\"{} {} solutions in {} to {} range\", solutions, uniqueness, low, high)\n}\n\nfn uniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, true);\n    print_results(&solutions);\n    print_results_summary(solutions.len(), low, high, true);\n}\n\nfn nonuniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, false);\n    print_results_summary(solutions.len(), low, high, false);\n}\n\nfn main() {\n    uniques(1, 7);\n    println!();\n    uniques(3, 9);\n    println!();\n    nonuniques(0, 9);\n}\n",
    "title": "4-rings or 4-squares puzzle",
    "url": "http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigUint, One, Zero};\nuse std::cmp::min;\n\npub struct Solver {\n    /// The `cache` is a private implementation detail,\n    /// it would be an improvement to throw away unused values\n    /// from the cache (to reduce memory for larger inputs)\n    cache: Vec<Vec<BigUint>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        // Setup the cache with the initial row\n        Solver {\n            cache: vec![vec![One::one()]],\n        }\n    }\n\n    /// Returns a string representing a line\n    pub fn row_string(&mut self, idx: usize) -> String {\n        let r = self.cumulative(idx);\n\n        (0..idx)\n            .map(|i| &r[i + 1] - &r[i])\n            .map(|n| n.to_string())\n            .collect::<Vec<String>>()\n            .join(\", \")\n    }\n\n    /// Convenience method to access the last column in a culmulated calculation\n    pub fn row_sum(&mut self, idx: usize) -> &BigUint {\n        // This can never fail as we always add zero or one, so it's never empty.\n        self.cumulative(idx).last().unwrap()\n    }\n\n    fn cumulative(&mut self, idx: usize) -> &[BigUint] {\n        for l in self.cache.len()..idx + 1 {\n            let mut r: Vec<BigUint> = vec![Zero::zero()];\n\n            for x in 1..l + 1 {\n                let w = {\n                    let y = &r[x - 1];\n                    let z = &self.cache[l - x][min(x, l - x)];\n                    y + z\n                };\n                r.push(w)\n            }\n            self.cache.push(r);\n        }\n\n        &self.cache[idx][..]\n    }\n}\n\nimpl Default for Solver {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n\n    println!(\"rows\");\n    for n in 1..11 {\n        println!(\"{}: {}\", n, solver.row_string(n));\n    }\n\n    println!(\"sums\");\n    for &y in &[23, 123, 1234, 12_345] {\n        println!(\"{}: {}\", y, solver.row_sum(y));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Solver;\n    use num::BigUint;\n\n    #[test]\n    fn cumulative() {\n        let mut solver = Solver::new();\n        let mut t = |n: usize, expected: &str| {\n            assert_eq!(solver.row_sum(n), &expected.parse::<BigUint>().unwrap());\n        };\n\n        t(23, \"1255\");\n        t(123, \"2552338241\");\n        t(1234, \"156978797223733228787865722354959930\");\n    }\n\n    #[test]\n    fn row() {\n        let mut solver = Solver::new();\n        let mut t = |n: usize, expected: &str| {\n            assert_eq!(solver.row_string(n), expected);\n        };\n\n        t(1, \"1\");\n        t(2, \"1, 1\");\n        t(3, \"1, 1, 1\");\n        t(4, \"1, 2, 1, 1\");\n        t(5, \"1, 2, 2, 1, 1\");\n        t(6, \"1, 3, 3, 2, 1, 1\");\n    }\n}\n",
    "path": "tasks/_9-billion-names-of-god-the-integer",
    "remote_code": "extern crate num;\n\nuse std::cmp;\nuse num::bigint::BigUint;\n\nfn cumu(n: usize, cache: &mut Vec<Vec<BigUint>>) {\n    for l in cache.len()..n+1 {\n        let mut r = vec![BigUint::from(0u32)];\n        for x in 1..l+1 {\n            let prev = r[r.len() - 1].clone();\n            r.push(prev + cache[l-x][cmp::min(x, l-x)].clone());\n        }\n        cache.push(r);\n    }\n}\n\nfn row(n: usize, cache: &mut Vec<Vec<BigUint>>) -> Vec<BigUint> {\n    cumu(n, cache);\n    let r = &cache[n];\n    let mut v: Vec<BigUint> = Vec::new();\n\n    for i in 0..n {\n        v.push(&r[i+1] - &r[i]);\n    }\n    v\n}\n\nfn main() {\n    let mut cache = vec![vec![BigUint::from(1u32)]];\n\n    println!(\"rows:\");\n    for x in 1..26 {\n        let v: Vec<String> = row(x, &mut cache).iter().map(|e| e.to_string()).collect();\n        let s: String = v.join(\" \");\n        println!(\"{}: {}\", x, s);\n    }\n\n    println!(\"sums:\");\n    for x in vec![23, 123, 1234, 12345] {\n        cumu(x, &mut cache);\n        let v = &cache[x];\n        let s = v[v.len() - 1].to_string();\n        println!(\"{}: {}\", x, s);\n    }\n}",
    "title": "9 billion names of God the integer",
    "url": "http://rosettacode.org/wiki/9_billion_names_of_God_the_integer"
  },
  {
    "local_code": "use std::string::String;\n\nfn main() {\n    for num_bottles in (1u32..100).rev() {\n        println!(\"{}\", bottles_line(num_bottles, true));\n        println!(\"{}\", bottles_line(num_bottles, false));\n        println!(\"Take one down, pass it around...\");\n        println!(\"{}\", bottles_line(num_bottles - 1, true));\n        println!(\"-----------------------------------\");\n    }\n}\n\nfn bottles_line(num_bottles: u32, on_the_wall: bool) -> String {\n    let tail = if on_the_wall {\n        \"of beer on the wall!\\n\"\n    } else {\n        \"of beer\\n\"\n    };\n\n    match num_bottles {\n        0 => format!(\"No bottles {}\", tail),\n        1 => format!(\"One bottle {}\", tail),\n        n => format!(\"{} bottles {}\", n, tail),\n    }\n}\n\n#[test]\nfn gen_bottle_line() {\n    let ln = bottles_line(42, false);\n    let ln2 = bottles_line(42, true);\n\n    assert_eq!(ln, \"42 bottles of beer\\n\");\n    assert_eq!(ln2, \"42 bottles of beer on the wall!\\n\");\n}\n",
    "path": "tasks/_99-bottles-of-beer",
    "remote_code": "fn main() {\n\tfor n in (0..100).rev() {\n\t\tmatch n {\n\t\t\t0 => {\n\t\t\t\tprintln!(\"No more bottles of beer on the wall, no more bottles of beer.\");\n\t\t\t\tprintln!(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n\t\t\t},\n\t\t\t1 => {\n\t\t\t\tprintln!(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n\t\t\t\tprintln!(\"Take one down and pass it around, no more bottles of beer on the wall.\\n\");\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\tprintln!(\"{0:?} bottles of beer on the wall, {0:?} bottles of beer.\", n);\n\t\t\t\tprintln!(\"Take one down and pass it around, {} bottles of beer on the wall.\\n\", n-1);\n\t\t\t},\n\t\t}\n\t}\n}",
    "title": "99 bottles of beer",
    "url": "http://rosettacode.org/wiki/99_bottles_of_beer"
  },
  {
    "local_code": "use std::error;\nuse std::io;\n\nfn get_sum(input: String) -> Result<i32, Box<dyn error::Error>> {\n    let numbers = input\n        .split_whitespace()\n        .map(|number| number.parse())\n        .collect::<Result<Vec<i32>, _>>()?;\n\n    if numbers.len() == 2 {\n        Ok(numbers.iter().sum())\n    } else {\n        Err(\"Please enter 2 integers\".into())\n    }\n}\n\nfn main() -> Result<(), Box<dyn error::Error>> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input)?;\n\n    let sum = get_sum(input)?;\n    println!(\"{}\", sum);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::get_sum;\n\n    #[test]\n    fn integer_sum_test() {\n        let input = \"2 2\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.unwrap(), 4);\n\n        let input = \"3 2\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.unwrap(), 5);\n\n        let input = \"79 -1\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.unwrap(), 78);\n\n        let input = \"-5 10\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.unwrap(), 5);\n\n        let input = \"1000 -1000\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.unwrap(), 0);\n    }\n\n    #[test]\n    fn bad_parsing_test() {\n        let input = \"2 1T\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.is_err(), true);\n\n        let input = \"2 2.4\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.is_err(), true);\n    }\n\n    #[test]\n    fn bad_length_test() {\n        let input = \"2 1 1\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.is_err(), true);\n\n        let input = \"2\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.is_err(), true);\n\n        let input = \"\".to_string();\n        let output = get_sum(input);\n        assert_eq!(output.is_err(), true);\n    }\n}\n",
    "path": "tasks/a-plus-b",
    "remote_code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let mut i: i64 = 0;\n    for word in line.split_whitespace() {\n        i += word.parse::<i64>().expect(\"trying to interpret your input as numbers\");\n    }\n    println!(\"{}\", i);\n}",
    "title": "A+B",
    "url": "http://rosettacode.org/wiki/A%2BB"
  },
  {
    "local_code": "use std::collections::HashSet;\n\nconst WORDS: &[&str] = &[\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"];\n\nconst BLOCKS: &[&str] = &[\n    \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\",\n    \"FS\", \"LY\", \"PC\", \"ZM\",\n];\n\nfn main() {\n    println!(\"******\\nmethod 1\\n******\");\n    for word in WORDS {\n        println!(\"can {} be built? {}\", word, can_be_built_input_first(*word))\n    }\n\n    println!(\"\\n******\\nmethod 2\\n******\");\n    for word in WORDS {\n        println!(\n            \"can {} be built? {}\",\n            word,\n            can_be_built_blocks_first(*word)\n        )\n    }\n}\n\n/// First method (common solution among other languages)\n///\n/// Iterates through the letters of the input and checks if there is a suitable\n/// *unused* block for each letter\nfn can_be_built_input_first(input: &str) -> bool {\n    let mut used = HashSet::new();\n\n    for chr in input.chars() {\n        for (ind, block) in BLOCKS.iter().enumerate() {\n            if !used.contains(&ind) && block.contains(chr) {\n                used.insert(ind);\n                break;\n            }\n        }\n    }\n\n    // If the number of used indices is equal to the input length, then we\n    // have can successfully make the word with the blocks.\n    used.len() == input.len()\n}\n\n/// Second method\n///\n/// Iterates over the blocks. For each block it checks if it can be used for one\n/// of the characters in the input that hasn't already been fulfilled.\n/// It should be more efficient than the first method whenever there are more\n/// blocks than characters in the input.\nfn can_be_built_blocks_first(input: &str) -> bool {\n    let mut matched = HashSet::new();\n\n    BLOCKS.iter().any(|block| {\n        for letter in block.chars() {\n            let needle = input.char_indices().find(|&(i, c)| {\n                // See if any of the letters in the block can be used for this word\n                c == letter && !matched.contains(&i)\n            });\n\n            if let Some((idx, _)) = needle {\n                // letter with offset idx in the original word has been matched\n                matched.insert(idx);\n                // don't check the other letter in this block\n                // (we can use one character per block)\n                break;\n            }\n        }\n\n        // The iterator will halt if/when this becomes true, so it will early\n        // return whenever there is a solution found.\n        matched.len() == input.len()\n    })\n}\n\n#[test]\nfn test_solutions() {\n    let expected = [true, true, false, true, false, true, true];\n\n    for (&word, &exp) in WORDS.iter().zip(expected.iter()) {\n        assert_eq!(can_be_built_input_first(word), exp);\n        assert_eq!(can_be_built_blocks_first(word), exp);\n    }\n}\n",
    "path": "tasks/abc-problem",
    "remote_code": "use std::iter::repeat;\n\nfn rec_can_make_word(index: usize, word: &str, blocks: &[&str], used: &mut[bool]) -> bool {\n    let c = word.chars().nth(index).unwrap().to_uppercase().next().unwrap();\n    for i in 0..blocks.len() {\n        if !used[i] && blocks[i].chars().any(|s| s == c) {\n            used[i] = true;\n            if index == 0 || rec_can_make_word(index - 1, word, blocks, used) {\n                return true;\n            }\n            used[i] = false;\n        }\n    }\n    false\n}\n\nfn can_make_word(word: &str, blocks: &[&str]) -> bool {\n    return rec_can_make_word(word.chars().count() - 1, word, blocks, \n                             &mut repeat(false).take(blocks.len()).collect::<Vec<_>>());\n}\n\nfn main() {\n    let blocks = [(\"BO\"), (\"XK\"), (\"DQ\"), (\"CP\"), (\"NA\"), (\"GT\"), (\"RE\"), (\"TG\"), (\"QD\"), (\"FS\"), \n                  (\"JW\"), (\"HU\"), (\"VI\"), (\"AN\"), (\"OB\"), (\"ER\"), (\"FS\"), (\"LY\"), (\"PC\"), (\"ZM\")];\n    let words = [\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"];\n    for word in &words {\n        println!(\"{} -> {}\", word, can_make_word(word, &blocks))\n    }\n}\n",
    "title": "ABC problem",
    "url": "http://rosettacode.org/wiki/ABC_problem"
  },
  {
    "local_code": "pub fn is_prime(p: u32) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let mut c = coefficients(p as usize);\n        c[0] -= 1;\n        for coefficient in c.iter().take((c.len() + 1) / 2) {\n            if (coefficient % (i64::from(p))) != 0 {\n                return false;\n            }\n        }\n        true\n    }\n}\n\npub fn coefficients(p: usize) -> Vec<i64> {\n    if p == 0 {\n        vec![1]\n    } else {\n        let mut result = vec![1, -1];\n        let zero = Some(0i64);\n        for _ in 1..p {\n            result = {\n                let a = result.iter().chain(zero.iter());\n                let b = zero.iter().chain(result.iter());\n                a.zip(b).map(|(x, &y)| *x - y).collect()\n            };\n        }\n        result\n    }\n}\n\n#[test]\nfn test_solution() {\n    let exp_coefficients = vec![\n        vec![1i64],\n        vec![1, -1],\n        vec![1, -2, 1],\n        vec![1, -3, 3, -1],\n        vec![1, -4, 6, -4, 1],\n        vec![1, -5, 10, -10, 5, -1],\n        vec![1, -6, 15, -20, 15, -6, 1],\n        vec![1, -7, 21, -35, 35, -21, 7, -1],\n    ];\n    let exp_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];\n\n    for (i, exp) in exp_coefficients.iter().enumerate() {\n        assert_eq!(*exp, coefficients(i));\n    }\n\n    let primes: Vec<u32> = (1..51).filter(|&i| is_prime(i)).collect();\n    assert_eq!(exp_primes, &primes[..]);\n}\nextern crate aks_test_for_primes;\n\nfn main() {\n    for p in 0..8 {\n        println!(\"{}: {:?}\", p, aks_test_for_primes::coefficients(p));\n    }\n\n    for p in (1..51).filter(|&x| aks_test_for_primes::is_prime(x)) {\n        print!(\"{} \", p);\n    }\n}\n",
    "path": "tasks/aks-test-for-primes",
    "remote_code": "fn aks_coefficients(k: usize) -> Vec<i64> {\n    let mut coefficients = vec![0i64; k + 1];\n    coefficients[0] = 1;\n    for i in 1..(k + 1) {\n        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{\n            let old = coefficients[j];\n            coefficients[j] = old - prev;\n            old\n        });\n    }\n    coefficients\n}\n\nfn is_prime(p: usize) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let c = aks_coefficients(p);\n        (1..p / 2 + 1).all(|i| c[i] % p as i64 == 0)\n    }\n}\n\nfn main() {\n    for i in 0..8 {\n        println!(\"{}: {:?}\", i, aks_coefficients(i));\n    }\n    for i in (1..=50).filter(|&i| is_prime(i)) {\n        print!(\"{} \", i);\n    }\n}",
    "title": "AKS test for primes",
    "url": "http://rosettacode.org/wiki/AKS_test_for_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{borrow::Cow, io::Write};\n\npub type Bit = bool;\n\n#[derive(Clone, Debug)]\npub struct Field {\n    name: String,\n    from: usize,\n    to: usize,\n}\n\nimpl Field {\n    pub fn new(name: String, from: usize, to: usize) -> Self {\n        assert!(from < to);\n        Self { name, from, to }\n    }\n\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    pub fn from(&self) -> usize {\n        self.from\n    }\n\n    pub fn to(&self) -> usize {\n        self.to\n    }\n\n    pub fn size(&self) -> usize {\n        self.to - self.from\n    }\n\n    pub fn extract_bits<'a>(\n        &self,\n        bytes: &'a [u8],\n    ) -> Option<impl Iterator<Item = (usize, Bit)> + 'a> {\n        if self.to <= bytes.len() * 8 {\n            Some((self.from..self.to).map(move |index| {\n                let byte = bytes[index / 8];\n                let bit_index = 7 - (index % 8);\n                let bit_value = (byte >> bit_index) & 1 == 1;\n                (index, bit_value)\n            }))\n        } else {\n            None\n        }\n    }\n\n    fn extend(&mut self, new_to: usize) {\n        assert!(self.to <= new_to);\n        self.to = new_to;\n    }\n}\n\ntrait Consume: Iterator {\n    fn consume(&mut self, value: Self::Item) -> Result<Self::Item, Option<Self::Item>>\n    where\n        Self::Item: PartialEq,\n    {\n        match self.next() {\n            Some(v) if v == value => Ok(v),\n            Some(v) => Err(Some(v)),\n            None => Err(None),\n        }\n    }\n}\n\nimpl<T: Iterator> Consume for T {}\n\n#[derive(Clone, Copy, Debug)]\nenum ParserState {\n    Uninitialized,\n    ExpectBorder,\n    ExpectField,\n    AllowEmpty,\n}\n\n#[derive(Clone, Copy, Debug)]\npub enum ParserError {\n    ParsingFailed,\n    UnexpectedEnd,\n    InvalidBorder,\n    WrongLineWidth,\n    FieldExpected,\n    BadField,\n}\n\n#[derive(Debug)]\npub(crate) struct Parser {\n    state: Option<ParserState>,\n    width: usize,\n    from: usize,\n    fields: Vec<Field>,\n}\n\nimpl Parser {\n    #[allow(clippy::new_without_default)]\n    pub fn new() -> Self {\n        Self {\n            state: Some(ParserState::Uninitialized),\n            width: 0,\n            from: 0,\n            fields: Vec::new(),\n        }\n    }\n\n    pub fn accept(&mut self, line: &str) -> Result<(), ParserError> {\n        if let Some(state) = self.state.take() {\n            let line = line.trim();\n\n            if !line.is_empty() {\n                self.state = Some(match state {\n                    ParserState::Uninitialized => self.parse_border(line)?,\n                    ParserState::ExpectBorder => self.accept_border(line)?,\n                    ParserState::ExpectField => self.parse_fields(line)?,\n                    ParserState::AllowEmpty => self.extend_field(line)?,\n                });\n            }\n\n            Ok(())\n        } else {\n            Err(ParserError::ParsingFailed)\n        }\n    }\n\n    pub fn finish(self) -> Result<Vec<Field>, ParserError> {\n        match self.state {\n            Some(ParserState::ExpectField) => Ok(self.fields),\n            _ => Err(ParserError::UnexpectedEnd),\n        }\n    }\n\n    fn parse_border(&mut self, line: &str) -> Result<ParserState, ParserError> {\n        self.width = Parser::border_columns(line).map_err(|_| ParserError::InvalidBorder)?;\n        Ok(ParserState::ExpectField)\n    }\n\n    fn accept_border(&mut self, line: &str) -> Result<ParserState, ParserError> {\n        match Parser::border_columns(line) {\n            Ok(width) if width == self.width => Ok(ParserState::ExpectField),\n            Ok(_) => Err(ParserError::WrongLineWidth),\n            Err(_) => Err(ParserError::InvalidBorder),\n        }\n    }\n\n    fn parse_fields(&mut self, line: &str) -> Result<ParserState, ParserError> {\n        let mut slots = line.split('|');\n        // The first split result is the space outside of the schema\n        slots.consume(\"\").map_err(|_| ParserError::FieldExpected)?;\n        let mut remaining_width = self.width * Parser::COLUMN_WIDTH;\n        let mut fields_found = 0;\n\n        loop {\n            match slots.next() {\n                Some(slot) if slot.is_empty() => {\n                    // The only empty slot is the last one\n                    if slots.next().is_some() || remaining_width != 0 {\n                        return Err(ParserError::BadField);\n                    }\n\n                    break;\n                }\n\n                Some(slot) => {\n                    let slot_width = slot.chars().count() + 1; // Include the slot separator\n                    if remaining_width < slot_width || slot_width % Parser::COLUMN_WIDTH != 0 {\n                        return Err(ParserError::BadField);\n                    }\n\n                    let name = slot.trim();\n\n                    if name.is_empty() {\n                        return Err(ParserError::BadField);\n                    }\n\n                    // An actual field slot confirmed\n                    remaining_width -= slot_width;\n                    fields_found += 1;\n                    let from = self.from;\n                    let to = from + slot_width / Parser::COLUMN_WIDTH;\n                    // If the slot belongs to the same field as the last one, just extend it\n                    if let Some(f) = self.fields.last_mut().filter(|f| f.name() == name) {\n                        f.extend(to);\n                    } else {\n                        self.fields.push(Field::new(name.to_string(), from, to));\n                    }\n\n                    self.from = to;\n                }\n\n                _ => return Err(ParserError::BadField),\n            }\n        }\n\n        Ok(if fields_found == 1 {\n            ParserState::AllowEmpty\n        } else {\n            ParserState::ExpectBorder\n        })\n    }\n\n    fn extend_field(&mut self, line: &str) -> Result<ParserState, ParserError> {\n        let mut slots = line.split('|');\n        // The first split result is the space outside of the schema\n        if slots.consume(\"\").is_ok() {\n            if let Some(slot) = slots.next() {\n                if slots.consume(\"\").is_ok() {\n                    let slot_width = slot.chars().count() + 1;\n                    let remaining_width = self.width * Parser::COLUMN_WIDTH;\n                    if slot_width == remaining_width && slot.chars().all(|c| c == ' ') {\n                        self.from += self.width;\n                        self.fields.last_mut().unwrap().extend(self.from);\n                        return Ok(ParserState::AllowEmpty);\n                    }\n                }\n            }\n        }\n\n        self.accept_border(line)\n    }\n\n    const COLUMN_WIDTH: usize = 3;\n\n    fn border_columns(line: &str) -> Result<usize, Option<char>> {\n        let mut chars = line.chars();\n\n        // Read the first cell, which is mandatory\n        chars.consume('+')?;\n        chars.consume('-')?;\n        chars.consume('-')?;\n        chars.consume('+')?;\n        let mut width = 1;\n\n        loop {\n            match chars.consume('-') {\n                Err(Some(c)) => return Err(Some(c)),\n                Err(None) => return Ok(width),\n                Ok(_) => {}\n            }\n\n            chars.consume('-')?;\n            chars.consume('+')?;\n            width += 1;\n        }\n    }\n}\n\npub struct Fields(pub Vec<Field>);\n\n#[derive(Clone, Debug)]\npub struct ParseFieldsError {\n    pub line: Option<String>,\n    pub kind: ParserError,\n}\n\nimpl ParseFieldsError {\n    fn new(line: Option<String>, kind: ParserError) -> Self {\n        Self { line, kind }\n    }\n}\n\nimpl std::str::FromStr for Fields {\n    type Err = ParseFieldsError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut parser = Parser::new();\n        for line in s.lines() {\n            parser\n                .accept(line)\n                .map_err(|e| ParseFieldsError::new(Some(line.to_string()), e))?;\n        }\n\n        parser\n            .finish()\n            .map(Fields)\n            .map_err(|e| ParseFieldsError::new(None, e))\n    }\n}\n\nimpl Fields {\n    pub fn print_schema(&self, f: &mut dyn Write) -> std::io::Result<()> {\n        writeln!(f, \"Name          Bits    Start   End\")?;\n        writeln!(f, \"=================================\")?;\n        for field in self.0.iter() {\n            writeln!(\n                f,\n                \"{:<12} {:>5}      {:>3}   {:>3}\",\n                field.name(),\n                field.size(),\n                field.from(),\n                field.to() - 1 // Range is exclusive, but display it as inclusive\n            )?;\n        }\n        writeln!(f)\n    }\n\n    pub fn print_decode(&self, f: &mut dyn Write, bytes: &[u8]) -> std::io::Result<()> {\n        writeln!(f, \"Input (hexadecimal octets): {:x?}\", bytes)?;\n        writeln!(f)?;\n        writeln!(f, \"Name          Size    Bit pattern\")?;\n        writeln!(f, \"=================================\")?;\n        for field in self.0.iter() {\n            writeln!(\n                f,\n                \"{:<12} {:>5}    {}\",\n                field.name(),\n                field.size(),\n                field\n                    .extract_bits(&bytes)\n                    .map(|it| it.fold(String::new(), |mut acc, (index, bit)| {\n                        // Instead of simple collect, let's print it rather with\n                        // byte boundaries visible as spaces\n                        if index % 8 == 0 && !acc.is_empty() {\n                            acc.push(' ');\n                        }\n                        acc.push(if bit { '1' } else { '0' });\n                        acc\n                    }))\n                    .map(Cow::Owned)\n                    .unwrap_or_else(|| Cow::Borrowed(\"N/A\"))\n            )?;\n        }\n\n        writeln!(f)\n    }\n}\n\nfn normalize(diagram: &str) -> String {\n    diagram\n        .lines()\n        .map(|line| line.trim())\n        .filter(|line| !line.is_empty())\n        .fold(String::new(), |mut acc, x| {\n            if !acc.is_empty() {\n                acc.push('\\n');\n            }\n\n            acc.push_str(x);\n            acc\n        })\n}\n\nfn main() {\n    let diagram = r\"\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                      ID                       |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    QDCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    ANCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    NSCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    ARCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                   OVERSIZED                   |\n        |                                               |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        | OVERSIZED |           unused                  |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        \";\n\n    let data = b\"\\x78\\x47\\x7b\\xbf\\x54\\x96\\xe1\\x2e\\x1b\\xf1\\x69\\xa4\\xab\\xcd\\xef\\xfe\\xdc\";\n\n    // Normalize and print the input, there is no need and no requirement to\n    // generate it from the parsed representation\n    let diagram = normalize(diagram);\n    println!(\"{}\", diagram);\n    println!();\n\n    match diagram.parse::<Fields>() {\n        Ok(fields) => {\n            let mut stdout = std::io::stdout();\n            fields.print_schema(&mut stdout).ok();\n            fields.print_decode(&mut stdout, data).ok();\n        }\n\n        Err(ParseFieldsError {\n            line: Some(line),\n            kind: e,\n        }) => eprintln!(\"Invalid input: {:?}\\n{}\", e, line),\n\n        Err(ParseFieldsError {\n            line: _,\n            kind: e,\n        }) => eprintln!(\"Could not parse the input: {:?}\", e),\n    }\n}",
    "title": "ASCII art diagram converter",
    "url": "http://rosettacode.org/wiki/ASCII_art_diagram_converter"
  },
  {
    "local_code": "/// This implementation uses an addressable vector as the tree's store.\n/// It is possible to construct a mutable tree using Rc<RefCell<>>,\n/// but it adds some complexity.\n///\n/// \"Pointers\" to nodes are indices into the vector store, and have\n/// trait Copy.\n///\n/// The index of a node in the vector store should not be confused with its key.\nextern crate rand;\nextern crate term_painter;\n\nuse std::cmp::Ordering;\nuse std::fmt::{Debug, Display, Formatter, Result};\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\nuse term_painter::Color::*;\nuse term_painter::ToStyle;\n\npub type NodePtr = Option<usize>;\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub enum Side {\n    Left,\n    Right,\n    Up,\n    Root,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum DisplayElement {\n    TrunkSpace,\n    SpaceLeft,\n    SpaceRight,\n    SpaceSpace,\n    Root,\n}\n\nimpl DisplayElement {\n    fn string(&self) -> String {\n        match *self {\n            DisplayElement::TrunkSpace => \"    │   \".to_string(),\n            DisplayElement::SpaceRight => \"    ┌───\".to_string(),\n            DisplayElement::SpaceLeft => \"    └───\".to_string(),\n            DisplayElement::SpaceSpace => \"        \".to_string(),\n            DisplayElement::Root => \"├──\".to_string(),\n        }\n    }\n}\n\n/// Handedness of balanced insert and delete operations differs only by values encapsulated here.\nstruct BalanceConstants {\n    bal_incr: i8,\n    this_side: Side,\n    that_side: Side,\n    key_order: Ordering, // Ins only\n    // These are used in the +1/-1 & -1/+1 deletion cases\n    gcm1_child_adj: i8, // Del only, balance adjustment to child for b = -1 grandchild\n    gcm1_parent_adj: i8, // Del only, balance adjustment to parent for b = -1 grandchild\n    gcp1_child_adj: i8, // Del only, balance adjustment to child for b = 1 grandchild\n    gcp1_parent_adj: i8, // Del only, balance adjustment to parent for b = 1 grandchild\n}\n\nconst BALANCE_CONSTANTS_A: BalanceConstants = BalanceConstants {\n    bal_incr: -1,\n    this_side: Side::Left,\n    that_side: Side::Right,\n    key_order: Ordering::Greater,\n    gcm1_child_adj: 0,\n    gcm1_parent_adj: 1,\n    gcp1_child_adj: -1,\n    gcp1_parent_adj: 0,\n};\n\nconst BALANCE_CONSTANTS_B: BalanceConstants = BalanceConstants {\n    bal_incr: 1,\n    this_side: Side::Right,\n    that_side: Side::Left,\n    key_order: Ordering::Less,\n    gcm1_child_adj: 1,\n    gcm1_parent_adj: 0,\n    gcp1_child_adj: 0,\n    gcp1_parent_adj: -1,\n};\n\n#[derive(Debug, Clone, Copy)]\npub struct Node<K, V> {\n    key: K,\n    value: V,\n    balance: i8,\n    left: NodePtr,\n    right: NodePtr,\n    up: NodePtr,\n}\n\n#[derive(Debug)]\n#[allow(clippy::upper_case_acronyms)]\npub struct AVLTree<K, V> {\n    root: NodePtr,\n    store: Vec<Node<K, V>>,\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Default for AVLTree<K, V> {\n    fn default() -> Self {\n        AVLTree::new()\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> AVLTree<K, V> {\n    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {\n        assert!(np.is_some());\n        self.store[np.unwrap()]\n    }\n\n    pub fn get_balance(&self, np: NodePtr) -> i8 {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance\n    }\n\n    pub fn get_key(&self, np: NodePtr) -> K {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key\n    }\n\n    pub fn get_value(&self, np: NodePtr) -> V {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value\n    }\n\n    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {\n        assert!(np.is_some());\n        self.store[np.unwrap()].get_ptr(side)\n    }\n\n    pub fn set_balance(&mut self, np: NodePtr, bal: i8) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance = bal;\n    }\n\n    pub fn set_key(&mut self, np: NodePtr, to: K) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key = to;\n    }\n\n    pub fn set_value(&mut self, np: NodePtr, to: V) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value = to;\n    }\n\n    pub fn set_pointer(&mut self, np: NodePtr, side: Side, to: NodePtr) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].set_ptr(side, to);\n    }\n\n    pub fn increment_balance(&mut self, np: NodePtr, delta: i8) -> i8 {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance += delta;\n        self.store[np.unwrap()].balance\n    }\n\n    pub fn new() -> Self {\n        AVLTree {\n            root: None,\n            store: Vec::<Node<K, V>>::with_capacity(20_000),\n        }\n    }\n\n    /// Insert key-value\n    pub fn insert(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        let (n, _) = self.insert_node(Node::new(k, v));\n        n\n    }\n\n    /// Insert Node struct\n    pub fn insert_node(&mut self, mut n: Node<K, V>) -> (Option<Node<K, V>>, Side) {\n        if self.root.is_none() {\n            assert!(self.store.is_empty());\n            self.store.push(n);\n            self.root = Some(0);\n            return (Some(n), Side::Root);\n        }\n\n        let mut p = self.root; // Possibly None\n        let mut prev = p;\n        let mut side = Side::Left;\n        while p.is_some() {\n            prev = p;\n            match n.key.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Equal => {\n                    println!(\"Key exists\");\n                    return (None, side);\n                }\n            }\n        }\n        // Set child's pointer\n        n.up = prev;\n        // Stow the node\n        self.store.push(n);\n        // Set parent's pointer\n        let ptr = Some(self.store.len() - 1);\n        self.set_pointer(prev, side, ptr);\n        (Some(n), side)\n    }\n\n    /// Insert key-value and rebalance\n    pub fn insert_bal(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        self.insert_node_bal(Node::new(k, v))\n    }\n\n    /// Insert Node struct and rebalance\n    pub fn insert_node_bal(&mut self, n: Node<K, V>) -> Option<Node<K, V>> {\n        let (nins, side) = self.insert_node(n);\n        if nins.is_none() || side == Side::Root {\n            return nins;\n        }\n\n        let mut p = nins.unwrap().up;\n        let mut is_left = side == Side::Left;\n\n        while p.is_some() {\n            let i_c = get_insertion_constants(is_left);\n\n            let b = self.increment_balance(p, i_c.bal_incr);\n            if b == 0 {\n                break; // No further adjustments necessary\n            } else if b.abs() > 1 {\n                let child_p = self.get_pointer(p, i_c.this_side);\n                match self.get_balance(child_p) * b {\n                    2 => {\n                        // -2/-1 & +2/+1 patterns\n                        self.single_rotation(i_c.this_side, p, child_p);\n                        self.set_balance(p, 0);\n                        self.set_balance(child_p, 0);\n                        break;\n                    }\n                    -2 => {\n                        // -2/+1 & +2/-1 patterns\n                        let grand_p = self.get_pointer(child_p, i_c.that_side);\n                        self.double_rotation(i_c.this_side, p, child_p, grand_p);\n                        if self.get_pointer(child_p, i_c.this_side).is_none() {\n                            // Degenerate case, no subtrees\n                            self.set_balance(child_p, 0);\n                            self.set_balance(p, 0);\n                        } else if n.key.cmp(&self.get_key(grand_p)) == i_c.key_order {\n                            self.set_balance(child_p, i_c.bal_incr);\n                            self.set_balance(p, 0);\n                        } else {\n                            self.set_balance(child_p, 0);\n                            self.set_balance(p, -i_c.bal_incr);\n                        }\n                        self.set_balance(grand_p, 0);\n                        break;\n                    }\n                    _ => unreachable!(),\n                }\n            }\n\n            let child_p = p;\n            p = self.get_pointer(p, Side::Up);\n            if p.is_some() {\n                let left_p = self.get_pointer(p, Side::Left);\n                is_left = left_p.is_some() && left_p == child_p;\n            }\n        }\n\n        nins\n    }\n\n    /// Remove the node at index from the store and patch the hole in the vector,\n    /// modifying pointers in the moved node's parents and children.\n    fn remove_carefully(&mut self, p: NodePtr) {\n        assert!(p.is_some());\n        let index = p.unwrap();\n        let old_index = self.store.len() - 1;\n        self.store.swap_remove(index);\n\n        if index == old_index {\n            // Nothing moved\n            return;\n        }\n\n        // Element -1 has moved into the spot _index_. The in-pointers that need modifying\n        // belong to that element's parent and children.\n\n        // Fix child pointer in parent:\n        let parent_p = self.get_pointer(p, Side::Up);\n        if parent_p.is_some() {\n            let l = self.get_pointer(parent_p, Side::Left);\n            if l == Some(old_index) {\n                self.set_pointer(parent_p, Side::Left, Some(index));\n            } else {\n                self.set_pointer(parent_p, Side::Right, Some(index));\n            }\n        }\n\n        // Fix parent pointers in children:\n        let l = self.get_pointer(p, Side::Left);\n        let r = self.get_pointer(p, Side::Right);\n        if l.is_some() {\n            self.set_pointer(l, Side::Up, Some(index));\n        }\n        if r.is_some() {\n            self.set_pointer(r, Side::Up, Some(index));\n        }\n\n        // Fix root if necessary\n        if self.root == Some(old_index) {\n            self.root = Some(index);\n        }\n    }\n\n    /// Uses delete-by-copy procedure if node with key k has two children.\n    /// Returns (parent, side) tuple.\n    pub fn delete(&mut self, k: K) -> (NodePtr, Side) {\n        let mut p = self.root;\n        let mut prev = None;\n        let mut res = None;\n        let mut side = Side::Root;\n        while p.is_some() {\n            match k.cmp(&self.get_key(p)) {\n                Ordering::Equal => {\n                    break;\n                }\n                Ordering::Less => {\n                    prev = p;\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    prev = p;\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n            }\n        }\n\n        if p.is_none() {\n            println!(\"Key {:?} not found\", k);\n            return (res, side);\n        }\n\n        let n = self.get_node(p);\n        // Is this a leaf?\n        if n.is_leaf() {\n            if n.key.cmp(&self.get_key(self.root)) == Ordering::Equal {\n                self.root = None;\n                assert_eq!(self.store.len(), 1);\n            } else {\n                self.set_pointer(prev, side, None);\n            }\n            self.remove_carefully(p);\n            // The prev pointer is now stale\n            res = if prev == Some(self.store.len()) {\n                p\n            } else {\n                prev\n            };\n\n        // Is this a one-child node?\n        } else if n.left.is_none() || n.right.is_none() {\n            let ch = if n.left.is_some() { n.left } else { n.right };\n            if n.key.cmp(&self.get_key(self.root)) == Ordering::Equal {\n                self.set_pointer(ch, Side::Up, None);\n                self.root = ch;\n            } else {\n                self.set_pointer(prev, side, ch);\n                self.set_pointer(ch, Side::Up, prev);\n            }\n            self.remove_carefully(p);\n            // The prev pointer is now stale\n            res = if prev == Some(self.store.len()) {\n                p\n            } else {\n                prev\n            };\n\n        // Complicated case:  two children, do delete-by-copy. Replace n with its first\n        // predecessor (the mirror image using the first successor would work as well).\n        } else {\n            let mut tmp = n.left;\n            let mut last = tmp;\n            prev = self.get_pointer(tmp, Side::Up);\n            while tmp.is_some() && self.get_pointer(last, Side::Right).is_some() {\n                prev = self.get_pointer(tmp, Side::Up);\n                last = tmp;\n                tmp = self.get_pointer(tmp, Side::Right);\n            }\n            tmp = last;\n            // Copy ...\n            let the_key = self.get_key(tmp);\n            let the_value = self.get_value(tmp);\n            self.set_key(p, the_key);\n            self.set_value(p, the_value);\n\n            let left_ptr = self.get_pointer(tmp, Side::Left);\n            if prev == p {\n                self.set_pointer(p, Side::Left, left_ptr);\n                if left_ptr.is_some() {\n                    self.set_pointer(left_ptr, Side::Up, p);\n                }\n                side = Side::Left;\n            } else {\n                self.set_pointer(prev, Side::Right, left_ptr);\n                if left_ptr.is_some() {\n                    self.set_pointer(left_ptr, Side::Up, prev);\n                }\n                side = Side::Right;\n            }\n\n            self.remove_carefully(tmp);\n            // The prev pointer is now stale\n            res = if prev.unwrap() == self.store.len() {\n                tmp\n            } else {\n                prev\n            };\n        }\n\n        (res, side)\n    }\n\n    /// Rebalance on delete\n    pub fn delete_bal(&mut self, k: K) -> Option<Node<K, V>> {\n        // slug: (pointer to parent of deleted node, side of deleted node)\n        let slug = self.delete(k);\n        let (pdel, side) = slug;\n        pdel?;\n        let ndel = self.get_node(pdel);\n\n        let mut p = pdel;\n        let mut is_left = side == Side::Left;\n\n        // Rebalance and update balance factors. There are two different rotation sequences that\n        // are the same within handedness,\n        // and the +1/-1 / -1/+1 sequence has three possible balance adjustments\n        // depending on the grandchild.\n        while p.is_some() {\n            let d_c = get_deletion_constants(is_left);\n\n            let b = self.increment_balance(p, d_c.bal_incr);\n            match b.abs() {\n                1 => break, // No further adjustments necessary\n                abs if abs > 1 => {\n                    let child_p = self.get_pointer(p, d_c.this_side);\n                    match self.get_balance(child_p) * b {\n                        2 => {\n                            // +1/+1 & -1/-1 patterns\n                            self.single_rotation(d_c.this_side, p, child_p);\n                            self.set_balance(p, 0);\n                            p = self.get_pointer(p, Side::Up);\n                            self.set_balance(p, 0);\n                        }\n                        0 => {\n                            // +1/0 & -1/0 patterns\n                            self.single_rotation(d_c.this_side, p, child_p);\n                            self.set_balance(p, d_c.bal_incr);\n                            p = self.get_pointer(p, Side::Up);\n                            self.set_balance(p, -d_c.bal_incr);\n                            break; // No height change\n                        }\n                        -2 => {\n                            // +1/-1/x & -1/+1/x patterns\n                            let grand_p = self.get_pointer(child_p, d_c.that_side);\n                            self.double_rotation(d_c.this_side, p, child_p, grand_p);\n                            // p is now one child, grand_p is the other, child_p is their parent\n                            match self.get_balance(grand_p) {\n                                -1 => {\n                                    self.set_balance(p, d_c.gcm1_parent_adj);\n                                    self.set_balance(child_p, d_c.gcm1_child_adj);\n                                }\n                                0 => {\n                                    self.set_balance(p, 0);\n                                    self.set_balance(child_p, 0);\n                                }\n                                1 => {\n                                    self.set_balance(p, d_c.gcp1_parent_adj);\n                                    self.set_balance(child_p, d_c.gcp1_child_adj);\n                                }\n                                _ => unreachable!(),\n                            }\n                            self.set_balance(grand_p, 0);\n                            p = self.get_pointer(p, Side::Up);\n                        }\n                        _ => unreachable!(),\n                    }\n                }\n                _ => (),\n            }\n\n            let child_p = p;\n            p = self.get_pointer(p, Side::Up);\n            if p.is_some() {\n                let left_p = self.get_pointer(p, Side::Left);\n                is_left = left_p.is_some() && left_p == child_p;\n            }\n        }\n\n        Some(ndel)\n    }\n\n    /// Returns node value\n    pub fn lookup(&self, k: K) -> Option<V> {\n        self.search(k).map(|n| n.value)\n    }\n\n    /// Returns node (not pointer)\n    pub fn search(&self, k: K) -> Option<Node<K, V>> {\n        let mut p = self.root;\n        let mut res = None;\n\n        while p.is_some() {\n            match k.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    p = self.get_pointer(p, Side::Left);\n                }\n                Ordering::Greater => {\n                    p = self.get_pointer(p, Side::Right);\n                }\n                Ordering::Equal => {\n                    res = Some(self.get_node(p));\n                    break;\n                }\n            }\n        }\n        res\n    }\n\n    /// Do an in-order traversal, where a \"visit\" prints the row with that node in it.\n    fn display(&self, p: NodePtr, side: Side, e: &[DisplayElement], f: &mut Formatter) {\n        if p.is_none() {\n            return;\n        }\n\n        let mut elems = e.to_vec();\n        let node = self.get_node(p);\n        let mut tail = DisplayElement::SpaceSpace;\n        if node.up != self.root {\n            // Direction switching, need trunk element to be printed for lines before that node\n            // is visited.\n            let new_elem = if side == Side::Left && node.right.is_some() {\n                DisplayElement::TrunkSpace\n            } else {\n                DisplayElement::SpaceSpace\n            };\n            elems.push(new_elem);\n        }\n        let hindex = elems.len() - 1;\n        self.display(node.right, Side::Right, &elems, f);\n\n        if p == self.root {\n            elems[hindex] = DisplayElement::Root;\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Right {\n            // Right subtree finished\n            elems[hindex] = DisplayElement::SpaceRight;\n            // Prepare trunk element in case there is a left subtree\n            tail = DisplayElement::TrunkSpace;\n        } else {\n            // if side == Side::Left\n            elems[hindex] = DisplayElement::SpaceLeft;\n            let parent_p = self.get_pointer(p, Side::Up);\n            let gp_p = self.get_pointer(parent_p, Side::Up);\n            if gp_p.is_some() && self.get_pointer(gp_p, Side::Right) == parent_p {\n                // Direction switched, need trunk element starting with this node/line\n                elems[hindex - 1] = DisplayElement::TrunkSpace;\n            }\n        }\n\n        // Visit node => print accumulated elements. Each node gets a line.\n        {\n            for e in elems.clone() {\n                let _ = write!(f, \"{}\", e.string());\n            }\n            let _ = write!(\n                f,\n                \"{key:>width$} \",\n                key = Green.bold().paint(node.key),\n                width = 2\n            );\n            let _ = write!(\n                f,\n                \"{value:>width$} \",\n                value = Blue.bold().paint(format!(\"{:.*}\", 2, node.value)),\n                width = 4\n            );\n            let _ = write!(\n                f,\n                \"{bal:<-width$}\",\n                bal = Red.bold().paint(node.balance),\n                width = 2\n            );\n            let _ = writeln!(f);\n\n            elems[hindex] = tail;\n        }\n\n        self.display(node.left, Side::Left, &elems, f);\n    }\n\n    pub fn gather_balances(&self) -> (Vec<K>, Vec<i8>) {\n        let mut keys = Vec::<K>::new();\n        let mut bals = Vec::<i8>::new();\n\n        self.gather_balances_impl(self.root, &mut keys, &mut bals);\n        (keys, bals)\n    }\n\n    #[allow(clippy::many_single_char_names)]\n    fn gather_balances_impl(&self, p: NodePtr, k: &mut Vec<K>, b: &mut Vec<i8>) {\n        if p.is_none() {\n            return;\n        }\n        let r = self.get_pointer(p, Side::Right);\n        self.gather_balances_impl(r, k, b);\n        k.push(self.get_key(p));\n        b.push(self.get_balance(p));\n        let l = self.get_pointer(p, Side::Left);\n        self.gather_balances_impl(l, k, b)\n    }\n\n    pub fn compute_balances(&mut self, p: NodePtr) -> i8 {\n        self.compute_balances_impl(p, 0)\n    }\n\n    fn compute_balances_impl(&mut self, p: NodePtr, level: i8) -> i8 {\n        if p.is_none() {\n            return level - 1;\n        }\n        let r = self.get_pointer(p, Side::Right);\n        let l = self.get_pointer(p, Side::Left);\n        let rb = self.compute_balances_impl(r, level + 1);\n        let lb = self.compute_balances_impl(l, level + 1);\n        self.set_balance(p, rb - lb);\n        std::cmp::max(rb, lb)\n    }\n\n    ///     P                Q\n    ///   /   \\     =>     /   \\\n    ///  h     Q          P     h'\n    fn rotate_left(&mut self, p: NodePtr, q: NodePtr) {\n        assert!(p.is_some());\n        assert!(q.is_some());\n        let p_parent = self.get_pointer(p, Side::Up);\n        // Take care of parent pointers\n        self.set_pointer(q, Side::Up, p_parent);\n        self.set_pointer(p, Side::Up, q);\n        let ql = self.get_pointer(q, Side::Left);\n        if ql.is_some() {\n            self.set_pointer(ql, Side::Up, p);\n        }\n\n        // Take care of child pointers\n        self.set_pointer(q, Side::Left, p);\n        self.set_pointer(p, Side::Right, ql);\n        if p_parent.is_some() {\n            let side = if self.get_pointer(p_parent, Side::Right) == p {\n                Side::Right\n            } else {\n                Side::Left\n            };\n            self.set_pointer(p_parent, side, q);\n        } else {\n            self.root = q;\n        }\n    }\n\n    ///     P                Q\n    ///   /   \\     =>     /   \\\n    ///  Q     h          h'    P\n    fn rotate_right(&mut self, p: NodePtr, q: NodePtr) {\n        assert!(p.is_some());\n        assert!(q.is_some());\n        let p_parent = self.get_pointer(p, Side::Up);\n        // Take care of parent pointers\n        self.set_pointer(q, Side::Up, p_parent);\n        self.set_pointer(p, Side::Up, q);\n        let qr = self.get_pointer(q, Side::Right);\n        if qr.is_some() {\n            self.set_pointer(qr, Side::Up, p);\n        }\n\n        // Take care of child pointers\n        self.set_pointer(q, Side::Right, p);\n        self.set_pointer(p, Side::Left, qr);\n        if p_parent.is_some() {\n            let side = if self.get_pointer(p_parent, Side::Right) == p {\n                Side::Right\n            } else {\n                Side::Left\n            };\n            self.set_pointer(p_parent, side, q);\n        } else {\n            self.root = q;\n        }\n    }\n\n    fn single_rotation(&mut self, side: Side, p: NodePtr, q: NodePtr) {\n        if side == Side::Left {\n            self.rotate_right(p, q);\n        } else {\n            self.rotate_left(p, q);\n        }\n    }\n\n    fn double_rotation(&mut self, side: Side, p: NodePtr, child_p: NodePtr, grand_p: NodePtr) {\n        if side == Side::Left {\n            self.rotate_left(child_p, grand_p);\n            self.rotate_right(p, grand_p);\n        } else {\n            self.rotate_right(child_p, grand_p);\n            self.rotate_left(p, grand_p);\n        }\n    }\n}\n\nimpl<K: Ord + Copy, V: Copy> Node<K, V> {\n    pub fn new(k: K, v: V) -> Node<K, V> {\n        Node {\n            key: k,\n            value: v,\n            balance: 0,\n            left: None,\n            right: None,\n            up: None,\n        }\n    }\n\n    pub fn is_leaf(&self) -> bool {\n        self.left.is_none() && self.right.is_none()\n    }\n\n    pub fn set_ptr(&mut self, side: Side, to: NodePtr) {\n        let field = match side {\n            Side::Up => &mut self.up,\n            Side::Left => &mut self.left,\n            _ => &mut self.right,\n        };\n        *field = to;\n    }\n\n    pub fn get_ptr(&self, side: Side) -> NodePtr {\n        match side {\n            Side::Up => self.up,\n            Side::Left => self.left,\n            _ => self.right,\n        }\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for AVLTree<K, V> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if self.root.is_none() {\n            write!(f, \"[empty]\")\n        } else {\n            let v: Vec<DisplayElement> = Vec::new();\n            self.display(self.root, Side::Up, &v, f);\n            Ok(())\n        }\n    }\n}\n\nfn get_insertion_constants(is_left: bool) -> &'static BalanceConstants {\n    if is_left {\n        &BALANCE_CONSTANTS_A\n    } else {\n        &BALANCE_CONSTANTS_B\n    }\n}\n\nfn get_deletion_constants(is_left: bool) -> &'static BalanceConstants {\n    get_insertion_constants(!is_left)\n}\n\npub fn random_bal_tree(n: u32) -> AVLTree<i32, f32> {\n    let mut tree: AVLTree<i32, f32> = AVLTree::new();\n    let mut rng = rand::thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let key_range = Uniform::new(-(n as i32) / 2, (n as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert_bal(0, rng.sample(value_range));\n    for _ in 0..n {\n        tree.insert_bal(rng.sample(key_range), rng.sample(value_range));\n    }\n    tree\n}\n\n#[allow(clippy::float_cmp)]\n#[cfg(test)]\nmod tests {\n    use rand::distributions::Uniform;\n    use rand::prelude::*;\n\n    use super::AVLTree;\n    use random_bal_tree;\n\n    #[test]\n    fn test_insert() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        assert_eq!(tree.lookup(4), Some(4.4));\n        assert_eq!(tree.lookup(5), None);\n        assert_eq!(tree.lookup(-8), Some(-8.8));\n\n        let s = &tree.store;\n        assert_eq!(\n            s[s[s[tree.root.unwrap()].right.unwrap()].right.unwrap()].value,\n            12.12\n        );\n        assert_eq!(\n            s[s[s[tree.root.unwrap()].right.unwrap()].right.unwrap()].left,\n            None\n        );\n    }\n\n    #[test]\n    fn test_delete() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        // delete leaf\n        tree.delete(12);\n        assert_eq!(tree.lookup(12), None);\n        let mut n = tree.search(8).unwrap();\n        assert_eq!(n.right, None);\n\n        // delete one-child node\n        tree.delete(4);\n        assert_eq!(tree.lookup(4), None);\n        n = tree.search(0).unwrap();\n        assert_eq!(tree.store[n.right.unwrap()].key, 8);\n\n        // delete two-child node\n        tree.insert(6, 6.6);\n        tree.insert(10, 10.10);\n        tree.insert(7, 7.7);\n        tree.delete(8);\n        n = tree.search(7).unwrap();\n        assert_eq!(tree.store[n.left.unwrap()].key, 6);\n        assert_eq!(tree.store[n.right.unwrap()].key, 10);\n        assert_eq!(tree.store[n.up.unwrap()].key, 0);\n\n        // delete two-child root\n        tree.delete(0);\n        assert_eq!(tree.store[tree.root.unwrap()].key, -8);\n\n        // delete one-child root\n        tree.delete(-8);\n        assert_eq!(tree.store[tree.root.unwrap()].key, 7);\n\n        // delete no-child root\n        tree.delete(6);\n        tree.delete(7);\n        tree.delete(10);\n        assert!(tree.root.is_none());\n        assert_eq!(tree.store.len(), 0);\n    }\n\n    #[test]\n    fn test_rotate_left() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(4, 4.4);\n        tree.insert(-8, -8.8);\n\n        let mut r = tree.root;\n        let mut right = tree.store[r.unwrap()].right;\n        tree.rotate_left(r, right);\n        r = tree.root;\n        right = tree.store[r.unwrap()].right;\n        let left = tree.store[r.unwrap()].left;\n        let left_left = tree.store[left.unwrap()].left;\n        let left_right = tree.store[left.unwrap()].right;\n        assert_eq!(right, None);\n        assert_eq!(tree.store[left.unwrap()].key, 0);\n        assert_eq!(tree.store[left_left.unwrap()].key, -8);\n        assert_eq!(tree.store[left_right.unwrap()].key, 4);\n        assert_eq!(tree.store[r.unwrap()].key, 8);\n    }\n\n    #[test]\n    fn test_rotate_right() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        tree.insert(-4, 4.4);\n\n        let mut r = tree.root;\n        let mut left = tree.store[r.unwrap()].left;\n        tree.rotate_right(r, left);\n        r = tree.root;\n        left = tree.store[r.unwrap()].left;\n        let right = tree.store[r.unwrap()].right;\n        let right_right = tree.store[right.unwrap()].right;\n        let right_left = tree.store[right.unwrap()].left;\n        assert_eq!(left, None);\n        assert_eq!(tree.store[right.unwrap()].key, 0);\n        assert_eq!(tree.store[right_right.unwrap()].key, 8);\n        assert_eq!(tree.store[right_left.unwrap()].key, -4);\n        assert_eq!(tree.store[r.unwrap()].key, -8);\n    }\n\n    #[test]\n    // This tree tests all four insertion types\n    fn test_balanced_inserts() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(8, 8.8);\n        tree.insert_bal(-8, -8.8);\n        tree.insert_bal(12, 12.12);\n        tree.insert_bal(16, 16.16);\n        tree.insert_bal(11, 11.11);\n        tree.insert_bal(4, 4.4);\n        tree.insert_bal(-10, -8.8);\n        tree.insert_bal(-12, -8.8);\n        tree.insert_bal(-9, -8.8);\n\n        let mut res = tree.gather_balances();\n        let (_, bals) = res;\n        assert!(bals.iter().max().unwrap() < &2);\n        assert!(bals.iter().min().unwrap() > &-2);\n\n        for _ in 0..10 {\n            tree = random_bal_tree(1000);\n            res = tree.gather_balances();\n            let (_, bals) = res;\n            assert!(bals.iter().max().unwrap() < &2);\n            assert!(bals.iter().min().unwrap() > &-2);\n        }\n    }\n\n    #[test]\n    /// This sequence hits all five rotation possibilities on each side.\n    fn test_balanced_deletes() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(-32, 0.0);\n        tree.insert_bal(32, 0.0);\n        tree.insert_bal(-64, 0.0);\n        tree.insert_bal(64, 0.0);\n        tree.delete_bal(64);\n        tree.delete_bal(32);\n        tree.delete_bal(-32);\n        tree.delete_bal(-64);\n        tree.delete_bal(0);\n        assert_eq!(tree.root, None);\n        assert_eq!(tree.store.len(), 0);\n\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(-32, 0.0);\n        tree.insert_bal(32, 0.0);\n        tree.insert_bal(-64, 0.0);\n        tree.insert_bal(64, 0.0);\n        tree.insert_bal(-16, 0.0);\n        tree.insert_bal(16, 0.0);\n        tree.insert_bal(-8, 0.0);\n        tree.insert_bal(8, 0.0);\n        tree.insert_bal(-12, 0.0);\n        tree.insert_bal(-7, 0.0);\n        tree.insert_bal(-6, 0.0);\n        tree.insert_bal(-11, 0.0);\n\n        tree.delete_bal(-64);\n        tree.delete_bal(-32);\n        tree.delete_bal(-7);\n        tree.delete_bal(-6);\n        tree.delete_bal(-16);\n        tree.delete_bal(-11);\n        tree.delete_bal(-12);\n        tree.delete_bal(8);\n        tree.delete_bal(-8);\n        tree.delete_bal(0);\n        tree.insert_bal(24, 0.0);\n        tree.insert_bal(8, 0.0);\n        tree.insert_bal(4, 0.0);\n        tree.insert_bal(128, 0.0);\n        tree.insert_bal(48, 0.0);\n        tree.delete_bal(32);\n        tree.delete_bal(48);\n\n        tree.insert_bal(-24, 0.0);\n        tree.insert_bal(-8, 0.0);\n        tree.insert_bal(-128, 0.0);\n        tree.insert_bal(-48, 0.0);\n        tree.insert_bal(-20, 0.0);\n        tree.insert_bal(-30, 0.0);\n        tree.insert_bal(-22, 0.0);\n        tree.insert_bal(-21, 0.0);\n        tree.delete_bal(24);\n        tree.delete_bal(64);\n        tree.delete_bal(-30);\n        tree.delete_bal(-22);\n        tree.delete_bal(-21);\n        tree.delete_bal(-128);\n        tree.delete_bal(128);\n        tree.delete_bal(-8);\n        tree.insert_bal(-96, 0.0);\n        tree.insert_bal(-95, 0.0);\n        tree.insert_bal(-10, 0.0);\n        tree.insert_bal(6, 0.0);\n        tree.delete_bal(-24);\n\n        let mut res = tree.gather_balances();\n        let (_, bals) = res;\n        assert!(bals.iter().max().unwrap() < &2);\n        assert!(bals.iter().min().unwrap() > &-2);\n\n        let mut p = tree.root;\n        while p.is_some() {\n            let key = tree.store[p.unwrap()].key;\n            tree.delete_bal(key);\n            p = tree.root;\n        }\n        assert_eq!(tree.root, None);\n        assert_eq!(tree.store.len(), 0);\n\n        // */*/+1 patterns\n        tree.insert(6, 0.0);\n        tree.insert(-1, 0.0);\n        tree.insert(9, 0.0);\n        tree.insert(7, 0.0);\n        tree.insert(3, 0.0);\n        tree.insert(-9, 0.0);\n        tree.insert(4, 0.0);\n        p = tree.root;\n        tree.compute_balances(p);\n        tree.delete_bal(-9);\n        res = tree.gather_balances();\n        let (_, bals) = res;\n        tree.compute_balances(p);\n        res = tree.gather_balances();\n        let (_, bals_after) = res;\n        assert_eq!(bals, bals_after);\n\n        tree.insert(6, 0.0);\n        tree.insert(-1, 0.0);\n        tree.insert(3, 0.0);\n        tree.insert(9, 0.0);\n        tree.insert(7, 0.0);\n        tree.insert(11, 0.0);\n        tree.insert(8, 0.0);\n        p = tree.root;\n        tree.compute_balances(p);\n        tree.delete_bal(-1);\n        res = tree.gather_balances();\n        let (_, bals) = res;\n        tree.compute_balances(p);\n        res = tree.gather_balances();\n        let (_, bals_after) = res;\n        assert_eq!(bals, bals_after);\n\n        let mut rng = thread_rng();\n        for _ in 0..100 {\n            tree = random_bal_tree(100);\n            for i in Uniform::from(-50..50).sample_iter(&mut rng).take(80) {\n                tree.delete_bal(i);\n            }\n        }\n\n        res = tree.gather_balances();\n        let (_, bals) = res;\n\n        if !bals.is_empty() {\n            assert!(*bals.iter().max().unwrap() < 2);\n            assert!(*bals.iter().min().unwrap() > -2);\n        }\n    }\n}\nextern crate avl_tree;\nextern crate rand;\nextern crate structopt;\n\nuse rand::distributions::Uniform;\nuse rand::Rng;\nuse structopt::StructOpt;\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Number of nodes in the random tree\n    #[structopt(short = \"r\", default_value = \"100\")]\n    nodes: usize,\n\n    /// Number of random inserts and deletes\n    #[structopt(short = \"n\", default_value = \"0\")]\n    operations: usize,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n\n    let mut tree = avl_tree::random_bal_tree(opt.nodes as u32);\n    let mut rng = rand::thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single`\n    let key_range = Uniform::new(-(opt.operations as i32) / 2, (opt.operations as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert_bal(0, rng.sample(value_range));\n    for _ in 0..opt.operations {\n        tree.insert_bal(rng.sample(key_range), rng.sample(value_range));\n    }\n    let (_, bals) = tree.gather_balances();\n    assert!(*bals.iter().max().unwrap() < 2);\n    assert!(*bals.iter().min().unwrap() > -2);\n\n    println!(\n        \"AVL tree after ~{} random inserts and ~{} random deletes, starting with {} nodes:\",\n        opt.operations, opt.operations, opt.nodes\n    );\n    println!(\"{}\", tree);\n}\n",
    "path": "tasks/avl-tree",
    "remote_code": null,
    "title": "AVL tree",
    "url": "http://rosettacode.org/wiki/AVL_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abbreviations, automatic",
    "url": "http://rosettacode.org/wiki/Abbreviations,_automatic"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let commands = \"\n        Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy \\\n        COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find \\\n        NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput \\\n        Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO \\\n        MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT \\\n        READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT \\\n        RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up \\\n    \";\n    let split = commands.split_ascii_whitespace();\n    let count_hashtable: HashMap<&str, usize> = split\n        .map(|word| {\n            (\n                word,\n                word.chars().take_while(|c| c.is_ascii_uppercase()).count(),\n            )\n        })\n        .collect();\n\n    let line = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n    let mut words_vec: Vec<String> = vec![];\n    for word in line.split_ascii_whitespace() {\n        let mut split = commands.split_ascii_whitespace();\n        let abbr = split.find(|x| {\n            x.to_ascii_lowercase()\n                .starts_with(&word.to_ascii_lowercase())\n                && word.len() >= *count_hashtable.get(x).unwrap()\n        });\n        words_vec.push(match abbr {\n            Some(word) => word.to_ascii_uppercase(),\n            None => String::from(\"*error*\"),\n        });\n    }\n    let corrected_line = words_vec.join(\" \");\n    println!(\"{}\", corrected_line);\n}\n",
    "path": "tasks/abbreviations-easy",
    "remote_code": null,
    "title": "Abbreviations, easy",
    "url": "http://rosettacode.org/wiki/Abbreviations,_easy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abbreviations, simple",
    "url": "http://rosettacode.org/wiki/Abbreviations,_simple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abelian sandpile model",
    "url": "http://rosettacode.org/wiki/Abelian_sandpile_model"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abelian sandpile model/Identity",
    "url": "http://rosettacode.org/wiki/Abelian_sandpile_model/Identity"
  },
  {
    "local_code": "trait Shape {\n    fn area(&self) -> i32;\n\n    fn is_shape(&self) -> bool {\n        true\n    }\n}\n\nstruct Square {\n    side_length: i32,\n}\n\nimpl Shape for Square {\n    fn area(&self) -> i32 {\n        self.side_length * self.side_length\n    }\n}\n\nfn main() {\n    let square = Square { side_length: 2 };\n    println!(\"The square's area is: {}\", square.area());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Shape, Square};\n\n    #[test]\n    fn area() {\n        let square = Square { side_length: 2 };\n        assert_eq!(square.area(), 4);\n    }\n\n    #[test]\n    fn is_shape() {\n        let square = Square { side_length: 2 };\n        assert!(square.is_shape())\n    }\n}\n",
    "path": "tasks/abstract-type",
    "remote_code": "trait Shape {\n    fn area(self) -> i32;\n}",
    "title": "Abstract type",
    "url": "http://rosettacode.org/wiki/Abstract_type"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abundant odd numbers",
    "url": "http://rosettacode.org/wiki/Abundant_odd_numbers"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications\nuse std::cmp::Ordering;\nuse std::iter::Map;\nuse std::ops::Range;\n\nfn divisors(n: i32) -> Vec<i32> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results\n}\n\nfn classify_numbers() -> Map<Range<i32>, fn(i32) -> Ordering> {\n    fn sum_divisors_and_cmp(n: i32) -> Ordering {\n        divisors(n).iter().fold(0, std::ops::Add::add).cmp(&n)\n    }\n    (1i32..20_001).map(sum_divisors_and_cmp as fn(i32) -> Ordering)\n}\n\nfn main() {\n    let mut deficient = 0;\n    let mut perfect = 0;\n    let mut abundant = 0;\n    for item in classify_numbers() {\n        match item {\n            Ordering::Less => deficient += 1,\n            Ordering::Equal => perfect += 1,\n            Ordering::Greater => abundant += 1,\n        }\n    }\n    println!(\"deficient: {}\", deficient);\n    println!(\"perfect: {}\", perfect);\n    println!(\"abundant: {}\", abundant);\n}\n\n#[test]\nfn test_divisors() {\n    let n = 6;\n    let divs = divisors(n);\n    let expected_divs: Vec<i32> = vec![1, 2, 3];\n    assert_eq!(divs, expected_divs);\n}\n\n#[test]\nfn test_classify_numbers() {\n    let mut deficient = 0;\n    let mut perfect = 0;\n    let mut abundant = 0;\n    for item in classify_numbers() {\n        match item {\n            Ordering::Less => deficient += 1,\n            Ordering::Equal => perfect += 1,\n            Ordering::Greater => abundant += 1,\n        }\n    }\n\n    // Numbers taken from the wiki page.\n    assert_eq!(deficient, 15043);\n    assert_eq!(perfect, 4);\n    assert_eq!(abundant, 4953);\n}\n",
    "path": "tasks/abundant-deficient-and-perfect-number-classifications",
    "remote_code": "fn main() {\n    // deficient starts at 1 because 1 is deficient but proper_divisors returns\n    // and empty Vec\n    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);\n    for i in 1..20_001 {\n        if let Some(divisors) = i.proper_divisors() {\n            let sum: u64 = divisors.iter().sum();\n            if sum < i {\n                deficient += 1\n            } else if sum > i {\n                abundant += 1\n            } else {\n                perfect += 1\n            }\n        }\n    }\n    println!(\"deficient:\\t{:5}\\nperfect:\\t{:5}\\nabundant:\\t{:5}\",\n             deficient, perfect, abundant);\n}\n",
    "title": "Abundant, deficient and perfect number classifications",
    "url": "http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications"
  },
  {
    "local_code": "use std::ops::Add;\n\nfn accum<'a, T>(mut n: T) -> Box<dyn FnMut(T) -> T + 'a>\nwhere\n    T: 'a + Add<T, Output = T> + Copy,\n{\n    Box::new(move |i: T| {\n        n = n + i;\n        n\n    })\n}\n\nfn main() {\n    println!(\"{}\", accumulate());\n}\n\n#[test]\nfn test() {\n    use std::f32;\n\n    assert!((8.3 - accumulate()).abs() < f32::EPSILON);\n}\n\n/// Deviation: works with all types implementing addition, but not a mixture\n/// of types (it is possible to handle mixed types, but would require type\n/// switching at the moment).\nfn accumulate() -> f32 {\n    let mut g = accum(1f32);\n    g(5.);\n    let _ = accum(3i32);\n    g(2.3)\n}\n",
    "path": "tasks/accumulator-factory",
    "remote_code": "// rustc 1.26.0 or later\n\nuse std::ops::Add;\n\nfn foo<Num>(n: Num) -> impl FnMut(Num) -> Num\n        where Num: Add<Output=Num> + Copy + 'static {\n    let mut acc = n;\n    move |i: Num| {\n        acc = acc + i;\n        acc\n    }\n}\n\nfn main() {\n    let mut x = foo(1.);\n    x(5.);\n    foo(3.);\n    println!(\"{}\", x(2.3));\n}",
    "title": "Accumulator factory",
    "url": "http://rosettacode.org/wiki/Accumulator_factory"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Achilles numbers",
    "url": "http://rosettacode.org/wiki/Achilles_numbers"
  },
  {
    "local_code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\n#[test]\nfn test_ack() {\n    let expected = 125;\n    let found = ack(3, 4);\n    assert_eq!(expected, found)\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a);\n}\n",
    "path": "tasks/ackermann-function",
    "remote_code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a); // 125\n}\n",
    "title": "Ackermann function",
    "url": "http://rosettacode.org/wiki/Ackermann_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet conn = ldap3::LdapConn::new(\"ldap://ldap.example.com\")?;\nconn.simple_bind(\"bind_dn\", \"bind_pass\")?.success()?;\n",
    "title": "Active Directory/Connect",
    "url": "http://rosettacode.org/wiki/Active_Directory/Connect"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Active Directory/Search for a user",
    "url": "http://rosettacode.org/wiki/Active_Directory/Search_for_a_user"
  },
  {
    "local_code": "use std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nuse num::traits::Zero;\nuse num::Float;\n\nuse channel::{select, SendError, Sender};\nuse crossbeam_channel as channel;\n\npub type Actor<S> = Sender<Box<dyn Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<dyn Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = channel::unbounded();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = channel::tick(Duration::from_millis(frequency.into()));\n            let mut t = 0;\n            let mut k: Box<dyn Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    recv(periodic) -> res => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    recv(input) -> res => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<dyn Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}\n",
    "path": "tasks/active-object",
    "remote_code": "#![feature(mpsc_select)]\n\nextern crate num;\nextern crate schedule_recv;\n\nuse num::traits::Zero;\nuse num::Float;\nuse schedule_recv::periodic_ms;\nuse std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::mpsc::{self, SendError, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\npub type Actor<S> = Sender<Box<Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = mpsc::channel();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || -> () {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = periodic_ms(frequency);\n            let mut t = 0;\n            let mut k: Box<Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    res = periodic.recv() => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    res = input.recv() => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}",
    "title": "Active object",
    "url": "http://rosettacode.org/wiki/Active_object"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Add a variable to a class instance at runtime",
    "url": "http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime"
  },
  {
    "local_code": "//===Flat implementation===\n\nfn main() {\n    let limit = 500;\n    let column_w = limit.to_string().len() + 1;\n    let mut pms = Vec::with_capacity(limit / 2 - limit / 3 / 2 - limit / 5 / 3 / 2 + 1);\n    let mut count = 0;\n    for u in (2..3).chain((3..limit).step_by(2)) {\n        if pms.iter().take_while(|&&p| p * p <= u).all(|&p| u % p != 0) {\n            pms.push(u);\n            let dgs = std::iter::successors(Some(u), |&n| (n > 9).then(|| n / 10)).map(|n| n % 10);\n            if pms.binary_search(&dgs.sum()).is_ok() {\n                print!(\"{}{u:column_w$}\", if count % 10 == 0 { \"\\n\" } else { \"\" });\n                count += 1;\n            }\n        }\n    }\n    println!(\"\\n---\\nFound {count} additive primes less than {limit}\");\n}\n",
    "path": "tasks/additive-primes/addit_primes-flat",
    "remote_code": null,
    "title": "Additive primes",
    "url": "http://rosettacode.org/wiki/Additive_primes"
  },
  {
    "local_code": "fn main() {\n    // Get the memory address of a variable\n    let var = 1_i32;\n    println!(\"address of var: {:p}\", &var);\n\n    // Get the value at a certain memory address\n    let address = &var as *const i32;\n    println!(\"value at {:p}: {:?}\", address, var);\n\n    // Set the value at a certain memory address\n    unsafe {\n        *(address as *mut i32) = 0;\n        println!(\"value at {:p}: {:?}\", address, var);\n    }\n}\n",
    "path": "tasks/address-of-a-variable",
    "remote_code": "let v1 = vec![vec![1,2,3]; 10];\nprintln!(\"Original address: {:p}\", &v1);\nlet mut v2;\n// Override rust protections on reading from uninitialized memory\nunsafe {v2 = mem::uninitialized();} \nlet addr = &mut v2 as *mut _;\n\n// ptr::write() though it takes v1 by value, v1s destructor is not run when it goes out of\n// scope, which is good since then we'd have a vector of free'd vectors\nunsafe {ptr::write(addr, v1)}\nprintln!(\"New address: {:p}\", &v2);",
    "title": "Address of a variable",
    "url": "http://rosettacode.org/wiki/Address_of_a_variable"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(box_patterns, box_syntax)]\nuse self::Color::*;\nuse std::cmp::Ordering::*;\n\nenum Color {R,B}\n\ntype Link<T> = Option<Box<N<T>>>;\nstruct N<T> {\n    c: Color,\n    l: Link<T>,\n    val: T,\n    r: Link<T>,\n}\n\n\nimpl<T: Ord> N<T> {\n    fn balance(col: Color, n1: Link<T>, z: T, n2: Link<T>) -> Link<T> {\n        Some(box \n             match (col,n1,n2) {\n                   (B, Some(box N {c: R, l: Some(box N {c: R, l: a, val: x, r: b}), val: y, r: c}), d)\n                |  (B, Some(box N {c: R, l: a, val: x, r: Some (box N {c: R, l: b, val: y, r: c})}), d)\n                => N {c: R, l: Some(box N {c: B, l: a, val: x, r: b}), val: y, r: Some(box N {c: B, l: c, val: z, r: d})},\n                   (B, a, Some(box N {c: R, l: Some(box N {c: R, l: b, val: y, r: c}), val: v, r: d}))\n                |  (B, a, Some(box N {c: R, l: b, val: y, r: Some(box N {c: R, l: c, val: v, r: d})}))\n                => N {c: R, l: Some(box N {c: B, l: a, val: z, r: b}), val: y, r: Some(box N {c: B, l: c, val: v, r: d})},\n                (col, a, b) => N {c: col, l: a, val: z, r: b},\n        })\n    }\n    fn insert(x: T, n: Link<T>) -> Link<T> {\n        match n {\n            None => Some(box N { c: R, l: None, val: x, r: None }),\n            Some(n) =>  {\n                let n = *n;\n                let N {c: col, l: a, val: y, r: b} = n;\n                match x.cmp(&y) {\n                    Greater => Self::balance(col, a,y,Self::insert(x,b)),\n                    Less    => Self::balance(col, Self::insert(x,a),y,b),\n                    Equal   => Some(box N {c: col, l: a, val: y, r: b})\n                }\n            }\n        }\n    }\n}",
    "title": "Algebraic data types",
    "url": "http://rosettacode.org/wiki/Algebraic_data_types"
  },
  {
    "local_code": "const TEST_STR: &str = r\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n\";\n\nfn main() {\n    let (chunks, max_lengths) = align_columns(TEST_STR);\n    print_aligned_columns(&chunks, &max_lengths);\n}\n\nfn align_columns(text: &str) -> (Vec<Vec<String>>, Vec<usize>) {\n    let lines: Vec<String> = text.split('\\n').map(|s| s.to_string()).collect();\n    let mut max_lengths: Vec<usize> = Vec::new();\n    let mut chunks: Vec<Vec<String>> = Vec::new();\n\n    for line in &lines {\n        let split_line: Vec<String> = line.split('$').map(|s| s.to_string()).collect();\n        chunks.push(split_line.clone());\n        let v: Vec<usize> = split_line.iter().map(|chunk| chunk.len()).collect();\n\n        for i in 0..v.len() {\n            if i < max_lengths.len() {\n                max_lengths[i] = std::cmp::max(max_lengths[i], v[i]);\n            } else {\n                max_lengths.push(v[i]);\n            }\n        }\n    }\n\n    (chunks, max_lengths)\n}\n\nfn print_aligned_columns(chunks: &[Vec<String>], max_lengths: &[usize]) {\n    // left aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            print!(\"{0:<1$}\", split, 1 + max_lengths[i]);\n        }\n        println!();\n    }\n    println!();\n    // right aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            print!(\"{0:>1$}\", split, 1 + max_lengths[i]);\n        }\n        println!();\n    }\n    println!();\n    // center aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            let spaces: usize = 1 + max_lengths[i] - split.len();\n            for _ in 0..spaces >> 1 {\n                print!(\" \");\n            }\n            print!(\"{}\", split);\n            for _ in 0..(spaces - (spaces >> 1)) {\n                print!(\" \");\n            }\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_result() {\n    let (chunks, max_lengths) = align_columns(TEST_STR);\n    for chunkset in &chunks {\n        // the number of words in a chunkset is <= the number of values in max_lengths\n        assert!(chunkset.len() <= max_lengths.len());\n        for j in 0..chunkset.len() {\n            // a word in a chunkset cannot be longer than max_lengths\n            assert!(chunkset[j].len() <= max_lengths[j]);\n        }\n    }\n    print_aligned_columns(&chunks, &max_lengths);\n}\n",
    "path": "tasks/align-columns",
    "remote_code": "use std::iter::{repeat, Extend};\n\nenum AlignmentType {\n    Left,\n    Center,\n    Right,\n}\n\nfn get_column_widths(text: &str) -> Vec<usize> {\n    let mut widths = Vec::new();\n    for line in text\n        .lines()\n        .map(|s| s.trim_matches(' ').trim_end_matches('$'))\n    {\n        let lens = line.split('$').map(|s| s.chars().count());\n        for (idx, len) in lens.enumerate() {\n            if idx < widths.len() {\n                widths[idx] = std::cmp::max(widths[idx], len);\n            } else {\n                widths.push(len);\n            }\n        }\n    }\n    widths\n}\n\nfn align_columns(text: &str, alignment: AlignmentType) -> String {\n    let widths = get_column_widths(text);\n    let mut result = String::new();\n    for line in text\n        .lines()\n        .map(|s| s.trim_matches(' ').trim_end_matches('$'))\n    {\n        for (s, w) in line.split('$').zip(widths.iter()) {\n            let blank_count = w - s.chars().count();\n            let (pre, post) = match alignment {\n                AlignmentType::Left => (0, blank_count),\n                AlignmentType::Center => (blank_count / 2, (blank_count + 1) / 2),\n                AlignmentType::Right => (blank_count, 0),\n            };\n            result.extend(repeat(' ').take(pre));\n            result.push_str(s);\n            result.extend(repeat(' ').take(post));\n            result.push(' ');\n        }\n        result.push_str(\"\\n\");\n    }\n    result\n}\n\nfn main() {\n    let text = r#\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"#;\n\n    println!(\"{}\", align_columns(text, AlignmentType::Left));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Center));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Right));\n}",
    "title": "Align columns",
    "url": "http://rosettacode.org/wiki/Align_columns"
  },
  {
    "local_code": "#[derive(Debug, PartialEq)]\nenum AliquotType {\n    Terminating,\n    Perfect,\n    Amicable,\n    Sociable,\n    Aspiring,\n    Cyclic,\n    NonTerminating,\n}\n\n#[allow(clippy::needless_range_loop)]\nfn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {\n    let limit = 1i64 << 47; // 140737488355328\n    let mut terms = Some(num).into_iter().collect::<Vec<_>>();\n    for i in 0..16 {\n        let n = terms[i];\n        let divsum = (1..(n + 1) / 2 + 1).filter(|&x| n % x == 0 && n != x).sum();\n        let classification = if divsum == 0 {\n            Some(AliquotType::Terminating)\n        } else if divsum > limit {\n            Some(AliquotType::NonTerminating)\n        } else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {\n            let cycle_len = terms.len() - prev_idx;\n            Some(if prev_idx == 0 {\n                match cycle_len {\n                    1 => AliquotType::Perfect,\n                    2 => AliquotType::Amicable,\n                    _ => AliquotType::Sociable,\n                }\n            } else if cycle_len == 1 {\n                AliquotType::Aspiring\n            } else {\n                AliquotType::Cyclic\n            })\n        } else {\n            None\n        };\n        terms.push(divsum);\n        if let Some(result) = classification {\n            return (result, terms);\n        }\n    }\n    (AliquotType::NonTerminating, terms)\n}\n\nfn main() {\n    let nums = [\n        1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12_496, 1_264_460, 790, 909,\n        562, 1064, 1488, /* , 15355717786080 */\n    ];\n    for num in &nums {\n        println!(\"{} {:?}\", num, classify_aliquot(*num));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{classify_aliquot, AliquotType};\n\n    #[test]\n    fn terminating() {\n        assert_eq!(\n            classify_aliquot(11),\n            (AliquotType::Terminating, vec![11, 1, 0])\n        );\n        assert_eq!(\n            classify_aliquot(12),\n            (AliquotType::Terminating, vec![12, 16, 15, 9, 4, 3, 1, 0])\n        );\n    }\n\n    #[test]\n    fn perfect() {\n        assert_eq!(classify_aliquot(28), (AliquotType::Perfect, vec![28, 28]));\n        assert_eq!(\n            classify_aliquot(496),\n            (AliquotType::Perfect, vec![496, 496])\n        );\n    }\n\n    #[test]\n    fn amicable() {\n        assert_eq!(\n            classify_aliquot(220),\n            (AliquotType::Amicable, vec![220, 284, 220])\n        );\n        assert_eq!(\n            classify_aliquot(1184),\n            (AliquotType::Amicable, vec![1184, 1210, 1184])\n        );\n    }\n\n    #[test]\n    fn sociable() {\n        assert_eq!(\n            classify_aliquot(12_496),\n            (\n                AliquotType::Sociable,\n                vec![12_496, 14_288, 15_472, 14_536, 14_264, 12_496]\n            )\n        );\n        assert_eq!(\n            classify_aliquot(1_264_460),\n            (\n                AliquotType::Sociable,\n                vec![1_264_460, 1_547_860, 1_727_636, 1_305_184, 1_264_460]\n            )\n        );\n    }\n\n    #[test]\n    fn aspiring() {\n        assert_eq!(\n            classify_aliquot(790),\n            (AliquotType::Aspiring, vec![790, 650, 652, 496, 496])\n        );\n        assert_eq!(\n            classify_aliquot(909),\n            (AliquotType::Aspiring, vec![909, 417, 143, 25, 6, 6])\n        );\n    }\n\n    #[test]\n    fn cyclic() {\n        assert_eq!(\n            classify_aliquot(562),\n            (AliquotType::Cyclic, vec![562, 284, 220, 284])\n        );\n        assert_eq!(\n            classify_aliquot(1064),\n            (AliquotType::Cyclic, vec![1064, 1336, 1184, 1210, 1184])\n        );\n    }\n\n    #[ignore]\n    #[test]\n    fn non_terminating() {\n        assert_eq!(\n            classify_aliquot(1488),\n            (\n                AliquotType::NonTerminating,\n                vec![\n                    1488, 2480, 3472, 4464, 8432, 9424, 10_416, 21_328, 22_320, 55_056, 95_728,\n                    96_720, 236_592, 459_792, 881_392, 882_384,\n                ]\n            )\n        );\n        assert_eq!(\n            classify_aliquot(15_355_717_786_080),\n            (\n                AliquotType::NonTerminating,\n                vec![15_355_717_786_080, 44_534_663_601_120, 144_940_087_464_480]\n            )\n        );\n    }\n}\n",
    "path": "tasks/aliquot-sequence-classifications",
    "remote_code": "#[derive(Debug)]\nenum AliquotType { Terminating, Perfect, Amicable, Sociable, Aspiring, Cyclic, NonTerminating }\n\nfn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {\n    let limit = 1i64 << 47; //140737488355328\n    let mut terms = Some(num).into_iter().collect::<Vec<_>>();\n    for i in 0..16 {\n        let n = terms[i];\n        let divsum = (1..(n + 1) / 2 + 1).filter(|&x| n % x == 0 && n != x).fold(0, |sum, x| sum + x);\n        let classification = if divsum == 0 {\n            Some(AliquotType::Terminating)\n        }\n        else if divsum > limit {\n            Some(AliquotType::NonTerminating)\n        }\n        else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {\n            let cycle_len = terms.len() - prev_idx;\n            Some(if prev_idx == 0 {\n                match cycle_len {\n                    1 => AliquotType::Perfect,\n                    2 => AliquotType::Amicable,\n                    _ => AliquotType::Sociable\n                }\n            }\n            else {\n                if cycle_len == 1 {AliquotType::Aspiring} else {AliquotType::Cyclic}\n            })\n        }\n        else {\n            None\n        };\n        terms.push(divsum);\n        if let Some(result) = classification {\n            return (result, terms);\n        }\n    }\n    (AliquotType::NonTerminating, terms)\n}\n\nfn main() {\n    let nums = [1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488/*, 15355717786080*/];\n    for num in &nums {\n        println!(\"{} {:?}\", num, classify_aliquot(*num));\n    }\n}",
    "title": "Aliquot sequence classifications",
    "url": "http://rosettacode.org/wiki/Aliquot_sequence_classifications"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Almkvist-Giullera formula for pi",
    "url": "http://rosettacode.org/wiki/Almkvist-Giullera_formula_for_pi"
  },
  {
    "local_code": "fn is_kprime(mut n: usize, k: usize) -> bool {\n    let mut p = 2;\n    let mut f = 0;\n\n    while f < k && p * p <= n {\n        while 0 == n % p {\n            n /= p;\n            f += 1;\n        }\n        p += 1;\n    }\n\n    f + (n > 1) as usize == k\n}\n\nfn get_kprimes(k: usize, amount: usize) -> Vec<usize> {\n    (2..).filter(|&x| is_kprime(x, k)).take(amount).collect()\n}\n\nfn main() {\n    for k in 1..6 {\n        println!(\"k = {}: {:?}\", k, get_kprimes(k, 10));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::get_kprimes;\n\n    #[test]\n    fn k_equals_1() {\n        assert!(get_kprimes(1, 10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n    }\n\n    #[test]\n    fn k_equals_2() {\n        assert!(get_kprimes(2, 10) == [4, 6, 9, 10, 14, 15, 21, 22, 25, 26]);\n    }\n\n    #[test]\n    fn k_equals_3() {\n        assert!(get_kprimes(3, 10) == [8, 12, 18, 20, 27, 28, 30, 42, 44, 45]);\n    }\n\n    #[test]\n    fn k_equals_4() {\n        assert!(get_kprimes(4, 10) == [16, 24, 36, 40, 54, 56, 60, 81, 84, 88]);\n    }\n\n    #[test]\n    fn k_equals_5() {\n        assert!(get_kprimes(5, 10) == [32, 48, 72, 80, 108, 112, 120, 162, 168, 176]);\n    }\n}\n",
    "path": "tasks/almost-prime",
    "remote_code": "fn is_kprime(n: u32, k: u32) -> bool {\n    let mut primes = 0;\n    let mut f = 2;\n    let mut rem = n;\n    while primes < k && rem > 1{\n        while (rem % f) == 0 && rem > 1{\n            rem /= f;\n            primes += 1;\n        }\n        f += 1;\n    }\n    rem == 1 && primes == k\n}\n\nstruct KPrimeGen {\n    k: u32,\n    n: u32,\n}\n\nimpl Iterator for KPrimeGen {\n    type Item = u32;\n    fn next(&mut self) -> Option<u32> {\n        self.n += 1;\n        while !is_kprime(self.n, self.k) {\n            self.n += 1;\n        }\n        Some(self.n)\n    }\n}\n\nfn kprime_generator(k: u32) -> KPrimeGen {\n    KPrimeGen {k: k, n: 1}\n}\n\nfn main() {\n    for k in 1..6 {\n        println!(\"{}: {:?}\", k, kprime_generator(k).take(10).collect::<Vec<_>>());\n    }\n}",
    "title": "Almost prime",
    "url": "http://rosettacode.org/wiki/Almost_prime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::ops::Add;\nstruct Amb<'a> {\n    list: Vec<Vec<&'a str>>,\n}\nfn main() {\n    let amb = Amb {\n        list: vec![\n            vec![\"the\", \"that\", \"a\"],\n            vec![\"frog\", \"elephant\", \"thing\"],\n            vec![\"walked\", \"treaded\", \"grows\"],\n            vec![\"slowly\", \"quickly\"],\n        ],\n    };\n    match amb.do_amb(0, 0 as char) {\n        Some(text) => println!(\"{}\", text),\n        None => println!(\"Nothing found\"),\n    }\n}\nimpl<'a> Amb<'a> {\n    fn do_amb(&self, level: usize, last_char: char) -> Option<String> {\n        if self.list.is_empty() {\n            panic!(\"No word list\");\n        }\n        if self.list.len() <= level {\n            return Some(String::new());\n        }\n        let mut res = String::new();\n        let word_list = &self.list[level];\n        for word in word_list {\n            if word.chars().next().unwrap() == last_char || last_char == 0 as char {\n                res = res.add(word).add(\" \");\n                let answ = self.do_amb(level + 1, word.chars().last().unwrap());\n                match answ {\n                    Some(x) => {\n                        res = res.add(&x);\n                        return Some(res);\n                    }\n                    None => res.clear(),\n                }\n            }\n        }\n        None\n    }\n}",
    "title": "Amb",
    "url": "http://rosettacode.org/wiki/Amb"
  },
  {
    "local_code": "fn sum_of_divisors(val: u32) -> u32 {\n    (1..val / 2 + 1).filter(|n| val % n == 0).sum()\n}\n\nfn main() {\n    let iter = (1..20_000)\n        .map(|i| (i, sum_of_divisors(i)))\n        .filter(|&(i, div_sum)| i > div_sum);\n\n    for (i, sum1) in iter {\n        if sum_of_divisors(sum1) == i {\n            println!(\"{} {}\", i, sum1);\n        }\n    }\n}\n",
    "path": "tasks/amicable-pairs",
    "remote_code": "fn sum_of_divisors(val: u32) -> u32 {\n    (1..val/2+1).filter(|n| val % n == 0)\n                .fold(0, |sum, n| sum + n)\n}\n\nfn main() {\n    let iter = (1..20_000).map(|i| (i, sum_of_divisors(i)))\n                          .filter(|&(i, div_sum)| i > div_sum);\n\n    for (i, sum1) in iter {\n        if sum_of_divisors(sum1) == i {\n           println!(\"{} {}\", i, sum1);\n        }\n    }\n}",
    "title": "Amicable pairs",
    "url": "http://rosettacode.org/wiki/Amicable_pairs"
  },
  {
    "local_code": "use std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::{HashMap, HashSet};\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::BufReader;\n\nfn sorted_characters(string: &str) -> String {\n    let mut chars = string.chars().collect::<Vec<char>>();\n    chars.sort_unstable();\n    chars.iter().cloned().collect()\n}\n\n/// Returns groups of anagrams where each group consists of a set\n/// containing the words\nfn anagrams<T: Iterator<Item = String>>(lines: T) -> HashMap<String, HashSet<String>> {\n    let mut groups = HashMap::new();\n\n    // Make groups of words according to the letters they contain\n    for line in lines {\n        let s = line.trim();\n        let sorted = sorted_characters(s);\n        let set = match groups.entry(sorted) {\n            Vacant(entry) => entry.insert(HashSet::new()), // Insert new set if not found\n            Occupied(entry) => entry.into_mut(),\n        };\n\n        set.insert(s.to_string());\n    }\n\n    groups\n}\n\n/// Returns the groups of anagrams that contain the most words in them\nfn largest_groups(groups: &HashMap<String, HashSet<String>>) -> HashMap<String, HashSet<String>> {\n    let max_length = groups.iter().map(|(_, group)| group.len()).max().unwrap();\n    groups\n        .iter()\n        .filter_map(|(key, group)| {\n            if group.len() == max_length {\n                Some((key.clone(), group.clone()))\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\nfn main() {\n    let reader = BufReader::new(File::open(\"resources/unixdict.txt\").unwrap());\n    let lines = reader.lines().map(|l| l.unwrap());\n\n    let anagram_groups = anagrams(lines);\n    let largest_groups = largest_groups(&anagram_groups);\n\n    // Print the words in the largest groups of anagrams\n    for group in largest_groups.values() {\n        for word in group {\n            print!(\"{} \", word)\n        }\n        println!();\n    }\n}\n\n#[test]\nfn basic_test() {\n    fn to_hash(s: &[&str]) -> HashSet<String> {\n        s.iter().map(|s| s.to_string()).collect()\n    }\n\n    fn assert_has_value(map: &HashMap<String, HashSet<String>>, set: &HashSet<String>) {\n        assert!(map.values().any(|v| v == set));\n    }\n\n    // Groups of anagrams\n    let group1 = &to_hash(&[\"lane\", \"neal\", \"lean\"]);\n    let group2 = &to_hash(&[\"angel\", \"angle\", \"galen\"]);\n    let group3 = &to_hash(&[\"glare\", \"large\"]);\n\n    // Prepare the input for the program\n    let word_iter = group1.iter().chain(group2.iter().chain(group3.iter()));\n\n    // Here begins the real testing\n    let all_groups = &anagrams(word_iter.map(|s| s.to_string()));\n    let largest_groups = &largest_groups(all_groups);\n\n    // Groups 1, 2 and 3 are contained in \"all_groups\"\n    assert_has_value(all_groups, group1);\n    assert_has_value(all_groups, group2);\n    assert_has_value(all_groups, group3);\n\n    // Groups 1 and 2 are contained in \"largest_groups\". Group 3 is not.\n    assert_has_value(largest_groups, group1);\n    assert_has_value(largest_groups, group2);\n    assert!(largest_groups.values().all(|group| group != group3));\n}\n",
    "path": "tasks/anagrams",
    "remote_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead,BufReader};\nuse std::borrow::ToOwned;\n\nextern crate unicode_segmentation;\nuse unicode_segmentation::{UnicodeSegmentation};\n\nfn main () {\n    let file = BufReader::new(File::open(\"unixdict.txt\").unwrap());\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let s = line.unwrap();\n        //Bytes:      let mut sorted = s.trim().bytes().collect::<Vec<_>>();\n        //Codepoints: let mut sorted = s.trim().chars().collect::<Vec<_>>();\n        let mut sorted = s.trim().graphemes(true).map(ToOwned::to_owned).collect::<Vec<_>>();\n        sorted.sort();\n\n        map.entry(sorted).or_insert_with(Vec::new).push(s);\n    }\n\n    if let Some(max_len) = map.values().map(|v| v.len()).max() {\n        for anagram in map.values().filter(|v| v.len() == max_len) {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}",
    "title": "Anagrams",
    "url": "http://rosettacode.org/wiki/Anagrams"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Deranged anagrams\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse std::io::BufReader;\nuse std::io::BufRead;\nuse std::usize::MAX;\n\n/// Get words from unix dictionary file\npub fn get_words() -> Result<Vec<String>, io::Error> {\n    let mut words = vec!();\n    // open file\n    let f = File::open(\"data/unixdict.txt\")?;\n    // read line by line\n    let reader = BufReader::new(&f);\n    for line in reader.lines() {\n        words.push(line?)\n    }\n    Ok(words)\n}\n\n/// Get the longest deranged anagram in the given list of word if any\npub fn longest_deranged(v: &mut Vec<String>) -> Option<(String,String)>{\n    // sort by length descending then by alphabetical order\n    v.sort_by(|s1, s2| {\n        let mut c = s2.len().cmp(&s1.len());\n        if c == Ordering::Equal {\n            c = s1.cmp(s2);\n        }\n        c\n    });\n    // keep all strings keyed by sorted characters (since anagrams have the same list of sorted characters)\n    let mut signatures : HashMap<Vec<char>, Vec<&String>> = HashMap::new();\n    // save on memory by only keeping in the map strings of the current processed length\n    let mut previous_length = MAX;\n    for s in v {\n        // length change, clear the map\n        if s.len()<previous_length {\n            signatures.clear();\n            previous_length = s.len();\n        }\n        // generate key as sorted characters\n        let mut sorted_chars = s.chars().collect::<Vec<char>>();\n        sorted_chars.sort();\n        let anagrams = signatures.entry(sorted_chars).or_insert(vec!());\n        // find if any anagram (string with the same sorted character vector) is deranged\n        if let Some(a) = anagrams.iter().filter(|anagram| is_deranged(anagram, s)).next(){\n            return Some(((*a).clone(), s.clone()));\n        }\n        anagrams.push(s);\n    }\n    None\n}\n\n/// check if two strings do NOT have the same character in the same position\npub fn is_deranged(s1: &String, s2: &String) -> bool {\n    // we zip the character iterators and check we find no position with the same two characters\n    s1.chars().zip(s2.chars()).filter(|(a,b)| a == b).next().is_none()\n}\n\n/// an example main method printing the results\nfn main() {\n    let r = get_words();\n    match r {\n        Ok(mut v) => {\n            let od = longest_deranged(&mut v);\n            match od {\n                None => println!(\"No deranged anagrams found!\"),\n                Some((s1,s2)) => println!(\"{} {}\",s1,s2),\n            }\n        },\n        Err(e) => panic!(\"Could not read words: {}\",e)\n    } \n}",
    "title": "Anagrams/Deranged anagrams",
    "url": "http://rosettacode.org/wiki/Anagrams/Deranged_anagrams"
  },
  {
    "local_code": "/// Calculate difference between two bearings, in -180 to 180 degrees range\npub fn angle_difference(bearing1: f64, bearing2: f64) -> f64 {\n    let diff = (bearing2 - bearing1) % 360.0;\n\n    if diff < -180.0 {\n        360.0 + diff\n    } else if diff > 180.0 {\n        -360.0 + diff\n    } else {\n        diff\n    }\n}\n\nfn main() {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_angle_difference() {\n        assert_eq!(25.00, angle_difference(20.00, 45.00));\n        assert_eq!(90.00, angle_difference(-45.00, 45.00));\n        assert_eq!(175.00, angle_difference(-85.00, 90.00));\n        assert_eq!(-175.00, angle_difference(-95.00, 90.00));\n        assert_eq!(170.00, angle_difference(-45.00, 125.00));\n        assert_eq!(-170.00, angle_difference(-45.00, 145.00));\n        approx_eq(-118.1184, angle_difference(29.4803, -88.6381));\n        approx_eq(-80.7109, angle_difference(-78.3251, -159.036));\n        approx_eq(\n            -139.5832,\n            angle_difference(-70099.74233810938, 29840.67437876723),\n        );\n        approx_eq(\n            -72.3439,\n            angle_difference(-165313.6666297357, 33693.9894517456),\n        );\n        approx_eq(\n            -161.5029,\n            angle_difference(1174.8380510598456, -154146.66490124757),\n        );\n        approx_eq(\n            37.2988,\n            angle_difference(60175.77306795546, 42213.07192354373),\n        );\n    }\n\n    // approximate equality on floats.\n    // see also https://crates.io/crates/float-cmp\n    fn approx_eq(f1: f64, f2: f64) {\n        assert!((f2 - f1).abs() < 0.0001, \"{} != {}\", f1, f2)\n    }\n}\n",
    "path": "tasks/angle-difference-between-two-bearings",
    "remote_code": "\n/// Calculate difference between two bearings, in -180 to 180 degrees range\npub fn angle_difference(bearing1: f64, bearing2: f64) -> f64 {\n    let diff = (bearing2 - bearing1) % 360.0;\n    if diff < -180.0 {\n        360.0 + diff\n    } else if diff > 180.0 {\n        -360.0 + diff\n    } else {\n        diff\n    }\n\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_angle_difference() {\n        assert_eq!(25.00, angle_difference(20.00, 45.00));\n        assert_eq!(90.00, angle_difference(-45.00, 45.00));\n        assert_eq!(175.00, angle_difference(-85.00, 90.00));\n        assert_eq!(-175.00, angle_difference(-95.00, 90.00));\n        assert_eq!(170.00, angle_difference(-45.00, 125.00));\n        assert_eq!(-170.00, angle_difference(-45.00, 145.00));\n        approx_eq(-118.1184, angle_difference(29.4803, -88.6381));\n        approx_eq(-80.7109, angle_difference(-78.3251 , -159.036));\n        approx_eq(-139.5832, angle_difference(-70099.74233810938, 29840.67437876723));\n        approx_eq(-72.3439, angle_difference(-165313.6666297357, 33693.9894517456));\n        approx_eq(-161.5029, angle_difference(1174.8380510598456, -154146.66490124757));\n        approx_eq(37.2988, angle_difference(60175.77306795546, 42213.07192354373));\n    }\n\n    // approximate equality on floats.\n    // see also https://crates.io/crates/float-cmp\n    fn approx_eq(f1: f64, f2: f64) {\n        assert!((f2-f1).abs() < 0.0001, \"{} != {}\", f1, f2)\n    }\n}\n",
    "title": "Angle difference between two bearings",
    "url": "http://rosettacode.org/wiki/Angle_difference_between_two_bearings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Angles (geometric), normalization and conversion",
    "url": "http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n// using version 0.107.0 of piston_window\nuse piston_window::{clear, ellipse, line_from_to, PistonWindow, WindowSettings};\n\nconst PI: f64 = std::f64::consts::PI;\nconst WIDTH: u32 = 640;\nconst HEIGHT: u32 = 480;\n\nconst ANCHOR_X: f64 = WIDTH as f64 / 2. - 12.;\nconst ANCHOR_Y: f64 = HEIGHT as f64 / 4.;\nconst ANCHOR_ELLIPSE: [f64; 4] = [ANCHOR_X - 3., ANCHOR_Y - 3., 6., 6.];\n\nconst ROPE_ORIGIN: [f64; 2] = [ANCHOR_X, ANCHOR_Y];\nconst ROPE_LENGTH: f64 = 200.;\nconst ROPE_THICKNESS: f64 = 1.;\n\nconst DELTA: f64 = 0.05;\nconst STANDARD_GRAVITY_VALUE: f64 = -9.81;\n\n// RGBA Colors\nconst BLACK: [f32; 4] = [0., 0., 0., 1.];\nconst RED: [f32; 4] = [1., 0., 0., 1.];\nconst GOLD: [f32; 4] = [216. / 255., 204. / 255., 36. / 255., 1.0];\nfn main() {\n    let mut window: PistonWindow = WindowSettings::new(\"Pendulum\", [WIDTH, HEIGHT])\n        .exit_on_esc(true)\n        .build()\n        .unwrap();\n\n    let mut angle = PI / 2.;\n    let mut angular_vel = 0.;\n\n    while let Some(event) = window.next() {\n        let (angle_sin, angle_cos) = angle.sin_cos();\n        let ball_x = ANCHOR_X + angle_sin * ROPE_LENGTH;\n        let ball_y = ANCHOR_Y + angle_cos * ROPE_LENGTH;\n\n        let angle_accel = STANDARD_GRAVITY_VALUE / ROPE_LENGTH * angle_sin;\n        angular_vel += angle_accel * DELTA;\n        angle += angular_vel * DELTA;\n        let rope_end = [ball_x, ball_y];\n        let ball_ellipse = [ball_x - 7., ball_y - 7., 14., 14.];\n\n        window.draw_2d(&event, |context, graphics, _device| {\n            clear([1.0; 4], graphics);\n            line_from_to(\n                BLACK,\n                ROPE_THICKNESS,\n                ROPE_ORIGIN,\n                rope_end,\n                context.transform,\n                graphics,\n            );\n            ellipse(RED, ANCHOR_ELLIPSE, context.transform, graphics);\n            ellipse(GOLD, ball_ellipse, context.transform, graphics);\n        });\n    }\n}\n",
    "title": "Animate a pendulum",
    "url": "http://rosettacode.org/wiki/Animate_a_pendulum"
  },
  {
    "local_code": "use iced::{\n    button::{self, Button},\n    executor, Application, Command, Element, Settings, Subscription, Text,\n};\n\nstruct Animation {\n    button: button::State,\n    text: String,\n    reverse: bool,\n}\n\nimpl Default for Animation {\n    fn default() -> Self {\n        Animation {\n            button: button::State::default(),\n            text: String::from(\"Hello, world! \"),\n            reverse: false,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum Message {\n    Tick,\n    Reverse,\n}\n\nimpl Application for Animation {\n    type Executor = executor::Default;\n    type Message = Message;\n    type Flags = ();\n\n    fn new(_flags: ()) -> (Self, Command<Self::Message>) {\n        (Animation::default(), Command::none())\n    }\n\n    fn title(&self) -> String {\n        String::from(\"Animation\")\n    }\n\n    fn update(&mut self, message: Message) -> Command<Message> {\n        match message {\n            Message::Tick => {\n                if self.reverse {\n                    let begin = self.text.split_off(1);\n                    self.text.insert_str(0, &begin);\n                } else {\n                    let end = self.text.split_off(self.text.len() - 1);\n                    self.text.insert_str(0, &end);\n                }\n            }\n            Message::Reverse => self.reverse = !self.reverse,\n        }\n\n        Command::none()\n    }\n\n    fn subscription(&self) -> Subscription<Message> {\n        iced::time::every(std::time::Duration::from_millis(100)).map(|_| Message::Tick)\n    }\n\n    fn view(&mut self) -> Element<Message> {\n        Button::new(&mut self.button, Text::new(&self.text))\n            .on_press(Message::Reverse)\n            .into()\n    }\n}\n\nfn main() -> iced::Result {\n    Animation::run(Settings::default())\n}\n",
    "path": "tasks/animation",
    "remote_code": "#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n    use std::ops::Not;\n    use std::sync::{Arc, RwLock};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        let button = gtk::Button::new_with_label(\"Hello World! \");\n        window.add(&button);\n\n        let lock = Arc::new(RwLock::new(false));\n\n        let lock_button = lock.clone();\n        button.connect_clicked(move |_| {\n            let mut reverse = lock_button.write().unwrap();\n            *reverse = reverse.not();\n        });\n\n        let lock_thread = lock.clone();\n        gtk::timeout_add(100, move || {\n            let reverse = lock_thread.read().unwrap();\n            let mut text = button.get_label().unwrap();\n            let len = &text.len();\n\n            if *reverse {\n                let begin = &text.split_off(1);\n                text.insert_str(0, begin);\n            } else {\n                let end = &text.split_off(len - 1);\n                text.insert_str(0, end);\n            }\n\n            button.set_label(&text);\n\n            gtk::Continue(true)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}",
    "title": "Animation",
    "url": "http://rosettacode.org/wiki/Animation"
  },
  {
    "local_code": "fn fib(n: i64) -> Option<i64> {\n    // A function declared inside another function does not pollute the outer namespace.\n    fn actual_fib(n: i64) -> i64 {\n        if n < 2 {\n            n\n        } else {\n            actual_fib(n - 1) + actual_fib(n - 2)\n        }\n    }\n\n    if n < 0 {\n        None\n    } else {\n        Some(actual_fib(n))\n    }\n}\n\nfn main() {\n    println!(\"Fib(-1) = {:?}\", fib(-1));\n    println!(\"Fib(0) = {:?}\", fib(0));\n    println!(\"Fib(1) = {:?}\", fib(1));\n    println!(\"Fib(2) = {:?}\", fib(2));\n    println!(\"Fib(3) = {:?}\", fib(3));\n    println!(\"Fib(4) = {:?}\", fib(4));\n    println!(\"Fib(5) = {:?}\", fib(5));\n    println!(\"Fib(10) = {:?}\", fib(10));\n}\n\n#[test]\nfn test_fib() {\n    assert_eq!(fib(0).unwrap(), 0);\n    assert_eq!(fib(1).unwrap(), 1);\n    assert_eq!(fib(2).unwrap(), 1);\n    assert_eq!(fib(3).unwrap(), 2);\n    assert_eq!(fib(4).unwrap(), 3);\n    assert_eq!(fib(5).unwrap(), 5);\n    assert_eq!(fib(10).unwrap(), 55);\n}\n\n#[test]\nfn test_invalid_argument() {\n    assert_eq!(fib(-1), None);\n}\n",
    "path": "tasks/anonymous-recursion",
    "remote_code": "fn fib(n: i64) -> Option<i64> {\n    // A function declared inside another function does not pollute the outer namespace.\n    fn actual_fib(n: i64) -> i64 {\n        if n < 2 {\n            n\n        } else {\n            actual_fib(n - 1) + actual_fib(n - 2)\n        }\n    }\n\n    if n < 0 {\n        None\n    } else {\n        Some(actual_fib(n))\n    }\n}\n\nfn main() {\n    println!(\"Fib(-1) = {:?}\", fib(-1));\n    println!(\"Fib(0) = {:?}\", fib(0));\n    println!(\"Fib(1) = {:?}\", fib(1));\n    println!(\"Fib(2) = {:?}\", fib(2));\n    println!(\"Fib(3) = {:?}\", fib(3));\n    println!(\"Fib(4) = {:?}\", fib(4));\n    println!(\"Fib(5) = {:?}\", fib(5));\n    println!(\"Fib(10) = {:?}\", fib(10));\n}\n\n#[test]\nfn test_fib() {\n    assert_eq!(fib(0).unwrap(), 0);\n    assert_eq!(fib(1).unwrap(), 1);\n    assert_eq!(fib(2).unwrap(), 1);\n    assert_eq!(fib(3).unwrap(), 2);\n    assert_eq!(fib(4).unwrap(), 3);\n    assert_eq!(fib(5).unwrap(), 5);\n    assert_eq!(fib(10).unwrap(), 55);\n}\n\n#[test]\nfn test_invalid_argument() {\n    assert_eq!(fib(-1), None);\n}",
    "title": "Anonymous recursion",
    "url": "http://rosettacode.org/wiki/Anonymous_recursion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Anti-primes",
    "url": "http://rosettacode.org/wiki/Anti-primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Result;\nuse std::io::Write;\nuse std::path::Path;\n\n/// Password record with all fields\n#[derive(Eq, PartialEq, Debug)]\npub struct PasswordRecord {\n    pub account: String,\n    pub password: String,\n    pub uid: u64,\n    pub gid: u64,\n    pub gecos: Vec<String>,\n    pub directory: String,\n    pub shell: String,\n}\n\n\nimpl PasswordRecord {\n    /// new instance, cloning all fields\n    pub fn new(\n        account: &str,\n        password: &str,\n        uid: u64,\n        gid: u64,\n        gecos: Vec<&str>,\n        directory: &str,\n        shell: &str,\n    ) -> PasswordRecord {\n        PasswordRecord {\n            account: account.to_string(),\n            password: password.to_string(),\n            uid,\n            gid,\n            gecos: gecos.iter().map(|s| s.to_string()).collect(),\n            directory: directory.to_string(),\n            shell: shell.to_string(),\n        }\n    }\n\n    /// convert to one line string\n    pub fn to_line(&self) -> String {\n        let gecos = self.gecos.join(\",\");\n        format!(\n            \"{}:{}:{}:{}:{}:{}:{}\",\n            self.account, self.password, self.uid, self.gid, gecos, self.directory, self.shell\n        )\n    }\n\n    /// read record from line\n    pub fn from_line(line: &str) -> PasswordRecord {\n        let sp: Vec<&str> = line.split(\":\").collect();\n        if sp.len() < 7 {\n            panic!(\"Less than 7 fields found\");\n        } else {\n            let uid = sp[2].parse().expect(\"Cannot parse uid\");\n            let gid = sp[3].parse().expect(\"Cannot parse gid\");\n            let gecos = sp[4].split(\",\").collect();\n            PasswordRecord::new(sp[0], sp[1], uid, gid, gecos, sp[5], sp[6])\n        }\n    }\n}\n\n/// read all records from file\npub fn read_password_file(file_name: &str) -> Result<Vec<PasswordRecord>> {\n    let p = Path::new(file_name);\n    if !p.exists() {\n        Ok(vec![])\n    } else {\n        let f = OpenOptions::new().read(true).open(p)?;\n        Ok(BufReader::new(&f)\n            .lines()\n            .map(|l| PasswordRecord::from_line(&l.unwrap()))\n            .collect())\n    }\n}\n\n/// overwrite file with records\npub fn overwrite_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .write(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// append records to file\npub fn append_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// internal, write records line by line\nfn write_records(f: File, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let mut writer = BufWriter::new(f);\n    for rec in recs {\n        write!(writer, \"{}\\n\", rec.to_line())?;\n    }\n    Ok(())\n}\n\nfn main(){\n    let recs1 = vec![\n            PasswordRecord::new(\n                \"jsmith\",\n                \"x\",\n                1001,\n                1000,\n                vec![\n                    \"Joe Smith\",\n                    \"Room 1007\",\n                    \"(234)555-8917\",\n                    \"(234)555-0077\",\n                    \"jsmith@rosettacode.org\",\n                ],\n                \"/home/jsmith\",\n                \"/bin/bash\",\n            ),\n            PasswordRecord::new(\n                \"jdoe\",\n                \"x\",\n                1002,\n                1000,\n                vec![\n                    \"Jane Doe\",\n                    \"Room 1004\",\n                    \"(234)555-8914\",\n                    \"(234)555-0044\",\n                    \"jdoe@rosettacode.org\",\n                ],\n                \"/home/jdoe\",\n                \"/bin/bash\",\n            ),\n        ];\n\n    overwrite_password_file(\"passwd\", &recs1).expect(\"cannot write file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"Original file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n    let append0 = vec![PasswordRecord::new(\n            \"xyz\",\n            \"x\",\n            1003,\n            1000,\n            vec![\n                \"X Yz\",\n                \"Room 1003\",\n                \"(234)555-8913\",\n                \"(234)555-0033\",\n                \"xyz@rosettacode.org\",\n            ],\n            \"/home/xyz\",\n            \"/bin/bash\",\n        )];\n    append_password_file(\"passwd\", &append0).expect(\"cannot append to file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"\");\n    println!(\"Appended file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n}\n",
    "title": "Append a record to the end of a text file",
    "url": "http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file"
  },
  {
    "local_code": "fn main() {\n    let array = [1, 2, 3, 4, 5];\n    println!(\"{:?}\", array);\n\n    println!(\"{:?}\", array.iter().map(callback).collect::<Vec<i32>>());\n}\n\nfn callback(val: &i32) -> i32 {\n    *val + 1\n}\n",
    "path": "tasks/apply-a-callback-to-an-array",
    "remote_code": "fn echo(n: &i32) {\n    println!(\"{}\", n);\n}\n\nfn main() {\n    let a: [i32; 5];\n    a = [1, 2, 3, 4, 5];\n    let _: Vec<_> = a.into_iter().map(echo).collect();\n}",
    "title": "Apply a callback to an array",
    "url": "http://rosettacode.org/wiki/Apply_a_callback_to_an_array"
  },
  {
    "local_code": "#![allow(clippy::excessive_precision)]\n\nstruct IIRFilter<'f>(&'f [f32], &'f [f32]);\n\nimpl<'f> IIRFilter<'f> {\n    pub fn with_coefficients(a: &'f [f32], b: &'f [f32]) -> IIRFilter<'f> {\n        IIRFilter(a, b)\n    }\n\n    // Performs the calculation as an iterator chain.\n    pub fn apply<I: Iterator<Item = &'f f32> + 'f>(\n        &self,\n        samples: I,\n    ) -> impl Iterator<Item = f32> + 'f {\n        // Name some things for readability\n        let a_coeff = self.0;\n        let b_coeff = self.1;\n\n        let mut prev_results = Vec::<f32>::new();\n        let mut prev_samples = Vec::<f32>::new();\n\n        // The actual calculation, done one number at a time\n        samples.enumerate().map(move |(i, sample)| {\n            prev_samples.push(*sample);\n            prev_results.push(0f32);\n\n            // For each coefficient in b, calculate the weight and sum them.\n            let sum_b: f32 = b_coeff\n                .iter()\n                .enumerate()\n                .map(|(j, c)| {\n                    if i >= j {\n                        (*c) * prev_samples[i - j]\n                    } else {\n                        0f32\n                    }\n                })\n                .sum();\n\n            // For each coefficient in a, calculate the weight and sum them.\n            let sum_a: f32 = a_coeff\n                .iter()\n                .enumerate()\n                .map(|(j, c)| {\n                    if i >= j {\n                        (*c) * prev_results[i - j]\n                    } else {\n                        0f32\n                    }\n                })\n                .sum();\n\n            // perform the final calculation\n            let result = (sum_b - sum_a) / a_coeff[0];\n\n            // update the previous result for the next iteration\n            prev_results[i] = result;\n\n            // return the current result in this iteration\n            result\n        })\n    }\n}\n\nfn main() {\n    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];\n    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];\n\n    let samples: Vec<f32> = vec![\n        -0.917843918645,\n        0.141984778794,\n        1.20536903482,\n        0.190286794412,\n        -0.662370894973,\n        -1.00700480494,\n        -0.404707073677,\n        0.800482325044,\n        0.743500089861,\n        1.01090520172,\n        0.741527555207,\n        0.277841675195,\n        0.400833448236,\n        -0.2085993586,\n        -0.172842103641,\n        -0.134316096293,\n        0.0259303398477,\n        0.490105989562,\n        0.549391221511,\n        0.9047198589,\n    ];\n\n    for (i, result) in IIRFilter::with_coefficients(a, b)\n        .apply(samples.iter())\n        .enumerate()\n    {\n        print!(\"{:.8}\", result);\n        if (i + 1) % 5 != 0 {\n            print!(\", \");\n        } else {\n            println!();\n        }\n    }\n    println!();\n}\n\n#[test]\nfn test() {\n    use std::cmp::Ordering;\n\n    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];\n    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];\n\n    let samples: Vec<f32> = vec![\n        -0.917843918645,\n        0.141984778794,\n        1.20536903482,\n        0.190286794412,\n        -0.662370894973,\n        -1.00700480494,\n        -0.404707073677,\n        0.800482325044,\n        0.743500089861,\n        1.01090520172,\n        0.741527555207,\n        0.277841675195,\n        0.400833448236,\n        -0.2085993586,\n        -0.172842103641,\n        -0.134316096293,\n        0.0259303398477,\n        0.490105989562,\n        0.549391221511,\n        0.9047198589,\n    ];\n\n    let expected = vec![\n        -0.15297399,\n        -0.43525785,\n        -0.13604343,\n        0.69750333,\n        0.65644467,\n        -0.43548250,\n        -1.08923948,\n        -0.53767651,\n        0.51705003,\n        1.05224979,\n        0.96185434,\n        0.69568992,\n        0.42435625,\n        0.19626230,\n        -0.02783510,\n        -0.21172196,\n        -0.17474557,\n        0.06925842,\n        0.38544586,\n        0.65177077,\n    ]\n    .into_iter();\n\n    let actual = IIRFilter::with_coefficients(a, b).apply(samples.iter());\n\n    let failed = actual\n        .zip(expected)\n        .inspect(|(act, exp)| {\n            eprintln!(\"{} <=> {}: {:?}\", act, exp, act.partial_cmp(exp));\n        })\n        .any(|(act, exp)| act.partial_cmp(&exp) != Some(Ordering::Equal));\n    assert!(!failed);\n}\n",
    "path": "tasks/apply-a-digital-filter",
    "remote_code": "use std::cmp::Ordering;\n\nstruct IIRFilter<'f>(&'f [f32], &'f [f32]);\n\nimpl<'f> IIRFilter<'f> {\n    pub fn with_coefficients(a: &'f [f32], b: &'f [f32]) -> IIRFilter<'f> {\n        IIRFilter(a, b)\n    }\n\n    // Performs the calculation as an iterator chain.\n    pub fn apply<I: Iterator<Item = &'f f32> + 'f>(\n        &self,\n        samples: I,\n    ) -> impl Iterator<Item = f32> + 'f {\n        // Name some things for readability\n        let a_coeff = self.0;\n        let b_coeff = self.1;\n\n        let mut prev_results = Vec::<f32>::new();\n        let mut prev_samples = Vec::<f32>::new();\n\n        // The actual calculation, done one number at a time\n        samples.enumerate() // (i, sample[i])\n            .map(move |(i, sample)| { // for each sample, apply this function\n                prev_samples.push(*sample);\n                prev_results.push(0f32); // the initial version of the previous result\n\n                let sum_b: f32 = b_coeff.iter() // for each coefficient in b\n                    .enumerate() // (j, b_coeff[j])\n                    .map(|(j, c)| { // calculate the weight of the coefficient\n                        if i >= j {\n                            (*c) * prev_samples[i-j]\n                        } else {\n                            0f32\n                        }\n                    })\n                    .sum(); // add them all together\n\n                let sum_a: f32 = a_coeff.iter() // for each coefficient in a\n                    .enumerate() // (j, a_coeff[j])\n                    .map(|(j, c)| { // calculate the weight of the coefficient\n                        if i >= j {\n                            (*c) * prev_results[i-j]\n                        } else {\n                            0f32\n                        }\n                    })\n                    .sum(); // add them all together\n\n                // perform the final calculation\n                let result = (sum_b - sum_a) / a_coeff[0];\n\n                // update the previous result for the next iteration\n                prev_results[i] = result;\n\n                // return the current result in this iteration\n                result\n            }\n        )\n    }\n}\n\nfn main() {\n    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];\n    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];\n\n    let samples: Vec<f32> = vec![\n        -0.917843918645,\n        0.141984778794,\n        1.20536903482,\n        0.190286794412,\n        -0.662370894973,\n        -1.00700480494,\n        -0.404707073677,\n        0.800482325044,\n        0.743500089861,\n        1.01090520172,\n        0.741527555207,\n        0.277841675195,\n        0.400833448236,\n        -0.2085993586,\n        -0.172842103641,\n        -0.134316096293,\n        0.0259303398477,\n        0.490105989562,\n        0.549391221511,\n        0.9047198589,\n    ];\n\n    for (i, result) in IIRFilter::with_coefficients(a, b)\n        .apply(samples.iter())\n        .enumerate()\n    {\n        print!(\"{:.8}\", result);\n        if (i + 1) % 5 != 0 {\n            print!(\", \");\n        } else {\n            println!();\n        }\n    }\n    println!();\n}",
    "title": "Apply a digital filter (direct form II transposed)",
    "url": "http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// Return whether the two numbers `a` and `b` are close.\n/// Closeness is determined by the `epsilon` parameter - \n/// the numbers are considered close if the difference between them\n/// is no more than epsilon * max(abs(a), abs(b)).\nfn isclose(a: f64, b: f64, epsilon: f64) -> bool {\n    (a - b).abs() <= a.abs().max(b.abs()) * epsilon\n}\n\nfn main() {\n    fn sqrt(x: f64) -> f64 { x.sqrt() }\n    macro_rules! test {\n        ($a: expr, $b: expr) => {\n            let operator = if isclose($a, $b, 1.0e-9) { '≈' } else { '≉' };\n            println!(\"{:>28} {} {}\", stringify!($a), operator, stringify!($b))\n        }\n    }\n\n    test!(100000000000000.01, 100000000000000.011);\n    test!(100.01, 100.011);\n    test!(10000000000000.001/10000.0, 1000000000.0000001000);\n    test!(0.001, 0.0010000001);\n    test!(0.000000000000000000000101, 0.0);\n    test!( sqrt(2.0) * sqrt(2.0), 2.0);\n    test!(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test!(3.14159265358979323846, 3.14159265358979324);\n}",
    "title": "Approximate equality",
    "url": "http://rosettacode.org/wiki/Approximate_equality"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigInt, Signed};\n\n// Dumbest iterative approach\nfn big_pow(base: &BigInt, exp: BigInt) -> BigInt {\n    if exp.is_negative() {\n        panic!(\"Negative exponent won't compute!\")\n    }\n    let mut tmp = base.clone();\n    for _ in num::range(BigInt::from(1), exp) {\n        tmp *= base;\n    }\n    tmp\n}\n\n// 5^4^3^2\nfn main() {\n    // Exponent is small enough to not use BigInt\n    let exp = BigInt::from(num::pow(4, num::pow(3, 2)));\n\n    let result = big_pow(&BigInt::from(5), exp).to_string();\n    let num_length = result.len();\n\n    println!(\"{}\", result);\n    println!(\"Number has {} digits.\", num_length);\n    assert!(result.starts_with(\"62060698786608744707\"));\n    assert!(result.ends_with(\"92256259918212890625\"));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::big_pow;\n    use num::BigInt;\n\n    #[test]\n    #[should_panic]\n    fn negative_exp_test() {\n        let num = BigInt::from(100);\n        let exp = BigInt::from(-100);\n        big_pow(&num, exp);\n    }\n\n    #[test]\n    fn big_powas() {\n        assert_eq!(\n            big_pow(&BigInt::from(100), BigInt::from(100)).to_string(),\n            \"10000000000000000000000000000000000000000000000000000000000000\\\n             000000000000000000000000000000000000000000000000000000000000000\\\n             000000000000000000000000000000000000000000000000000000000000000\\\n             0000000000000\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(89)).to_string(),\n            \"618970019642690137449562112\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(107)).to_string(),\n            \"162259276829213363391578010288128\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(127)).to_string(),\n            \"170141183460469231731687303715884105728\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(521)).to_string(),\n            \"6864797660130609714981900799081393217269435300143305409394\\\n             46345918554318339765605212255964066145455497729631139148085\\\n             8037121987999716643812574028291115057152\"\n        );\n    }\n}\n",
    "path": "tasks/arbitrary-precision-integers-included",
    "remote_code": "extern crate num;\nuse num::bigint::BigUint;\nuse num::FromPrimitive;\nuse num::pow::pow;\n\nfn main() {\n    let big = BigUint::from_u8(5).unwrap();\n    let answer_as_string = format!(\"{}\", pow(big,pow(4,pow(3,2))));\n    \n      // The rest is output formatting.\n    let first_twenty: String = answer_as_string.chars().take(20).collect();\n    let last_twenty_reversed: Vec<char> = answer_as_string.chars().rev().take(20).collect();\n    let last_twenty: String = last_twenty_reversed.into_iter().rev().collect();\n    println!(\"Number of digits: {}\", answer_as_string.len());\n    println!(\"First and last digits: {:?}..{:?}\", first_twenty, last_twenty);\n}",
    "title": "Arbitrary-precision integers (included)",
    "url": "http://rosettacode.org/wiki/Arbitrary-precision_integers_(included)"
  },
  {
    "local_code": "#[macro_use(px)]\nextern crate bmp;\n\nuse bmp::{Image, Pixel};\nuse std::f64;\n\n#[allow(clippy::many_single_char_names)]\nfn main() {\n    let width = 600u32;\n    let half_width = (width / 2) as i32;\n    let mut img = Image::new(width, width);\n    let draw_color = px!(255, 128, 128);\n\n    // Constants defining the spiral size.\n    let a = 1.0_f64;\n    let b = 9.0_f64;\n\n    // max_angle = number of spirals * 2pi.\n    let max_angle = 5.0_f64 * 2.0_f64 * f64::consts::PI;\n\n    let mut theta = 0.0_f64;\n    while theta < max_angle {\n        theta += 0.002_f64;\n\n        let r = a + b * theta;\n        let x = (r * theta.cos()) as i32 + half_width;\n        let y = (r * theta.sin()) as i32 + half_width;\n        img.set_pixel(x as u32, y as u32, draw_color);\n    }\n\n    // Save the image\n    img.save(\"archimedean_spiral.bmp\")\n        .unwrap_or_else(|e| panic!(\"Failed to save: {}\", e));\n}\n",
    "path": "tasks/archimedean-spiral",
    "remote_code": "#[macro_use(px)]\nextern crate bmp;\n\nuse bmp::{Image, Pixel};\nuse std::f64;\n\nfn main() {\n    let width = 600u32;\n    let half_width = (width / 2) as i32;\n    let mut img = Image::new(width, width);\n    let draw_color = px!(255, 128, 128);\n\n    // Constants defining the spiral size.\n    let a = 1.0_f64;\n    let b = 9.0_f64;\n\n    // max_angle = number of spirals * 2pi.\n    let max_angle = 5.0_f64 * 2.0_f64 * f64::consts::PI;\n\n    let mut theta = 0.0_f64;\n    while theta < max_angle {\n        theta = theta + 0.002_f64;\n\n        let r = a + b * theta;\n        let x = (r * theta.cos()) as i32 + half_width;\n        let y = (r * theta.sin()) as i32 + half_width;\n        img.set_pixel(x as u32, y as u32, draw_color);\n    }\n\n    // Save the image\n    let _ = img.save(\"archimedean_spiral.bmp\").unwrap_or_else(|e| panic!(\"Failed to save: {}\", e));\n}",
    "title": "Archimedean spiral",
    "url": "http://rosettacode.org/wiki/Archimedean_spiral"
  },
  {
    "local_code": "extern crate typed_arena;\n\nuse typed_arena::Arena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to Arena::with_capacity if necessary.\n    let arena = Arena::new();\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}\n",
    "path": "tasks/arena-storage-pool",
    "remote_code": "#![feature(rustc_private)]\n\nextern crate arena;\n\nuse arena::TypedArena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.\n    let arena = TypedArena::new();\n\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}",
    "title": "Arena storage pool",
    "url": "http://rosettacode.org/wiki/Arena_storage_pool"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Simple calculator parser and evaluator\n\n\n/// Binary operator\n#[derive(Debug)]\npub enum Operator {\n    Add,\n    Substract,\n    Multiply,\n    Divide\n}\n\n/// A node in the tree\n#[derive(Debug)]\npub enum Node {\n    Value(f64),\n    SubNode(Box<Node>),\n    Binary(Operator, Box<Node>,Box<Node>),\n}\n\n/// parse a string into a node\npub fn parse(txt :&str) -> Option<Node> {\n    let chars = txt.chars().filter(|c| *c != ' ').collect();\n    parse_expression(&chars, 0).map(|(_,n)| n)\n}\n\n/// parse an expression into a node, keeping track of the position in the character vector\nfn parse_expression(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match parse_start(chars, pos) {\n        Some((new_pos, first)) => {\n            match parse_operator(chars, new_pos) {\n                Some((new_pos2,op)) => {\n                    if let Some((new_pos3, second)) = parse_expression(chars, new_pos2) {\n                        Some((new_pos3, combine(op, first, second)))\n                    } else {\n                        None\n                    }\n                },\n                None => Some((new_pos,first)), \n            }\n        },\n        None => None,\n    }\n}\n\n/// combine nodes to respect associativity rules\nfn combine(op: Operator, first: Node, second: Node) -> Node {\n    match second {\n        Node::Binary(op2,v21,v22) => if precedence(&op)>=precedence(&op2) {\n            Node::Binary(op2,Box::new(combine(op,first,*v21)),v22)\n        } else {\n            Node::Binary(op,Box::new(first),Box::new(Node::Binary(op2,v21,v22)))\n        },\n        _ => Node::Binary(op,Box::new(first),Box::new(second)),\n    }\n}\n\n/// a precedence rank for operators\nfn precedence(op: &Operator) -> usize {\n    match op{\n        Operator::Multiply | Operator::Divide => 2,\n        _ => 1\n    }\n}\n\n/// try to parse from the start of an expression (either a parenthesis or a value)\nfn parse_start(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match start_parenthesis(chars, pos){\n        Some (new_pos) => {\n            let r = parse_expression(chars, new_pos);\n            end_parenthesis(chars, r)\n        },\n        None => parse_value(chars, pos),\n    }\n}\n\n/// match a starting parentheseis\nfn start_parenthesis(chars: &Vec<char>, pos: usize) -> Option<usize>{\n    if pos<chars.len() && chars[pos] == '(' {\n        Some(pos+1)\n    } else {\n        None\n    }\n}\n\n/// match an end parenthesis, if successful will create a sub node contained the wrapped expression\nfn end_parenthesis(chars: &Vec<char>, wrapped :Option<(usize,Node)>) -> Option<(usize,Node)>{\n    match wrapped {\n        Some((pos, node)) => if pos<chars.len() && chars[pos] == ')' {\n                Some((pos+1,Node::SubNode(Box::new(node))))\n            } else {\n                None\n            },\n        None => None,\n    }\n}\n\n/// parse a value: an decimal with an optional minus sign\nfn parse_value(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)>{\n    let mut new_pos = pos;\n    if new_pos<chars.len() && chars[new_pos] == '-' {\n        new_pos = new_pos+1;\n    }\n    while new_pos<chars.len() && (chars[new_pos]=='.' || (chars[new_pos] >= '0' && chars[new_pos] <= '9')) {\n        new_pos = new_pos+1;\n    }\n    if new_pos>pos {\n        if let Ok(v) = dbg!(chars[pos..new_pos].iter().collect::<String>()).parse() {\n            Some((new_pos,Node::Value(v)))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n\n}\n\n/// parse an operator\nfn parse_operator(chars: &Vec<char>, pos: usize) -> Option<(usize,Operator)> {\n    if pos<chars.len() {\n        let ops_with_char = vec!(('+',Operator::Add),('-',Operator::Substract),('*',Operator::Multiply),('/',Operator::Divide));\n        for (ch,op) in ops_with_char {\n            if chars[pos] == ch {\n                return Some((pos+1, op));\n            }\n        }\n    } \n    None\n}\n\n/// eval a string\npub fn eval(txt :&str) -> f64 {\n    match parse(txt) {\n        Some(t) => eval_term(&t),\n        None => panic!(\"Cannot parse {}\",txt),\n    }\n    \n}\n\n/// eval a term, recursively\nfn eval_term(t: &Node) -> f64 {\n    match t {\n        Node::Value(v) => *v,\n        Node::SubNode(t) => eval_term(t),\n        Node::Binary(Operator::Add,t1,t2) => eval_term(t1) + eval_term(t2),\n        Node::Binary(Operator::Substract,t1,t2) => eval_term(t1) - eval_term(t2),\n        Node::Binary(Operator::Multiply,t1,t2) => eval_term(t1) * eval_term(t2),\n        Node::Binary(Operator::Divide,t1,t2) => eval_term(t1) / eval_term(t2),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eval(){\n        assert_eq!(2.0,eval(\"2\"));\n        assert_eq!(4.0,eval(\"2+2\"));\n        assert_eq!(11.0/4.0, eval(\"2+3/4\"));\n        assert_eq!(2.0, eval(\"2*3-4\"));\n        assert_eq!(3.0, eval(\"1+2*3-4\"));\n        assert_eq!(89.0/6.0, eval(\"2*(3+4)+5/6\"));\n        assert_eq!(14.0, eval(\"2 * (3 -1) + 2 * 5\"));\n        assert_eq!(7000.0, eval(\"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\"));\n        assert_eq!(-9.0/4.0, eval(\"2*-3--4+-.25\"));\n        assert_eq!(1.5, eval(\"1 - 5 * 2 / 20 + 1\"));\n        assert_eq!(3.5, eval(\"2 * (3 + ((5) / (7 - 11)))\"));\n        \n    }\n}\n\n",
    "title": "Arithmetic evaluation",
    "url": "http://rosettacode.org/wiki/Arithmetic_evaluation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn divisor_count_and_sum(mut n: u32) -> (u32, u32) {\n    let mut divisor_count = 1;\n    let mut divisor_sum = 1;\n    let mut power = 2;\n    while (n & 1) == 0 {\n        divisor_count += 1;\n        divisor_sum += power;\n        power <<= 1;\n        n >>= 1;\n    }\n    let mut p = 3;\n    while p * p <= n {\n        let mut count = 1;\n        let mut sum = 1;\n        power = p;\n        while n % p == 0 {\n            count += 1;\n            sum += power;\n            power *= p;\n            n /= p;\n        }\n        divisor_count *= count;\n        divisor_sum *= sum;\n        p += 2;\n    }\n    if n > 1 {\n        divisor_count *= 2;\n        divisor_sum *= n + 1;\n    }\n    (divisor_count, divisor_sum)\n}\n\nfn main() {\n    let mut arithmetic_count = 0;\n    let mut composite_count = 0;\n    let mut n = 1;\n    while arithmetic_count <= 1000000 {\n        let (divisor_count, divisor_sum) = divisor_count_and_sum(n);\n        if divisor_sum % divisor_count != 0 {\n            n += 1;\n            continue;\n        }\n        arithmetic_count += 1;\n        if divisor_count > 2 {\n            composite_count += 1;\n        }\n        if arithmetic_count <= 100 {\n            print!(\"{:3} \", n);\n            if arithmetic_count % 10 == 0 {\n                println!();\n            }\n        }\n        if arithmetic_count == 1000\n            || arithmetic_count == 10000\n            || arithmetic_count == 100000\n            || arithmetic_count == 1000000\n        {\n            println!(\"\\n{}th arithmetic number is {}\", arithmetic_count, n);\n            println!(\n                \"Number of composite arithmetic numbers <= {}: {}\",\n                n, composite_count\n            );\n        }\n        n += 1;\n    }\n}",
    "title": "Arithmetic numbers",
    "url": "http://rosettacode.org/wiki/Arithmetic_numbers"
  },
  {
    "local_code": "//! Accepts two command line arguments\n//! cargo run --name agm arg1 arg2\n\nuse std::f32;\n\nfn main() {\n    let mut args = std::env::args();\n\n    let x = args.next().unwrap().parse::<f32>().unwrap();\n    let y = args.next().unwrap().parse::<f32>().unwrap();\n\n    let result = agm(x, y);\n    println!(\"The arithmetic-geometric mean is {}\", result);\n}\n\nfn agm(x: f32, y: f32) -> f32 {\n    let mut a = x;\n    let mut g = y;\n    let mut a1: f32;\n    let mut g1: f32;\n\n    if a * g < 0f32 {\n        panic!(\"The arithmetic-geometric mean is undefined for numbers less than zero!\");\n    } else {\n        loop {\n            a1 = (a + g) / 2f32;\n            g1 = (a * g).sqrt();\n            a = a1;\n            g = g1;\n            if (a - g).abs() < f32::EPSILON {\n                return a;\n            }\n        }\n    }\n}\n\n#[test]\nfn test_agm_12_6() {\n    use std::f32;\n\n    assert!((agm(12f32, 6f32) - 8.740746f32).abs() < f32::EPSILON);\n}\n",
    "path": "tasks/arithmetic-geometric-mean",
    "remote_code": "// Accepts two command line arguments\n// cargo run --name agm arg1 arg2\n\nfn main () {\n    let mut args = std::env::args();\n\n    let x = args.nth(1).expect(\"First argument not specified.\").parse::<f32>().unwrap();\n    let y = args.next().expect(\"Second argument not specified.\").parse::<f32>().unwrap();\n\n    let result = agm(x,y);\n    println!(\"The arithmetic-geometric mean is {}\", result);\n}\n\nfn agm (x: f32, y: f32) -> f32 {\n    let e: f32 = 0.000001;\n    let mut a = x;\n    let mut g = y;\n    let mut a1: f32;\n    let mut g1: f32;\n\n    if a * g < 0f32 { panic!(\"The arithmetric-geometric mean is undefined for numbers less than zero!\"); }\n    else {\n        loop {\n            a1 = (a + g) / 2.;\n            g1 = (a * g).sqrt();\n            a = a1;\n            g = g1;\n            if (a - g).abs() < e {  return a; }\n        }\n    }\n}",
    "title": "Arithmetic-geometric mean",
    "url": "http://rosettacode.org/wiki/Arithmetic-geometric_mean"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// calculate pi with algebraic/geometric mean\npub fn pi(n: usize) -> f64 {\n    let mut a : f64 = 1.0;\n    let two : f64= 2.0;\n    let mut g = 1.0 / two.sqrt();\n    let mut s = 0.0;\n    let mut k = 1;\n    while k<=n  {\n       \n        let a1 = (a+g)/two;\n        let g1 = (a*g).sqrt();\n        a = a1;\n        g = g1;\n        s += (a.powi(2)-g.powi(2)) * two.powi((k+1) as i32);\n        k += 1;\n         \n\n    }\n\n    4.0 * a.powi(2) / (1.0-s)\n}\n",
    "title": "Arithmetic-geometric mean/Calculate Pi",
    "url": "http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi"
  },
  {
    "local_code": "extern crate num;\n\nuse num::complex::Complex;\n\nfn main() {\n    let a = Complex::new(-4.0f32, 5.0);\n    let b = Complex::new(1.0f32, 1.0);\n\n    println!(\"a = {}\", a);\n    println!(\"b = {}\", b);\n    println!(\"a + b = {}\", a + b);\n    println!(\"a * b = {}\", a * b);\n    println!(\"1 / a = {}\", Complex::new(1.0f32, 0.0) / a);\n    println!(\"-a = {}\", -a);\n    println!(\"conj a = {}\", a.conj());\n}\n",
    "path": "tasks/arithmetic/complex",
    "remote_code": "extern crate num;\nuse num::complex::Complex;\n\nfn main() {\n    // two valid forms of definition\n    let a = Complex {re:-4.0, im: 5.0};\n    let b = Complex::new(1.0, 1.0);\n\n    println!(\"   a    = {}\", a);\n    println!(\"   b    = {}\", b);\n    println!(\" a + b  = {}\", a + b);\n    println!(\" a * b  = {}\", a * b);\n    println!(\" 1 / a  = {}\", a.inv());\n    println!(\"  -a    = {}\", -a);\n    println!(\"conj(a) = {}\", a.conj());\n}",
    "title": "Arithmetic/Complex",
    "url": "http://rosettacode.org/wiki/Arithmetic/Complex"
  },
  {
    "local_code": "use std::io::stdin;\n\nfn main() {\n    let mut input = String::new();\n    let _ = stdin().read_line(&mut input).unwrap();\n    let words = input\n        .split_whitespace()\n        .take(2)\n        .map(|s| s.parse().ok())\n        .collect::<Vec<Option<i32>>>();\n\n    let (a, b) = match words[..] {\n        [Some(x), Some(y)] => (x, y),\n        _ => panic!(\"Please enter 2 integers\"),\n    };\n\n    println!(\"a + b = {}\", a + b);\n    println!(\"a - b = {}\", a - b);\n    println!(\"a * b = {}\", a * b);\n    println!(\"a / b = {}\", a / b);\n    println!(\"a % b = {}\", a % b);\n}\n",
    "path": "tasks/arithmetic/integer",
    "remote_code": "use std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let a = args[1].parse::<i32>().unwrap();\n    let b = args[2].parse::<i32>().unwrap();\n\n    println!(\"sum:              {}\", a + b);\n    println!(\"difference:       {}\", a - b);\n    println!(\"product:          {}\", a * b);\n    println!(\"integer quotient: {}\", a / b); // truncates towards zero\n    println!(\"remainder:        {}\", a % b); // same sign as first operand\n}",
    "title": "Arithmetic/Integer",
    "url": "http://rosettacode.org/wiki/Arithmetic/Integer"
  },
  {
    "local_code": "extern crate num;\n\nuse std::cmp::Ordering;\nuse std::fmt;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\nuse num::{One, Zero};\n\nfn main() {\n    for p in perfect_numbers(1 << 19) {\n        println!(\"{} is perfect\", p);\n    }\n}\n\nfn perfect_numbers(max: i64) -> Vec<i64> {\n    let mut ret = Vec::new();\n    for candidate in 2..max {\n        let mut sum = Frac::secure_new(1, candidate).unwrap();\n        let max2 = ((candidate as f64).sqrt().floor()) as i64;\n\n        for factor in 2..max2 + 1 {\n            if candidate % factor == 0 {\n                sum = sum + Frac::new(1, factor) + Frac::new(factor, candidate);\n            }\n        }\n        if sum == Frac::new(1, 1) {\n            ret.push(candidate);\n        }\n    }\n    ret\n}\n\n#[derive(Copy, Clone)]\nstruct Frac {\n    num: i64,\n    den: i64,\n}\n\nfn gcd(m: i64, n: i64) -> i64 {\n    let mut t: i64;\n    let (mut m, mut n) = (m.abs(), n.abs());\n    while n > 0 {\n        t = n;\n        n = m % n;\n        m = t;\n    }\n    m\n}\n\nfn lcm(m: i64, n: i64) -> i64 {\n    m.abs() / gcd(m, n) * n.abs()\n}\n\nimpl Frac {\n    /// fails on den=0\n    fn new(num: i64, den: i64) -> Frac {\n        let (n, d) = match (num, den) {\n            (0, _) => (0, 0),\n            (n, d) if d < 0 => (-n, -d),\n            a => a,\n        };\n\n        Frac { num: n, den: d }\n    }\n\n    /// does not fail (returns Err on den=0)\n    fn secure_new(num: i64, den: i64) -> Result<Frac, String> {\n        if den == 0 {\n            Err(\"Error: Division by zero\".to_string())\n        } else {\n            Ok(Frac::new(num, den))\n        }\n    }\n\n    /// fails on den=0, returns frac already in its reduced form\n    fn new_reduced(num: i64, den: i64) -> Frac {\n        Frac::new(num, den).reduce()\n    }\n\n    /// reduces the fraction to lowest terms\n    fn reduce(mut self) -> Frac {\n        match self {\n            z @ Frac { num: 0, den: 0 } => z,\n            _ => {\n                let gcd = gcd(self.num, self.den);\n                self.num /= gcd;\n                self.den /= gcd;\n                self\n            }\n        }\n    }\n}\n\nimpl fmt::Debug for Frac {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match (self.num, self.den) {\n            (_, 1) | (0, 0) => write!(f, \"{}\", self.num),\n            (_, _) => write!(f, \"{}/{}\", self.num, self.den),\n        }\n    }\n}\n\nimpl PartialEq for Frac {\n    fn eq(&self, other: &Frac) -> bool {\n        let (red_a, red_b) = (self.reduce(), other.reduce());\n        red_a.num == red_b.num && red_a.den == red_b.den\n    }\n}\n\nimpl Eq for Frac {}\n\nimpl PartialOrd for Frac {\n    fn partial_cmp(&self, other: &Frac) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Frac {\n    fn cmp(&self, other: &Frac) -> Ordering {\n        (self.num * other.den).cmp(&(self.den * other.num))\n    }\n}\n\nimpl Neg for Frac {\n    type Output = Frac;\n\n    fn neg(self) -> Frac {\n        Frac {\n            num: -self.num,\n            den: self.den,\n        }\n    }\n}\n\nimpl Add for Frac {\n    type Output = Frac;\n    fn add(self, other: Frac) -> Frac {\n        let (a, b) = (self.reduce(), other.reduce());\n        let m = lcm(a.den, b.den);\n\n        let na = a.num * m / a.den;\n        let nb = b.num * m / b.den;\n        Frac::new_reduced(na + nb, m)\n    }\n}\n\nimpl Sub for Frac {\n    type Output = Frac;\n    fn sub(self, other: Frac) -> Frac {\n        self + (-other)\n    }\n}\n\nimpl Mul for Frac {\n    type Output = Frac;\n    fn mul(self, other: Frac) -> Frac {\n        Frac::new_reduced(self.num * other.num, self.den * other.den)\n    }\n}\n\nimpl Div for Frac {\n    type Output = Frac;\n    fn div(self, other: Frac) -> Frac {\n        Frac::new_reduced(self.num * other.den, self.den * other.num)\n    }\n}\n\nimpl Zero for Frac {\n    fn zero() -> Frac {\n        Frac::new(0, 1)\n    }\n\n    fn is_zero(&self) -> bool {\n        self.num == 0 && self.den != 0\n    }\n}\n\nimpl One for Frac {\n    fn one() -> Frac {\n        Frac::new(1, 1)\n    }\n}\n\n#[test]\nfn operators() {\n    let (a, b) = (Frac::new(1, 2), Frac::new(12, 15));\n    assert_eq!(a + b, Frac::secure_new(13, 10).unwrap());\n    assert_eq!(b - a, Frac::new(3, 10));\n    assert_eq!(a - b, Frac::new(-3, 10));\n    assert_eq!(a * b, Frac::new(2, 5));\n    assert_eq!(a / b, Frac::new(5, 8));\n\n    let (a, b) = (Frac::new(1, 2), Frac::new(1, 2));\n    assert_eq!(a + b, One::one());\n    assert_eq!(b - a, Zero::zero());\n    assert_eq!(a - b, Zero::zero());\n    assert_eq!(a * b, Frac::new(1, 4));\n    assert_eq!(a / b, Frac::new(1, 1));\n}\n\n#[test]\nfn first_perfect_numbers() {\n    assert_eq!(perfect_numbers(8150), vec![6, 28, 496, 8128]);\n}\n",
    "path": "tasks/arithmetic/rational",
    "remote_code": "use std::cmp::Ordering;\nuse std::ops::{Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Div, DivAssign, Neg};\n\nfn gcd(a: i64, b: i64) -> i64 {\n    match b {\n        0 => a,\n        _ => gcd(b, a % b),\n    }\n}\n\nfn lcm(a: i64, b: i64) -> i64 {\n    a / gcd(a, b) * b\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord)]\npub struct Rational {\n    numerator: i64,\n    denominator: i64,\n}\n\nimpl Rational {\n    fn new(numerator: i64, denominator: i64) -> Self {\n        let divisor = gcd(numerator, denominator);\n        Rational {\n            numerator: numerator / divisor,\n            denominator: denominator / divisor,\n        }\n    }\n}\n\nimpl Add for Rational {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        let multiplier = lcm(self.denominator, other.denominator);\n        Rational::new(self.numerator * multiplier / self.denominator +\n                      other.numerator * multiplier / other.denominator,\n                      multiplier)\n    }\n}\n\nimpl AddAssign for Rational {\n    fn add_assign(&mut self, other: Self) {\n        *self = *self + other;\n    }\n}\n\nimpl Sub for Rational {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n        self + -other\n    }\n}\n\nimpl SubAssign for Rational {\n    fn sub_assign(&mut self, other: Self) {\n        *self = *self - other;\n    }\n}\n\nimpl Mul for Rational {\n    type Output = Self;\n\n    fn mul(self, other: Self) -> Self {\n        Rational::new(self.numerator * other.numerator,\n                      self.denominator * other.denominator)\n    }\n}\n\nimpl MulAssign for Rational {\n    fn mul_assign(&mut self, other: Self) {\n        *self = *self * other;\n    }\n}\n\nimpl Div for Rational {\n    type Output = Self;\n\n    fn div(self, other: Self) -> Self {\n        self *\n        Rational {\n            numerator: other.denominator,\n            denominator: other.numerator,\n        }\n    }\n}\n\nimpl DivAssign for Rational {\n    fn div_assign(&mut self, other: Self) {\n        *self = *self / other;\n    }\n}\n\nimpl Neg for Rational {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Rational {\n            numerator: -self.numerator,\n            denominator: self.denominator,\n        }\n    }\n}\n\nimpl PartialOrd for Rational {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        (self.numerator * other.denominator).partial_cmp(&(self.denominator * other.numerator))\n    }\n}\n\nimpl<T: Into<i64>> From<T> for Rational {\n    fn from(value: T) -> Self {\n        Rational::new(value.into(), 1)\n    }\n}\n\nfn main() {\n    let max = 1 << 19;\n    for candidate in 2..max {\n        let mut sum = Rational::new(1, candidate);\n        for factor in 2..(candidate as f64).sqrt().ceil() as i64 {\n            if candidate % factor == 0 {\n                sum += Rational::new(1, factor);\n                sum += Rational::new(1, candidate / factor);\n            }\n        }\n\n        if sum == 1.into() {\n            println!(\"{} is perfect\", candidate);\n        }\n    }\n}\n",
    "title": "Arithmetic/Rational",
    "url": "http://rosettacode.org/wiki/Arithmetic/Rational"
  },
  {
    "local_code": "fn main() {\n    let a_vec: Vec<i32> = vec![1, 2, 3, 4, 5];\n    let b_vec: Vec<i32> = vec![6; 5];\n\n    let c_vec = concatenate_arrays::<i32>(a_vec.as_slice(), b_vec.as_slice());\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat: Vec<T> = vec![x[0].clone(); x.len()];\n\n    concat.clone_from_slice(x);\n    concat.extend_from_slice(y);\n\n    concat\n}\n\n#[cfg(test)]\nmod tests {\n    use super::concatenate_arrays;\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct Dummy {\n        a: f64,\n        b: &'static str,\n    }\n\n    #[test]\n    fn test_concatenation_int() {\n        let a_vec: Vec<u64> = vec![0, 1, 2, 3, 4];\n        let b_vec: Vec<u64> = vec![5; 5];\n        let c_vec = concatenate_arrays::<u64>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(c_vec, [0, 1, 2, 3, 4, 5, 5, 5, 5, 5]);\n    }\n\n    #[test]\n    fn test_concatenation_str() {\n        let a_vec: Vec<&str> = vec![\"hay\", \"ye\", \"eye\", \"owe\", \"you\"];\n        let b_vec: Vec<&str> = vec![\"why\"];\n        let c_vec = concatenate_arrays::<&str>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(c_vec, [\"hay\", \"ye\", \"eye\", \"owe\", \"you\", \"why\"]);\n    }\n\n    #[test]\n    fn test_concatenation_tuple() {\n        let a_vec: Vec<(i32, &str)> = vec![(0, \"hay\"), (1, \"ye\"), (2, \"eye\")];\n        let b_vec: Vec<(i32, &str)> = vec![(3, \"owe\"), (4, \"you\")];\n        let c_vec = concatenate_arrays::<(i32, &str)>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(\n            c_vec,\n            [(0, \"hay\"), (1, \"ye\"), (2, \"eye\"), (3, \"owe\"), (4, \"you\")]\n        );\n    }\n\n    #[test]\n    fn test_concatenation_struct() {\n        let a_vec: Vec<Dummy> = vec![\n            Dummy { a: 0.0, b: \"hay\" },\n            Dummy { a: 1.1, b: \"ye\" },\n            Dummy { a: 2.2, b: \"eye\" },\n        ];\n        let b_vec: Vec<Dummy> = vec![Dummy { a: 3.3, b: \"owe\" }, Dummy { a: 4.4, b: \"you\" }];\n\n        let c_vec = concatenate_arrays::<Dummy>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(\n            c_vec,\n            [\n                Dummy { a: 0.0, b: \"hay\" },\n                Dummy { a: 1.1, b: \"ye\" },\n                Dummy { a: 2.2, b: \"eye\" },\n                Dummy { a: 3.3, b: \"owe\" },\n                Dummy { a: 4.4, b: \"you\" },\n            ]\n        );\n    }\n}\n",
    "path": "tasks/array-concatenation",
    "remote_code": "fn main() {\n    let a_vec = vec![1, 2, 3, 4, 5];\n    let b_vec = vec![6; 5];\n\n    let c_vec = concatenate_arrays(&a_vec, &b_vec);\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat = x.to_vec();\n    concat.extend_from_slice(y);\n\n    concat\n}\n",
    "title": "Array concatenation",
    "url": "http://rosettacode.org/wiki/Array_concatenation"
  },
  {
    "local_code": "fn main() {\n    let array = [\"foo\", \"bar\", \"baz\", \"biff\"];\n    println!(\"the array has {} elements\", array.len());\n}\n",
    "path": "tasks/array-length",
    "remote_code": "\nfn main() {\n    let array = [\"foo\", \"bar\", \"baz\", \"biff\"];\n    println!(\"the array has {} elements\", array.len());\n}\n",
    "title": "Array length",
    "url": "http://rosettacode.org/wiki/Array_length"
  },
  {
    "local_code": "fn main() {}\n\n#[test]\nfn create_array() {\n    let empty_vec: Vec<i32> = vec![];\n    assert!(empty_vec.is_empty());\n\n    let prepopulated_vec = vec![1i32, 2, 3];\n    assert!(prepopulated_vec.len() == 3);\n\n    // Three string slices.\n    let string_vec = vec![\"Foo\", \"Bar\", \"Baz\"];\n    assert!(string_vec.len() == 3);\n}\n\n#[test]\nfn add_to_array() {\n    // Mutatable adding.\n    let mut a_vec = vec![1i32];\n    assert_eq!(a_vec[0], 1);\n\n    // Immutable adding.\n    let b_vec = vec![2, 3, 4];\n    a_vec.extend(b_vec.into_iter());\n    assert_eq!(a_vec, [1, 2, 3, 4]);\n}\n\n#[test]\nfn retrieving_from_array() {\n    // Indexing.\n    let a_vec = vec![1i32, 2, 3];\n    assert!(a_vec[0] == 1i32);\n\n    // A full copy of the vector, but mutable.\n    let mut mut_vec = a_vec;\n    assert_eq!(mut_vec.pop(), Some(3));\n    assert_eq!(mut_vec, [1, 2]);\n}\n",
    "path": "tasks/arrays",
    "remote_code": "let a = [1, 2, 3]; // immutable array\nlet mut m = [1, 2, 3]; // mutable array\nlet zeroes = [0; 200]; // creates an array of 200 zeroes",
    "title": "Arrays",
    "url": "http://rosettacode.org/wiki/Arrays"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ascending primes",
    "url": "http://rosettacode.org/wiki/Ascending_primes"
  },
  {
    "local_code": "fn main() {\n    let my_number = 42;\n    assert!(my_number == 42);\n    assert_eq!(my_number, 42);\n}\n",
    "path": "tasks/assertions",
    "remote_code": "\nlet x = 42;\nassert!(x == 42);\nassert_eq!(x, 42);\n",
    "title": "Assertions",
    "url": "http://rosettacode.org/wiki/Assertions"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}\n",
    "path": "tasks/associative-array/creation",
    "remote_code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}",
    "title": "Associative array/Creation",
    "url": "http://rosettacode.org/wiki/Associative_array/Creation"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    // Note that `HashMap` does not preserve order. If this is important,\n    // `std::collections::BTreeMap` is what you want.\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    for (country, medals) in olympic_medals {\n        println!(\n            \"{} has had {} gold medals, {} silver medals, and {} bronze medals\",\n            country, medals.0, medals.1, medals.2\n        );\n    }\n}\n",
    "path": "tasks/associative-array/iteration",
    "remote_code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    for (country, medals) in olympic_medals {\n        println!(\"{} has had {} gold medals, {} silver medals, and {} bronze medals\", \n               country, medals.0, medals.1, medals.2);\n            \n    }\n}",
    "title": "Associative array/Iteration",
    "url": "http://rosettacode.org/wiki/Associative_array/Iteration"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let mut original = HashMap::new();\n    original.insert(\"name\", \"Rocket Skates\");\n    original.insert(\"price\", \"12.75\");\n    original.insert(\"color\", \"yellow\");\n\n    let mut update = HashMap::new();\n    update.insert(\"price\", \"15.25\");\n    update.insert(\"color\", \"red\");\n    update.insert(\"year\", \"1974\");\n\n    original.extend(&update);\n\n    println!(\"{:#?}\", original)\n}\n",
    "path": "tasks/associative-array/merging",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let mut original = HashMap::new();\n    original.insert(\"name\", \"Rocket Skates\");\n    original.insert(\"price\", \"12.75\");\n    original.insert(\"color\", \"yellow\");\n\n    let mut update = HashMap::new();\n    update.insert(\"price\", \"15.25\");\n    update.insert(\"color\", \"red\");\n    update.insert(\"year\", \"1974\");\n\n    original.extend(&update);\n\n    println!(\"{:#?}\", original);\n}\n",
    "title": "Associative array/Merging",
    "url": "http://rosettacode.org/wiki/Associative_array/Merging"
  },
  {
    "local_code": "//! This is mostly a straight port of the D version.  Originally, the \"non-locking\" Go solution was\n//! tried, because it was supposed to be faster than the version with Mutexes, but my experience\n//! was that this was not the case.  Perhaps it is true with green threads.  D's version was much\n//! faster and this version seems to achieve parity with the benchmarks on the Rosetta Code site\n//! (at least on my machine).  I am pretty sure it could be made faster, though--for example, the\n//! Mutex type we're using here was the fourth type I tried but the first to produce acceptable\n//! performance (previously I tried, in order, `std::sync::RwLock`, `std::sync::Mutex`, and\n//! `std::sync::Semaphore`) and this type still appears to have quite a bit of overhead.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\n/// The reason I used a module here is simply to keep it clearer who can access what.  Rust\n/// protects against data races just fine, but it's not as good at protecting against deadlocks or\n/// other types of race conditions.\nmod buckets {\n    use std::sync::atomic::{AtomicUsize, Ordering};\n    use std::sync::Mutex;\n\n    /// We hardcode the number of buckets mostly for convenience.  Now that Rust has dynamically\n    /// sized types, this is possibly no longer a problem.\n    ///\n    /// To expand: in Rust, there are two special kinds, `Sync` and `Send`, used for concurrency.\n    ///\n    /// If `T` is `Sync`, and you take an immutable reference of type `&T`, then it's safe to share\n    /// between threads.  Most types are `Sync` unless they contain non-threadsafe interior\n    /// mutability: for example, `Cell` and `RefCell` are not Sync, because they can be modified\n    /// through a `&` reference in a non-threadsafe way.  On the other hand, atomic types are\n    /// `Sync` even though they can be modified this way.  So are types accessible through a\n    /// `Mutex`.\n    ///\n    /// The other type is `Send`.  `Send`'s semantic meaning is \"a type that can be sent between\n    /// tasks.\"  For most practical purposes, this means \"has no non-`'static` references\" (with a\n    /// very few exceptions, like the `Rc` type, which are non-`Send` anyway).  The idea is that it\n    /// is not safe to send a type between tasks if it has any non-static references, because one\n    /// doesn't know when the data it's referencing will be deallocated if it's on some other\n    /// task's stack.\n    ///\n    /// Usually, that's a reasonable assumption.  But it means that if we want to put a slice in a\n    /// structure and share it between tasks, it can't be a `&[T]`--it has to be a bare [T].  `Arc`\n    /// has `Send` + `Sync` bounds for this reason.  We could also use a `Vec`, but this would\n    /// introduce unnecessary indirection.  With dynamically sized types, this problem may be\n    /// solved--we can have a dynamically sized `struct` that doesn't contain explicit references.\n    /// But until that is fully baked, this seems like the sanest solution.\n    ///\n    /// Another way to solve this would be associated constants.\n    pub const N_BUCKETS: usize = 20;\n\n    /// We don't really have to hardcode the workers.  This is left over from the Go\n    /// implementation. All the counting statistics could be moved outside of buckets and probably\n    /// should, since they have no influence on the correctness of the algorithm.\n    pub const N_WORKERS: usize = 2;\n\n    struct Bucket {\n        /// The actual data.  It is atomic because it is read (not written) outside the `Mutex`,\n        /// unless a consistent snapshot is required.\n        data: AtomicUsize,\n\n        /// The mutex used to synchronize writes and snapshot reads of the\n        /// bucket.\n        /// As the D solution says, using a per-bucket `Mutex` dramatically\n        /// improves scalability compared to the alternatives.\n        mutex: Mutex<()>,\n    }\n\n    pub struct Buckets {\n        /// Buckets containing values to be transferred.\n        buckets: [Bucket; N_BUCKETS],\n\n        /// Statistics about total transfers this go-around.\n        transfers: [AtomicUsize; N_WORKERS],\n    }\n\n    impl Buckets {\n        /// Create a new Buckets instance.\n        pub fn new(buckets: [usize; N_BUCKETS]) -> Buckets {\n            Buckets {\n                buckets: array_init::from_iter(buckets.iter().map(|&val| Bucket {\n                    data: AtomicUsize::new(val),\n                    mutex: Mutex::new(()),\n                }))\n                .unwrap(),\n                transfers: array_init::array_init(|_| AtomicUsize::new(0)),\n            }\n        }\n\n        /// Get the value of the bucket at index i, or None if out of bounds.\n        pub fn get(&self, i: usize) -> Option<usize> {\n            // This is used as an estimate, and is used without the mutex lock, so there's no\n            // compelling reason to demand consistency here.\n            self.buckets.get(i).map(|b| b.data.load(Ordering::Relaxed))\n        }\n\n        /// Transfer at most `amount` from the bucket at index `from` to that at index `to`, and\n        /// increment the transfer count for worker `worker` (like I said, that last part can\n        /// likely be done elsewhere).\n        pub fn transfer(&self, from: usize, to: usize, amount: usize, worker: usize) {\n            // The from == to check is important so we don't deadlock, since Rust mutexes are\n            // non-reentrant.\n            if from == to || N_BUCKETS <= from || N_BUCKETS <= to || N_WORKERS <= worker {\n                return;\n            }\n            // We know this won't fail, and the compiler seems to know as well.  However, if it\n            // *did* fail, it wouldn't fail while we were holding mutexes (which can cause\n            // problems since they may need to poison other tasks).\n            let b1 = &self.buckets[from];\n            let b2 = &self.buckets[to];\n            // It's very important to lock our Mutexes in the same order everywhere to avoid\n            // deadlock.  We arbitrarily choose the convention that we lock in ascending index\n            // order.\n            let (low, high) = if from < to { (b1, b2) } else { (b2, b1) };\n            {\n                // The reason we introduce a new scope here is that we want to make it clear how\n                // long we're locking for.  Locks should be held as briefly as possible and\n                // anything that happens here should really *require* the locks.\n                let _s1 = low.mutex.lock();\n                let _s2 = high.mutex.lock();\n                // It is possible that SeqCst is too strong for this section, but it is hard to\n                // test on x86 because it has unusually strong consistency by default.\n                let v1 = b1.data.load(Ordering::SeqCst);\n                let real_amount = ::std::cmp::min(v1, amount);\n                b1.data.store(v1 - real_amount, Ordering::SeqCst);\n                b2.data.fetch_add(real_amount, Ordering::SeqCst);\n            }\n            // Doing this outside the critical section increases throughput substantially.  Since\n            // this is just a summary statistic, it's okay for it to be a few off.  That's also why\n            // we use Acquire semantics rather than AcqRel or SeqCst here--we only really care that\n            // we synchronize when the transfer count is set to 0.\n            self.transfers[worker].fetch_add(1, Ordering::Acquire);\n        }\n\n        /// Acquire a consistent snapshot of the state of the bucket list.  This should maintain\n        /// the invariant that total buckets are conserved.  Also returns the list of transfer\n        /// counts.\n        pub fn snapshot(&self) -> ([usize; N_BUCKETS], [usize; N_WORKERS]) {\n            // Since this method is called relatively rarely, we aren't too concerned about\n            // performance here.\n            let mut buckets = [0; N_BUCKETS];\n            let mut transfers = [0; N_WORKERS];\n            // We collect all the locks in order, being careful not to drop any until we're done\n            // (so as to preserve consistency of the snapshot).\n            let locks = buckets\n                .iter_mut()\n                .zip(self.buckets.iter())\n                .map(|(dest, src)| {\n                    let lock = src.mutex.lock();\n                    // Is SeqCst necessary here?  Maybe, maybe not, but when in doubt go with\n                    // SeqCst.\n                    *dest = src.data.load(Ordering::SeqCst);\n                    lock\n                })\n                .collect::<Vec<_>>();\n            for (dest, src) in transfers.iter_mut().zip(self.transfers.iter()) {\n                // We synchronize with the Acquire in transfer, making sure that our zeroing out\n                // gets noticed.\n                *dest = src.swap(0, Ordering::Release);\n            }\n            // We can drop the locks before we return.  This probably gets optimized out, but it's\n            // rarely a bad idea to drop locks explicitly.\n            drop(locks);\n            (buckets, transfers)\n        }\n    }\n}\n\n/// Convenience method to create a distribution of buckets summing to `initial_sum`.\nfn make_buckets(initial_sum: usize) -> buckets::Buckets {\n    let mut buckets = [0; buckets::N_BUCKETS];\n    let mut dist = initial_sum;\n    for (i, b) in buckets.iter_mut().enumerate() {\n        let v = dist / (buckets::N_BUCKETS - i);\n        *b = v;\n        dist -= v;\n    }\n    buckets::Buckets::new(buckets)\n}\n\n/// The equalize task--it chooses two random buckets and tries to make their values the same.\nfn equalize(bl: &buckets::Buckets, running: &AtomicBool, worker: usize) {\n    let mut rng = thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new(0, buckets::N_BUCKETS);\n    // Running is read Relaxed because it's not important that the task stop right away as long as\n    // it happens eventually.\n    while running.load(Ordering::Relaxed) {\n        let b1 = rng.sample(range);\n        let b2 = rng.sample(range);\n        let v1 = bl.get(b1).unwrap();\n        let v2 = bl.get(b2).unwrap();\n        if v1 > v2 {\n            bl.transfer(b1, b2, (v1 - v2) / 2, worker)\n        } else {\n            bl.transfer(b2, b1, (v2 - v1) / 2, worker)\n        }\n    }\n}\n\n/// The randomize task--it chooses two random buckets and randomly redistributes their values.\nfn randomize(bl: &buckets::Buckets, running: &AtomicBool, worker: usize) {\n    let mut rng = thread_rng();\n    let range = Uniform::new(0, buckets::N_BUCKETS);\n    // Running is read Relaxed because it's not important that the task stop right away as long as\n    // it happens eventually.\n    while running.load(Ordering::Relaxed) {\n        let b1 = rng.sample(range);\n        let b2 = rng.sample(range);\n        bl.transfer(b1, b2, rng.gen_range(0, bl.get(b1).unwrap() + 1), worker);\n    }\n}\n\n/// The display task--for a total time of `duration`, it displays information about the update\n/// process and checks to make sure that the invariant (that the total remains constant) is\n/// preserved.  It prints an update `nticks` times, evenly spaced.\nfn display(\n    bl: &buckets::Buckets,\n    running: &AtomicBool,\n    original_total: usize,\n    duration: Duration,\n    nticks: u32,\n) {\n    println!(\"transfers, N. transfers, buckets, buckets sum:\");\n\n    let duration = duration / nticks;\n    for _ in 0..nticks {\n        // Get a consistent snapshot\n        let (s, tc) = bl.snapshot();\n        // Sum up the buckets\n        let sum: usize = s.iter().sum();\n        // Sum up the transfers.\n        let n_transfers: usize = tc.iter().sum();\n        // Print the relevant information.\n        println!(\"{:?}, {}, {:?}, {}\", tc, n_transfers, s, sum);\n        // Check the invariant, failing if necessary.\n        assert_eq!(sum, original_total);\n        // Sleep before printing again.\n        thread::sleep(duration);\n    }\n    // We're done--cleanly exit the other update tasks.\n    running.store(false, Ordering::Relaxed);\n}\n\n/// Putting together all three tasks.\nfn perform_atomic_updates(duration: Duration, original_total: usize, num_ticks: u32) {\n    // Worker IDs for the two updater tasks.\n    const ID_EQUALIZE: usize = 0;\n    const ID_RANDOMIZE: usize = 1;\n\n    // `running` is an atomic boolean that we use to signal when to stop to the updater tasks.\n    let running = AtomicBool::new(true);\n    // We use an Arc here in order to share a reference to the buckets between threads.  Since the\n    // Buckets are already Sync, and we don't need &mut references to them, there's no need to\n    // create a Mutex here.\n    let arc = Arc::new((make_buckets(original_total), running));\n    // Cloning the arc bumps the reference count.\n    let arc_ = arc.clone();\n    // Start off the equalize task\n    spawn(move || equalize(&arc_.0, &arc_.1, ID_EQUALIZE));\n    let arc_ = arc.clone();\n    // Start off the randomize task\n    spawn(move || randomize(&arc_.0, &arc_.1, ID_RANDOMIZE));\n    let (ref bl, ref running) = *arc;\n    // Run the display task in the current thread, so failure propagates to the user.\n    display(bl, running, original_total, duration, num_ticks);\n}\n\nconst ORIGINAL_TOTAL: usize = 1000;\nconst NUM_TICKS: u32 = 10;\n\nfn main() {\n    perform_atomic_updates(Duration::from_secs(10), ORIGINAL_TOTAL, NUM_TICKS);\n}\n\n#[test]\nfn test_atomic_updates() {\n    perform_atomic_updates(Duration::from_secs(1) / 10, ORIGINAL_TOTAL, NUM_TICKS);\n}\n",
    "path": "tasks/atomic-updates",
    "remote_code": "extern crate rand;\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::cmp;\nuse std::time::Duration;\n\nuse rand::Rng;\nuse rand::distributions::{IndependentSample, Range};\n\ntrait Buckets {\n    fn equalize<R:Rng>(&mut self, rng: &mut R);\n    fn randomize<R:Rng>(&mut self, rng: &mut R);\n    fn print_state(&self);\n}\n\nimpl Buckets for [i32] {\n    fn equalize<R:Rng>(&mut self, rng: &mut R) {\n        let range = Range::new(0,self.len()-1);\n        let src = range.ind_sample(rng);\n        let dst = range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(((dst + src) / 2) as i32, self[src]);\n            let multiplier = if amount >= 0 { -1 } else { 1 };\n            self[src] += amount * multiplier;\n            self[dst] -= amount * multiplier;\n        }\n    }\n    fn randomize<R:Rng>(&mut self, rng: &mut R) {\n        let ind_range = Range::new(0,self.len()-1);\n        let src = ind_range.ind_sample(rng);\n        let dst = ind_range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(Range::new(0,20).ind_sample(rng), self[src]);\n            self[src] -= amount;\n            self[dst] += amount;\n\n        }\n    }\n    fn print_state(&self) {\n        println!(\"{:?} = {}\", self, self.iter().sum::<i32>());\n    }\n}\n\nfn main() {\n    let e_buckets = Arc::new(Mutex::new([10; 10]));\n    let r_buckets = e_buckets.clone();\n    let p_buckets = e_buckets.clone();\n\n    thread::spawn(move || { \n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = e_buckets.lock().unwrap();\n            buckets.equalize(&mut rng);\n        }\n    });\n    thread::spawn(move || {\n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = r_buckets.lock().unwrap();\n            buckets.randomize(&mut rng);\n        }\n    });\n\n    let sleep_time = Duration::new(1,0);\n    loop {\n        {\n            let buckets = p_buckets.lock().unwrap();\n            buckets.print_state();\n        }\n        thread::sleep(sleep_time);\n    }\n}",
    "title": "Atomic updates",
    "url": "http://rosettacode.org/wiki/Atomic_updates"
  },
  {
    "local_code": "use primal::StreamingSieve;\n\nconst MAX: u64 = 120;\n\n/// Returns an Option with a tuple => Ok((smaller prime factor, num divided by that prime factor))\n/// If num is a prime number itself, returns None\nfn extract_prime_factor(num: u64) -> Option<(u64, u64)> {\n    let mut i = 1;\n\n    if num < 2 || primal::is_prime(num) {\n        None\n    } else {\n        loop {\n            let prime = StreamingSieve::nth_prime(i) as u64;\n\n            if num % prime == 0 {\n                return Some((prime, num / prime));\n            } else {\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Returns a vector containing all the prime factors of num\nfn factorize(num: u64) -> Vec<u64> {\n    let mut factorized = Vec::new();\n    let mut rest = num;\n\n    while let Some((prime, factorizable_rest)) = extract_prime_factor(rest) {\n        factorized.push(prime);\n        rest = factorizable_rest;\n    }\n\n    factorized.push(rest);\n    factorized\n}\n\nfn main() {\n    let mut output: Vec<u64> = Vec::new();\n\n    for num in 4..=MAX {\n        if primal::is_prime(factorize(num).len() as u64) {\n            output.push(num);\n        }\n    }\n\n    println!(\n        \"The attractive numbers up to and including {} are\\n{:?}\",\n        MAX, output\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_prime_factor() {\n        assert_eq!(extract_prime_factor(0), None);\n        assert_eq!(extract_prime_factor(1), None);\n        assert_eq!(extract_prime_factor(2), None);\n        assert_eq!(extract_prime_factor(3), None);\n        assert_eq!(extract_prime_factor(4), Some((2, 2)));\n        assert_eq!(extract_prime_factor(5), None);\n        assert_eq!(extract_prime_factor(6), Some((2, 3)));\n        assert_eq!(extract_prime_factor(7), None);\n        assert_eq!(extract_prime_factor(8), Some((2, 4)));\n        assert_eq!(extract_prime_factor(9), Some((3, 3)));\n        assert_eq!(extract_prime_factor(10), Some((2, 5)));\n        assert_eq!(extract_prime_factor(11), None);\n        assert_eq!(extract_prime_factor(12), Some((2, 6)));\n    }\n\n    #[test]\n    fn test_factorize() {\n        assert_eq!(factorize(0), vec![0]);\n        assert_eq!(factorize(1), vec![1]);\n        assert_eq!(factorize(2), vec![2]);\n        assert_eq!(factorize(3), vec![3]);\n        assert_eq!(factorize(4), vec![2, 2]);\n        assert_eq!(factorize(5), vec![5]);\n        assert_eq!(factorize(6), vec![2, 3]);\n        assert_eq!(factorize(7), vec![7]);\n        assert_eq!(factorize(8), vec![2, 2, 2]);\n        assert_eq!(factorize(9), vec![3, 3]);\n        assert_eq!(factorize(10), vec![2, 5]);\n        assert_eq!(factorize(11), vec![11]);\n        assert_eq!(factorize(12), vec![2, 2, 3]);\n    }\n}\n",
    "path": "tasks/attractive-numbers",
    "remote_code": "use primal::Primes;\n\nconst MAX: u64 = 120;\n\n/// Returns an Option with a tuple => Ok((smaller prime factor, num divided by that prime factor))\n/// If num is a prime number itself, returns None\nfn extract_prime_factor(num: u64) -> Option<(u64, u64)> {\n    let mut i = 0;\n    if primal::is_prime(num) {\n        None\n    } else {\n        loop {\n            let prime = Primes::all().nth(i).unwrap() as u64;\n            if num % prime == 0 {\n                return Some((prime, num / prime));\n            } else {\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Returns a vector containing all the prime factors of num\nfn factorize(num: u64) -> Vec<u64> {\n    let mut factorized = Vec::new();\n    let mut rest = num;\n    while let Some((prime, factorizable_rest)) = extract_prime_factor(rest) {\n        factorized.push(prime);\n        rest = factorizable_rest;\n    }\n    factorized.push(rest);\n    factorized\n}\n\nfn main() {\n    let mut output: Vec<u64> = Vec::new();\n    for num in 4 ..= MAX {\n        if primal::is_prime(factorize(num).len() as u64) {\n            output.push(num);\n        }\n    }\n    println!(\"The attractive numbers up to and including 120 are\\n{:?}\", output);\n}",
    "title": "Attractive numbers",
    "url": "http://rosettacode.org/wiki/Attractive_numbers"
  },
  {
    "local_code": "//! Accepts two command-line arguments\n\nextern crate rand;\n\nuse std::collections::HashSet;\nuse std::env;\nuse std::process;\n\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\nfn help() {\n    println!(\"usage: average_loop_length <max_N> <trials>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut max_n: u32 = 20;\n    let mut trials: u32 = 1000;\n\n    match args.len() {\n        1 => {}\n        3 => {\n            max_n = args[1].parse().unwrap();\n            trials = args[2].parse().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    println!(\" N    average    analytical    (error)\");\n    println!(\"===  =========  ============  =========\");\n    for n in 1..(max_n + 1) {\n        let the_analytical = analytical(n);\n        let the_empirical = empirical(n, trials, &mut rng);\n        println!(\n            \" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)\",\n            n,\n            the_empirical,\n            the_analytical,\n            100.0 * (the_empirical / the_analytical - 1.0)\n        );\n    }\n}\n\nfn factorial(n: u32) -> f64 {\n    (1..n + 1).map(f64::from).product()\n}\n\nfn analytical(n: u32) -> f64 {\n    (1..(n + 1))\n        .map(|i| factorial(n) / f64::from(n).powi(i as i32) / factorial(n - i))\n        .sum()\n}\n\nfn empirical(n: u32, trials: u32, rng: &mut impl Rng) -> f64 {\n    let sum: f64 = (0..trials)\n        .map(|_trial| {\n            let mut seen = HashSet::new();\n            let range = Uniform::new_inclusive(1, n);\n\n            seen.insert(1);\n            for step in 1..n {\n                let item = rng.sample(range);\n                let inserted = seen.insert(item);\n                if !inserted {\n                    return f64::from(step);\n                }\n            }\n            f64::from(n)\n        })\n        .sum();\n    sum / f64::from(trials)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::f64;\n\n    #[test]\n    fn test_factorial() {\n        assert!((factorial(10) - 3628800f64).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn test_analytical() {\n        assert!((analytical(10) - 3.6602).abs() < 0.0001);\n        assert!((analytical(20) - 5.2936).abs() < 0.0001);\n    }\n\n    #[test]\n    fn test_empirical() {\n        let mut rng = thread_rng();\n        let emp = empirical(20, 10000, &mut rng);\n        let ana = analytical(20);\n        assert!((emp / ana - 1.0).abs() < 0.05);\n    }\n}\n",
    "path": "tasks/average-loop-length",
    "remote_code": "extern crate rand;\n\nuse rand::{ThreadRng, thread_rng};\nuse rand::distributions::{IndependentSample, Range};\nuse std::collections::HashSet;\nuse std::env;\nuse std::process;\n\nfn help() {\n    println!(\"usage: average_loop_length <max_N> <trials>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut max_n: u32 = 20;\n    let mut trials: u32 = 1000;\n\n    match args.len() {\n        1 => {}\n        3 => {\n            max_n = args[1].parse::<u32>().unwrap();\n            trials = args[2].parse::<u32>().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    println!(\" N    average    analytical    (error)\");\n    println!(\"===  =========  ============  =========\");\n    for n in 1..(max_n + 1) {\n        let the_analytical = analytical(n);\n        let the_empirical = empirical(n, trials, &mut rng);\n        println!(\" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)\",\n                 n,\n                 the_empirical,\n                 the_analytical,\n                 100f64 * (the_empirical / the_analytical - 1f64));\n    }\n}\n\nfn factorial(n: u32) -> f64 {\n    (1..n + 1).fold(1f64, |p, n| p * n as f64)\n}\n\nfn analytical(n: u32) -> f64 {\n    let sum: f64 = (1..(n + 1))\n                       .map(|i| factorial(n) / (n as f64).powi(i as i32) / factorial(n - i))\n                       .fold(0f64, |a, v| a + v);\n    sum\n}\n\nfn empirical(n: u32, trials: u32, rng: &mut ThreadRng) -> f64 {\n    let sum: f64 = (0..trials)\n                       .map(|_t| {\n                           let mut item = 1u32;\n                           let mut seen = HashSet::new();\n                           let range = Range::new(1u32, n + 1);\n\n                           for step in 0..n {\n                               if seen.contains(&item) {\n                                   return step as f64;\n                               }\n                               seen.insert(item);\n                               item = range.ind_sample(rng);\n                           }\n                           n as f64\n                       })\n                       .fold(0f64, |a, v| a + v);\n    sum / trials as f64\n}\n\n\n",
    "title": "Average loop length",
    "url": "http://rosettacode.org/wiki/Average_loop_length"
  },
  {
    "local_code": "// The mean is not defined for an empty list, so we must return an Option\nfn mean(list: &[f64]) -> Option<f64> {\n    match list.len() {\n        0 => None,\n        n => {\n            let sum = list.iter().fold(0f64, |a, &b| a + b);\n            Some(sum / n as f64)\n        }\n    }\n}\n\nfn main() {\n    let input = [3.0, 1.0, 4.0, 1.0, 5.0, 9.0];\n\n    // This should be 3.833333\n    let mean = mean(&input).unwrap();\n    println!(\"{}\", mean);\n}\n\n#[test]\nfn simple_test() {\n    let nums = [1.0, 2.0, 3.0, 4.0, 5.0];\n    assert_eq!(mean(&nums), Some(3.0));\n}\n\n#[test]\nfn mean_empty_list() {\n    let no_nums = [];\n    assert_eq!(mean(&no_nums), None);\n}\n",
    "path": "tasks/averages/arithmetic-mean",
    "remote_code": "fn sum(arr: &[f64]) -> f64 {\n    arr.iter().fold(0.0, |p,&q| p + q)\n}\n\nfn mean(arr: &[f64]) -> f64 {\n    sum(arr) / arr.len() as f64\n}\n\nfn main() {\n    let v = &[2.0, 3.0, 5.0, 7.0, 13.0, 21.0, 33.0, 54.0];\n    println!(\"mean of {:?}: {:?}\", v, mean(v));\n\n    let w = &[];\n    println!(\"mean of {:?}: {:?}\", w, mean(w));\n}",
    "title": "Averages/Arithmetic mean",
    "url": "http://rosettacode.org/wiki/Averages/Arithmetic_mean"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Averages/Mean_angle\n\nuse std::f64::consts::PI;\n\nfn mean_angle(angles: &[f64]) -> f64 {\n    let (sum_cos, sum_sin) = angles\n        .iter()\n        .map(|&x| x * PI / 180.)\n        .map(|x| (x.cos(), x.sin()))\n        .fold((0., 0.), |(sc, ss), (c, s)| (sc + c, ss + s));\n\n    let mean_cos = sum_cos / angles.len() as f64;\n    let mean_sin = sum_sin / angles.len() as f64;\n\n    mean_sin.atan2(mean_cos) * 180. / PI\n}\n\nfn main() {\n    let set1 = &[350., 10.];\n    let set2 = &[90., 180., 270., 360.];\n    let set3 = &[10., 20., 30.];\n\n    println!(\"Mean angle of first set is {} degrees\", mean_angle(set1));\n    println!(\"Mean angle of second set is {} degrees\", mean_angle(set2));\n    println!(\"Mean angle of third set is {} degrees\", mean_angle(set3));\n}\n\n#[test]\nfn basic_tests() {\n    use std::f64;\n\n    let set1 = [350., 10.];\n    let set2 = [90., 180., 270., 360.];\n    let set3 = [10., 20., 30.];\n\n    // We need to round the numbers\n    assert!((mean_angle(&set1).round() - 0.).abs() < f64::EPSILON);\n    assert!((mean_angle(&set2).round() - -90.).abs() < f64::EPSILON);\n    assert!((mean_angle(&set3).round() - 20.).abs() < f64::EPSILON);\n}\nuse std::f64;\n\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles1,\n        mean_angle(&angles1)\n    );\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles2,\n        mean_angle(&angles2)\n    );\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles3,\n        mean_angle(&angles3)\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::mean_angle;\n\n    macro_rules! assert_diff {\n        ($x:expr, $y:expr, $diff:expr) => {\n            if ($x - $y).abs() > $diff {\n                panic!(\"floating point difference is to big {}\", $x - $y);\n            }\n        };\n    }\n\n    #[test]\n    fn calculate() {\n        let angles1 = [350.0_f64, 10.0];\n        let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n        let angles3 = [10.0_f64, 20.0, 30.0];\n        assert_diff!(0.0, mean_angle(&angles1), 0.001);\n        assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n        assert_diff!(20.0, mean_angle(&angles3), 0.001);\n    }\n}\n",
    "path": "tasks/averages/mean-angle",
    "remote_code": "\nuse std::f64;\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles1,\n             mean_angle(&angles1));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles2,\n             mean_angle(&angles2));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles3,\n             mean_angle(&angles3));\n}\n\nmacro_rules! assert_diff{\n    ($x: expr,$y : expr, $diff :expr)=>{\n        if ( $x - $y ).abs() > $diff {\n            panic!(\"floating point difference is to big {}\", $x - $y );\n        }\n    }\n}\n\n#[test]\nfn calculate() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    assert_diff!(0.0, mean_angle(&angles1), 0.001);\n    assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n    assert_diff!(20.0, mean_angle(&angles3), 0.001);\n}\n",
    "title": "Averages/Mean angle",
    "url": "http://rosettacode.org/wiki/Averages/Mean_angle"
  },
  {
    "local_code": "use std::f64::consts::PI;\n\n#[derive(Debug, PartialEq, Eq)]\nstruct Time {\n    h: u8,\n    m: u8,\n    s: u8,\n}\n\nimpl Time {\n    /// Create a Time from equivalent radian measure\n    fn from_radians(mut rads: f64) -> Time {\n        rads %= 2.0 * PI;\n        if rads < 0.0 {\n            rads += 2.0 * PI\n        }\n        Time {\n            h: (rads * 12.0 / PI) as u8,\n            m: ((rads * 720.0 / PI) % 60.0) as u8,\n            s: ((rads * 43200.0 / PI) % 60.0).round() as u8,\n        }\n    }\n\n    /// Create a Time from H/M/S\n    fn from_parts(h: u8, m: u8, s: u8) -> Result<Time, ()> {\n        if h > 23 || m > 59 || s > 59 {\n            return Err(());\n        }\n        Ok(Time { h, m, s })\n    }\n\n    /// Return time as measure in radians\n    fn as_radians(&self) -> f64 {\n        ((self.h as f64 / 12.0) + (self.m as f64 / 720.0) + (self.s as f64 / 43200.0)) * PI\n    }\n}\n\n/// Compute the mean time from a slice of times\nfn mean_time(times: &[Time]) -> Time {\n    // compute sum of sines and cosines\n    let (ss, sc) = times\n        .iter()\n        .map(Time::as_radians)\n        .map(|a| (a.sin(), a.cos()))\n        .fold((0.0, 0.0), |(ss, sc), (s, c)| (ss + s, sc + c));\n    // scaling does not matter for atan2, meaning we do not have to divide sums by len\n    Time::from_radians(ss.atan2(sc))\n}\n\nfn main() {\n    let times = [\n        Time::from_parts(23, 00, 17).unwrap(),\n        Time::from_parts(23, 40, 20).unwrap(),\n        Time::from_parts(00, 12, 45).unwrap(),\n        Time::from_parts(00, 17, 19).unwrap(),\n    ];\n\n    let mean = mean_time(&times);\n\n    println!(\"{:02}:{:02}:{:02}\", mean.h, mean.m, mean.s);\n}\n\n#[test]\nfn test_time_eq() {\n    // simple tests\n    assert_eq!(\n        Time::from_parts(00, 00, 00).unwrap(),\n        Time::from_radians(0.0)\n    );\n    assert_eq!(\n        Time::from_parts(12, 00, 00).unwrap(),\n        Time::from_radians(PI)\n    );\n    assert_eq!(\n        Time::from_parts(18, 00, 00).unwrap(),\n        Time::from_radians(3.0 * PI / 2.0)\n    );\n\n    // targeted tests\n    assert_eq!(\n        Time::from_parts(23, 00, 17).unwrap(),\n        Time::from_radians(6.022622194267266)\n    );\n    assert_eq!(\n        Time::from_parts(23, 40, 20).unwrap(),\n        Time::from_radians(6.197373285623199)\n    );\n    assert_eq!(\n        Time::from_parts(00, 12, 45).unwrap(),\n        Time::from_radians(0.05563236990731926)\n    );\n    assert_eq!(\n        Time::from_parts(00, 17, 19).unwrap(),\n        Time::from_radians(0.07555821220092118)\n    );\n    assert_eq!(\n        Time::from_parts(23, 47, 23).unwrap(),\n        Time::from_radians(6.228134713689599)\n    );\n}\n",
    "path": "tasks/averages/mean-time-of-day",
    "remote_code": "\nuse std::f64::consts::PI;\n\n#[derive(Debug, PartialEq, Eq)]\nstruct Time {\n    h: u8,\n    m: u8,\n    s: u8,\n}\n\nimpl Time {\n    /// Create a Time from equivalent radian measure\n    fn from_radians(mut rads: f64) -> Time {\n        rads %= 2.0 * PI;\n        if rads < 0.0 {\n            rads += 2.0 * PI\n        }\n        Time {\n            h: (rads * 12.0 / PI) as u8,\n            m: ((rads * 720.0 / PI) % 60.0) as u8,\n            s: ((rads * 43200.0 / PI) % 60.0).round() as u8,\n        }\n    }\n\n    /// Create a Time from H/M/S\n    fn from_parts(h: u8, m: u8, s: u8) -> Result<Time, ()> {\n        if h > 23 || m > 59 || s > 59 {\n            return Err(());\n        }\n        Ok(Time { h, m, s })\n    }\n\n    /// Return time as measure in radians\n    fn as_radians(&self) -> f64 {\n        ((self.h as f64 / 12.0) + (self.m as f64 / 720.0) + (self.s as f64 / 43200.0)) * PI\n    }\n}\n\n/// Compute the mean time from a slice of times\nfn mean_time(times: &[Time]) -> Time {\n    // compute sum of sines and cosines\n    let (ss, sc) = times\n        .iter()\n        .map(Time::as_radians)\n        .map(|a| (a.sin(), a.cos()))\n        .fold((0.0, 0.0), |(ss, sc), (s, c)| (ss + s, sc + c));\n    // scaling does not matter for atan2, meaning we do not have to divide sums by len\n    Time::from_radians(ss.atan2(sc))\n}\n\nfn main() {\n    let times = [\n        Time::from_parts(23, 00, 17).unwrap(),\n        Time::from_parts(23, 40, 20).unwrap(),\n        Time::from_parts(00, 12, 45).unwrap(),\n        Time::from_parts(00, 17, 19).unwrap(),\n    ];\n\n    let mean = mean_time(&times);\n\n    println!(\"{:02}:{:02}:{:02}\", mean.h, mean.m, mean.s);\n}\n\n",
    "title": "Averages/Mean time of day",
    "url": "http://rosettacode.org/wiki/Averages/Mean_time_of_day"
  },
  {
    "local_code": "fn median(samples: &[f64]) -> f64 {\n    let mut xs = samples.to_vec();\n    xs.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\n    let n = xs.len();\n    if n % 2 == 0 {\n        (xs[n / 2] + xs[(n / 2) - 1]) / 2.0\n    } else {\n        xs[n / 2]\n    }\n}\n\nfn main() {\n    let nums = vec![2., 3., 5., 0., 9., 82., 353., 32., 12.];\n    println!(\"{:?}\", median(&nums))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::f64;\n\n    #[test]\n    fn median() {\n        let nums = vec![1.];\n        assert!((super::median(&nums) - 1_f64).abs() < f64::EPSILON);\n\n        let nums = vec![1., 2.];\n        assert!((super::median(&nums) - 1.5_f64).abs() < f64::EPSILON);\n\n        let nums = vec![2., 3., 5., 0., 9., 82., 353., 32., 12.];\n        assert!((super::median(&nums) - 9_f64).abs() < f64::EPSILON);\n    }\n}\n",
    "path": "tasks/averages/median",
    "remote_code": "fn median(mut xs: Vec<f64>) -> f64 {\n    // sort in ascending order, panic on f64::NaN\n    xs.sort_by(|x,y| x.partial_cmp(y).unwrap() );\n    let n = xs.len();\n    if n % 2 == 0 {\n        (xs[n/2] + xs[n/2 - 1]) / 2.0\n    } else {\n        xs[n/2]\n    }\n}\n\nfn main() {\n    let nums = vec![2.,3.,5.,0.,9.,82.,353.,32.,12.];\n    println!(\"{:?}\", median(nums))\n}",
    "title": "Averages/Median",
    "url": "http://rosettacode.org/wiki/Averages/Median"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n/// Returns the most common element a collection implementing\n/// `IntoIterator<Item=T>`, where `T` must implement the `Eq` and `Hash` traits\n///\n/// ```\n/// let v1 = vec![1,3,6,6,6,6,7,7,12,12,17];\n/// println!(\"{}\", mode(v1));\n/// ```\nfn mode<I>(items: I) -> Vec<I::Item>\nwhere\n    I: IntoIterator,\n    I::Item: Hash + Eq,\n{\n    // NOTE: Usually, you wouldn't need to explicitly call `into_iter()` before\n    // looping over a type implementing `IntoIterator`. However, we do it here\n    // because we need to call `size_hint()` on the iterator so we can\n    // preallocate the `HashMap`.\n    let items = items.into_iter();\n    let (lower_bound, _upper_bound) = items.size_hint();\n\n    // Allocate a new HashMap with enough space to fit the lower bound of the\n    // number of items in `items`.\n    //\n    // If the lower bound (`lower_bound`) is the same as the upper bound as\n    // will be the case for most collections (e.g. `Vec<T>`, `[T]`,\n    // `HashSet<T>`, etc.) it will be an overestimate on the number of unique\n    // elements in the collection. This means that, in the common case, we'll\n    // never have to grow the `HashMap`. While overestimating means we'll likely\n    // use more memory than necessary, the allocation size will usually be\n    // proportional to the size of the input collection (assuming it's not a\n    // lazy collection). This `HashMap` is short lived anyways.\n    let mut map = HashMap::with_capacity(lower_bound); // HashMap<I::Item, i32>\n\n    // Count the number of occurrences of each item.\n    for item in items {\n        *map.entry(item).or_insert(0) += 1;\n    }\n\n    // Iterate over the counts, and find the maximum or default to 0.\n    let max = map.values().cloned().max().unwrap_or(0);\n\n    // Iterate by (item, value) pairs and find all modes (there may be multiple).\n    map.into_iter()\n        .filter(|&(_, v)| v == max)\n        .map(|(k, _)| k)\n        .collect()\n}\n\nfn main() {\n    let items = vec![1, 2, 3, 1, 2, 4, 2, 6, 3, 3, 1, 3, 6];\n    println!(\"{:?}\", mode(&items));\n}\n\n#[test]\nfn simple_tests() {\n    let v1 = vec![1, 2, 3, 2, 1];\n    let mut m1 = mode(v1);\n    m1.sort_unstable();\n    assert_eq!(m1, vec![1, 2]);\n\n    let v2: &[u64] = &[0xdeadbeef, 0xba5eba11, 0xdeadbeef];\n    let mut m2 = mode(v2.iter().cloned());\n    m2.sort_unstable();\n    assert_eq!(m2, vec![0xdeadbeef]);\n\n    let v3 = \"Eneyi\\u{e4}n\";\n    let mut m3 = mode(v3.chars());\n    m3.sort_unstable();\n    assert_eq!(m3, vec!['n']);\n\n    let v4 = vec![1, 3, 6, 6, 7, 7, 12, 12, 17];\n    let mut m4 = mode(&v4);\n    m4.sort_unstable();\n    assert_eq!(m4, &[&6, &7, &12]);\n}\n",
    "path": "tasks/averages/mode",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let mode_vec1 = mode(vec![ 1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);\n    let mode_vec2 = mode(vec![ 1, 1, 2, 4, 4]);\n\n    println!(\"Mode of vec1 is: {:?}\", mode_vec1);\n    println!(\"Mode of vec2 is: {:?}\", mode_vec2);\n\n    assert!( mode_vec1 == [6], \"Error in mode calculation\");\n    assert!( (mode_vec2 == [1, 4]) || (mode_vec2 == [4,1]), \"Error in mode calculation\" );\n}\n\nfn mode(vs: Vec<i32>) -> Vec<i32> {\n    let mut vec_mode = Vec::new();\n    let mut seen_map = HashMap::new();\n    let mut max_val = 0;\n    for i in vs{\n        let ctr = seen_map.entry(i).or_insert(0);\n        *ctr += 1;\n        if *ctr > max_val{\n            max_val = *ctr;\n        }\n    }\n    for (key, val) in seen_map {\n        if val == max_val{\n            vec_mode.push(key);\n        }\n    }\n    vec_mode\n}\n",
    "title": "Averages/Mode",
    "url": "http://rosettacode.org/wiki/Averages/Mode"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut sum = 0.0;\n    let mut prod = 1;\n    let mut recsum = 0.0;\n    for i in 1..11{\n        sum += i as f32;\n        prod *= i;\n        recsum += 1.0/(i as f32);\n    } \n    let avg = sum/10.0;\n    let gmean = (prod as f32).powf(0.1);\n    let hmean = 10.0/recsum;\n    println!(\"Average: {}, Geometric mean: {}, Harmonic mean: {}\", avg, gmean, hmean);\n    assert!( ( (avg >= gmean) && (gmean >= hmean) ), \"Incorrect calculation\");\n\n}\n",
    "title": "Averages/Pythagorean means",
    "url": "http://rosettacode.org/wiki/Averages/Pythagorean_means"
  },
  {
    "local_code": "/// The mean is not defined for an empty list, so we must return an Option\nfn rms(list: &[f64]) -> Option<f64> {\n    match list.len() {\n        0 => None,\n        n => {\n            let sum = list.iter().fold(0., |a, &b| a + b * b);\n            Some(f64::sqrt(sum / n as f64))\n        }\n    }\n}\n\nfn main() {\n    let input: Vec<_> = (1..11).map(f64::from).collect();\n\n    // 6.2048368229954285\n    let rms = rms(&input).unwrap();\n    println!(\"{}\", rms);\n}\n\n#[test]\nfn test() {\n    let arr = [5., 7., 2., 0., 0.5];\n    assert_eq!(rms(&arr), Some(3.9560080889704965));\n}\n\n#[test]\nfn rms_empty_array() {\n    let no_nums = [];\n    assert_eq!(rms(&no_nums), None);\n}\n",
    "path": "tasks/averages/root-mean-square",
    "remote_code": "fn root_mean_square(vec: Vec<i32>) -> f32 {\n    let sum_squares = vec.iter().fold(0, |acc, &x| acc + x.pow(2));\n    return ((sum_squares as f32)/(vec.len() as f32)).sqrt();\n}\n\nfn main() {\n    let vec = (1..11).collect();\n    println!(\"The root mean square is: {}\", root_mean_square(vec));\n}",
    "title": "Averages/Root mean square",
    "url": "http://rosettacode.org/wiki/Averages/Root_mean_square"
  },
  {
    "local_code": "use std::error::Error;\nuse std::fmt;\n\nstruct MovingAverage {\n    period: u32,\n    list: Vec<f32>,\n}\n\n#[derive(Debug)]\nstruct MovingAverageError {\n    entries: usize,\n    period: u32,\n}\n\nimpl fmt::Display for MovingAverageError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"currently only have {} entries, but period is {}\",\n            self.entries, self.period\n        )\n    }\n}\n\nimpl Error for MovingAverageError {}\n\nimpl MovingAverage {\n    fn new(period: u32) -> MovingAverage {\n        if period > 0 {\n            MovingAverage {\n                period,\n                list: Vec::new(),\n            }\n        } else {\n            panic!(\"Cannot have a period less than or equal to 0\");\n        }\n    }\n\n    fn append(&mut self, value: f32) {\n        self.list.push(value);\n        if self.list.len() > self.period as usize {\n            self.list.remove(0);\n        }\n    }\n\n    fn calculate(&self) -> Result<f32, MovingAverageError> {\n        if self.list.len() < self.period as usize {\n            Err(MovingAverageError {\n                entries: self.list.len(),\n                period: self.period,\n            })\n        } else {\n            Ok(self.list.iter().fold(0.0_f32, |l, r| l + r) / (self.period as f32))\n        }\n    }\n}\n\nfn main() {\n    let mut ma = MovingAverage::new(3);\n    ma.append(1.0);\n    ma.append(2.0);\n    ma.append(3.0);\n\n    println!(\"{:?}\", ma.calculate());\n}\n\n#[allow(clippy::float_cmp)]\n#[test]\nfn test_ma() {\n    let mut ma = MovingAverage::new(3);\n    assert!(ma.calculate().is_err());\n    ma.append(1.0);\n    assert!(ma.calculate().is_err());\n    ma.append(2.0);\n    assert!(ma.calculate().is_err());\n    ma.append(3.0);\n    assert_eq!(ma.calculate().unwrap(), 2.0);\n    ma.append(1.0);\n    assert_eq!(ma.calculate().unwrap(), 2.0);\n    ma.append(8.0);\n    assert_eq!(ma.calculate().unwrap(), 4.0);\n}\n",
    "path": "tasks/averages/simple-moving-average",
    "remote_code": "struct SimpleMovingAverage {\n    period: usize,\n    numbers: Vec<usize>\n}\n\nimpl SimpleMovingAverage {\n    fn new(p: usize) -> SimpleMovingAverage {\n        SimpleMovingAverage {\n            period: p,\n            numbers: Vec::new()\n        }\n    }\n\n    fn add_number(&mut self, number: usize) -> f64 {\n        self.numbers.push(number);\n        \n        if self.numbers.len() > self.period {\n            self.numbers.remove(0);\n        }\n        \n        if self.numbers.is_empty() {\n            return 0f64;\n        }else {\n            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);\n            return sum as f64 / self.numbers.len() as f64;\n        }\n    }\n}\n\nfn main() {\n    for period in [3, 5].iter() {\n        println!(\"Moving average with period {}\", period);\n\n        let mut sma = SimpleMovingAverage::new(*period);\n        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {\n            println!(\"Number: {} | Average: {}\", i, sma.add_number(*i));\n        }\n    }\n}",
    "title": "Averages/Simple moving average",
    "url": "http://rosettacode.org/wiki/Averages/Simple_moving_average"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut current = 0;\n    while (current * current) % 1_000_000 != 269_696 {\n        current += 1;\n    }\n    println!(\n        \"The smallest number whose square ends in 269696 is {}\",\n        current\n    );\n}",
    "title": "Babbage problem",
    "url": "http://rosettacode.org/wiki/Babbage_problem"
  },
  {
    "local_code": "extern crate rand;\n\ntrait Balanced {\n    /// Returns true if the brackets are balanced\n    fn is_balanced(&self) -> bool;\n}\n\nimpl<'a> Balanced for str {\n    fn is_balanced(&self) -> bool {\n        let mut count = 0;\n\n        for bracket in self.chars() {\n            let change = match bracket {\n                '[' => 1,\n                ']' => -1,\n                _ => panic!(\"Strings should only contain brackets\"),\n            };\n\n            count += change;\n            if count < 0 {\n                return false;\n            }\n        }\n\n        count == 0\n    }\n}\n\n/// Generates random brackets\nfn generate_brackets(num: usize) -> String {\n    use rand::{thread_rng, Rng};\n\n    let mut rng = thread_rng();\n    (0..num)\n        .map(|_| if rng.gen() { '[' } else { ']' })\n        .collect()\n}\n\nfn main() {\n    for i in 0..10 {\n        let brackets = generate_brackets(i);\n\n        println!(\"{}    {}\", brackets, brackets.is_balanced())\n    }\n}\n\n#[test]\nfn test_empty_string() {\n    assert!(\"\".is_balanced());\n}\n\n#[test]\nfn test_wrong_brackets() {\n    assert!(!\"][\".is_balanced());\n    assert!(!\"][][\".is_balanced());\n    assert!(!\"[]][[]\".is_balanced());\n}\n\n#[test]\nfn test_good_brackets() {\n    assert!(\"[]\".is_balanced());\n    assert!(\"[][]\".is_balanced());\n    assert!(\"[[][]]\".is_balanced());\n}\n",
    "path": "tasks/balanced-brackets",
    "remote_code": "extern crate rand;\n\ntrait Balanced {\n    /// Returns true if the brackets are balanced\n    fn is_balanced(&self) -> bool;\n}\n\nimpl<'a> Balanced for str {\n    fn is_balanced(&self) -> bool {\n        let mut count = 0;\n\n        for bracket in self.chars() {\n            let change = match bracket {\n                '[' => 1,\n                ']' => -1,\n                _ => panic!(\"Strings should only contain brackets\")\n            };\n\n            count += change;\n            if count < 0 { return false; }\n        }\n\n        count == 0\n    }\n}\n\n/// Generates random brackets\nfn generate_brackets(num: usize) -> String {\n    use rand::random;\n\n    (0..num).map(|_| if random() { '[' } else { ']' }).collect()\n}\n\nfn main() {\n    for i in (0..10) {\n        let brackets = generate_brackets(i);\n\n        println!(\"{}    {}\", brackets, brackets.is_balanced())\n    }\n}",
    "title": "Balanced brackets",
    "url": "http://rosettacode.org/wiki/Balanced_brackets"
  },
  {
    "local_code": "use std::{\n    cmp::min,\n    convert::{TryFrom, TryInto},\n    fmt,\n    ops::{Add, Mul, Neg},\n    str::FromStr,\n};\n\nfn main() -> Result<(), &'static str> {\n    let a = BalancedTernary::from_str(\"+-0++0+\")?;\n    let b = BalancedTernary::from(-436);\n    let c = BalancedTernary::from_str(\"+-++-\")?;\n    println!(\"a = {} = {}\", a, i128::try_from(a.clone())?);\n    println!(\"b = {} = {}\", b, i128::try_from(b.clone())?);\n    println!(\"c = {} = {}\", c, i128::try_from(c.clone())?);\n\n    let d = a * (b + -c);\n    println!(\"a * (b - c) = {} = {}\", d, i128::try_from(d.clone())?);\n\n    let a = BalancedTernary::from_str(\n        \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",\n    )?;\n    assert!(i128::try_from(a).is_err());\n\n    Ok(())\n}\n\n#[derive(Clone, Copy, PartialEq)]\nenum Trit {\n    Zero,\n    Pos,\n    Neg,\n}\n\nimpl TryFrom<char> for Trit {\n    type Error = &'static str;\n\n    fn try_from(value: char) -> Result<Self, Self::Error> {\n        match value {\n            '0' => Ok(Self::Zero),\n            '+' => Ok(Self::Pos),\n            '-' => Ok(Self::Neg),\n            _ => Err(\"Invalid character for balanced ternary\"),\n        }\n    }\n}\n\nimpl From<Trit> for char {\n    fn from(x: Trit) -> Self {\n        match x {\n            Trit::Zero => '0',\n            Trit::Pos => '+',\n            Trit::Neg => '-',\n        }\n    }\n}\n\nimpl Add for Trit {\n    // (Carry, Current)\n    type Output = (Self, Self);\n\n    fn add(self, rhs: Self) -> Self::Output {\n        use Trit::{Neg, Pos, Zero};\n        match (self, rhs) {\n            (Zero, x) | (x, Zero) => (Zero, x),\n            (Pos, Neg) | (Neg, Pos) => (Zero, Zero),\n            (Pos, Pos) => (Pos, Neg),\n            (Neg, Neg) => (Neg, Pos),\n        }\n    }\n}\n\nimpl Mul for Trit {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        use Trit::{Neg, Pos, Zero};\n        match (self, rhs) {\n            (Zero, _) | (_, Zero) => Zero,\n            (Pos, Pos) | (Neg, Neg) => Pos,\n            (Pos, Neg) | (Neg, Pos) => Neg,\n        }\n    }\n}\n\nimpl Neg for Trit {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        match self {\n            Trit::Zero => Trit::Zero,\n            Trit::Pos => Trit::Neg,\n            Trit::Neg => Trit::Pos,\n        }\n    }\n}\n\n// The vector is stored in reverse from how it would be viewed, as\n// operations tend to work backwards\n#[derive(Clone)]\nstruct BalancedTernary(Vec<Trit>);\n\nimpl fmt::Display for BalancedTernary {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.0\n                .iter()\n                .rev()\n                .map(|&d| char::from(d))\n                .collect::<String>()\n        )\n    }\n}\n\nimpl Add for BalancedTernary {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        use Trit::Zero;\n\n        // Trim leading zeroes\n        fn trim(v: &mut Vec<Trit>) {\n            while let Some(last_elem) = v.pop() {\n                if last_elem != Zero {\n                    v.push(last_elem);\n                    break;\n                }\n            }\n        }\n\n        if rhs.0.is_empty() {\n            // A balanced ternary shouldn't be empty\n            if self.0.is_empty() {\n                return BalancedTernary(vec![Zero]);\n            }\n            return self;\n        }\n\n        let length = min(self.0.len(), rhs.0.len());\n        let mut sum = Vec::new();\n        let mut carry = vec![Zero];\n\n        for i in 0..length {\n            let (carry_dig, digit) = self.0[i] + rhs.0[i];\n            sum.push(digit);\n            carry.push(carry_dig);\n        }\n        // At least one of these two loops will be ignored\n        for i in length..self.0.len() {\n            sum.push(self.0[i]);\n        }\n        for i in length..rhs.0.len() {\n            sum.push(rhs.0[i]);\n        }\n\n        trim(&mut sum);\n        trim(&mut carry);\n\n        BalancedTernary(sum) + BalancedTernary(carry)\n    }\n}\n\n// This version of `Mul` requires an implementation of the `Add` trait\nimpl Mul for BalancedTernary {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        let mut results = Vec::with_capacity(rhs.0.len());\n        for i in 0..rhs.0.len() {\n            let mut digits = vec![Trit::Zero; i];\n            for j in 0..self.0.len() {\n                digits.push(self.0[j] * rhs.0[i]);\n            }\n            results.push(BalancedTernary(digits));\n        }\n        #[allow(clippy::suspicious_arithmetic_impl)]\n        results\n            .into_iter()\n            .fold(BalancedTernary(vec![Trit::Zero]), |acc, x| acc + x)\n    }\n}\n\nimpl Neg for BalancedTernary {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        BalancedTernary(self.0.iter().map(|&x| -x).collect())\n    }\n}\n\nimpl FromStr for BalancedTernary {\n    type Err = &'static str;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.chars()\n            .rev()\n            .map(|c| c.try_into())\n            .collect::<Result<_, _>>()\n            .map(BalancedTernary)\n    }\n}\n\nimpl From<i128> for BalancedTernary {\n    fn from(x: i128) -> Self {\n        let mut v = Vec::new();\n        let mut curr = x;\n\n        loop {\n            let rem = curr % 3;\n\n            match rem {\n                0 => v.push(Trit::Zero),\n                1 | -2 => v.push(Trit::Pos),\n                2 | -1 => v.push(Trit::Neg),\n                _ => unreachable!(),\n            }\n\n            let offset = (rem as f64 / 3.0).round() as i128;\n            curr = curr / 3 + offset;\n\n            if curr == 0 {\n                break;\n            }\n        }\n\n        BalancedTernary(v)\n    }\n}\n\nimpl TryFrom<BalancedTernary> for i128 {\n    type Error = &'static str;\n\n    fn try_from(value: BalancedTernary) -> Result<Self, Self::Error> {\n        value\n            .0\n            .iter()\n            .enumerate()\n            .try_fold(0_i128, |acc, (i, character)| {\n                let size_err = \"Balanced ternary string is too large to fit into 16 bytes\";\n                let index: u32 = i.try_into().map_err(|_| size_err)?;\n\n                match character {\n                    Trit::Zero => Ok(acc),\n                    Trit::Pos => 3_i128\n                        .checked_pow(index)\n                        .and_then(|x| acc.checked_add(x))\n                        .ok_or(size_err),\n                    Trit::Neg => 3_i128\n                        .checked_pow(index)\n                        .and_then(|x| acc.checked_sub(x))\n                        .ok_or(size_err),\n                }\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_str() {\n        assert_eq!(BalancedTernary::from_str(\"+-0++0+\").is_ok(), true);\n        assert_eq!(BalancedTernary::from_str(\"+-O++0+\").is_err(), true);\n        assert_eq!(\n            BalancedTernary::from_str(\n                \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\"\n            )\n            .is_ok(),\n            true\n        );\n    }\n\n    #[test]\n    fn test_from_int() {\n        BalancedTernary::from(0);\n        BalancedTernary::from(-5);\n        BalancedTernary::from(21);\n    }\n\n    #[test]\n    fn test_to_int() {\n        assert_eq!(\n            i128::try_from(BalancedTernary::from_str(\"+-0++0+\").unwrap()),\n            Ok(523)\n        );\n        assert_eq!(\n            i128::try_from(BalancedTernary::from_str(\"-++-0--\").unwrap()),\n            Ok(-436)\n        );\n        assert_eq!(\n            i128::try_from(BalancedTernary::from_str(\"-++-0--\").unwrap()),\n            Ok(-436)\n        );\n        assert_eq!(\n            i128::try_from(BalancedTernary::from_str(\n                \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\"\n            ).unwrap())\n            .is_err(),\n            true\n        );\n    }\n\n    #[test]\n    fn test_to_str() {\n        assert_eq!(\n            BalancedTernary::from_str(\"+-0++0+\").unwrap().to_string(),\n            String::from(\"+-0++0+\")\n        );\n        assert_eq!(\n            BalancedTernary::from_str(\"0\").unwrap().to_string(),\n            String::from(\"0\")\n        );\n    }\n\n    #[test]\n    fn test_add() {\n        let a = BalancedTernary::from(45);\n        let b = BalancedTernary::from(2);\n        let c = BalancedTernary::from(-2);\n        assert_eq!(i128::try_from(a.clone() + b), Ok(47));\n        assert_eq!(i128::try_from(c + a), Ok(43));\n    }\n\n    #[test]\n    fn test_neg() {\n        let a = BalancedTernary::from_str(\"+-0++0+\").unwrap();\n        assert_eq!((-a).to_string(), String::from(\"-+0--0-\"));\n    }\n\n    #[test]\n    fn test_mul() {\n        let a = BalancedTernary::from(45);\n        let b = BalancedTernary::from(20);\n        let c = BalancedTernary::from(-20);\n        assert_eq!(i128::try_from(a.clone() * b), Ok(900));\n        assert_eq!(i128::try_from(c * a), Ok(-900));\n    }\n}\n",
    "path": "tasks/balanced-ternary",
    "remote_code": "use std::{\n    cmp::min,\n    convert::{TryFrom, TryInto},\n    fmt,\n    ops::{Add, Mul, Neg},\n    str::FromStr,\n};\n\nfn main() -> Result<(), &'static str> {\n    let a = BalancedTernary::from_str(\"+-0++0+\")?;\n    let b = BalancedTernary::from(-436);\n    let c = BalancedTernary::from_str(\"+-++-\")?;\n    println!(\"a = {} = {}\", a, i128::try_from(a.clone())?);\n    println!(\"b = {} = {}\", b, i128::try_from(b.clone())?);\n    println!(\"c = {} = {}\", c, i128::try_from(c.clone())?);\n\n    let d = a * (b + -c);\n    println!(\"a * (b - c) = {} = {}\", d, i128::try_from(d.clone())?);\n\n    let e = BalancedTernary::from_str(\n        \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\",\n    )?;\n    assert_eq!(i128::try_from(e).is_err(), true);\n\n    Ok(())\n}\n\n#[derive(Clone, Copy, PartialEq)]\nenum Trit {\n    Zero,\n    Pos,\n    Neg,\n}\n\nimpl TryFrom<char> for Trit {\n    type Error = &'static str;\n\n    fn try_from(value: char) -> Result<Self, Self::Error> {\n        match value {\n            '0' => Ok(Self::Zero),\n            '+' => Ok(Self::Pos),\n            '-' => Ok(Self::Neg),\n            _ => Err(\"Invalid character for balanced ternary\"),\n        }\n    }\n}\n\nimpl From<Trit> for char {\n    fn from(x: Trit) -> Self {\n        match x {\n            Trit::Zero => '0',\n            Trit::Pos => '+',\n            Trit::Neg => '-',\n        }\n    }\n}\n\nimpl Add for Trit {\n    // (Carry, Current)\n    type Output = (Self, Self);\n\n    fn add(self, rhs: Self) -> Self::Output {\n        use Trit::{Neg, Pos, Zero};\n        match (self, rhs) {\n            (Zero, x) | (x, Zero) => (Zero, x),\n            (Pos, Neg) | (Neg, Pos) => (Zero, Zero),\n            (Pos, Pos) => (Pos, Neg),\n            (Neg, Neg) => (Neg, Pos),\n        }\n    }\n}\n\nimpl Mul for Trit {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        use Trit::{Neg, Pos, Zero};\n        match (self, rhs) {\n            (Zero, _) | (_, Zero) => Zero,\n            (Pos, Pos) | (Neg, Neg) => Pos,\n            (Pos, Neg) | (Neg, Pos) => Neg,\n        }\n    }\n}\n\nimpl Neg for Trit {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        match self {\n            Trit::Zero => Trit::Zero,\n            Trit::Pos => Trit::Neg,\n            Trit::Neg => Trit::Pos,\n        }\n    }\n}\n\n// The vector is stored in reverse from how it would be viewed, as\n// operations tend to work backwards\n#[derive(Clone)]\nstruct BalancedTernary(Vec<Trit>);\n\nimpl fmt::Display for BalancedTernary {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.0\n                .iter()\n                .rev()\n                .map(|&d| char::from(d))\n                .collect::<String>()\n        )\n    }\n}\n\nimpl Add for BalancedTernary {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        use Trit::Zero;\n\n        // Trim leading zeroes\n        fn trim(v: &mut Vec<Trit>) {\n            while let Some(last_elem) = v.pop() {\n                if last_elem != Zero {\n                    v.push(last_elem);\n                    break;\n                }\n            }\n        }\n\n        if rhs.0.is_empty() {\n            // A balanced ternary shouldn't be empty\n            if self.0.is_empty() {\n                return BalancedTernary(vec![Zero]);\n            }\n            return self;\n        }\n\n        let length = min(self.0.len(), rhs.0.len());\n        let mut sum = Vec::new();\n        let mut carry = vec![Zero];\n\n        for i in 0..length {\n            let (carry_dig, digit) = self.0[i] + rhs.0[i];\n            sum.push(digit);\n            carry.push(carry_dig);\n        }\n        // At least one of these two loops will be ignored\n        for i in length..self.0.len() {\n            sum.push(self.0[i]);\n        }\n        for i in length..rhs.0.len() {\n            sum.push(rhs.0[i]);\n        }\n\n        trim(&mut sum);\n        trim(&mut carry);\n\n        BalancedTernary(sum) + BalancedTernary(carry)\n    }\n}\n\n// This version of `Mul` requires an implementation of the `Add` trait\nimpl Mul for BalancedTernary {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        let mut results = Vec::with_capacity(rhs.0.len());\n        for i in 0..rhs.0.len() {\n            let mut digits = vec![Trit::Zero; i];\n            for j in 0..self.0.len() {\n                digits.push(self.0[j] * rhs.0[i]);\n            }\n            results.push(BalancedTernary(digits));\n        }\n        #[allow(clippy::suspicious_arithmetic_impl)]\n        results\n            .into_iter()\n            .fold(BalancedTernary(vec![Trit::Zero]), |acc, x| acc + x)\n    }\n}\n\nimpl Neg for BalancedTernary {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        BalancedTernary(self.0.iter().map(|&x| -x).collect())\n    }\n}\n\nimpl FromStr for BalancedTernary {\n    type Err = &'static str;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.chars()\n            .rev()\n            .map(|c| c.try_into())\n            .collect::<Result<_, _>>()\n            .map(BalancedTernary)\n    }\n}\n\nimpl From<i128> for BalancedTernary {\n    fn from(x: i128) -> Self {\n        let mut v = Vec::new();\n        let mut curr = x;\n\n        loop {\n            let rem = curr % 3;\n\n            match rem {\n                0 => v.push(Trit::Zero),\n                1 | -2 => v.push(Trit::Pos),\n                2 | -1 => v.push(Trit::Neg),\n                _ => unreachable!(),\n            }\n\n            let offset = (rem as f64 / 3.0).round() as i128;\n            curr = curr / 3 + offset;\n\n            if curr == 0 {\n                break;\n            }\n        }\n\n        BalancedTernary(v)\n    }\n}\n\nimpl TryFrom<BalancedTernary> for i128 {\n    type Error = &'static str;\n\n    fn try_from(value: BalancedTernary) -> Result<Self, Self::Error> {\n        value\n            .0\n            .iter()\n            .enumerate()\n            .try_fold(0_i128, |acc, (i, character)| {\n                let size_err = \"Balanced ternary string is too large to fit into 16 bytes\";\n                let index: u32 = i.try_into().map_err(|_| size_err)?;\n\n                match character {\n                    Trit::Zero => Ok(acc),\n                    Trit::Pos => 3_i128\n                        .checked_pow(index)\n                        .and_then(|x| acc.checked_add(x))\n                        .ok_or(size_err),\n                    Trit::Neg => 3_i128\n                        .checked_pow(index)\n                        .and_then(|x| acc.checked_sub(x))\n                        .ok_or(size_err),\n                }\n            })\n    }\n}\n",
    "title": "Balanced ternary",
    "url": "http://rosettacode.org/wiki/Balanced_ternary"
  },
  {
    "local_code": "extern crate rand;\nextern crate raster;\n\nuse rand::Rng;\n\nconst MAX_ITER: u32 = 200_000;\nconst HEIGHT: i32 = 640;\nconst WIDTH: i32 = 640;\nconst OUTPUT: &str = \"fractal.png\";\n\nfn transform(x: f64, y: f64) -> (f64, f64) {\n    let cx: f64;\n    let cy: f64;\n\n    match rand::thread_rng().gen::<f32>() {\n        r if r <= 0.01 => {\n            cx = 0.0;\n            cy = 0.16 * y;\n        }\n        r if r <= 0.08 => {\n            cx = 0.2 * x - 0.26 * y;\n            cy = 0.23 * x + 0.22 * y + 1.6;\n        }\n        r if r <= 0.15 => {\n            cx = -0.15 * x + 0.28 * y;\n            cy = 0.26 * x + 0.26 * y + 0.44;\n        }\n        _ => {\n            cx = 0.85 * x + 0.04 * y;\n            cy = -0.04 * x + 0.85 * y + 1.6;\n        }\n    }\n\n    (cx, cy)\n}\n\nfn main() {\n    let mut image = raster::Image::blank(WIDTH, HEIGHT);\n\n    raster::editor::fill(&mut image, raster::Color::white()).unwrap();\n\n    let mut x = 0.0;\n    let mut y = 0.0;\n\n    for _ in 0..MAX_ITER {\n        let (cx, cy) = transform(x, y);\n\n        let target_x = (WIDTH as f64 / 2.0 + cx * (WIDTH as f64) / 11.0).round() as i32;\n        let target_y = (HEIGHT as f64 - cy * (HEIGHT as f64) / 11.0).round() as i32;\n        let color = raster::Color::rgb(50, 205, 50);\n\n        image.set_pixel(target_x, target_y, color).unwrap();\n\n        x = cx;\n        y = cy;\n    }\n\n    raster::save(&image, OUTPUT).unwrap();\n}\n",
    "path": "tasks/barnsley-fern",
    "remote_code": "extern crate rand;\nextern crate raster;\n\nuse rand::Rng;\n\nfn main() {\n    let max_iterations = 200_000u32;\n    let height = 640i32;\n    let width = 640i32;\n\n    let mut rng = rand::thread_rng();\n    let mut image = raster::Image::blank(width, height);\n    raster::editor::fill(&mut image, raster::Color::white()).unwrap();\n\n    let mut x = 0.;\n    let mut y = 0.;\n    for _ in 0..max_iterations {\n        let r = rng.gen::<f32>();\n        let cx: f64;\n        let cy: f64;\n\n        if r <= 0.01 {\n            cx = 0f64;\n            cy = 0.16 * y as f64;\n        } else if r <= 0.08 {\n            cx = 0.2 * x as f64 - 0.26 * y as f64;\n            cy = 0.23 * x as f64 + 0.22 * y as f64 + 1.6;\n        } else if r <= 0.15 {\n            cx = -0.15 * x as f64 + 0.28 * y as f64;\n            cy = 0.26 * x as f64 + 0.26 * y as f64 + 0.44;\n        } else {\n            cx = 0.85 * x as f64 + 0.04 * y as f64;\n            cy = -0.04 * x as f64 + 0.85 * y as f64 + 1.6;\n        }\n        x = cx;\n        y = cy;\n\n        let _ = image.set_pixel(\n            ((width as f64) / 2. + x * (width as f64) / 11.).round() as i32,\n            ((height as f64) - y * (height as f64) / 11.).round() as i32,\n            raster::Color::rgb(50, 205, 50));\n    }\n\n    raster::save(&image, \"fractal.png\").unwrap();\n}",
    "title": "Barnsley fern",
    "url": "http://rosettacode.org/wiki/Barnsley_fern"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::str;\n\nconst INPUT: &str = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\";\nconst UPPERCASE_OFFSET: i8 = -65;\nconst LOWERCASE_OFFSET: i8 = 26 - 97;\nconst NUM_OFFSET: i8 = 52 - 48;\n\nfn main() {\n    println!(\"Input: {}\", INPUT);\n\n    let result = INPUT.chars()\n        .filter(|&ch| ch != '=')                                //Filter '=' chars\n        .map(|ch| {                                             //Map char values using Base64 Characters Table\n            let ascii = ch as i8;                           \n            let convert = match ch {\n                '0' ... '9' => ascii + NUM_OFFSET,\n                'a' ... 'z' => ascii + LOWERCASE_OFFSET,\n                'A' ... 'Z' => ascii + UPPERCASE_OFFSET,\n                '+' => 62,\n                '/' => 63,\n                _ => panic!(\"Not a valid base64 encoded string\")\n            };\n            format!(\"{:#08b}\", convert)[2..].to_string()        //convert indices to binary format and remove the two first digits\n        })\n        .collect::<String>()                                    //concatenate the resulting binary values\n        .chars()\n        .collect::<Vec<char>>()\n        .chunks(8)                                              //split into 8 character chunks\n        .map(|chunk| {\n            let num_str = chunk.iter().collect::<String>();\n            usize::from_str_radix(&num_str, 2).unwrap() as u8   //convert the binary string into its u8 value\n        })\n        .collect::<Vec<_>>();\n\n    let result = str::from_utf8(&result).unwrap();              //convert into UTF-8 string\n\n    println!(\"Output: {}\", result);\n}",
    "title": "Base64 decode data",
    "url": "http://rosettacode.org/wiki/Base64_decode_data"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use num::BigUint;\n\nfn main() {\n    let bt = bell_triangle(51);\n    // the fifteen first\n    for i in 1..=15 {\n        println!(\"{}: {}\", i, bt[i][0]);\n    }\n\n    // the fiftieth\n    println!(\"50: {}\", bt[50][0])\n}\n\nfn bell_triangle(n: usize) -> Vec<Vec<BigUint>> {\n    let mut tri: Vec<Vec<BigUint>> = Vec::with_capacity(n);\n    for i in 0..n {\n        let v = vec![BigUint::from(0u32); i];\n        tri.push(v);\n    }\n    tri[1][0] = BigUint::from(1u32);\n\n    for i in 2..n {\n        tri[i][0] = BigUint::from_bytes_be(&tri[i - 1][i - 2].to_bytes_be());\n        for j in 1..i {\n            let added_big_uint = &tri[i][j - 1] + &tri[i - 1][j - 1];\n            tri[i][j] = BigUint::from_bytes_be(&added_big_uint.to_bytes_be());\n        }\n    }\n\n    tri\n}\n",
    "title": "Bell numbers",
    "url": "http://rosettacode.org/wiki/Bell_numbers"
  },
  {
    "local_code": "//! Contributed by Gavin Baker <gavinb@antonym.org>\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\n/// Calculate the expected frequency of a digit according to Benford's Law\nfn benford_freq(d: u64) -> f32 {\n    assert!((1..=9).contains(&d));\n\n    (1.0 + 1.0 / (d as f32)).log10()\n}\n\n/// Returns the leading digit of any number\nfn first_digit_of(n: u64) -> usize {\n    let mut d = n;\n    while d > 9 {\n        d /= 10;\n    }\n    d as usize\n}\n\n/// Count frequency table using the first digit of each number in a vector\nfn benford_distrib(numbers: &[u64]) -> Vec<f32> {\n    // Counts\n\n    let mut counts = [0u64; 10];\n\n    for num in numbers {\n        let first = first_digit_of(*num);\n        counts[first] += 1;\n    }\n\n    // Frequencies\n\n    let mut freq = vec![0f32; 10];\n\n    for digit in 1..10 {\n        freq[digit] = counts[digit] as f32 / numbers.len() as f32;\n    }\n\n    freq\n}\n\nfn main() {\n    // Calculate expected frequencies of all digits according to Benford's Law\n    let mut expected_distrib = [0f32; 10];\n    for digit in &mut expected_distrib {\n        *digit = benford_freq(*digit as u64);\n    }\n\n    // Load data from the Fibonacci sequence\n    let file = BufReader::new(File::open(\"resources/fib1000.txt\").unwrap());\n\n    let fibs: Vec<u64> = file\n        .lines()\n        .map(|x| {\n            let s = x.unwrap();\n            s[0..1].parse::<u64>().unwrap()\n        })\n        .collect();\n\n    // Calculate freuencies of first digits in test data\n    let found_distrib = benford_distrib(&fibs[..]);\n\n    // Print the stats to compare actual vs expected\n    println!(\"\\nBenford's Law - Digit Distribution\");\n    println!(\"\\nFirst 1000 Numbers in the Fibonacci Sequence\\n\");\n    println!(\"digit    expect     found     delta\");\n    for digit in 1..10 {\n        let expected_pc = expected_distrib[digit] * 100.0;\n        let found_pc = found_distrib[digit] * 100.0;\n        let delta_pc = expected_pc - found_pc;\n\n        println!(\n            \"{}        {:>4.1}%      {:>4.1}%    {:>5.2}%\",\n            digit, expected_pc, found_pc, delta_pc\n        );\n    }\n}\n",
    "path": "tasks/benfords-law",
    "remote_code": "\nextern crate num_traits;\nextern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num_traits::{Zero, One};\nuse std::collections::HashMap;\n\n// Return a vector of all fibonacci results from fib(1) to fib(n)\nfn fib(n: usize) -> Vec<BigInt> {\n    let mut result = Vec::with_capacity(n);\n    let mut a = BigInt::zero();\n    let mut b = BigInt::one();\n\n    result.push(b.clone());\n\n    for i in 1..n {\n        let t = b.clone();\n        b = a+b;\n        a = t;\n        result.push(b.clone());\n    }\n\n    result\n}\n\n// Return the first digit of a `BigInt`\nfn first_digit(x: &BigInt) -> u8 {\n    let zero = BigInt::zero();\n    assert!(x > &zero);\n\n    let s = x.to_str_radix(10);\n\n    // parse the first digit of the stringified integer\n    *&s[..1].parse::<u8>().unwrap()\n}\n\nfn main() {\n    const N: usize = 1000;\n    let mut counter: HashMap<u8, u32> = HashMap::new();\n    for x in fib(N) {\n        let d = first_digit(&x);\n        *counter.entry(d).or_insert(0) += 1;\n    }\n\n    println!(\"{:>13}    {:>10}\", \"real\", \"predicted\");\n    for y in 1..10 {\n        println!(\"{}: {:10.3} v. {:10.3}\", y, *counter.get(&y).unwrap_or(&0) as f32 / N as f32,\n        (1.0 + 1.0 / (y as f32)).log10());\n    }\n\n}\n",
    "title": "Benford's law",
    "url": "http://rosettacode.org/wiki/Benford's_law"
  },
  {
    "local_code": "use std::cmp::max;\nuse std::env;\nuse std::process;\n\nuse bernoulli_numbers::Context;\n\nfn help() {\n    println!(\"Usage: bernoulli_numbers <up_to>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut up_to: usize = 60;\n\n    match args.len() {\n        1 => {}\n        2 => {\n            up_to = args[1].parse::<usize>().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let context = Context::new();\n    // Collect the solutions by using the Context iterator\n    // (this is not as fast as calling the optimized function directly).\n    let res = context.take(up_to + 1).collect::<Vec<_>>();\n    let width = res\n        .iter()\n        .fold(0, |a, r| max(a, r.value.numer().to_string().len()));\n\n    for r in res.iter().filter(|r| r.index % 2 == 0) {\n        println!(\n            \"B({:>2}) = {:>2$} / {denom}\",\n            r.index,\n            r.value.numer(),\n            width,\n            denom = r.value.denom()\n        );\n    }\n}\nuse bernoulli_numbers::{bernoulli, bernoulli_naive, Context};\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn benchmark(c: &mut Criterion) {\n    c.bench_function(\"naive\", |b| {\n        b.iter(|| {\n            let mut context = Context::new();\n\n            for n in 0..=30 {\n                bernoulli_naive(black_box(n), &mut context);\n            }\n        })\n    });\n\n    c.bench_function(\"naive\", |b| {\n        b.iter(|| {\n            let mut context = Context::new();\n\n            for n in 0..=30 {\n                bernoulli(black_box(n), &mut context);\n            }\n        })\n    });\n}\n\ncriterion_group!(benches, benchmark);\ncriterion_main!(benches);\n//! 2.5 implementations here:  naive, optimized, and an iterator using\n//! the optimized function. The speeds vary significantly: relative\n//! speeds of optimized:iterator:naive implementations is 625:25:1.\n\nextern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num::rational::BigRational;\nuse std::ops::{Mul, Sub};\n\npub struct Bn {\n    pub value: BigRational,\n    pub index: i32,\n}\n\npub struct Context {\n    bigone_const: BigInt,\n    a: Vec<BigRational>,\n    index: i32, // Counter for iterator implementation\n}\n\nimpl Context {\n    pub fn new() -> Context {\n        let bigone = 1.to_bigint().unwrap();\n        let a_vec: Vec<BigRational> = vec![];\n        Context {\n            bigone_const: bigone,\n            a: a_vec,\n            index: -1,\n        }\n    }\n}\n\nimpl Default for Context {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Iterator for Context {\n    type Item = Bn;\n\n    fn next(&mut self) -> Option<Bn> {\n        self.index += 1;\n        Some(Bn {\n            value: bernoulli(self.index as usize, self),\n            index: self.index,\n        })\n    }\n}\n\n// Implementation with no reused calculations.\npub fn bernoulli_naive(n: usize, c: &mut Context) -> BigRational {\n    for m in 0..n + 1 {\n        c.a.push(BigRational::new(\n            c.bigone_const.clone(),\n            (m + 1).to_bigint().unwrap(),\n        ));\n        for j in (1..m + 1).rev() {\n            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(BigRational::new(\n                j.to_bigint().unwrap(),\n                c.bigone_const.clone(),\n            ));\n        }\n    }\n    c.a[0].reduced()\n}\n\n// Implementation with reused calculations (does not require sequential calls).\npub fn bernoulli(n: usize, c: &mut Context) -> BigRational {\n    for i in 0..n + 1 {\n        if i >= c.a.len() {\n            c.a.push(BigRational::new(\n                c.bigone_const.clone(),\n                (i + 1).to_bigint().unwrap(),\n            ));\n            for j in (1..i + 1).rev() {\n                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(BigRational::new(\n                    j.to_bigint().unwrap(),\n                    c.bigone_const.clone(),\n                ));\n            }\n        }\n    }\n    c.a[0].reduced()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{bernoulli, bernoulli_naive, Context};\n    use num::rational::BigRational;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_bernoulli_naive() {\n        let mut context = Context::new();\n        assert_eq!(\n            bernoulli_naive(60, &mut context),\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n\n    #[test]\n    fn test_bernoulli() {\n        let mut context = Context::new();\n        assert_eq!(\n            bernoulli(60, &mut context),\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n\n    #[test]\n    fn test_bernoulli_iter() {\n        let context = Context::new();\n        let res = context.take(60 + 1).collect::<Vec<_>>();\n        assert_eq!(\n            res.last().unwrap().value,\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n}\n",
    "path": "tasks/bernoulli-numbers",
    "remote_code": "// 2.5 implementations presented here:  naive, optimized, and an iterator using\n// the optimized function. The speeds vary significantly: relative\n// speeds of optimized:iterator:naive implementations is 625:25:1.\n\n#![feature(test)]\n\nextern crate num;\nextern crate test;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num::rational::{BigRational};\nuse std::cmp::max;\nuse std::env;\nuse std::ops::{Mul, Sub};\nuse std::process;\n\nstruct Bn {\n    value: BigRational,\n    index: i32\n}\n\nstruct Context {\n    bigone_const: BigInt,\n    a: Vec<BigRational>,\n    index: i32              // Counter for iterator implementation\n}\n\nimpl Context {\n    pub fn new() -> Context {\n        let bigone = 1.to_bigint().unwrap();\n        let a_vec: Vec<BigRational> = vec![];\n        Context {\n            bigone_const: bigone,\n            a: a_vec,\n            index: -1\n        }\n    }\n}\n\nimpl Iterator for Context {\n    type Item = Bn;\n\n    fn next(&mut self) -> Option<Bn> {\n        self.index += 1;\n        Some(Bn { value: bernoulli(self.index as usize, self), index: self.index })\n    }\n}\n\nfn help() {\n    println!(\"Usage: bernoulli_numbers <up_to>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut up_to: usize = 60;\n\n    match args.len() {\n        1 => {},\n        2 => {\n            up_to = args[1].parse::<usize>().unwrap();\n        },\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let context = Context::new();\n    // Collect the solutions by using the Context iterator\n    // (this is not as fast as calling the optimized function directly).\n    let res = context.take(up_to + 1).collect::<Vec<_>>();\n    let width = res.iter().fold(0, |a, r| max(a, r.value.numer().to_string().len()));\n\n    for r in res.iter().filter(|r| *r.value.numer() != ToBigInt::to_bigint(&0).unwrap()) {\n        println!(\"B({:>2}) = {:>2$} / {denom}\", r.index, r.value.numer(), width,\n            denom = r.value.denom());\n    }\n}\n\n// Implementation with no reused calculations.\nfn _bernoulli_naive(n: usize, c: &mut Context) -> BigRational {\n    for m in 0..n + 1 {\n        c.a.push(BigRational::new(c.bigone_const.clone(), (m + 1).to_bigint().unwrap()));\n        for j in (1..m + 1).rev() {\n            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n            );\n        }\n    }\n    c.a[0].reduced()\n}\n\n// Implementation with reused calculations (does not require sequential calls).\nfn bernoulli(n: usize, c: &mut Context) -> BigRational {\n    for i in 0..n + 1 {\n        if i >= c.a.len() {\n            c.a.push(BigRational::new(c.bigone_const.clone(), (i + 1).to_bigint().unwrap()));\n            for j in (1..i + 1).rev() {\n                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                    BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n                );\n            }\n        }\n    }\n    c.a[0].reduced()\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::{Bn, Context, bernoulli, _bernoulli_naive};\n    use num::rational::{BigRational};\n    use std::str::FromStr;\n    use test::Bencher;\n\n    // [tests elided]\n\n    #[bench]\n    fn bench_bernoulli_naive(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = _bernoulli_naive(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = bernoulli(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli_iter(b: &mut Bencher) {\n        b.iter(|| {\n            let context = Context::new();\n            let _res = context.take(30 + 1).collect::<Vec<_>>();\n        });\n    }\n}\n",
    "title": "Bernoulli numbers",
    "url": "http://rosettacode.org/wiki/Bernoulli_numbers"
  },
  {
    "local_code": "extern crate permutohedron;\nextern crate rand;\n\nuse std::cmp::{min, Ordering};\nuse std::env;\nuse std::str;\n\nuse rand::prelude::*;\n\nconst WORDS: &[&str] = &[\"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\"];\n\n#[derive(Eq)]\nstruct Solution {\n    original: String,\n    shuffled: String,\n    score: usize,\n}\n\n// Ordering trait implementations are only needed for the permutations method\nimpl PartialOrd for Solution {\n    fn partial_cmp(&self, other: &Solution) -> Option<Ordering> {\n        self.score.partial_cmp(&other.score)\n    }\n}\n\nimpl PartialEq for Solution {\n    fn eq(&self, other: &Solution) -> bool {\n        self.score == other.score\n    }\n}\n\nimpl Ord for Solution {\n    fn cmp(&self, other: &Solution) -> Ordering {\n        self.score.cmp(&other.score)\n    }\n}\n\nfn _help() {\n    println!(\"Usage: best_shuffle <word1> <word2> ...\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let words = match args.len() {\n        1 => WORDS.iter().map(|s| s.to_string()).collect(),\n        _ => args[1..].to_vec(),\n    };\n\n    let solutions = words.iter().map(|w| best_shuffle(w));\n\n    for s in solutions {\n        println!(\"{}, {}, ({})\", s.original, s.shuffled, s.score);\n    }\n}\n\n// Implementation iterating over all permutations\nfn _best_shuffle_perm(w: &str) -> Solution {\n    let w = String::from(w);\n\n    let mut soln = Solution {\n        original: w.clone(),\n        shuffled: w.clone(),\n        score: w.len(),\n    };\n    let w_bytes: Vec<u8> = w.clone().into_bytes();\n    let mut permutocopy = w_bytes.clone();\n    let mut permutations = permutohedron::Heap::new(&mut permutocopy);\n    while let Some(p) = permutations.next_permutation() {\n        let hamm = hamming(&w_bytes, p);\n        soln = min(\n            soln,\n            Solution {\n                original: w.clone(),\n                shuffled: String::from(str::from_utf8(p).unwrap()),\n                score: hamm,\n            },\n        );\n        // Accept the solution if score 0 found\n        if hamm == 0 {\n            break;\n        }\n    }\n    soln\n}\n\n// Quadratic implementation\n#[allow(clippy::suspicious_operation_groupings)]\nfn best_shuffle(w: &str) -> Solution {\n    let w = String::from(w);\n\n    let w_bytes = w.clone().into_bytes();\n    let mut shuffled_bytes = w.clone().into_bytes();\n    shuffled_bytes.shuffle(&mut thread_rng());\n\n    // Swap wherever it doesn't decrease the score\n    for i in 0..shuffled_bytes.len() {\n        for j in 0..shuffled_bytes.len() {\n            if (i == j)\n                | (shuffled_bytes[i] == w_bytes[j])\n                | (shuffled_bytes[j] == w_bytes[i])\n                | (shuffled_bytes[i] == shuffled_bytes[j])\n            {\n                continue;\n            }\n            shuffled_bytes.swap(i, j);\n            break;\n        }\n    }\n\n    let res = String::from(str::from_utf8(&shuffled_bytes).unwrap());\n    let res_bytes: Vec<u8> = res.clone().into_bytes();\n    Solution {\n        original: w,\n        shuffled: res,\n        score: hamming(&w_bytes, &res_bytes),\n    }\n}\n\nfn hamming(w0: &[u8], w1: &[u8]) -> usize {\n    w0.iter().zip(w1.iter()).filter(|&(a, b)| a == b).count()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{_best_shuffle_perm, best_shuffle};\n\n    #[test]\n    fn test_best_shuffle_perm() {\n        let mut s0 = _best_shuffle_perm(\"seesaw\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"elk\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"grrrrrr\");\n        assert_eq!(s0.score, 5);\n\n        s0 = _best_shuffle_perm(\"up\");\n        assert_eq!(s0.shuffled, \"pu\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"a\");\n        assert_eq!(s0.shuffled, \"a\");\n        assert_eq!(s0.score, 1);\n    }\n\n    #[test]\n    fn test_best_shuffle() {\n        let mut s0 = best_shuffle(\"abracadabra\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"seesaw\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"elk\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"grrrrrr\");\n        assert_eq!(s0.score, 5);\n\n        s0 = best_shuffle(\"up\");\n        assert_eq!(s0.shuffled, \"pu\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"a\");\n        assert_eq!(s0.shuffled, \"a\");\n        assert_eq!(s0.score, 1);\n    }\n}\n",
    "path": "tasks/best-shuffle",
    "remote_code": "extern crate permutohedron;\nextern crate rand;\n\nuse std::cmp::{min, Ordering};\nuse std::env;\nuse rand::{thread_rng, Rng};\nuse std::str;\n\nconst WORDS: &'static [&'static str] = &[\"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\"];\n\n#[derive(Eq)]\nstruct Solution {\n    original: String,\n    shuffled: String,\n    score: usize,\n}\n\n// Ordering trait implementations are only needed for the permutations method\nimpl PartialOrd for Solution {\n    fn partial_cmp(&self, other: &Solution) -> Option<Ordering> {\n        match (self.score, other.score) {\n            (s, o) if s < o => Some(Ordering::Less),\n            (s, o) if s > o => Some(Ordering::Greater),\n            (s, o) if s == o => Some(Ordering::Equal),\n            _ => None,\n        }\n    }\n}\n\n\nimpl PartialEq for Solution {\n    fn eq(&self, other: &Solution) -> bool {\n        match (self.score, other.score) {\n            (s, o) if s == o => true,\n            _ => false,\n        }\n    }\n}\n\nimpl Ord for Solution {\n    fn cmp(&self, other: &Solution) -> Ordering {\n        match (self.score, other.score) {\n            (s, o) if s < o => Ordering::Less,\n            (s, o) if s > o => Ordering::Greater,\n            _ => Ordering::Equal,\n        }\n    }\n}\n\nfn _help() {\n    println!(\"Usage: best_shuffle <word1> <word2> ...\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut words: Vec<String> = vec![];\n\n    match args.len() {\n        1 => {\n            for w in WORDS.iter() {\n                words.push(String::from(*w));\n            }\n        }\n        _ => {\n            for w in args.split_at(1).1 {\n                words.push(w.clone());\n            }\n        }\n    }\n\n    let solutions = words.iter().map(|w| best_shuffle(w)).collect::<Vec<_>>();\n\n    for s in solutions {\n        println!(\"{}, {}, ({})\", s.original, s.shuffled, s.score);\n    }\n}\n\n// Implementation iterating over all permutations\nfn _best_shuffle_perm(w: &String) -> Solution {\n    let mut soln = Solution {\n        original: w.clone(),\n        shuffled: w.clone(),\n        score: w.len(),\n    };\n    let w_bytes: Vec<u8> = w.clone().into_bytes();\n    let mut permutocopy = w_bytes.clone();\n    let mut permutations = permutohedron::Heap::new(&mut permutocopy);\n    while let Some(p) = permutations.next_permutation() {\n        let hamm = hamming(&w_bytes, p);\n        soln = min(soln,\n                   Solution {\n                       original: w.clone(),\n                       shuffled: String::from(str::from_utf8(p).unwrap()),\n                       score: hamm,\n                   });\n        // Accept the solution if score 0 found\n        if hamm == 0 {\n            break;\n        }\n    }\n    soln\n}\n\n// Quadratic implementation\nfn best_shuffle(w: &String) -> Solution {\n    let w_bytes: Vec<u8> = w.clone().into_bytes();\n    let mut shuffled_bytes: Vec<u8> = w.clone().into_bytes();\n\n    // Shuffle once\n    let sh: &mut [u8] = shuffled_bytes.as_mut_slice();\n    thread_rng().shuffle(sh);\n\n    // Swap wherever it doesn't decrease the score\n    for i in 0..sh.len() {\n        for j in 0..sh.len() {\n            if (i == j) | (sh[i] == w_bytes[j]) | (sh[j] == w_bytes[i]) | (sh[i] == sh[j]) {\n                continue;\n            }\n            sh.swap(i, j);\n            break;\n        }\n    }\n\n    let res = String::from(str::from_utf8(sh).unwrap());\n    let res_bytes: Vec<u8> = res.clone().into_bytes();\n    Solution {\n        original: w.clone(),\n        shuffled: res,\n        score: hamming(&w_bytes, &res_bytes),\n    }\n}\n\nfn hamming(w0: &Vec<u8>, w1: &Vec<u8>) -> usize {\n    w0.iter().zip(w1.iter()).filter(|z| z.0 == z.1).count()\n}\n",
    "title": "Best shuffle",
    "url": "http://rosettacode.org/wiki/Best_shuffle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn make_bins(limits: &Vec<usize>, data: &Vec<usize>) -> Vec<Vec<usize>> {\n    let mut bins: Vec<Vec<usize>> = Vec::with_capacity(limits.len() + 1);\n    for _ in 0..=limits.len() {bins.push(Vec::new());}\n\n    limits.iter().enumerate().for_each(|(idx, limit)| {\n        data.iter().for_each(|elem| {\n                 if idx == 0 && elem < limit              { bins[0].push(*elem); }             // smaller than the smallest limit\n            else if idx == limits.len()-1 && elem >= limit { bins[limits.len()].push(*elem); } // larger than the largest limit\n            else if elem < limit && elem >= &limits[idx-1] { bins[idx].push(*elem); }          // otherwise\n        });\n    });\n\n    bins\n}\n\nfn print_bins(limits: &Vec<usize>, bins: &Vec<Vec<usize>>) {\n    for (idx, bin) in bins.iter().enumerate() {\n        if idx == 0 {\n            println!(\"          < {:3} := {:3}\", limits[idx], bin.len());\n        } else if idx == limits.len() {\n            println!(\">= {:3}          := {:3}\",  limits[idx-1], bin.len());\n        }else {\n            println!(\">= {:3} .. < {:3} := {:3}\", limits[idx-1], limits[idx], bin.len());\n        }\n    };\n}\n\nfn main() {\n    let limits1  = vec![23, 37, 43, 53, 67, 83];\n    let data1 = vec![95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                     16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55];\n\n   let limits2 = vec![14, 18, 249, 312, 389, 392, 513, 591, 634, 720];\n   let data2 = vec![\n       445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n       416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n       655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n       346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n       345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n       854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n       787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n       698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n       605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n       466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749\n           ];\n\n\n    // Why are we calling it RC anyways???\n    println!(\"RC FIRST EXAMPLE\");\n    let bins1 = make_bins(&limits1, &data1);\n    print_bins(&limits1, &bins1);\n\n    println!(\"\\nRC SECOND EXAMPLE\");\n    let bins2 = make_bins(&limits2, &data2);\n    print_bins(&limits2, &bins2);\n}\n",
    "title": "Bin given limits",
    "url": "http://rosettacode.org/wiki/Bin_given_limits"
  },
  {
    "local_code": "trait BinaryString {\n    fn to_binary_string(&self) -> String;\n}\n\nimpl BinaryString for usize {\n    fn to_binary_string(&self) -> String {\n        format!(\"{:b}\", *self)\n    }\n}\n\nfn main() {\n    for s in 0..17 {\n        println!(\"{}\", s.to_binary_string());\n    }\n}\n\n#[test]\nfn test_digits() {\n    let expected = [\n        \"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\",\n        \"1101\", \"1110\", \"1111\",\n    ];\n\n    for (n, expected) in (0..17).zip(expected.iter()) {\n        assert_eq!(n.to_binary_string(), *expected);\n    }\n}\n",
    "path": "tasks/binary-digits",
    "remote_code": "fn main() {\n    for i in 0..8 {\n        println!(\"{:b}\", i)\n    }\n}",
    "title": "Binary digits",
    "url": "http://rosettacode.org/wiki/Binary_digits"
  },
  {
    "local_code": "use std::cmp::Ordering;\n\nfn main() {\n    println!(\"{:?}\", binary_search(&[1, 2, 3, 4, 5, 6], &4));\n    println!(\"{:?}\", binary_search_rec(&[1, 2, 3, 4, 5, 6], &4));\n}\n\n/// iterative version\nfn binary_search<T: Ord>(haystack: &[T], needle: &T) -> Option<usize> {\n    let mut low = 0;\n    let mut high = haystack.len() - 1;\n\n    if high == 0 {\n        return None;\n    }\n\n    while low <= high {\n        // avoid overflow\n        let mid = (low + high) >> 1;\n\n        match haystack[mid].cmp(needle) {\n            Ordering::Greater => high = mid - 1,\n            Ordering::Less => low = mid + 1,\n            Ordering::Equal => return Some(mid),\n        }\n    }\n    None\n}\n\n/// recursive version\nfn binary_search_rec<T: Ord>(haystack: &[T], needle: &T) -> Option<usize> {\n    fn recurse<T: Ord>(low: usize, high: usize, haystack: &[T], needle: &T) -> Option<usize> {\n        match (low + high) / 2 {\n            _ if high < low => None,\n            mid if haystack[mid] > *needle => recurse(low, mid - 1, haystack, needle),\n            mid if haystack[mid] < *needle => recurse(mid + 1, high, haystack, needle),\n            mid => Some(mid),\n        }\n    }\n    recurse::<T>(0, haystack.len() - 1, haystack, needle)\n}\n\n#[test]\nfn test_result() {\n    let haystack = &[1, 2, 3, 4, 5, 6];\n    let needle = 4;\n\n    assert_eq!(binary_search(haystack, &needle), Some(3));\n    assert_eq!(binary_search_rec(haystack, &needle), Some(3));\n}\n",
    "path": "tasks/binary-search",
    "remote_code": "fn binary_search<T:PartialOrd>(v: &[T], searchvalue: T) -> Option<T> {\n    let mut lower = 0 as usize;\n    let mut upper = v.len() - 1;\n\n    while upper >= lower {\n        let mid = (upper + lower) / 2;\n        if v[mid] == searchvalue {\n            return Some(searchvalue);\n        } else if searchvalue < v[mid] {\n            upper = mid - 1;\n        } else {\n            lower = mid + 1;\n        }\n    }\n\n    None\n}",
    "title": "Binary search",
    "url": "http://rosettacode.org/wiki/Binary_search"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::str;\n\nfn main() {\n    // Create new string\n    let string = String::from(\"Hello world!\");\n    println!(\"{}\", string);\n    assert_eq!(string, \"Hello world!\", \"Incorrect string text\");\n\n    // Create and assign value to string\n    let mut assigned_str = String::new();\n    assert_eq!(assigned_str, \"\", \"Incorrect string creation\");\n    assigned_str += \"Text has been assigned!\";\n    println!(\"{}\", assigned_str);\n    assert_eq!(assigned_str, \"Text has been assigned!\",\"Incorrect string text\");\n\n    // String comparison, compared lexicographically byte-wise same as the asserts above\n    if string == \"Hello world!\" && assigned_str == \"Text has been assigned!\" {\n        println!(\"Strings are equal\");\n    }\n\n    // Cloning -> string can still be used after cloning\n    let clone_str = string.clone();\n    println!(\"String is:{}  and  Clone string is: {}\", string, clone_str);\n    assert_eq!(clone_str, string, \"Incorrect string creation\");\n\n    // Copying, string won't be usable anymore, accessing it will cause compiler failure\n    let copy_str = string;\n    println!(\"String copied now: {}\", copy_str);\n\n    // Check if string is empty\n    let empty_str = String::new();\n    assert!(empty_str.is_empty(), \"Error, string should be empty\");\n\n    // Append byte, Rust strings are a stream of UTF-8 bytes\n    let byte_vec = [65]; // contains A\n    let byte_str = str::from_utf8(&byte_vec).unwrap();\n    assert_eq!(byte_str, \"A\", \"Incorrect byte append\");\n\n    // Substrings can be accessed through slices\n    let test_str = \"Blah String\";\n    let mut sub_str = &test_str[0..11];\n    assert_eq!(sub_str, \"Blah String\", \"Error in slicing\");\n    sub_str = &test_str[1..5];\n    assert_eq!(sub_str, \"lah \", \"Error in slicing\");\n    sub_str = &test_str[3..];\n    assert_eq!(sub_str, \"h String\", \"Error in slicing\");\n    sub_str = &test_str[..2];\n    assert_eq!(sub_str, \"Bl\", \"Error in slicing\");\n\n    // String replace, note string is immutable\n    let org_str = \"Hello\";\n    assert_eq!(org_str.replace(\"l\", \"a\"), \"Heaao\", \"Error in replacement\");\n    assert_eq!(org_str.replace(\"ll\", \"r\"), \"Hero\", \"Error in replacement\");\n\n    // Joining strings requires a `String` and an &str or a two `String`s one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Joining strings requires a `String` and an &str or two `Strings`s, one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Splits -- note Rust supports passing patterns to splits\n    let f_str = \"Pooja and Sundar are up in Tumkur\";\n    let split_str: Vec<_> = f_str.split(' ').collect();\n    assert_eq!(split_str, [\"Pooja\", \"and\", \"Sundar\", \"are\", \"up\", \"in\", \"Tumkur\"], \"Error in string split\");\n}",
    "title": "Binary strings",
    "url": "http://rosettacode.org/wiki/Binary_strings"
  },
  {
    "local_code": "mod seq;\n\npub use seq::*;\nuse std::collections::HashMap;\nuse std::fmt::{Display, Error, Formatter};\n\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\npub struct Seq<'a> {\n    alphabet: Vec<&'a str>,\n    seq: Vec<&'a str>,\n    base_distr: Uniform<usize>,\n    pos_distr: Uniform<usize>,\n}\n\nimpl Seq<'_> {\n    pub fn new(alphabet: Vec<&str>, len: usize) -> Seq {\n        let base_distr = Uniform::new_inclusive(0, alphabet.len() - 1);\n        let pos_distr = Uniform::new_inclusive(0, len - 1);\n\n        let seq = (0..len)\n            .map(|_| alphabet[thread_rng().sample(base_distr)])\n            .collect();\n\n        Seq {\n            alphabet,\n            base_distr,\n            pos_distr,\n            seq,\n        }\n    }\n\n    pub fn insert(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n        let base = self.alphabet[thread_rng().sample(self.base_distr)];\n\n        println!(\"Inserting {} at position {}\", base, pos);\n\n        self.seq.insert(pos, base);\n    }\n\n    pub fn delete(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n\n        println!(\"Deleting {} at position {}\", self.seq[pos], pos);\n\n        self.seq.remove(pos);\n    }\n\n    pub fn swap(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n        let cur_base = self.seq[pos];\n        let new_base = self.alphabet[thread_rng().sample(self.base_distr)];\n\n        println!(\n            \"Replacing {} at position {} with {}\",\n            cur_base, pos, new_base\n        );\n\n        self.seq[pos] = new_base;\n    }\n}\n\nimpl Display for Seq<'_> {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        let pretty: String = self\n            .seq\n            .chunks(60)\n            .map(|bases| format!(\"{}\\n\", bases.join(\"\")))\n            .collect();\n\n        let counts_hm = self\n            .seq\n            .iter()\n            .fold(HashMap::<&str, usize>::new(), |mut m, base| {\n                *m.entry(base).or_insert(0) += 1;\n                m\n            });\n\n        let mut counts_vec: Vec<(&str, usize)> = counts_hm.into_iter().collect();\n\n        counts_vec.sort_by(|a, b| a.0.cmp(b.0));\n\n        let counts_string =\n            counts_vec\n                .iter()\n                .fold(String::new(), |mut counts_string, (base, count)| {\n                    counts_string += &format!(\"{} = {}\\n\", base, count);\n                    counts_string\n                });\n\n        write!(\n            f,\n            \"Seq:\\n{}\\n\\nLength: {}\\n\\nCounts:\\n{}\",\n            pretty,\n            self.seq.len(),\n            counts_string\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn base_consists_of_alphabet_only() {\n        let alphabet = vec![\"A\", \"B\"];\n        let seq = Seq::new(alphabet.clone(), 5);\n\n        let consists_of_alphabet_only = seq.seq.iter().all(|s| alphabet.contains(s));\n\n        assert!(consists_of_alphabet_only);\n    }\n\n    #[test]\n    fn length_is_equal_to_given_value() {\n        let seq_1 = Seq::new(vec![\"A\", \"B\", \"C\"], 15);\n        let seq_2 = Seq::new(vec![\"X\", \"Y\", \"Z\"], 1);\n        let seq_3 = Seq::new(vec![\"X\"], 10);\n\n        assert_eq!(seq_1.seq.len(), 15);\n        assert_eq!(seq_2.seq.len(), 1);\n        assert_eq!(seq_3.seq.len(), 10);\n    }\n\n    #[test]\n    fn insertion_increases_length() {\n        let mut seq = Seq::new(vec![\"A\", \"B\", \"C\"], 15);\n        let prev_length = seq.seq.len();\n\n        seq.insert();\n\n        assert_eq!(seq.seq.len(), prev_length + 1);\n    }\n\n    #[test]\n    fn deletion_decreases_length() {\n        let mut seq = Seq::new(vec![\"A\", \"B\", \"C\"], 20);\n        let prev_length = seq.seq.len();\n\n        seq.delete();\n\n        assert_eq!(seq.seq.len(), prev_length - 1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn cannot_make_deletion_on_empty_sequence() {\n        let mut seq = Seq::new(vec![\"X\", \"Y\", \"Z\"], 1);\n\n        seq.delete();\n        seq.delete();\n\n        assert_eq!(seq.seq.len(), 0);\n    }\n\n    #[test]\n    fn swapping_does_not_change_length() {\n        let mut seq = Seq::new(vec![\"X\", \"Y\", \"Z\"], 1);\n        let prev_length = seq.seq.len();\n\n        seq.swap();\n\n        assert_eq!(seq.seq.len(), prev_length);\n    }\n}\nuse rand::{distributions::Uniform, thread_rng, Rng};\n\nuse sequence_mutation::Seq;\n\nfn main() {\n    let mut seq = Seq::new(vec![\"A\", \"C\", \"T\", \"G\"], 200);\n\n    println!(\"Initial sequnce:\\n{}\", seq);\n\n    let mut_distr = Uniform::new_inclusive(0, 2);\n\n    for _ in 0..10 {\n        let mutation = thread_rng().sample(mut_distr);\n\n        match mutation {\n            0 => seq.insert(),\n            1 => seq.delete(),\n            _ => seq.swap(),\n        }\n    }\n\n    println!(\"\\nMutated sequence:\\n{}\", seq);\n}\n",
    "path": "tasks/bioinformatics/sequence-mutation",
    "remote_code": "\nuse rand::prelude::*;\nuse std::collections::HashMap;\nuse std::fmt::{Display, Formatter, Error};\n\npub struct Seq<'a> {\n    alphabet: Vec<&'a str>,\n    distr: rand::distributions::Uniform<usize>,\n    pos_distr: rand::distributions::Uniform<usize>,\n    seq: Vec<&'a str>,\n}\n\nimpl Display for Seq<'_> {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n\n        let pretty: String = self.seq\n            .iter()\n            .enumerate()\n            .map(|(i, nt)| if (i + 1) % 60 == 0 { format!(\"{}\\n\", nt) } else { nt.to_string() })\n            .collect();\n        \n        let counts_hm = self.seq\n            .iter()\n            .fold(HashMap::<&str, usize>::new(), |mut m, nt| {\n                *m.entry(nt).or_default() += 1;\n                m\n            });\n\n        let mut counts_vec: Vec<(&str, usize)> = counts_hm.into_iter().collect();\n        counts_vec.sort_by(|a, b| a.0.cmp(&b.0));\n        let counts_string = counts_vec\n            .iter()\n            .fold(String::new(), |mut counts_string, (nt, count)| {\n                counts_string += &format!(\"{} = {}\\n\", nt, count);\n                counts_string\n            });\n\n        write!(f, \"Seq:\\n{}\\n\\nLength: {}\\n\\nCounts:\\n{}\", pretty, self.seq.len(), counts_string)\n    }\n}\n\nimpl Seq<'_> {\n    pub fn new(alphabet: Vec<&str>, len: usize) -> Seq {\n        let distr = rand::distributions::Uniform::new_inclusive(0, alphabet.len() - 1);\n        let pos_distr = rand::distributions::Uniform::new_inclusive(0, len - 1);\n\n        let seq: Vec<&str> = (0..len)\n            .map(|_| {\n                alphabet[thread_rng().sample(distr)]\n            })\n            .collect();\n        Seq { alphabet, distr, pos_distr, seq }\n    }\n\n    pub fn insert(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n        let nt = self.alphabet[thread_rng().sample(self.distr)];\n        println!(\"Inserting {} at position {}\", nt, pos);\n        self.seq.insert(pos, nt);\n    }\n\n    pub fn delete(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n        println!(\"Deleting {} at position {}\", self.seq[pos], pos);\n        self.seq.remove(pos);\n    }\n\n    pub fn swap(&mut self) {\n        let pos = thread_rng().sample(self.pos_distr);\n        let cur_nt = self.seq[pos];\n        let new_nt = self.alphabet[thread_rng().sample(self.distr)];\n        println!(\"Replacing {} at position {} with {}\", cur_nt, pos, new_nt);\n        self.seq[pos] = new_nt;\n    }\n}\n\nfn main() {\n\n    let mut seq = Seq::new(vec![\"A\", \"C\", \"T\", \"G\"], 200);\n    println!(\"Initial sequnce:\\n{}\", seq);\n\n    let mut_distr = rand::distributions::Uniform::new_inclusive(0, 2);\n\n    for _ in 0..10 {\n        let mutation = thread_rng().sample(mut_distr);\n\n        if mutation == 0 {\n            seq.insert()\n        } else if mutation == 1 {\n            seq.delete()\n        } else {\n            seq.swap()\n        }\n    }\n\n    println!(\"\\nMutated sequence:\\n{}\", seq);\n}\n",
    "title": "Bioinformatics/Sequence mutation",
    "url": "http://rosettacode.org/wiki/Bioinformatics/Sequence_mutation"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nconst DNA: &str = \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\";\nconst SEQUENCE_LIMIT: u32 = 50;\n\nfn main() {\n    let mut base_count = HashMap::new();\n    let mut total_count = 0;\n\n    print!(\"Sequence:\");\n\n    for base in DNA.chars() {\n        if total_count % SEQUENCE_LIMIT == 0 {\n            print!(\"\\n{:3}: \", total_count);\n        }\n        print!(\"{}\", base);\n        total_count += 1;\n        let count = base_count.entry(base).or_insert(0); // Return current count for base or insert 0\n        *count += 1;\n    }\n\n    println!(\"\\n\");\n    println!(\"Base count:\");\n    println!(\"-----------\");\n\n    let mut base_count: Vec<_> = base_count.iter().collect(); // HashMaps can't be sorted, so collect into Vec\n    base_count.sort_by_key(|bc| bc.0); // Sort bases alphabetically\n\n    for (base, count) in base_count.iter() {\n        println!(\"{}: {:3}\", base, count);\n    }\n\n    println!(\"\\nTotal: {}\", total_count);\n}\n",
    "path": "tasks/bioinformatics/base-count",
    "remote_code": "\nuse std::collections::HashMap;\n\nfn main() {\n    let dna = \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\\\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\\\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\\\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\\\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\\\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\\\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\\\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\\\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\\\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\";\n\n    let mut base_count = HashMap::new();\n    let mut total_count = 0;\n    print!(\"Sequence:\");\n    for base in dna.chars() {\n        if total_count % 50 == 0 {\n            print!(\"\\n{:3}: \", total_count);\n        }\n        print!(\"{}\", base);\n        total_count += 1;\n        let count = base_count.entry(base).or_insert(0); // Return current count for base or insert 0\n        *count += 1;\n    }\n    println!(\"\\n\");\n    println!(\"Base count:\");\n    println!(\"-----------\");\n\n    let mut base_count: Vec<_> = base_count.iter().collect(); // HashMaps can't be sorted, so collect into Vec\n    base_count.sort_by_key(|bc| bc.0); // Sort bases alphabetically\n    for (base, count) in base_count.iter() {\n        println!(\"  {}: {:3}\", base, count);\n    }\n    println!();\n    println!(\"Total: {}\", total_count);\n}\n",
    "title": "Bioinformatics/base count",
    "url": "http://rosettacode.org/wiki/Bioinformatics/base_count"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Biorhythms",
    "url": "http://rosettacode.org/wiki/Biorhythms"
  },
  {
    "local_code": "extern crate ring;\n\nuse ring::digest::{digest, SHA256};\n\n/// Decodes a base58-encoded string into an array of bytes.\nfn decode_base58(address: &str) -> Result<Vec<u8>, &'static str> {\n    const ALPHABET: &str = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    const BASE: usize = 58;\n\n    let mut result = vec![0; 25];\n\n    for c in address.chars() {\n        let mut value = match ALPHABET.find(c) {\n            Some(index) => index,\n            None => return Err(\"invalid character\"),\n        };\n\n        for byte in &mut result {\n            value += BASE * (*byte as usize);\n            *byte = (value % 256) as u8;\n            value /= 256;\n        }\n\n        if value > 0 {\n            return Err(\"address too long\");\n        }\n    }\n\n    Ok(result.iter().rev().map(|&byte| byte as u8).collect())\n}\n\n/// Hashed the input with the SHA-256 algorithm twice, and returns the output.\nfn double_sha256(bytes: &[u8]) -> Vec<u8> {\n    let digest_1 = digest(&SHA256, bytes);\n\n    let digest_2 = digest(&SHA256, digest_1.as_ref());\n    digest_2.as_ref().to_vec()\n}\n\n/// Validates a bitcoin address.\n///\n/// Returns `Ok` if the address validates.\n/// Returns `Err` with the reason if the address is invalid.\nfn validate(address: &str) -> Result<(), &'static str> {\n    let bytes = decode_base58(address)?;\n\n    // A bitcoin address encodes 25 bytes:\n    if bytes.len() != 25 {\n        return Err(\"invalid length\");\n    }\n\n    // The first byte is the version number, which will be zero for this task\n    if bytes[0] != 0 {\n        return Err(\"unknown version encountered\");\n    }\n\n    // The next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this\n    // task: you can consider them a pure arbitrary data\n    let _ = &bytes[1..21];\n\n    // The last four bytes are a checksum check. They are the first four bytes of a double SHA-256\n    // digest of the previous 21 bytes.\n    let checksum = &bytes[21..];\n    let result = double_sha256(&bytes[..21]);\n    if &result[..4] != checksum {\n        return Err(\"checksum did not validate\");\n    }\n\n    Ok(())\n}\n\nfn main() {\n    use std::env;\n\n    let result = match env::args().nth(2) {\n        Some(address) => validate(&address),\n        None => Err(\"no address supplied\"),\n    };\n\n    match result {\n        Ok(()) => println!(\"address is valid.\"),\n        Err(reason) => println!(\"address is invalid: {}\", reason),\n    }\n}\n\n#[test]\nfn test_valid() {\n    assert!(validate(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\").is_ok());\n}\n\n#[test]\nfn test_invalid() {\n    assert!(\n        validate(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\").unwrap_err() == \"checksum did not validate\"\n    )\n}\n",
    "path": "tasks/bitcoin/address-validation",
    "remote_code": "\nextern crate crypto;\n\nuse crypto::digest::Digest;\nuse crypto::sha2::Sha256;\n\nconst DIGITS58: [char; 58] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\nfn main() {\n    println!(\"{}\", validate_address(\"1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i\"));\n    println!(\"{}\", validate_address(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\"));\n    println!(\"{}\", validate_address(\"17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j\"));\n    println!(\"{}\", validate_address(\"17NdbrSGoUotzeGCcMMC?nFkEvLymoou9j\"));\n}\n\nfn validate_address(address: &str) -> bool {\n    let decoded = match from_base58(address, 25) {\n        Ok(x) => x,\n        Err(_) => return false\n    };\n    if decoded[0] != 0 {\n        return false;\n    }\n    let mut sha = Sha256::new();\n    sha.input(&decoded[0..21]);\n    let mut first_round = vec![0u8; sha.output_bytes()];\n    sha.result(&mut first_round);\n    sha.reset();\n    \n    sha.input(&first_round);\n    let mut second_round = vec![0u8; sha.output_bytes()];\n    sha.result(&mut second_round);\n    if second_round[0..4] != decoded[21..25] {\n        return false\n    }\n    true\n}\n\nfn from_base58(encoded: &str, size: usize) -> Result<Vec<u8>, String> {\n    let mut res: Vec<u8> = vec![0; size];\n    for base58_value in encoded.chars() {\n        let mut value: u32 = match DIGITS58\n            .iter()\n            .position(|x| *x == base58_value){\n            Some(x) => x as u32,\n            None => return Err(String::from(\"Invalid character found in encoded string.\"))\n        };\n        for result_index in (0..size).rev() {\n            value += 58 * res[result_index] as u32;\n            res[result_index] = (value % 256) as u8;\n            value /= 256;\n        }\n    }\n    Ok(res)\n}\n",
    "title": "Bitcoin/address validation",
    "url": "http://rosettacode.org/wiki/Bitcoin/address_validation"
  },
  {
    "local_code": "use ring::digest::{digest, SHA256};\nuse ripemd160::{Digest, Ripemd160};\n\nuse hex::FromHex;\n\nstatic X: &str = \"50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352\";\nstatic Y: &str = \"2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\";\nstatic ALPHABET: [char; 58] = [\n    '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',\n    'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\n    'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\n    'z',\n];\n\nfn base58_encode(bytes: &mut [u8]) -> String {\n    let base = ALPHABET.len();\n    if bytes.is_empty() {\n        return String::from(\"\");\n    }\n    let mut output: Vec<u8> = Vec::new();\n    let mut num: usize;\n    for _ in 0..33 {\n        num = 0;\n        for byte in bytes.iter_mut() {\n            num = num * 256 + *byte as usize;\n            *byte = (num / base) as u8;\n            num %= base;\n        }\n        output.push(num as u8);\n    }\n    let mut string = String::new();\n    for b in output.iter().rev() {\n        string.push(ALPHABET[*b as usize]);\n    }\n    string\n}\n\n// stolen from address-validation/src/main.rs\n/// Hashes the input with the SHA-256 algorithm twice, and returns the output.\nfn double_sha256(bytes: &[u8]) -> Vec<u8> {\n    let digest_1 = digest(&SHA256, bytes);\n\n    let digest_2 = digest(&SHA256, digest_1.as_ref());\n    digest_2.as_ref().to_vec()\n}\n\nfn point_to_address(x: &str, y: &str) -> String {\n    let mut addrv: Vec<u8> = Vec::with_capacity(65);\n    addrv.push(4u8);\n    addrv.append(&mut <Vec<u8>>::from_hex(x).unwrap());\n    addrv.append(&mut <Vec<u8>>::from_hex(y).unwrap());\n    // hash the addresses first using SHA256\n    let sha_digest = digest(&SHA256, &addrv);\n    let mut ripemd_digest = Ripemd160::digest(sha_digest.as_ref()).as_slice().to_vec();\n    // prepend a 0 to the vector\n    ripemd_digest.insert(0, 0);\n    // calculate checksum of extended ripemd digest\n    let checksum = double_sha256(&ripemd_digest);\n    ripemd_digest.extend_from_slice(&checksum[..4]);\n    base58_encode(&mut ripemd_digest)\n}\n\nfn main() {\n    println!(\"{}\", point_to_address(X, Y));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{point_to_address, X, Y};\n\n    #[test]\n    fn bitcoin_address() {\n        assert_eq!(point_to_address(X, Y), \"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\");\n    }\n}\n",
    "path": "tasks/bitcoin/public-point-to-address",
    "remote_code": "\nuse ring::digest::{digest, SHA256};\nuse ripemd160::{Digest, Ripemd160};\n\nuse hex::FromHex;\n\nstatic X: &str = \"50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352\";\nstatic Y: &str = \"2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\";\nstatic ALPHABET: [char; 58] = [\n    '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',\n    'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\n    'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\n    'z',\n];\n\nfn base58_encode(bytes: &mut [u8]) -> String {\n    let base = ALPHABET.len();\n    if bytes.is_empty() {\n        return String::from(\"\");\n    }\n    let mut output: Vec<u8> = Vec::new();\n    let mut num: usize;\n    for _ in 0..33 {\n        num = 0;\n        for byte in bytes.iter_mut() {\n            num = num * 256 + *byte as usize;\n            *byte = (num / base) as u8;\n            num %= base;\n        }\n        output.push(num as u8);\n    }\n    let mut string = String::new();\n    for b in output.iter().rev() {\n        string.push(ALPHABET[*b as usize]);\n    }\n    string\n}\n\n// stolen from address-validation/src/main.rs\n/// Hashes the input with the SHA-256 algorithm twice, and returns the output.\nfn double_sha256(bytes: &[u8]) -> Vec<u8> {\n    let digest_1 = digest(&SHA256, bytes);\n\n    let digest_2 = digest(&SHA256, digest_1.as_ref());\n    digest_2.as_ref().to_vec()\n}\n\nfn point_to_address(x: &str, y: &str) -> String {\n    let mut addrv: Vec<u8> = Vec::with_capacity(65);\n    addrv.push(4u8);\n    addrv.append(&mut <Vec<u8>>::from_hex(x).unwrap());\n    addrv.append(&mut <Vec<u8>>::from_hex(y).unwrap());\n    // hash the addresses first using SHA256\n    let sha_digest = digest(&SHA256, &addrv);\n    let mut ripemd_digest = Ripemd160::digest(&sha_digest.as_ref()).as_slice().to_vec();\n    // prepend a 0 to the vector\n    ripemd_digest.insert(0, 0);\n    // calculate checksum of extended ripemd digest\n    let checksum = double_sha256(&ripemd_digest);\n    ripemd_digest.extend_from_slice(&checksum[..4]);\n    base58_encode(&mut ripemd_digest)\n}\n\nfn main() {\n    println!(\"{}\", point_to_address(X, Y));\n}\n\n",
    "title": "Bitcoin/public point to address",
    "url": "http://rosettacode.org/wiki/Bitcoin/public_point_to_address"
  },
  {
    "local_code": "use super::{Color, ImageFormat};\nuse std::str::from_utf8;\nuse std::str::FromStr;\n\npub fn parse_version(input: &[u8]) -> nom::IResult<&[u8], ImageFormat> {\n    use nom::branch::alt;\n    use nom::bytes::complete::tag;\n    use nom::character::complete::line_ending;\n    use nom::combinator::map;\n    use nom::sequence::terminated;\n\n    // starts with P3/P6 ends with a CR/LF\n    terminated(\n        alt((\n            map(tag(\"P3\".as_bytes()), |_| ImageFormat::P3),\n            map(tag(\"P6\".as_bytes()), |_| ImageFormat::P6),\n        )),\n        line_ending,\n    )(input)\n}\n\npub fn parse_image_attributes(input: &[u8]) -> nom::IResult<&[u8], (usize, usize, usize)> {\n    use nom::character::complete::line_ending;\n    use nom::character::complete::{digit1, space1};\n    use nom::sequence::terminated;\n    use nom::sequence::tuple;\n\n    // 3 numbers separated by spaces ends with a CR/LF\n    terminated(tuple((digit1, space1, digit1, space1, digit1)), line_ending)(input).map(\n        |(next_input, result)| {\n            (\n                next_input,\n                (\n                    from_utf8(result.0).unwrap().parse().unwrap(),\n                    from_utf8(result.2).unwrap().parse().unwrap(),\n                    from_utf8(result.4).unwrap().parse().unwrap(),\n                ),\n            )\n        },\n    )\n}\n\npub fn parse_color_binary(input: &[u8]) -> nom::IResult<&[u8], Color> {\n    use nom::number::complete::u8 as nom_u8;\n    use nom::sequence::tuple;\n\n    tuple((nom_u8, nom_u8, nom_u8))(input).map(|(next_input, res)| {\n        (\n            next_input,\n            Color {\n                red: res.0,\n                green: res.1,\n                blue: res.2,\n            },\n        )\n    })\n}\n\npub fn parse_data_binary(input: &[u8]) -> nom::IResult<&[u8], Vec<Color>> {\n    use nom::multi::many0;\n    many0(parse_color_binary)(input)\n}\n\npub fn parse_color_ascii(input: &[u8]) -> nom::IResult<&[u8], Color> {\n    use nom::character::complete::{digit1, space0, space1};\n    use nom::sequence::tuple;\n\n    tuple((digit1, space1, digit1, space1, digit1, space0))(input).map(|(next_input, res)| {\n        (\n            next_input,\n            Color {\n                red: u8::from_str(from_utf8(res.0).unwrap()).unwrap(),\n                green: u8::from_str(from_utf8(res.2).unwrap()).unwrap(),\n                blue: u8::from_str(from_utf8(res.4).unwrap()).unwrap(),\n            },\n        )\n    })\n}\n\npub fn parse_data_ascii(input: &[u8]) -> nom::IResult<&[u8], Vec<Color>> {\n    use nom::multi::many0;\n    many0(parse_color_ascii)(input)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use nom::Err;\n\n    #[test]\n    fn test_parse_version() {\n        assert_eq!(\n            Ok((&b\"200 300 255\\nabcde\"[..], ImageFormat::P6)),\n            parse_version(&b\"P6\\n200 300 255\\nabcde\"[..])\n        );\n\n        assert_eq!(\n            Ok((&b\"200 300 255\\nabcde\"[..], ImageFormat::P3)),\n            parse_version(&b\"P3\\n200 300 255\\nabcde\"[..])\n        );\n\n        assert_eq!(\n            Err(Err::Error(nom::error::Error::new(\n                &b\"P1\\n200 300 255\\nabcde\"[..],\n                nom::error::ErrorKind::Tag,\n            ))),\n            parse_version(&b\"P1\\n200 300 255\\nabcde\"[..])\n        );\n\n        assert_eq!(\n            Err(Err::Error(nom::error::Error::new(\n                &b\"\\n200 300 255\\nabcde\"[..],\n                nom::error::ErrorKind::Tag,\n            ))),\n            parse_version(&b\"\\n200 300 255\\nabcde\"[..])\n        );\n    }\n\n    #[test]\n    fn test_parse_image_attributes() {\n        assert_eq!(\n            Ok((&b\"abcde\"[..], (200, 300, 255))),\n            parse_image_attributes(&b\"200 300 255\\nabcde\"[..])\n        );\n\n        assert_eq!(\n            Err(Err::Error(nom::error::Error::new(\n                &b\"a200 300 255\\nabcde\"[..],\n                nom::error::ErrorKind::Digit,\n            ))),\n            parse_image_attributes(&b\"a200 300 255\\nabcde\"[..])\n        );\n\n        assert_eq!(\n            Ok((&b\"abcde\"[..], (200, 300, 255))),\n            parse_image_attributes(&b\"200    300     255\\nabcde\"[..])\n        );\n    }\n\n    #[test]\n    fn test_parse_color_binary() {\n        assert_eq!(\n            Ok((\n                &b\"\"[..],\n                Color {\n                    red: 255,\n                    green: 0,\n                    blue: 0\n                }\n            )),\n            parse_color_binary(&[255, 0, 0])\n        );\n    }\n\n    #[test]\n    fn test_parse_data_binary() {\n        assert_eq!(\n            Ok((\n                &b\"\"[..],\n                vec![\n                    Color {\n                        red: 255,\n                        green: 0,\n                        blue: 0\n                    },\n                    Color {\n                        red: 0,\n                        green: 0,\n                        blue: 255\n                    }\n                ]\n            )),\n            parse_data_binary(&[255, 0, 0, 0, 0, 255])\n        );\n    }\n\n    #[test]\n    fn test_parse_color_ascii() {\n        assert_eq!(\n            Ok((\n                &b\"\"[..],\n                Color {\n                    red: 255,\n                    green: 0,\n                    blue: 0\n                }\n            )),\n            parse_color_ascii(&b\"255 0 0\"[..])\n        );\n    }\n\n    #[test]\n    fn test_parse_data_ascii() {\n        assert_eq!(\n            Ok((\n                &b\"\"[..],\n                vec![\n                    Color {\n                        red: 255,\n                        green: 0,\n                        blue: 0\n                    },\n                    Color {\n                        red: 0,\n                        green: 0,\n                        blue: 255\n                    }\n                ]\n            )),\n            parse_data_ascii(&b\"255 0 0 0 0 255\"[..])\n        );\n    }\n}\nextern crate nom;\nextern crate thiserror;\nmod parser;\n\nuse std::default::Default;\nuse std::fmt;\nuse std::io::{BufWriter, Error, Write};\nuse std::ops::{Index, IndexMut};\nuse std::{fs::File, io::Read};\nuse thiserror::Error;\n\n#[derive(Copy, Clone, Default, PartialEq, Debug)]\npub struct Color {\n    pub red: u8,\n    pub green: u8,\n    pub blue: u8,\n}\n\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum ImageFormat {\n    P3,\n    P6,\n}\n\nimpl From<&str> for ImageFormat {\n    fn from(i: &str) -> Self {\n        match i.to_lowercase().as_str() {\n            \"p3\" => ImageFormat::P3,\n            \"p6\" => ImageFormat::P6,\n            _ => unimplemented!(\"no other formats supported\"),\n        }\n    }\n}\n\nimpl fmt::Display for ImageFormat {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ImageFormat::P3 => {\n                write!(f, \"P3\")\n            }\n            ImageFormat::P6 => {\n                write!(f, \"P6\")\n            }\n        }\n    }\n}\n\n#[derive(Error, Debug)]\npub enum ImageError {\n    #[error(\"File not found\")]\n    FileNotFound,\n    #[error(\"File not readable\")]\n    FileNotReadable,\n    #[error(\"Invalid header information\")]\n    InvalidHeader,\n    #[error(\"Invalid information in the data block\")]\n    InvalidData,\n    #[error(\"Invalid max color information\")]\n    InvalidMaxColor,\n    #[error(\"File is incomplete\")]\n    IncompleteFile,\n    #[error(\"unknown data store error\")]\n    Unknown,\n}\npub struct Image {\n    pub format: ImageFormat,\n    pub width: usize,\n    pub height: usize,\n    pub data: Vec<Color>,\n}\n\nimpl Image {\n    #[must_use]\n    pub fn new(width: usize, height: usize) -> Self {\n        Self {\n            format: ImageFormat::P6,\n            width,\n            height,\n            data: vec![Color::default(); width * height],\n        }\n    }\n\n    pub fn fill(&mut self, color: Color) {\n        for elem in &mut self.data {\n            *elem = color;\n        }\n    }\n\n    /// # Errors\n    ///\n    /// Will return `Error` if `filename` does not exist or the user does not have\n    /// permission to write to it, or the write operation fails.\n    pub fn write_ppm(&self, filename: &str) -> Result<(), Error> {\n        let file = File::create(filename)?;\n        let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"{}\", self.format)?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        match self.format {\n            ImageFormat::P3 => {\n                writer.write_all(\n                    self.data\n                        .iter()\n                        .flat_map(|color| {\n                            vec![\n                                color.red.to_string(),\n                                color.green.to_string(),\n                                color.blue.to_string(),\n                            ]\n                        })\n                        .collect::<Vec<String>>()\n                        .join(\" \")\n                        .as_bytes(),\n                )?;\n            }\n            ImageFormat::P6 => {\n                writer.write_all(\n                    &self\n                        .data\n                        .iter()\n                        .flat_map(|color| vec![color.red, color.green, color.blue])\n                        .collect::<Vec<u8>>(),\n                )?;\n            }\n        }\n        Ok(())\n    }\n\n    /// # Panics\n    ///\n    /// Panics if the format is not P6 or P3 PPM\n    /// # Errors\n    ///\n    /// Will return `Error` if `filename` does not exist or the user does not have\n    /// permission to read it or the read operation fails, or the file format does not\n    /// match the specification\n    pub fn read_ppm(filename: &str) -> Result<Image, ImageError> {\n        let mut file = File::open(filename).map_err(|_| ImageError::FileNotFound)?;\n        let mut data: Vec<u8> = Vec::new();\n        file.read_to_end(&mut data)\n            .map_err(|_| ImageError::FileNotReadable)?;\n\n        let (i, format) = parser::parse_version(&data).map_err(|_| ImageError::InvalidHeader)?;\n        let (i, (width, height, max_color)) =\n            parser::parse_image_attributes(i).map_err(|_| ImageError::InvalidHeader)?;\n\n        if max_color != 255 {\n            return Err(ImageError::InvalidMaxColor);\n        }\n\n        let (_, data) = match format {\n            ImageFormat::P3 => parser::parse_data_ascii(i).map_err(|_| ImageError::InvalidData)?,\n            ImageFormat::P6 => parser::parse_data_binary(i).map_err(|_| ImageError::InvalidData)?,\n        };\n\n        if data.len() != height * width {\n            return Err(ImageError::IncompleteFile);\n        };\n\n        Ok(Image {\n            format,\n            width,\n            height,\n            data,\n        })\n    }\n}\n\nimpl Index<(usize, usize)> for Image {\n    type Output = Color;\n\n    fn index(&self, (x, y): (usize, usize)) -> &Color {\n        &self.data[x + y * self.width]\n    }\n}\n\nimpl IndexMut<(usize, usize)> for Image {\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Color {\n        &mut self.data[x + y * self.width]\n    }\n}\n\n#[allow(dead_code)]\npub fn main() {\n    let mut image = Image::new(10, 10);\n\n    for y in 0..10 {\n        for x in 5..10 {\n            image[(x, y)] = Color {\n                red: 255,\n                green: 255,\n                blue: 255,\n            };\n        }\n    }\n\n    for y in 0..10 {\n        for x in 0..10 {\n            let color = image[(x, y)];\n            let ch = if color.red + color.green + color.blue == 0 {\n                '#'\n            } else {\n                '.'\n            };\n            print!(\"{}\", ch);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    #[allow(clippy::no_effect)]\n    fn out_of_bounds() {\n        let image = Image::new(10, 10);\n        image[(10, 11)];\n    }\n\n    #[test]\n    fn getting() {\n        let image = Image::new(3, 4);\n        for x in 0..3 {\n            for y in 0..4 {\n                assert_eq!(image[(x, y)], Default::default());\n            }\n        }\n    }\n\n    #[test]\n    fn setting() {\n        let mut image = Image::new(3, 3);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 1,\n            blue: 1,\n        };\n        assert_eq!(\n            image[(0, 0)],\n            Color {\n                red: 1,\n                green: 1,\n                blue: 1,\n            }\n        );\n    }\n\n    #[test]\n    fn filling() {\n        let mut image = Image::new(4, 3);\n        let fill = Color {\n            red: 3,\n            green: 2,\n            blue: 5,\n        };\n        image.fill(fill);\n        for x in 0..4 {\n            for y in 0..3 {\n                assert_eq!(image[(x, y)], fill);\n            }\n        }\n    }\n}\nextern crate bitmap;\n\nuse bitmap::{Color, Image};\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::*;\n\n#[allow(clippy::upper_case_acronyms)]\ntrait PPMWritable {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error>;\n}\n\nimpl PPMWritable for Image {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error> {\n        let mut writer = File::create(filename)?;\n        // let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"P6\")?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        for color in &(self.data) {\n            for &channel in &[color.red, color.green, color.blue] {\n                let ch = channel as u8;\n                writer.write_all(&[ch])?;\n            }\n        }\n        Ok(())\n    }\n}\n\npub fn main() {\n    // write a PPM image, the left side of which is red, and the right side\n    // of which is blue\n    let mut image = Image::new(64, 64);\n    image.fill(Color {\n        red: 255,\n        green: 0,\n        blue: 0,\n    });\n    for y in 0..64 {\n        for x in 32..64 {\n            image[(x, y)] = Color {\n                red: 0,\n                green: 0,\n                blue: 255,\n            };\n        }\n    }\n    image.write_ppm(\"./test_image.ppm\").unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use super::*;\n    use io::BufReader;\n    use std::env;\n\n    #[test]\n    fn write_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 2,\n            blue: 3,\n        };\n        image[(1, 0)] = Color {\n            red: 4,\n            green: 5,\n            blue: 6,\n        };\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n        // Can't use try! macro because we want to panic, not return.\n        image.write_ppm(&fname).unwrap();\n\n        let file = File::open(&fname).unwrap();\n        let mut reader = BufReader::new(file);\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"P6\\n\");\n        line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"2 1 255\\n\");\n        let mut bytes = reader.bytes();\n        assert_eq!(bytes.next().unwrap().unwrap(), 1);\n        assert_eq!(bytes.next().unwrap().unwrap(), 2);\n        assert_eq!(bytes.next().unwrap().unwrap(), 3);\n        assert_eq!(bytes.next().unwrap().unwrap(), 4);\n        assert_eq!(bytes.next().unwrap().unwrap(), 5);\n        assert_eq!(bytes.next().unwrap().unwrap(), 6);\n        assert!(bytes.next().is_none());\n    }\n}\nuse bitmap::Image;\n\n// see read_ppm implementation in the bitmap library\n\npub fn main() {\n    // read a PPM image, which was produced by the write-a-ppm-file task\n    let image = Image::read_ppm(\"./test_image.ppm\").unwrap();\n\n    println!(\"Read using nom parsing:\");\n    println!(\"Format: {:?}\", image.format);\n    println!(\"Dimensions: {} x {}\", image.height, image.width);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use bitmap::{Color, Image};\n    use std::env;\n    #[test]\n    fn read_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 255,\n            green: 0,\n            blue: 0,\n        };\n        image[(1, 0)] = Color {\n            red: 0,\n            green: 255,\n            blue: 0,\n        };\n\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n\n        image.write_ppm(&fname).unwrap();\n\n        image = Image::read_ppm(&fname).unwrap();\n\n        assert_eq!(image.width, 2);\n        assert_eq!(image.height, 1);\n        assert_eq!(\n            image.data,\n            vec![\n                Color {\n                    red: 255,\n                    green: 0,\n                    blue: 0\n                },\n                Color {\n                    red: 0,\n                    green: 255,\n                    blue: 0\n                }\n            ]\n        )\n    }\n}\nextern crate bitmap;\n\nuse bitmap::{Color, Image};\n\nfn main() {\n    let mut image = Image::new(10, 10);\n\n    for y in 0..10 {\n        for x in 5..10 {\n            image[(x, y)] = Color {\n                red: 255,\n                green: 255,\n                blue: 255,\n            };\n        }\n    }\n\n    for y in 0..10 {\n        for x in 0..10 {\n            let color = image[(x, y)];\n            let ch = if color.red.wrapping_add(color.green).wrapping_add(color.blue) == 0 {\n                '#'\n            } else {\n                '.'\n            };\n            print!(\"{}\", ch);\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/bitmap",
    "remote_code": "#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct Rgb {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n}\n\nimpl Rgb {\n    pub fn new(r: u8, g: u8, b: u8) -> Self {\n        Rgb { r, g, b }\n    }\n\n    pub const BLACK: Rgb = Rgb { r: 0, g: 0, b: 0 };\n    pub const RED: Rgb = Rgb { r: 255, g: 0, b: 0 };\n    pub const GREEN: Rgb = Rgb { r: 0, g: 255, b: 0 };\n    pub const BLUE: Rgb = Rgb { r: 0, g: 0, b: 255 };\n}\n\n#[derive(Clone, Debug)]\npub struct Image {\n    width: usize,\n    height: usize,\n    pixels: Vec<Rgb>,\n}\n\nimpl Image {\n    pub fn new(width: usize, height: usize) -> Self {\n        Image {\n            width,\n            height,\n            pixels: vec![Rgb::BLACK; width * height],\n        }\n    }\n    \n    pub fn width(&self) -> usize {\n        self.width\n    }\n    \n    pub fn height(&self) -> usize {\n        self.height\n    }\n\n    pub fn fill(&mut self, color: Rgb) {\n        for pixel in &mut self.pixels {\n            *pixel = color;\n        }\n    }\n\n    pub fn get(&self, row: usize, col: usize) -> Option<&Rgb> {\n        if row >= self.width {\n            return None;\n        }\n        self.pixels.get(row * self.width + col)\n    }\n\n    pub fn get_mut(&mut self, row: usize, col: usize) -> Option<&mut Rgb> {\n        if row >= self.width {\n            return None;\n        }\n        self.pixels.get_mut(row * self.width + col)\n    }\n}\n\nfn main() {\n    let mut image = Image::new(16, 9);\n    assert_eq!(Some(&Rgb::BLACK), image.get(3, 4));\n    assert!(image.get(22, 3).is_none());\n\n    image.fill(Rgb::RED);\n    assert_eq!(Some(&Rgb::RED), image.get(3, 4));\n\n    if let Some(pixel) = image.get_mut(3, 4) {\n        *pixel = Rgb::GREEN;\n    }\n    assert_eq!(Some(&Rgb::GREEN), image.get(3, 4));\n\n    if let Some(pixel) = image.get_mut(3, 4) {\n        pixel.g -= 100;\n        pixel.b = 20;\n    }\n    assert_eq!(Some(&Rgb::new(0, 155, 20)), image.get(3, 4));\n}",
    "title": "Bitmap",
    "url": "http://rosettacode.org/wiki/Bitmap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct Point {\n    x: i32,\n    y: i32\n}\n\nfn main() {\n    let mut points: Vec<Point> = Vec::new();\n    points.append(&mut get_coordinates(1, 20, 20, 28));\n    points.append(&mut get_coordinates(20, 28, 69, 0));\n    draw_line(points, 70, 30);\n}\n\nfn get_coordinates(x1: i32, y1: i32, x2: i32, y2: i32) -> Vec<Point> {\n    let mut coordinates: Vec<Point> = vec![];\n    let dx:i32 = i32::abs(x2 - x1);\n    let dy:i32 = i32::abs(y2 - y1);\n    let sx:i32 = { if x1 < x2 { 1 } else { -1 } };\n    let sy:i32 = { if y1 < y2 { 1 } else { -1 } };\n\n    let mut error:i32 = (if dx > dy  { dx } else { -dy }) / 2 ;\n    let mut current_x:i32 = x1;\n    let mut current_y:i32 = y1;\n    loop {\n        coordinates.push(Point { x : current_x, y: current_y });\n\n        if current_x == x2 && current_y == y2 { break; }\n\n        let error2:i32 = error;\n\n        if error2 > -dx {\n            error -= dy;\n            current_x += sx;\n        }\n        if error2 < dy {\n            error += dx;\n            current_y += sy;\n        }\n    }\n    coordinates\n}\n\nfn draw_line(line: std::vec::Vec<Point>, width: i32, height: i32) {\n    for col in 0..height {\n        for row in 0..width {\n            let is_point_in_line = line.iter().any(| point| point.x == row && point.y == col);\n            match is_point_in_line {\n                true => print!(\"@\"),\n                _ => print!(\".\")\n            };\n        }\n        print!(\"\\n\");\n    }\n}\n",
    "title": "Bitmap/Bresenham's line algorithm",
    "url": "http://rosettacode.org/wiki/Bitmap/Bresenham's_line_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Bézier curves/Cubic",
    "url": "http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Cubic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Bézier curves/Quadratic",
    "url": "http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Quadratic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n/* Naive Rust implementation of RosettaCode's Bitmap/Flood fill excercise.\n *\n * For the sake of simplicity this code reads PPM files (format specification can be found here: http://netpbm.sourceforge.net/doc/ppm.html ).\n * The program assumes that the image has been created by GIMP in PPM ASCII mode and panics at any error.\n *\n * Also this program expects the input file to be in the same directory as the executable and named\n * \"input.ppm\" and outputs a file in the same directory under the name \"output.ppm\".\n *\n */\n\nuse std::fs::File; // Used for creating/opening files.\nuse std::io::{BufReader, BufRead, Write}; // Used for reading/writing files.\n\nfn read_image(filename: String) -> Vec<Vec<(u8,u8,u8)>> {\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n    let mut lines = reader.lines();\n\n    let _ = lines.next().unwrap(); // Skip P3 signature.\n    let _ = lines.next().unwrap(); // Skip GIMP comment.\n\n    let dimensions: (usize, usize) = {\n        let line = lines.next().unwrap().unwrap();\n        let values = line.split_whitespace().collect::<Vec<&str>>();\n\n        // We turn the &str vector that holds the width & height of the image into an usize tuplet.\n        (values[0].parse::<usize>().unwrap(),values[1].parse::<usize>().unwrap())\n    };\n\n    let _ = lines.next().unwrap(); // Skip maximum color value (we assume 255).\n\n    let mut image_data = Vec::with_capacity(dimensions.1);\n\n    for y in 0..dimensions.1 {\n        image_data.push(Vec::new());\n        for _ in 0..dimensions.0 {\n            // We read the R, G and B components and put them in the image_data vector.\n            image_data[y].push((lines.next().unwrap().unwrap().parse::<u8>().unwrap(),\n                                lines.next().unwrap().unwrap().parse::<u8>().unwrap(),\n                                lines.next().unwrap().unwrap().parse::<u8>().unwrap()));\n        }\n    }\n\n    image_data\n}\n\nfn write_image(image_data: Vec<Vec<(u8,u8,u8)>>) {\n    let mut file = File::create(format!(\"./output.ppm\")).unwrap();\n\n    // Signature, then width and height, then 255 as max color value.\n    write!(file, \"P3\\n{} {}\\n255\\n\", image_data.len(), image_data[0].len()).unwrap();\n\n    for row in &image_data {\n        // For performance reasons, we reserve a String with the necessary length for a line and\n        // fill that up before writing it to the file.\n\n        let mut line = String::with_capacity(row.len()*6); // 6 = r(space)g(space)b(space)\n        for (r,g,b) in row {\n\n            // &* is used to turn a String into a &str as needed by push_str.\n            line.push_str(&*format!(\"{} {} {} \", r,g,b));\n        }\n\n        write!(file, \"{}\", line).unwrap();\n    }\n\n}\n\nfn flood_fill(x: usize, y: usize, target: &(u8,u8,u8), replacement: &(u8,u8,u8), image_data: &mut Vec<Vec<(u8,u8,u8)>>) {\n    if &image_data[y][x] == target {\n        image_data[y][x] = *replacement;\n\n        if y > 0 {flood_fill(x,y-1, &target, &replacement, image_data);}\n        if x > 0 {flood_fill(x-1,y, &target, &replacement, image_data);}\n        if y < image_data.len()-1 {flood_fill(x,y+1, &target, &replacement, image_data);}\n        if x < image_data[0].len()-1 {flood_fill(x+1,y, &target, &replacement, image_data);}\n    }\n}\n\nfn main() {\n    let mut data = read_image(String::from(\"./input.ppm\"));\n\n    flood_fill(1,50, &(255,255,255), &(0,255,0), &mut data); // Fill the big white circle with green.\n    flood_fill(40,35, &(0,0,0), &(255,0,0), &mut data); // Fill the small black circle with red.\n\n    write_image(data);\n\n}",
    "title": "Bitmap/Flood fill",
    "url": "http://rosettacode.org/wiki/Bitmap/Flood_fill"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\nuse image::{DynamicImage, GenericImageView, ImageBuffer, Rgba};\n\n/// index of the alpha channel in RGBA\nconst ALPHA: usize = 3;\n\n/// Computes the luminance of a single pixel\n/// Result lies within `u16::MIN..u16::MAX`\nconst fn luminance(rgba: Rgba<u8>) -> u16 {\n    let Rgba([r, g, b, _a]) = rgba;\n    55 * r as u16 + 183 * g as u16 + 19 * b as u16\n}\n\n/// computes the median of a given histogram\n/// Result lies within `u16::MIN..u16::MAX`\nfn get_median(total: usize, histogram: &[usize]) -> u16 {\n    let mut sum = 0;\n    for (index, &count) in histogram.iter().enumerate() {\n        sum += count;\n        if sum >= total / 2 {\n            return index as u16;\n        }\n    }\n\n    u16::MAX\n}\n\n/// computes the histogram of a given image\nfn compute_histogram(img: &DynamicImage) -> Vec<usize> {\n    let mut histogram = vec![0; 1 << u16::BITS];\n\n    img.pixels()\n        .map(|(_x, _y, pixel)| luminance(pixel))\n        .for_each(|luminance| histogram[luminance as usize] += 1);\n\n    histogram\n}\n\n/// returns a black or white pixel with an alpha value\nconst fn black_white(is_white: bool, alpha: u8) -> [u8; 4] {\n    if is_white {\n        [255, 255, 255, alpha]\n    } else {\n        [0, 0, 0, alpha]\n    }\n}\n\n/// create a monochome compy of the given image\n/// preserves alpha data\nfn convert_to_monochrome(img: &DynamicImage) -> ImageBuffer<Rgba<u8>, Vec<u8>> {\n    let histogram = compute_histogram(img);\n\n    let (width, height) = img.dimensions();\n    let pixel_count = (width * height) as usize;\n    let median = get_median(pixel_count, &histogram);\n\n    let pixel_buffer = img.pixels()\n        .flat_map(|(_x, _y, pixel)| black_white(luminance(pixel) > median, pixel[ALPHA]))\n        .collect();\n\n    ImageBuffer::from_vec(width, height, pixel_buffer).unwrap_or_else(|| unreachable!())\n}\n\nfn main() {\n    let img = image::open(\"lena.jpg\").expect(\"could not load image file\");\n    let img = convert_to_monochrome(&img);\n    img.save(\"lena-mono.png\").expect(\"could not save result image\");\n}\n",
    "title": "Bitmap/Histogram",
    "url": "http://rosettacode.org/wiki/Bitmap/Histogram"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Midpoint circle algorithm",
    "url": "http://rosettacode.org/wiki/Bitmap/Midpoint_circle_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/PPM conversion through a pipe",
    "url": "http://rosettacode.org/wiki/Bitmap/PPM_conversion_through_a_pipe"
  },
  {
    "local_code": "use bitmap::Image;\n\n// see read_ppm implementation in the bitmap library\n\npub fn main() {\n    // read a PPM image, which was produced by the write-a-ppm-file task\n    let image = Image::read_ppm(\"./test_image.ppm\").unwrap();\n\n    println!(\"Read using nom parsing:\");\n    println!(\"Format: {:?}\", image.format);\n    println!(\"Dimensions: {} x {}\", image.height, image.width);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use bitmap::{Color, Image};\n    use std::env;\n    #[test]\n    fn read_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 255,\n            green: 0,\n            blue: 0,\n        };\n        image[(1, 0)] = Color {\n            red: 0,\n            green: 255,\n            blue: 0,\n        };\n\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n\n        image.write_ppm(&fname).unwrap();\n\n        image = Image::read_ppm(&fname).unwrap();\n\n        assert_eq!(image.width, 2);\n        assert_eq!(image.height, 1);\n        assert_eq!(\n            image.data,\n            vec![\n                Color {\n                    red: 255,\n                    green: 0,\n                    blue: 0\n                },\n                Color {\n                    red: 0,\n                    green: 255,\n                    blue: 0\n                }\n            ]\n        )\n    }\n}\n",
    "path": "tasks/bitmap/read-a-ppm-file",
    "remote_code": "\nparser.rs:\nuse super::{Color, ImageFormat};\nuse std::str::from_utf8;\nuse std::str::FromStr;\n\npub fn parse_version(input: &[u8]) -> nom::IResult<&[u8], ImageFormat> {\n    use nom::branch::alt;\n    use nom::bytes::complete::tag;\n    use nom::character::complete::line_ending;\n    use nom::combinator::map;\n    use nom::sequence::terminated;\n\n    // starts with P3/P6 ends with a CR/LF\n    terminated(\n        alt((\n            map(tag(\"P3\".as_bytes()), |_| ImageFormat::P3),\n            map(tag(\"P6\".as_bytes()), |_| ImageFormat::P6),\n        )),\n        line_ending,\n    )(input)\n}\n\npub fn parse_image_attributes(input: &[u8]) -> nom::IResult<&[u8], (usize, usize, usize)> {\n    use nom::character::complete::line_ending;\n    use nom::character::complete::{digit1, space1};\n    use nom::sequence::terminated;\n    use nom::sequence::tuple;\n\n    // 3 numbers separated by spaces ends with a CR/LF\n    terminated(tuple((digit1, space1, digit1, space1, digit1)), line_ending)(input).map(\n        |(next_input, result)| {\n            (\n                next_input,\n                (\n                    usize::from_str_radix(from_utf8(result.0).unwrap(), 10).unwrap(),\n                    usize::from_str_radix(from_utf8(result.2).unwrap(), 10).unwrap(),\n                    usize::from_str_radix(from_utf8(result.4).unwrap(), 10).unwrap(),\n                ),\n            )\n        },\n    )\n}\n\npub fn parse_color_binary(input: &[u8]) -> nom::IResult<&[u8], Color> {\n    use nom::number::complete::u8 as nom_u8;\n    use nom::sequence::tuple;\n\n    tuple((nom_u8, nom_u8, nom_u8))(input).map(|(next_input, res)| {\n        (\n            next_input,\n            Color {\n                red: res.0,\n                green: res.1,\n                blue: res.2,\n            },\n        )\n    })\n}\n\npub fn parse_data_binary(input: &[u8]) -> nom::IResult<&[u8], Vec<Color>> {\n    use nom::multi::many0;\n    many0(parse_color_binary)(input)\n}\n\npub fn parse_color_ascii(input: &[u8]) -> nom::IResult<&[u8], Color> {\n    use nom::character::complete::{digit1, space0, space1};\n    use nom::sequence::tuple;\n\n    tuple((digit1, space1, digit1, space1, digit1, space0))(input).map(|(next_input, res)| {\n        (\n            next_input,\n            Color {\n                red: u8::from_str(from_utf8(res.0).unwrap()).unwrap(),\n                green: u8::from_str(from_utf8(res.2).unwrap()).unwrap(),\n                blue: u8::from_str(from_utf8(res.4).unwrap()).unwrap(),\n            },\n        )\n    })\n}\n\npub fn parse_data_ascii(input: &[u8]) -> nom::IResult<&[u8], Vec<Color>> {\n    use nom::multi::many0;\n    many0(parse_color_ascii)(input)\n}\n\n\nlib.rs:\nextern crate nom;\nextern crate thiserror;\nmod parser;\n\nuse std::default::Default;\nuse std::fmt;\nuse std::io::{BufWriter, Error, Write};\nuse std::ops::{Index, IndexMut};\nuse std::{fs::File, io::Read};\nuse thiserror::Error;\n\n#[derive(Copy, Clone, Default, PartialEq, Debug)]\npub struct Color {\n    pub red: u8,\n    pub green: u8,\n    pub blue: u8,\n}\n\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum ImageFormat {\n    P3,\n    P6,\n}\n\nimpl From<&str> for ImageFormat {\n    fn from(i: &str) -> Self {\n        match i.to_lowercase().as_str() {\n            \"p3\" => ImageFormat::P3,\n            \"p6\" => ImageFormat::P6,\n            _ => unimplemented!(\"no other formats supported\"),\n        }\n    }\n}\n\nimpl fmt::Display for ImageFormat {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ImageFormat::P3 => {\n                write!(f, \"P3\")\n            }\n            ImageFormat::P6 => {\n                write!(f, \"P6\")\n            }\n        }\n    }\n}\n\n#[derive(Error, Debug)]\npub enum ImageError {\n    #[error(\"File not found\")]\n    FileNotFound,\n    #[error(\"File not readable\")]\n    FileNotReadable,\n    #[error(\"Invalid header information\")]\n    InvalidHeader,\n    #[error(\"Invalid information in the data block\")]\n    InvalidData,\n    #[error(\"Invalid max color information\")]\n    InvalidMaxColor,\n    #[error(\"File is incomplete\")]\n    IncompleteFile,\n    #[error(\"unknown data store error\")]\n    Unknown,\n}\npub struct Image {\n    pub format: ImageFormat,\n    pub width: usize,\n    pub height: usize,\n    pub data: Vec<Color>,\n}\n\nimpl Image {\n    #[must_use]\n    pub fn new(width: usize, height: usize) -> Self {\n        Self {\n            format: ImageFormat::P6,\n            width,\n            height,\n            data: vec![Color::default(); width * height],\n        }\n    }\n\n    pub fn fill(&mut self, color: Color) {\n        for elem in &mut self.data {\n            *elem = color;\n        }\n    }\n\n    /// # Errors\n    ///\n    /// Will return `Error` if `filename` does not exist or the user does not have\n    /// permission to write to it, or the write operation fails.\n    pub fn write_ppm(&self, filename: &str) -> Result<(), Error> {\n        let file = File::create(filename)?;\n        let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"{}\", self.format.to_string())?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        match self.format {\n            ImageFormat::P3 => {\n                writer.write_all(\n                    &self\n                        .data\n                        .iter()\n                        .flat_map(|color| {\n                            vec![\n                                color.red.to_string(),\n                                color.green.to_string(),\n                                color.blue.to_string(),\n                            ]\n                        })\n                        .collect::<Vec<String>>()\n                        .join(\" \")\n                        .as_bytes(),\n                )?;\n            }\n            ImageFormat::P6 => {\n                writer.write_all(\n                    &self\n                        .data\n                        .iter()\n                        .flat_map(|color| vec![color.red, color.green, color.blue])\n                        .collect::<Vec<u8>>(),\n                )?;\n            }\n        }\n        Ok(())\n    }\n\n    /// # Panics\n    ///\n    /// Panics if the format is not P6 or P3 PPM\n    /// # Errors\n    ///\n    /// Will return `Error` if `filename` does not exist or the user does not have\n    /// permission to read it or the read operation fails, or the file format does not\n    /// match the specification\n    pub fn read_ppm(filename: &str) -> Result<Image, ImageError> {\n        let mut file = File::open(filename).map_err(|_| ImageError::FileNotFound)?;\n        let mut data: Vec<u8> = Vec::new();\n        file.read_to_end(&mut data)\n            .map_err(|_| ImageError::FileNotReadable)?;\n\n        let (i, format) = parser::parse_version(&data).map_err(|_| ImageError::InvalidHeader)?;\n        let (i, (width, height, max_color)) =\n            parser::parse_image_attributes(i).map_err(|_| ImageError::InvalidHeader)?;\n\n        if max_color != 255 {\n            return Err(ImageError::InvalidMaxColor);\n        }\n\n        let (_, data) = match format {\n            ImageFormat::P3 => parser::parse_data_ascii(i).map_err(|_| ImageError::InvalidData)?,\n            ImageFormat::P6 => parser::parse_data_binary(i).map_err(|_| ImageError::InvalidData)?,\n        };\n\n        if data.len() != height * width {\n            return Err(ImageError::IncompleteFile);\n        };\n\n        Ok(Image {\n            format,\n            width,\n            height,\n            data,\n        })\n    }\n}\n\nimpl Index<(usize, usize)> for Image {\n    type Output = Color;\n\n    fn index(&self, (x, y): (usize, usize)) -> &Color {\n        &self.data[x + y * self.width]\n    }\n}\n\nimpl IndexMut<(usize, usize)> for Image {\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Color {\n        &mut self.data[x + y * self.width]\n    }\n}\n\n\nuse bitmap::Image;\n\n// see read_ppm implementation in the bitmap library\n\npub fn main() {\n    // read a PPM image, which was produced by the write-a-ppm-file task\n    let image = Image::read_ppm(\"./test_image.ppm\").unwrap();\n\n    println!(\"Read using nom parsing:\");\n    println!(\"Format: {:?}\", image.format);\n    println!(\"Dimensions: {} x {}\", image.height, image.width);\n}\n",
    "title": "Bitmap/Read a PPM file",
    "url": "http://rosettacode.org/wiki/Bitmap/Read_a_PPM_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Read an image through a pipe",
    "url": "http://rosettacode.org/wiki/Bitmap/Read_an_image_through_a_pipe"
  },
  {
    "local_code": "extern crate bitmap;\n\nuse bitmap::{Color, Image};\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::*;\n\n#[allow(clippy::upper_case_acronyms)]\ntrait PPMWritable {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error>;\n}\n\nimpl PPMWritable for Image {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error> {\n        let mut writer = File::create(filename)?;\n        // let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"P6\")?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        for color in &(self.data) {\n            for &channel in &[color.red, color.green, color.blue] {\n                let ch = channel as u8;\n                writer.write_all(&[ch])?;\n            }\n        }\n        Ok(())\n    }\n}\n\npub fn main() {\n    // write a PPM image, the left side of which is red, and the right side\n    // of which is blue\n    let mut image = Image::new(64, 64);\n    image.fill(Color {\n        red: 255,\n        green: 0,\n        blue: 0,\n    });\n    for y in 0..64 {\n        for x in 32..64 {\n            image[(x, y)] = Color {\n                red: 0,\n                green: 0,\n                blue: 255,\n            };\n        }\n    }\n    image.write_ppm(\"./test_image.ppm\").unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use super::*;\n    use io::BufReader;\n    use std::env;\n\n    #[test]\n    fn write_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 2,\n            blue: 3,\n        };\n        image[(1, 0)] = Color {\n            red: 4,\n            green: 5,\n            blue: 6,\n        };\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n        // Can't use try! macro because we want to panic, not return.\n        image.write_ppm(&fname).unwrap();\n\n        let file = File::open(&fname).unwrap();\n        let mut reader = BufReader::new(file);\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"P6\\n\");\n        line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"2 1 255\\n\");\n        let mut bytes = reader.bytes();\n        assert_eq!(bytes.next().unwrap().unwrap(), 1);\n        assert_eq!(bytes.next().unwrap().unwrap(), 2);\n        assert_eq!(bytes.next().unwrap().unwrap(), 3);\n        assert_eq!(bytes.next().unwrap().unwrap(), 4);\n        assert_eq!(bytes.next().unwrap().unwrap(), 5);\n        assert_eq!(bytes.next().unwrap().unwrap(), 6);\n        assert!(bytes.next().is_none());\n    }\n}\n",
    "path": "tasks/bitmap/write-a-ppm-file",
    "remote_code": "use std::path::Path;\nuse std::io::Write;\nuse std::fs::File;\n\npub struct RGB {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\npub struct PPM {\n    height: u32,\n    width: u32,\n    data: Vec<u8>,\n}\n\nimpl PPM {\n    pub fn new(height: u32, width: u32) -> PPM {\n        let size = 3 * height * width;\n        let buffer = vec![0; size as usize];\n        PPM { height: height, width: width, data: buffer }\n    }\n\n    fn buffer_size(&self) -> u32 {\n        3 * self.height * self.width\n    }\n\n    fn get_offset(&self, x: u32, y: u32) -> Option<usize> {\n        let offset = (y * self.width * 3) + (x * 3);\n        if offset < self.buffer_size() {\n            Some(offset as usize)\n        } else {\n            None\n        }\n    }\n\n    pub fn get_pixel(&self, x: u32, y: u32) -> Option<RGB> {\n        match self.get_offset(x, y) {\n            Some(offset) => {\n                let r = self.data[offset];\n                let g = self.data[offset + 1];\n                let b = self.data[offset + 2];\n                Some(RGB {r: r, g: g, b: b})\n            },\n            None => None\n        }\n    }\n\n    pub fn set_pixel(&mut self, x: u32, y: u32, color: RGB) -> bool {\n        match self.get_offset(x, y) {\n            Some(offset) => {\n                self.data[offset] = color.r;\n                self.data[offset + 1] = color.g;\n                self.data[offset + 2] = color.b;\n                true\n            },\n            None => false\n        }\n    }\n\n    pub fn write_file(&self, filename: &str) -> std::io::Result<()> {\n        let path = Path::new(filename);\n        let mut file = File::create(&path)?;\n        let header = format!(\"P6 {} {} 255\\n\", self.width, self.height);\n        file.write(header.as_bytes())?;\n        file.write(&self.data)?;\n        Ok(())\n    }\n}",
    "title": "Bitmap/Write a PPM file",
    "url": "http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub trait Codec<Input = u8> {\n    type Output: Iterator<Item = u8>;\n\n    fn accept(&mut self, input: Input) -> Self::Output;\n    fn finish(self) -> Self::Output;\n}\n\n#[derive(Debug)]\npub struct BitDiscard {\n    buf: u16,      // Use the higher byte for storing the leftovers\n    buf_bits: u8,  // How many bits are valid in the buffer\n    valid_len: u8, // How many bits to keep from the input\n    shift_len: u8, // Pre-computed shift of the input byte\n}\n\nimpl BitDiscard {\n    pub fn new(discard: u8) -> Self {\n        assert!(discard < 8);\n\n        BitDiscard {\n            buf: 0,\n            buf_bits: 0,\n            valid_len: 8 - discard,\n            shift_len: 8 + discard,\n        }\n    }\n}\n\nimpl Codec<u8> for BitDiscard {\n    type Output = std::option::IntoIter<u8>;\n\n    fn accept(&mut self, input: u8) -> Self::Output {\n        let add = ((input as u16) << self.shift_len) >> self.buf_bits;\n        self.buf |= add;\n        self.buf_bits += self.valid_len;\n\n        let result = if self.buf_bits >= 8 {\n            let result = (self.buf >> 8) as u8;\n            self.buf <<= 8;\n            self.buf_bits -= 8;\n            Some(result)\n        } else {\n            None\n        };\n\n        result.into_iter()\n    }\n\n    fn finish(self) -> Self::Output {\n        let result = if self.buf_bits > 0 {\n            Some((self.buf >> 8) as u8)\n        } else {\n            None\n        };\n\n        result.into_iter()\n    }\n}\n\n#[derive(Debug)]\npub struct BitExpand {\n    buf: u16,      // For storing the leftovers\n    buf_bits: u8,  // How many bits are valid in the buffer\n    valid_len: u8, // How many bits are valid in the input\n    shift_len: u8, // How many bits to shift when expanding\n}\n\nimpl BitExpand {\n    pub fn new(expand: u8) -> Self {\n        assert!(expand < 8);\n\n        Self {\n            buf: 0,\n            buf_bits: 0,\n            valid_len: 8 - expand,\n            shift_len: 8 + expand,\n        }\n    }\n}\n\nimpl Codec<u8> for BitExpand {\n    type Output = BitExpandIter;\n\n    fn accept(&mut self, input: u8) -> Self::Output {\n        let add = ((input as u16) << 8) >> self.buf_bits;\n        self.buf |= add;\n        self.buf_bits += 8;\n        let buf = self.buf;\n        let leftover = self.buf_bits % self.valid_len;\n        let buf_bits = self.buf_bits - leftover;\n        self.buf <<= buf_bits;\n        self.buf_bits = leftover;\n\n        Self::Output {\n            buf,\n            buf_bits,\n            shift_len: self.shift_len,\n            valid_len: self.valid_len,\n        }\n    }\n\n    fn finish(self) -> Self::Output {\n        Self::Output {\n            buf: 0,\n            buf_bits: 0,\n            shift_len: 0,\n            valid_len: self.valid_len,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct BitExpandIter {\n    buf: u16,\n    buf_bits: u8,\n    valid_len: u8,\n    shift_len: u8,\n}\n\nimpl Iterator for BitExpandIter {\n    type Item = u8;\n\n    fn next(&mut self) -> Option<u8> {\n        if self.buf_bits < self.valid_len {\n            None\n        } else {\n            let result = (self.buf >> self.shift_len) as u8;\n            self.buf <<= self.valid_len;\n            self.buf_bits -= self.valid_len;\n            Some(result)\n        }\n    }\n}\n\nfn process_bytes<C: Codec>(mut codec: C, bytes: &[u8]) -> Vec<u8> {\n    let mut result: Vec<u8> = bytes.iter().flat_map(|byte| codec.accept(*byte)).collect();\n    codec.finish().for_each(|byte| result.push(byte));\n    result\n}\n\nfn print_bytes(bytes: &[u8]) {\n    for byte in bytes {\n        print!(\"{:08b} \", byte);\n    }\n    println!();\n\n    for byte in bytes {\n        print!(\"{:02x} \", byte);\n    }\n    println!();\n}\n\nfn main() {\n    let original = b\"STRINGIFY!\";\n    let discard = 1;\n    print_bytes(&original[..]);\n    let compressed = process_bytes(BitDiscard::new(discard), &original[..]);\n    print_bytes(&compressed);\n    let decompressed = process_bytes(BitExpand::new(discard), &compressed);\n    print_bytes(&decompressed);\n}",
    "title": "Bitwise IO",
    "url": "http://rosettacode.org/wiki/Bitwise_IO"
  },
  {
    "local_code": "fn main() {\n    let a: u8 = 105;\n    let b: u8 = 91;\n    println!(\"a      = {:0>8}\", a);\n    println!(\"b      = {:0>8}\", b);\n    println!(\"a | b  = {:0>8}\", a | b);\n    println!(\"a & b  = {:0>8}\", a & b);\n    println!(\"a ^ b  = {:0>8}\", a ^ b);\n    println!(\"!a     = {:0>8}\", !a);\n    println!(\"a << 3 = {:0>8}\", a >> 3);\n    println!(\"a >> 3 = {:0>8}\", a << 3);\n}\n",
    "path": "tasks/bitwise-operations",
    "remote_code": "fn main() {\n    let a: u8 = 105;\n    let b: u8 = 91;\n    println!(\"a      = {:0>8b}\", a);\n    println!(\"b      = {:0>8b}\", b);\n    println!(\"a | b  = {:0>8b}\", a | b);\n    println!(\"a & b  = {:0>8b}\", a & b);\n    println!(\"a ^ b  = {:0>8b}\", a ^ b);\n    println!(\"!a     = {:0>8b}\", !a);\n    println!(\"a << 3 = {:0>8b}\", a << 3);\n    println!(\"a >> 3 = {:0>8b}\", a >> 3);\n}",
    "title": "Bitwise operations",
    "url": "http://rosettacode.org/wiki/Bitwise_operations"
  },
  {
    "local_code": "fn main() {\n    // Rust contains a single boolean type: `bool`, represented by the keywords `true` and `false`.\n    // Expressions inside `if` and `while` statements must result in type `bool`. There is no\n    // automatic conversion to the boolean type.\n\n    let true_value = true;\n    if true_value {\n        println!(\"foo is {}.\", true_value);\n    }\n\n    let false_value = false;\n    if !false_value {\n        println!(\"bar is {}.\", false_value);\n    }\n}\n",
    "path": "tasks/boolean-values",
    "remote_code": "\nfn main() {\n    // Rust contains a single boolean type: `bool`, represented by the keywords `true` and `false`.\n    // Expressions inside `if` and `while` statements must result in type `bool`. There is no\n    // automatic conversion to the boolean type.\n\n    let true_value = true;\n    if true_value {\n        println!(\"foo is {}.\", true_value);\n    }\n\n    let false_value = false;\n    if !false_value {\n        println!(\"bar is {}.\", false_value);\n    }\n}\n",
    "title": "Boolean values",
    "url": "http://rosettacode.org/wiki/Boolean_values"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn expand(cp: &str) -> String {\n    let mut out = String::new();\n    for c in cp.chars() {\n        out.push_str(match c {\n            'N' => \"north\",\n            'E' => \"east\",\n            'S' => \"south\",\n            'W' => \"west\",\n            'b' => \" by \",\n            _ => \"-\",\n        });\n    }\n    out\n}\n\nfn main() {\n    let cp = [\n        \"N\", \"NbE\", \"N-NE\", \"NEbN\", \"NE\", \"NEbE\", \"E-NE\", \"EbN\",\n        \"E\", \"EbS\", \"E-SE\", \"SEbE\", \"SE\", \"SEbS\", \"S-SE\", \"SbE\",\n        \"S\", \"SbW\", \"S-SW\", \"SWbS\", \"SW\", \"SWbW\", \"W-SW\", \"WbS\",\n        \"W\", \"WbN\", \"W-NW\", \"NWbW\", \"NW\", \"NWbN\", \"N-NW\", \"NbW\"\n    ];\n    println!(\"Index  Degrees  Compass point\");\n    println!(\"-----  -------  -------------\");\n    for i in 0..=32 {\n        let index = i % 32;\n        let heading = i as f32 * 11.25\n            + match i % 3 {\n                1 => 5.62,\n                2 => -5.62,\n                _ => 0.0,\n            };\n        println!(\n            \"{:2}     {:6.2}   {}\",\n            index + 1,\n            heading,\n            expand(cp[index])\n        );\n    }\n}",
    "title": "Box the compass",
    "url": "http://rosettacode.org/wiki/Box_the_compass"
  },
  {
    "local_code": "use std::char;\n\nuse crate::{Branches, CLOSE_CHAR, OPEN_CHAR, SEPARATOR};\n\n#[derive(Clone, PartialEq, Debug)]\npub enum Token {\n    Open,\n    Close,\n    Separator,\n    Payload(String),\n    Branches(Branches),\n}\n\nimpl From<char> for Token {\n    fn from(ch: char) -> Token {\n        match ch {\n            OPEN_CHAR => Token::Open,\n            CLOSE_CHAR => Token::Close,\n            SEPARATOR => Token::Separator,\n            _ => panic!(\"Non tokenizable char!\"),\n        }\n    }\n}\n\nimpl From<Branches> for Token {\n    fn from(branches: Branches) -> Token {\n        Token::Branches(branches)\n    }\n}\n\nimpl From<Token> for String {\n    fn from(token: Token) -> String {\n        match token {\n            Token::Open => OPEN_CHAR.to_string(),\n            Token::Close => CLOSE_CHAR.to_string(),\n            Token::Separator => SEPARATOR.to_string(),\n            Token::Payload(text) => text,\n            Token::Branches(_) => panic!(\"Cannot convert to String!\"),\n        }\n    }\n}\n\nimpl From<Token> for Vec<String> {\n    fn from(token: Token) -> Vec<String> {\n        match token {\n            Token::Branches(branches) => branches.into(),\n            _ => {\n                let frag: String = token.into();\n                vec![frag]\n            }\n        }\n    }\n}\nuse crate::{Branches, Token, CLOSE_CHAR, ESCAPE, OPEN_CHAR, SEPARATOR};\n\npub fn tokenize(string: &str) -> Vec<Token> {\n    let mut tokens: Vec<Token> = Vec::new();\n    let mut chars = string.chars();\n    let mut payload = String::new();\n\n    while let Some(ch) = chars.next() {\n        match ch {\n            OPEN_CHAR | SEPARATOR | CLOSE_CHAR => {\n                if payload.len() > 0 {\n                    tokens.push(Token::Payload(payload));\n                    payload = String::new();\n                }\n\n                if ch == CLOSE_CHAR {\n                    let pos = tokens.iter().rposition(|token| *token == Token::Open);\n\n                    if let Some(pos) = pos {\n                        let branches: Branches = {\n                            let mut to_branches = tokens.split_off(pos);\n                            to_branches.remove(0);\n                            to_branches\n                        }\n                        .into();\n                        tokens.push(branches.into());\n                    } else {\n                        tokens.push(ch.into());\n                    }\n                } else {\n                    tokens.push(ch.into());\n                }\n            }\n            ESCAPE => {\n                payload.push(ch);\n\n                if let Some(next_char) = chars.next() {\n                    payload.push(next_char);\n                }\n            }\n            _ => payload.push(ch),\n        }\n    }\n\n    let payload = payload.trim_end();\n\n    if payload.len() > 0 {\n        tokens.push(Token::Payload(payload.into()));\n    }\n\n    tokens\n}\n\npub fn expand(tokens: Vec<Token>) -> Vec<String> {\n    let mut output = vec![String::new()];\n\n    for token in tokens {\n        let mut aux: Vec<String> = Vec::new();\n        let strings: Vec<String> = token.into();\n\n        for root in &output {\n            for string in &strings {\n                aux.push(format!(\"{}{}\", root, string));\n            }\n        }\n\n        output = aux;\n    }\n\n    output\n}\nmod branches;\nmod constants;\nmod token;\nmod utils;\n\npub use branches::*;\npub use constants::*;\npub use token::*;\npub use utils::*;\nuse brace_expansion::{expand, tokenize};\n\nfn main() {\n    let mut input: String = String::new();\n\n    std::io::stdin().read_line(&mut input).unwrap();\n\n    let tokens = tokenize(&input);\n    let expanded = expand(tokens);\n\n    for line in &expanded {\n        println!(\"{}\", line);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn case1() {\n        let input = r\"~/{Downloads,Pictures}/*.{jpg,gif,png}\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\n            \"~/Downloads/*.jpg\",\n            \"~/Downloads/*.gif\",\n            \"~/Downloads/*.png\",\n            \"~/Pictures/*.jpg\",\n            \"~/Pictures/*.gif\",\n            \"~/Pictures/*.png\",\n        ];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case2() {\n        let input = \"It{{em,alic}iz,erat}e{d,}, please.\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\n            \"Itemized, please.\",\n            \"Itemize, please.\",\n            \"Italicized, please.\",\n            \"Italicize, please.\",\n            \"Iterated, please.\",\n            \"Iterate, please.\",\n        ];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case3() {\n        let input = r\"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\n            \"cowbell!\",\n            \"more cowbell!\",\n            \"gotta have more cowbell!\",\n            r\"gotta have\\, again\\, more cowbell!\",\n        ];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case4() {\n        let input = r\"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\n            r\"{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\",\n            r\"{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\",\n        ];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case5() {\n        let input = \"a{b{1,2}c\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\"a{b1c\", \"a{b2c\"];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case6() {\n        let input = r\"a{1,2}b}c\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\"a1b}c\", \"a2b}c\"];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case7() {\n        let input = \"a{1,{2},3}b\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\"a1b\", \"a{2}b\", \"a3b\"];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case8() {\n        let input = \"a{b{1,2}c{}}\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\"a{b1c{}}\", \"a{b2c{}}\"];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case9() {\n        let input = \"more{ darn{ cowbell,},}\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\"more darn cowbell\", \"more darn\", \"more\"];\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn case10() {\n        let input = r\"ab{c,d\\,e{f,g\\h},i\\,j{k,l\\,m}n,o\\,p}qr\";\n        let actual = expand(tokenize(input));\n        let expected = vec![\n            \"abcqr\",\n            r\"abd\\,efqr\",\n            r\"abd\\,eg\\hqr\",\n            r\"abi\\,jknqr\",\n            r\"abi\\,jl\\,mnqr\",\n            r\"abo\\,pqr\",\n        ];\n\n        assert_eq!(actual, expected);\n    }\n}\nuse crate::{expand, Token, CLOSE_CHAR, OPEN_CHAR};\n\n#[derive(Clone, PartialEq, Debug)]\npub struct Branches {\n    tokens: Vec<Vec<Token>>,\n}\n\nimpl Branches {\n    pub fn new() -> Self {\n        Branches { tokens: Vec::new() }\n    }\n\n    pub fn add_branch(&mut self, branch: Vec<Token>) {\n        self.tokens.push(branch);\n    }\n}\n\nimpl From<Vec<Token>> for Branches {\n    fn from(tokens: Vec<Token>) -> Branches {\n        let mut branches = Branches::new();\n        let mut tail = tokens.clone();\n\n        while let Some(pos) = tail.iter().position(|token| *token == Token::Separator) {\n            let mut rest = tail.split_off(pos);\n\n            branches.add_branch(tail);\n            rest.remove(0);\n            tail = rest;\n        }\n\n        branches.add_branch(tail);\n        branches\n    }\n}\n\nimpl From<Branches> for Vec<String> {\n    fn from(branches: Branches) -> Vec<String> {\n        let Branches {\n            tokens: token_lines,\n        } = branches;\n        let mut vec: Vec<String> = Vec::new();\n        let braces = {\n            if token_lines.len() == 1 {\n                true\n            } else {\n                false\n            }\n        };\n\n        for tokens in token_lines {\n            let mut vec_string = expand(tokens);\n            vec.append(&mut vec_string);\n        }\n\n        if braces {\n            vec.iter()\n                .map(|line| format!(\"{}{}{}\", OPEN_CHAR, line, CLOSE_CHAR))\n                .collect()\n        } else {\n            vec\n        }\n    }\n}\npub const OPEN_CHAR: char = '{';\npub const CLOSE_CHAR: char = '}';\npub const SEPARATOR: char = ',';\npub const ESCAPE: char = '\\\\';\n",
    "path": "tasks/brace-expansion",
    "remote_code": "const OPEN_CHAR: char = '{';\nconst CLOSE_CHAR: char = '}';\nconst SEPARATOR: char = ',';\nconst ESCAPE: char = '\\\\';\n\n#[derive(Debug, PartialEq, Clone)]\nenum Token {\n    Open,\n    Close,\n    Separator,\n    Payload(String),\n    Branches(Branches),\n}\n\nimpl From<char> for Token {\n    fn from(ch: char) -> Token {\n        match ch {\n            OPEN_CHAR => Token::Open,\n            CLOSE_CHAR => Token::Close,\n            SEPARATOR => Token::Separator,\n            _ => panic!(\"Non tokenizable char!\"),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Clone)]\nstruct Branches {\n    tokens: Vec<Vec<Token>>,\n}\n\nimpl Branches {\n    fn new() -> Branches {\n        Branches{\n            tokens: Vec::new(),\n        }\n    }\n\n    fn add_branch(&mut self, branch: Vec<Token>) {\n        self.tokens.push(branch);\n    }\n\n    fn from(tokens: &Vec<Token>) -> Branches {\n        let mut branches = Branches::new();\n        let mut tail = tokens.clone();\n        while let Some(pos) = tail.iter().position(|token| { *token == Token::Separator }) {\n            let mut rest = tail.split_off(pos);\n            branches.add_branch(tail);\n            rest.remove(0);\n            tail = rest;\n        }\n        branches.add_branch(tail);\n        branches\n    }\n}\n\nimpl From<Branches> for Token {\n    fn from(branches: Branches) -> Token {\n        Token::Branches(branches)\n    }\n}\n\nimpl From<Vec<Token>> for Branches {\n    fn from(tokens: Vec<Token>) -> Branches {\n        Branches::from(&tokens)\n    }\n}\n\nimpl From<Token> for String {\n    fn from(token: Token) -> String {\n        match token {\n            Token::Branches(_) => panic!(\"Cannot convert to String!\"),\n            Token::Payload(text) => text,\n            Token::Open => OPEN_CHAR.to_string(),\n            Token::Close => CLOSE_CHAR.to_string(),\n            Token::Separator => SEPARATOR.to_string(),\n        }\n    }\n}\n\nimpl From<Branches> for Vec<String> {\n    fn from(branches: Branches) -> Vec<String> {\n        let Branches{ tokens: token_lines } = branches;\n        let mut vec: Vec<String> = Vec::new();\n        let braces = { if token_lines.len() == 1 { true } else { false } };\n        for tokens in token_lines {\n            let mut vec_string = output(tokens);\n            vec.append(&mut vec_string);\n        }\n        if braces {\n            vec.iter()\n                .map(|line| {\n                    format!(\"{}{}{}\", OPEN_CHAR, line, CLOSE_CHAR)\n                }).\n                collect::<Vec<String>>()\n        } else {\n            vec\n        }\n    }\n}\n\nimpl From<Token> for Vec<String> {\n    fn from(token: Token) -> Vec<String> {\n        match token {\n            Token::Branches(branches) => {\n                branches.into()\n            },\n            _ => {\n                let frag: String = token.into();\n                vec![frag]\n            },\n        }\n    }\n}\n\nfn tokenize(string: &str) -> Vec<Token> {\n    let mut tokens: Vec<Token> = Vec::new();\n    let mut chars = string.chars();\n    let mut payload = String::new();\n    while let Some(ch) = chars.next() {\n        match ch {\n            OPEN_CHAR | SEPARATOR | CLOSE_CHAR => {\n                if payload.len() > 0 {\n                    tokens.push(Token::Payload(payload));\n                }\n                payload = String::new();\n                if ch == CLOSE_CHAR {\n                    let pos = tokens.iter().rposition(|token| *token == Token::Open);\n                    if let Some(pos) = pos {\n                        let branches: Branches = {\n                            let mut to_branches = tokens.split_off(pos);\n                            to_branches.remove(0);\n                            to_branches\n                        }.into();\n                        tokens.push(branches.into());\n                    } else {\n                        tokens.push(ch.into());\n                    }\n                } else {\n                    tokens.push(ch.into());\n                }\n            },\n            ESCAPE => {\n                payload.push(ch);\n                if let Some(next_char) = chars.next() {\n                    payload.push(next_char);\n                }\n            },\n            _ => payload.push(ch),\n        }\n    }\n    let payload = payload.trim_end();\n    if payload.len() > 0 {\n        tokens.push(Token::Payload(payload.into()));\n    }\n    tokens\n}\n\nfn output(tokens: Vec<Token>) -> Vec<String> {\n    let mut output: Vec<String> = vec![String::new()];\n    for token in tokens {\n        let mut aux: Vec<String> = Vec::new();\n        let strings: Vec<String> = token.into();\n        for root in &output {\n            for string in &strings {\n                aux.push({format!(\"{}{}\", root, string)});\n            }\n        }\n        output = aux;\n    }\n    output\n}\n\nfn main() {\n    let mut input: String = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n\n    let tokens: Vec<Token> = tokenize(&input);\n    // println!(\"Tokens:\\n{:#?}\", tokens);\n\n    let output = output(tokens);\n    for line in &output {\n        println!(\"{}\", line);\n    }\n}",
    "title": "Brace expansion",
    "url": "http://rosettacode.org/wiki/Brace_expansion"
  },
  {
    "local_code": "fn same_digits(x: u64, base: u64) -> bool {\n    let f = x % base;\n    let mut n = x;\n    while n > 0 {\n        if n % base != f {\n            return false;\n        }\n        n /= base;\n    }\n\n    true\n}\nfn is_brazilian(x: u64) -> bool {\n    if x < 7 {\n        return false;\n    };\n    if x % 2 == 0 {\n        return true;\n    };\n\n    for base in 2..(x - 1) {\n        if same_digits(x, base) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let mut counter = 0;\n    let limit = 20;\n    let big_limit = 100_000;\n    let mut big_result: u64 = 0;\n    let mut br: Vec<u64> = Vec::new();\n    let mut o: Vec<u64> = Vec::new();\n    let mut p: Vec<u64> = Vec::new();\n\n    for x in 7.. {\n        if is_brazilian(x) {\n            counter += 1;\n            if br.len() < limit {\n                br.push(x);\n            }\n            if o.len() < limit && x % 2 == 1 {\n                o.push(x);\n            }\n            if p.len() < limit && primes::is_prime(x) {\n                p.push(x);\n            }\n            if counter == big_limit {\n                big_result = x;\n                break;\n            }\n        }\n    }\n    println!(\"First {} Brazilian numbers:\", limit);\n    println!(\"{:?}\", br);\n    println!(\"\\nFirst {} odd Brazilian numbers:\", limit);\n    println!(\"{:?}\", o);\n    println!(\"\\nFirst {} prime Brazilian numbers:\", limit);\n    println!(\"{:?}\", p);\n\n    println!(\"\\nThe {}th Brazilian number: {}\", big_limit, big_result);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_brazilian;\n\n    #[test]\n    fn test_is_brazilian() {\n        assert_eq!(false, is_brazilian(0));\n        assert_eq!(true, is_brazilian(7));\n        assert_eq!(true, is_brazilian(8));\n        assert_eq!(false, is_brazilian(11));\n        assert_eq!(true, is_brazilian(2801));\n    }\n}\n",
    "path": "tasks/brazilian-numbers",
    "remote_code": "\nfn same_digits(x: u64, base: u64) -> bool {\n    let f = x % base;\n    let mut n = x;\n    while n > 0 {\n        if n % base != f {\n            return false;\n        }\n        n /= base;\n    }\n\n    true\n}\nfn is_brazilian(x: u64) -> bool {\n    if x < 7 {\n        return false;\n    };\n    if x % 2 == 0 {\n        return true;\n    };\n\n    for base in 2..(x - 1) {\n        if same_digits(x, base) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let mut counter = 0;\n    let limit = 20;\n    let big_limit = 100_000;\n    let mut big_result: u64 = 0;\n    let mut br: Vec<u64> = Vec::new();\n    let mut o: Vec<u64> = Vec::new();\n    let mut p: Vec<u64> = Vec::new();\n\n    for x in 7.. {\n        if is_brazilian(x) {\n            counter += 1;\n            if br.len() < limit {\n                br.push(x);\n            }\n            if o.len() < limit && x % 2 == 1 {\n                o.push(x);\n            }\n            if p.len() < limit && primes::is_prime(x) {\n                p.push(x);\n            }\n            if counter == big_limit {\n                big_result = x;\n                break;\n            }\n        }\n    }\n    println!(\"First {} Brazilian numbers:\", limit);\n    println!(\"{:?}\", br);\n    println!(\"\\nFirst {} odd Brazilian numbers:\", limit);\n    println!(\"{:?}\", o);\n    println!(\"\\nFirst {} prime Brazilian numbers:\", limit);\n    println!(\"{:?}\", p);\n\n    println!(\"\\nThe {}th Brazilian number: {}\", big_limit, big_result);\n}\n",
    "title": "Brazilian numbers",
    "url": "http://rosettacode.org/wiki/Brazilian_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Break OO privacy",
    "url": "http://rosettacode.org/wiki/Break_OO_privacy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// indexing = \"0.4.1\"\n\nfn get_primes_by_digits(limit: usize) -> Vec<Vec<usize>> {\n    let mut primes_by_digits = Vec::new();\n    let mut power = 10;\n    let mut primes = Vec::new();\n    for prime in primal::Primes::all().take_while(|p| *p < limit) {\n        if prime > power {\n            primes_by_digits.push(primes);\n            primes = Vec::new();\n            power *= 10;\n        }\n        primes.push(prime);\n    }\n    primes_by_digits.push(primes);\n    primes_by_digits\n}\n\nfn main() {\n    use indexing::algorithms::lower_bound;\n    use std::time::Instant;\n\n    let start = Instant::now();\n\n    let primes_by_digits = get_primes_by_digits(1000000000);\n\n    println!(\"First 100 brilliant numbers:\");\n    let mut brilliant_numbers = Vec::new();\n    for primes in &primes_by_digits {\n        for i in 0..primes.len() {\n            let p1 = primes[i];\n            for j in i..primes.len() {\n                let p2 = primes[j];\n                brilliant_numbers.push(p1 * p2);\n            }\n        }\n        if brilliant_numbers.len() >= 100 {\n            break;\n        }\n    }\n    brilliant_numbers.sort();\n    for i in 0..100 {\n        let n = brilliant_numbers[i];\n        print!(\"{:4}{}\", n, if (i + 1) % 10 == 0 { '\\n' } else { ' ' });\n    }\n\n    println!();\n    let mut power = 10;\n    let mut count = 0;\n    for p in 1..2 * primes_by_digits.len() {\n        let primes = &primes_by_digits[p / 2];\n        let mut position = count + 1;\n        let mut min_product = 0;\n        for i in 0..primes.len() {\n            let p1 = primes[i];\n            let n = (power + p1 - 1) / p1;\n            let j = lower_bound(&primes[i..], &n);\n            let p2 = primes[i + j];\n            let product = p1 * p2;\n            if min_product == 0 || product < min_product {\n                min_product = product;\n            }\n            position += j;\n            if p1 >= p2 {\n                break;\n            }\n        }\n        println!(\"First brilliant number >= 10^{p} is {min_product} at position {position}\");\n        power *= 10;\n        if p % 2 == 1 {\n            let size = primes.len();\n            count += size * (size + 1) / 2;\n        }\n    }\n\n    let time = start.elapsed();\n    println!(\"\\nElapsed time: {} milliseconds\", time.as_millis());\n}",
    "title": "Brilliant numbers",
    "url": "http://rosettacode.org/wiki/Brilliant_numbers"
  },
  {
    "local_code": "use std::cmp::min;\nuse std::env;\nuse std::path::Path;\nuse std::process;\n\nuse image::ColorType;\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\nfn help() {\n    println!(\"Usage: brownian_tree <output_path> <mote_count> <edge_length>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut output_path = Path::new(\"out.png\");\n    let mut mote_count: u32 = 10_000;\n    let mut width: usize = 512;\n    let mut height: usize = 512;\n\n    match args.len() {\n        1 => {}\n        4 => {\n            output_path = Path::new(&args[1]);\n            mote_count = args[2].parse::<u32>().unwrap();\n            width = args[3].parse::<usize>().unwrap();\n            height = width;\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    assert!(width >= 2);\n\n    // Base 1d array\n    let mut field_raw = vec![0u8; width * height];\n    populate_tree(&mut field_raw, width, height, mote_count);\n\n    // Balance image for 8-bit grayscale\n    let our_max = field_raw.iter().max().unwrap();\n    let fudge = u8::max_value() / our_max;\n    let balanced: Vec<u8> = field_raw.iter().map(|e| e * fudge).collect();\n\n    match image::save_buffer(\n        output_path,\n        &balanced,\n        width as u32,\n        height as u32,\n        ColorType::L8,\n    ) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n\nfn populate_tree(raw: &mut Vec<u8>, width: usize, height: usize, mc: u32) {\n    // Vector of 'width' elements slices\n    let mut field_base: Vec<_> = raw.chunks_mut(width).collect();\n    // Addressable 2d vector\n    let field = field_base.as_mut_slice();\n\n    // Seed mote\n    field[width / 2][height / 2] = 1;\n\n    let x_spawn_range = Uniform::new(1, width - 1);\n    let y_spawn_range = Uniform::new(1, height - 1);\n    let mut rng = thread_rng();\n\n    for i in 0..mc {\n        if i % 100 == 0 {\n            println!(\"{}\", i)\n        }\n\n        // Spawn mote\n        let mut x = rng.sample(x_spawn_range);\n        let mut y = rng.sample(y_spawn_range);\n\n        // Increment field value when motes spawn on top of the structure\n        if field[x][y] > 0 {\n            field[x][y] = min(field[x][y] + 1, u8::max_value()) as u8;\n            continue;\n        }\n\n        loop {\n            let contacts = field[x - 1][y - 1]\n                + field[x][y - 1]\n                + field[x + 1][y - 1]\n                + field[x - 1][y]\n                + field[x + 1][y]\n                + field[x - 1][y + 1]\n                + field[x][y + 1]\n                + field[x + 1][y + 1];\n\n            if contacts > 0 {\n                field[x][y] = min(field[x][y] + 1, u8::max_value()) as u8;\n                break;\n            } else {\n                let range = Uniform::new(-1, 2);\n                let xw = rng.sample(range) + x as i32;\n                let yw = rng.sample(range) + y as i32;\n                if xw < 1 || xw >= (width as i32 - 1) || yw < 1 || yw >= (height as i32 - 1) {\n                    // println!(\"wandered off\");\n                    break;\n                }\n                x = xw as usize;\n                y = yw as usize;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::populate_tree;\n\n    #[test]\n    fn test_brownian_tree() {\n        let width = 128;\n        let height = 128;\n        let mote_count = 1000;\n        let mut field_raw = vec![0u8; width * height];\n        populate_tree(&mut field_raw, width, height, mote_count);\n        let our_max = field_raw.iter().max().unwrap();\n        assert!(*our_max >= 1);\n    }\n}\n",
    "path": "tasks/brownian-tree",
    "remote_code": "\nextern crate image;\nextern crate rand;\n\nuse image::ColorType;\n\nuse std::cmp::{min, max};\nuse std::env;\nuse std::path::Path;\nuse std::process;\nuse rand::Rng;\n\nfn help() {\n    println!(\"Usage: brownian_tree <output_path> <mote_count> <edge_length>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut output_path = Path::new(\"out.png\");\n    let mut mote_count: u32 = 10000;\n    let mut width: usize = 512;\n    let mut height: usize = 512;\n\n    match args.len() {\n        1 => {}\n        4 => {\n            output_path = Path::new(&args[1]);\n            mote_count = args[2].parse::<u32>().unwrap();\n            width = args[3].parse::<usize>().unwrap();\n            height = width;\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    assert!(width >= 2);\n\n    // Base 1d array\n    let mut field_raw = vec![0u8; width * height];\n    populate_tree(&mut field_raw, width, height, mote_count);\n\n    // Balance image for 8-bit grayscale\n    let our_max = field_raw.iter().fold(0u8, |champ, e| max(champ, *e));\n    let fudge = std::u8::MAX / our_max;\n    let balanced: Vec<u8> = field_raw.iter().map(|e| e * fudge).collect();\n\n    match image::save_buffer(output_path,\n                             &balanced,\n                             width as u32,\n                             height as u32,\n                             ColorType::L8) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n\n\nfn populate_tree(raw: &mut Vec<u8>, width: usize, height: usize, mc: u32) {\n    // Vector of 'width' elements slices\n    let mut field_base: Vec<_> = raw.as_mut_slice().chunks_mut(width).collect();\n    // Addressable 2d vector\n    let field: &mut [&mut [u8]] = field_base.as_mut_slice();\n\n    // Seed mote\n    field[width / 2][height / 2] = 1;\n\n    let mut rng = rand::thread_rng();\n\n    for i in 0..mc {\n        if i % 100 == 0 {\n            println!(\"{}\", i)\n        }\n\n        let mut x=rng.gen_range(1usize..width-1);\n        let mut y=rng.gen_range(1usize..height-1);\n\n        // Increment field value when motes spawn on top of the structure\n        if field[x][y] > 0 {\n            field[x][y] = min(field[x][y] as u32 + 1, std::u8::MAX as u32) as u8;\n            continue;\n        }\n\n        loop {\n            let contacts = field[x - 1][y - 1] + field[x][y - 1] + field[x + 1][y - 1] +\n                field[x - 1][y] + field[x + 1][y] +\n                field[x - 1][y + 1] + field[x][y + 1] +\n                field[x + 1][y + 1];\n\n            if contacts > 0 {\n                field[x][y] = 1;\n                break;\n            } else {\n                let xw = rng.gen_range(-1..2) + x as i32;\n                let yw = rng.gen_range(-1..2) + y as i32;\n                if xw < 1 || xw >= (width as i32 - 1) || yw < 1 || yw >= (height as i32 - 1) {\n                    break;\n                }\n                x = xw as usize;\n                y = yw as usize;\n            }\n        }\n    }\n}",
    "title": "Brownian tree",
    "url": "http://rosettacode.org/wiki/Brownian_tree"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::fmt::{self, Display};\n\nuse rand::prelude::*;\n\nconst NUMBER_OF_DIGITS: usize = 4;\n\n/// Generates `NUMBER_OF_DIGITS` random unique digits.\nfn generate_digits(rng: &mut impl Rng) -> Vec<u32> {\n    (1..=9).choose_multiple(rng, NUMBER_OF_DIGITS)\n}\n\n/// types of errors we can have when parsing a malformed guess\n#[derive(Debug, PartialEq, Eq)]\nenum ParseError {\n    NotValidDigit,\n    ExpectedNumberOfDigits(usize),\n    NoDuplicates,\n}\n\n/// printable description for each `ParseError`\nimpl fmt::Display for ParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            ParseError::NotValidDigit => Display::fmt(\"only digits from 1 to 9, please\", f),\n            ParseError::ExpectedNumberOfDigits(exp) => {\n                write!(f, \"you need to guess with {} digits\", exp)\n            }\n            ParseError::NoDuplicates => Display::fmt(\"no duplicates, please\", f),\n        }\n    }\n}\n\n/// a well-formed guess string should be like \"1543\", with `NUMBER_OF_DIGITS` digits, no\n/// repetitions, no separators or other characters. Parse the guess string as a `Vec<usize>` or\n/// return a `ParseError`. This could trivially return a `[usize; NUMBER_OF_DIGITS]` instead of a\n/// `Vec<usize>` and avoid dynamic allocations. However, in the more general case,\n/// `NUMBER_OF_DIGITS` would not be a constant, but a runtime configuration (which would make using\n/// a stack-allocated array more difficult)\nfn parse_guess_string(guess: &str) -> Result<Vec<u32>, ParseError> {\n    let mut ret = Vec::with_capacity(NUMBER_OF_DIGITS);\n\n    for (i, c) in guess.char_indices() {\n        // check that our guess contains the right number of digits\n        if i >= NUMBER_OF_DIGITS {\n            return Err(ParseError::ExpectedNumberOfDigits(NUMBER_OF_DIGITS));\n        }\n        match c.to_digit(10) {\n            Some(d) if d > 0 => {\n                // the guess should not contain duplicate digits\n                if ret.contains(&d) {\n                    return Err(ParseError::NoDuplicates);\n                }\n                ret.push(d);\n            }\n            _ => return Err(ParseError::NotValidDigit),\n        }\n    }\n\n    Ok(ret)\n}\n\n/// returns a tuple with the count of Bulls and Cows in the guess\nfn calculate_score(given_digits: &[u32], guessed_digits: &[u32]) -> (usize, usize) {\n    let mut bulls = 0;\n    let mut cows = 0;\n    for (i, given_digit) in given_digits.iter().enumerate().take(NUMBER_OF_DIGITS) {\n        let pos = guessed_digits.iter().position(|a| a == given_digit);\n\n        match pos {\n            None => (),\n            Some(p) if p == i => bulls += 1,\n            Some(_) => cows += 1,\n        }\n    }\n    (bulls, cows)\n}\n\nfn main() {\n    let reader = std::io::stdin();\n    let mut rng = rand::thread_rng();\n\n    loop {\n        let given_digits = generate_digits(&mut rng);\n        println!(\n            \"I have chosen my {} digits. Please guess what they are\",\n            NUMBER_OF_DIGITS\n        );\n        loop {\n            let mut guess_string = String::new();\n            let _ = reader.read_line(&mut guess_string).unwrap();\n            let digits_maybe = parse_guess_string(guess_string.trim());\n            match digits_maybe {\n                Err(msg) => {\n                    println!(\"{}\", msg);\n                }\n                Ok(guess_digits) => match calculate_score(&given_digits, &guess_digits) {\n                    (NUMBER_OF_DIGITS, _) => {\n                        println!(\"you win!\");\n                        break;\n                    }\n                    (bulls, cows) => println!(\"bulls: {}, cows: {}\", bulls, cows),\n                },\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ParseError;\n\n    /// test we generate `NUMBER_OF_DIGITS` unique digits between 1 and 9\n    #[test]\n    fn generate_digits() {\n        let mut rng = super::rand::thread_rng();\n        let mut digits = super::generate_digits(&mut rng);\n        assert!(digits.iter().all(|&d| d > 0));\n        digits.sort_unstable();\n        digits.dedup();\n        assert_eq!(digits.len(), super::NUMBER_OF_DIGITS)\n    }\n\n    #[test]\n    fn parse_guess_string() {\n        match super::parse_guess_string(\"1234\") {\n            Ok(p) => assert_eq!(p, vec![1, 2, 3, 4]),\n            _ => panic!(\"Failed parsing a valid string\"),\n        }\n\n        assert_eq!(\n            super::parse_guess_string(\"0123\"),\n            Err(ParseError::NotValidDigit)\n        );\n        assert_eq!(\n            super::parse_guess_string(\"1213\"),\n            Err(ParseError::NoDuplicates)\n        );\n        assert_eq!(\n            super::parse_guess_string(\"12354\"),\n            Err(ParseError::ExpectedNumberOfDigits(4))\n        );\n    }\n\n    #[test]\n    fn calculate_score() {\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[1, 2, 3, 4]), (4, 0));\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[1, 2, 4, 3]), (2, 2));\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[5, 6, 7, 8]), (0, 0));\n    }\n}\n",
    "path": "tasks/bulls-and-cows",
    "remote_code": "use std::io;\nuse rand::{Rng,thread_rng};\n\nextern crate rand;\n\nconst NUMBER_OF_DIGITS: usize = 4;\n\nstatic DIGITS: [char; 9] = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nfn generate_digits() -> Vec<char> {\n    let mut temp_digits: Vec<_> = (&DIGITS[..]).into();\n    thread_rng().shuffle(&mut temp_digits);\n    return temp_digits.iter().take(NUMBER_OF_DIGITS).map(|&a| a).collect();\n}\n\nfn parse_guess_string(guess: &str) -> Result<Vec<char>, String> {\n    let chars: Vec<char> = (&guess).chars().collect();\n\n    if !chars.iter().all(|c| DIGITS.contains(c)) {\n        return Err(\"only digits, please\".to_string());\n    }\n\n    if chars.len() != NUMBER_OF_DIGITS {\n        return Err(format!(\"you need to guess with {} digits\", NUMBER_OF_DIGITS));\n    }\n\n    let mut uniques: Vec<char> = chars.clone();\n    uniques.dedup();\n    if uniques.len() != chars.len() {\n        return Err(\"no duplicates, please\".to_string());\n    }\n\n    return Ok(chars);\n}\n\nfn calculate_score(given_digits: &[char], guessed_digits: &[char]) -> (usize, usize) {\n    let mut bulls = 0;\n    let mut cows = 0;\n    for i in 0..NUMBER_OF_DIGITS {\n        let pos: Option<usize> = guessed_digits.iter().position(|&a| -> bool {a == given_digits[i]});\n        match pos {\n            None              => (),\n            Some(p) if p == i => bulls += 1,\n            Some(_)           => cows += 1\n        }\n    }\n    return (bulls, cows);\n}\n\nfn main() {\n    let reader = io::stdin();\n\n    loop {\n        let given_digits = generate_digits();\n        println!(\"I have chosen my {} digits. Please guess what they are\", NUMBER_OF_DIGITS);\n\n        loop {\n            let guess_string: String = {\n                let mut buf = String::new();\n                reader.read_line(&mut buf).unwrap();\n                buf.trim().into()\n            };\n\n            let digits_maybe = parse_guess_string(&guess_string);\n            match digits_maybe {\n                Err(msg) => {\n                    println!(\"{}\", msg);\n                    continue;\n                },\n                Ok(guess_digits) => {\n                    match calculate_score(&given_digits, &guess_digits) {\n                        (NUMBER_OF_DIGITS, _) => {\n                            println!(\"you win!\");\n                            break;\n                        },\n                        (bulls, cows) => println!(\"bulls: {}, cows: {}\", bulls, cows)\n                    }\n                }\n            }\n        }\n    }\n}",
    "title": "Bulls and cows",
    "url": "http://rosettacode.org/wiki/Bulls_and_cows"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bulls and cows/Player",
    "url": "http://rosettacode.org/wiki/Bulls_and_cows/Player"
  },
  {
    "local_code": "use core::cmp::Ordering;\n\nconst STX: char = '\\u{0002}';\nconst ETX: char = '\\u{0003}';\n\n// this compare uses simple alphabetical sort, but for the special characters (ETX, STX)\n// it sorts them later than alphanumeric characters\n#[must_use]\npub fn special_cmp(lhs: &str, rhs: &str) -> Ordering {\n    let mut iter1 = lhs.chars();\n    let mut iter2 = rhs.chars();\n\n    loop {\n        match (iter1.next(), iter2.next()) {\n            (Some(lhs), Some(rhs)) => {\n                if lhs != rhs {\n                    let is_left_hs_special = lhs == ETX || lhs == STX;\n                    let is_right_hs_special = rhs == ETX || rhs == STX;\n\n                    let result = if is_left_hs_special == is_right_hs_special {\n                        lhs.cmp(&rhs)\n                    } else if is_left_hs_special {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Less\n                    };\n\n                    return result;\n                }\n            }\n            (Some(_), None) => return Ordering::Greater,\n            (None, Some(_)) => return Ordering::Less,\n            (None, None) => return lhs.cmp(rhs),\n        }\n    }\n}\n\nfn burrows_wheeler_transform(input: &str) -> String {\n    let mut table: Vec<String> = vec![];\n\n    // add markers for the start and end\n    let input_string = format!(\"{}{}{}\", STX, input, ETX);\n\n    // create all possible rotations\n    for (i, _) in input_string.char_indices() {\n        table.push(format!(\n            \"{}{}\",\n            &input_string[input_string.len() - 1 - i..],\n            &input_string[0..input_string.len() - 1 - i]\n        ));\n    }\n\n    // sort rows alphabetically\n    table.sort_unstable_by(|lhs, rhs| special_cmp(lhs, rhs));\n\n    // return the last column\n    table\n        .iter()\n        .map(|s| s.chars().nth_back(0).unwrap())\n        .collect::<String>()\n}\n\nfn inverse_burrows_wheeler_transform(input: &str) -> String {\n    let mut table: Vec<String> = vec![String::new(); input.len()];\n    for _ in 0..input.len() {\n        // insert the charatcers of the encoded input as a first column for each row\n        for (j, s) in table.iter_mut().enumerate() {\n            *s = format!(\"{}{}\", input.chars().nth(j).unwrap(), s);\n        }\n\n        // sort rows alphabetically\n        table.sort_unstable_by(|lhs, rhs| special_cmp(lhs, rhs));\n    }\n\n    // return the row which has the end marker at the last position\n    table\n        .into_iter()\n        .filter(|s| s.ends_with(ETX))\n        .collect::<String>()\n        .replace(STX, \"\")\n        .replace(ETX, \"\")\n}\n\nfn main() {\n    let input = [\n        \"banana\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n    ];\n    for s in &input {\n        let bwt = burrows_wheeler_transform(s);\n        let inverse_bwt = inverse_burrows_wheeler_transform(&bwt);\n        println!(\"Input: {}\", s);\n        println!(\"\\tBWT: {}\", bwt.replace(STX, \"^\").replace(ETX, \"|\"));\n        println!(\"\\tInverse BWT: {}\", inverse_bwt);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{burrows_wheeler_transform, inverse_burrows_wheeler_transform};\n    #[test]\n    fn test_bwt() {\n        let input = \"banana\";\n        let output = burrows_wheeler_transform(input);\n        assert_eq!(\"bnn\\u{0002}aa\\u{0003}a\", output);\n    }\n\n    #[test]\n    fn test_ibwt() {\n        let input = \"bnn\\u{0002}aa\\u{0003}a\";\n        let output = inverse_burrows_wheeler_transform(input);\n        assert_eq!(\"banana\", output);\n    }\n}\n",
    "path": "tasks/burrows-wheeler-transform",
    "remote_code": "\nuse core::cmp::Ordering;\n\nconst STX: char = '\\u{0002}';\nconst ETX: char = '\\u{0003}';\n\n// this compare uses simple alphabetical sort, but for the special characters (ETX, STX)\n// it sorts them later than alphanumeric characters\npub fn special_cmp(lhs: &str, rhs: &str) -> Ordering {\n    let mut iter1 = lhs.chars();\n    let mut iter2 = rhs.chars();\n\n    loop {\n        match (iter1.next(), iter2.next()) {\n            (Some(lhs), Some(rhs)) => {\n                if lhs != rhs {\n                    let is_lhs_special = lhs == ETX || lhs == STX;\n                    let is_rhs_special = rhs == ETX || rhs == STX;\n\n                    let result = if is_lhs_special == is_rhs_special {\n                        lhs.cmp(&rhs)\n                    } else if is_lhs_special {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Less\n                    };\n\n                    return result;\n                }\n            }\n            (Some(_), None) => return Ordering::Greater,\n            (None, Some(_)) => return Ordering::Less,\n            (None, None) => return lhs.cmp(&rhs),\n        }\n    }\n}\n\nfn burrows_wheeler_transform(input: &str) -> String {\n    let mut table: Vec<String> = vec![];\n\n    // add markers for the start and end\n    let input_string = format!(\"{}{}{}\", STX, input, ETX);\n\n    // create all possible rotations\n    for (i, _) in input_string.char_indices() {\n        table.push(format!(\n            \"{}{}\",\n            &input_string[input_string.len() - 1 - i..],\n            &input_string[0..input_string.len() - 1 - i]\n        ));\n    }\n\n    // sort rows alphabetically\n    table.sort_unstable_by(|lhs, rhs| special_cmp(&lhs, &rhs));\n\n    // return the last column\n    table\n        .iter()\n        .map(|s| s.chars().nth_back(0).unwrap())\n        .collect::<String>()\n}\n\nfn inverse_burrows_wheeler_transform(input: &str) -> String {\n    let mut table: Vec<String> = vec![String::new(); input.len()];\n    for _ in 0..input.len() {\n        // insert the charatcers of the encoded input as a first column for each row\n        for (j, s) in table.iter_mut().enumerate() {\n            *s = format!(\"{}{}\", input.chars().nth(j).unwrap(), s);\n        }\n\n        // sort rows alphabetically\n        table.sort_unstable_by(|lhs, rhs| special_cmp(&lhs, &rhs));\n    }\n\n    // return the row which has the end marker at the last position\n    table\n        .into_iter()\n        .filter(|s| s.ends_with(ETX))\n        .collect::<String>()\n        // remove start and markers\n        .replace(STX, \"\")\n        .replace(ETX, \"\")\n}\n\nfn main() {\n    let input = [\n        \"banana\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n    ];\n    for s in input.iter() {\n        let bwt = burrows_wheeler_transform(s);\n        let ibwt = inverse_burrows_wheeler_transform(&bwt);\n        println!(\"Input: {}\", s);\n        println!(\"\\tBWT: {}\", bwt.replace(STX, \"^\").replace(ETX, \"|\"));\n        println!(\"\\tInverse BWT: {}\", ibwt);\n    }\n}\n",
    "title": "Burrows–Wheeler transform",
    "url": "http://rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform"
  },
  {
    "local_code": "fn main() {\n    let s = \"The quick brown fox jumps over the lazy dog\";\n    println!(\"{:X}\", crc(s.as_bytes()));\n}\n\nfn crc(bytes: &[u8]) -> u32 {\n    // Store the CRC of all possible 256 one byte values in table\n    let mut table: [u32; 256] = [0; 256];\n    for (i, value) in table.iter_mut().enumerate() {\n        let mut word = i as u32;\n        for _ in 0..8 {\n            if word & 1 == 1 {\n                word = (word >> 1) ^ 0xedb8_8320\n            } else {\n                word >>= 1;\n            }\n        }\n        *value = word;\n    }\n\n    let mut crc: u32 = 0xffff_ffff;\n    for byte in bytes {\n        crc = table[(crc as u8 ^ *byte) as usize] ^ (crc >> 8);\n    }\n    crc ^ 0xffff_ffff\n}\n\n#[test]\nfn test() {\n    let s = \"The quick brown fox jumps over the lazy dog\";\n    assert_eq!(crc(s.as_bytes()), 0x414F_A339);\n}\n",
    "path": "tasks/crc-32",
    "remote_code": "\nfn crc32_compute_table() -> [u32; 256] {\n    let mut crc32_table = [0; 256];\n\n    for n in 0..256 {\n        crc32_table[n as usize] = (0..8).fold(n as u32, |acc, _| {\n            match acc & 1 {\n                1 => 0xedb88320 ^ (acc >> 1),\n                _ => acc >> 1,\n            }\n        });\n    }\n\n    crc32_table\n}\n\nfn crc32(buf: &str) -> u32 {\n    let crc_table = crc32_compute_table();\n\n    !buf.bytes().fold(!0, |acc, octet| {\n        (acc >> 8) ^ crc_table[((acc & 0xff) ^ octet as u32) as usize]\n    })\n}\n\nfn main() {\n    println!(\"{:x}\", crc32(\"The quick brown fox jumps over the lazy dog\"));\n}\n",
    "title": "CRC-32",
    "url": "http://rosettacode.org/wiki/CRC-32"
  },
  {
    "local_code": "use std::vec::Vec;\n\nfn check_csv_length(values: &[Vec<String>], line_length: usize) -> Result<(), String> {\n    if values.iter().all(|line| line.len() == line_length) {\n        Ok(())\n    } else {\n        Err(\"Values have inconsistent number of columns\".to_string())\n    }\n}\n\nfn csv_sum(csv: &str) -> Result<Vec<Vec<String>>, String> {\n    let mut lines: Vec<Vec<String>> = csv\n        .split('\\n')\n        .map(|line| {\n            // Split each line into subparts, and convert them into owned strings.\n            line.split(',')\n                .map(|value| value.trim().to_string())\n                .collect::<Vec<String>>()\n        })\n        .filter(|line| {\n            // Filter empty lines\n            let (string, slice) = line.split_first().unwrap();\n            !(slice.is_empty() && string.trim().is_empty())\n        })\n        .collect(); // transform the iterator over lines into a vector\n    match lines.split_first_mut() {\n        None => Err(\"The CSV file is empty !\".to_string()),\n        Some((_, ref values)) if values.is_empty() => {\n            Err(\"The CSV file has no values !\".to_string())\n        }\n        Some((ref mut headers, ref mut values)) => {\n            let columns_number = headers.len();\n            check_csv_length(values, columns_number).and_then(|_| {\n                // if check_csv_length is already an error, return it,\n                // otherwise do something with result (which in this case is '()', but we will\n                // rather use 'headers' and 'values' for our stuff' )\n\n                headers.push(\"SUM\".to_string());\n                // Since every line has the correct number of columns, add a \"SUM\" column\n\n                let mut global_result = Ok(());\n                'lines: for (line_number, ref mut line) in values.iter_mut().enumerate() {\n                    let line_number = line_number + 2;\n                    // + 1 because enumerate is 0 indexed, and usually lines start from line 1;\n                    // and another + 1 because this enumerate counts the line values,\n                    // not all the lines. Note that it will not display the correct line if\n                    // the file has some empty lines\n                    let sum = {\n                        // let's calculate the sum of a line\n                        let f64_values = line.iter().map(|value| value.parse::<f64>());\n                        // map all the values of a line py parsing them as f64\n                        // if it fails, it maps as an Err, otherwise an Ok( value )\n                        let mut sum: Result<f64, _> = Ok(0.0);\n                        'sum: for value in f64_values {\n                            match value {\n                                Ok(v) => {\n                                    sum = sum.map(|f64_value| f64_value + v);\n                                }\n                                Err(e) => {\n                                    sum = Err(format!(\n                                        \"Error \\\"{error}\\\" at line {line}\",\n                                        error = e,\n                                        line = line_number\n                                    ));\n                                    // a parsing error has been found\n                                    break 'sum; // break the 'sum' loop, pointless to keep it going\n                                }\n                            };\n                        }\n                        sum\n                    };\n                    match sum {\n                        Ok(value) => {\n                            line.push(value.to_string());\n                        }\n                        Err(err) => {\n                            global_result = Err(err);\n                            break 'lines;\n                        }\n                    };\n                }\n                global_result\n            })\n        }\n    }\n    .map(|_| lines)\n}\n\nfn vec_csv_to_string(csv: &[Vec<String>]) -> String {\n    let mut string = String::new();\n    for line in csv.iter() {\n        string.push_str(&line.join(\",\"));\n        string.push('\\n');\n    }\n    string\n}\n\nfn main() {\n    let example_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                      1,5,9,13,17\\n\\\n                                      2,6,10,14,18\\n\\\n                                      3,7,11,15,19\\n\\\n                                      4,8,12,16,20\";\n    println!(\"INPUT : \");\n    println!(\"{}\", example_file);\n    println!(\"--------\");\n    println!(\"OUTPUT : \");\n    match csv_sum(example_file) {\n        Ok(csv) => {\n            println!(\"{}\", vec_csv_to_string(&csv));\n        }\n        Err(err_string) => {\n            println!(\"An error occured : {desc}\", desc = err_string);\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{csv_sum, vec_csv_to_string};\n    #[test]\n    fn check_empty_csv() {\n        let empty_file: &'static str = \"\";\n        let no_values_file: &'static str = \"C1,C2,C3,C4,C5\\n\";\n        assert!(csv_sum(empty_file).is_err());\n        assert!(csv_sum(no_values_file).is_err());\n    }\n\n    #[test]\n    fn check_correct_csv() {\n        let correct_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                          1,5,9,13,17\\n\\\n                                          2,6,10,14,18\\n\\\n                                          3,7,11,15,19\\n\\\n                                          4,8,12,16,20\";\n        let whitespace_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                             1,5,9,13,17\\n\\\n                                             2,6,10,14,18\\n\\\n                                             \\n\\\n                                             3,7,11,15,19\\n\\\n                                             4,8,12,16,20\";\n        assert!(csv_sum(correct_file).is_ok());\n        let csv = csv_sum(correct_file);\n        assert!(csv.is_ok());\n        assert_eq!(\n            vec_csv_to_string(&csv.unwrap()),\n            \"C1,C2,C3,C4,C5,SUM\\n\\\n             1,5,9,13,17,45\\n\\\n             2,6,10,14,18,50\\n\\\n             3,7,11,15,19,55\\n\\\n             4,8,12,16,20,60\\n\"\n                .to_string()\n        );\n        assert!(csv_sum(whitespace_file).is_ok());\n    }\n\n    #[test]\n    fn check_incomplete_csv() {\n        let incomplete_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                             1,5,9,13,17\\n\\\n                                             2,6,18\\n\\\n                                             3,7,11,15,19\\n\\\n                                             4\";\n        assert!(csv_sum(incomplete_file).is_err());\n    }\n\n    #[test]\n    fn check_wrong_csv() {\n        let wrong_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                        1,5,9,13,17\\n\\\n                                        2,6,error,14,18\\n\\\n                                        3,7,11,15,19\\n\\\n                                        4,8,12,16,20\";\n        assert!(csv_sum(wrong_file).is_err());\n    }\n}\n",
    "path": "tasks/csv-data-manipulation",
    "remote_code": "use std::error::Error;\nuse std::num::ParseIntError;\nuse csv::{Reader, Writer};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut reader = Reader::from_path(\"data.csv\")?;\n    let mut writer = Writer::from_path(\"output.csv\")?;\n\n    // headers() returns an immutable reference, so clone() before appending\n    let mut headers = reader.headers()?.clone();\n    headers.push_field(\"SUM\");\n    writer.write_record(headers.iter())?;\n\n    for row in reader.records() {\n        let mut row = row?;\n\n        // `sum` needs the type annotation so that `parse::<i64>` knows what error type to return\n        let sum: Result<_, ParseIntError> = row.iter().try_fold(0, |accum, s| {\n            Ok(accum + s.parse::<i64>()?)\n        });\n\n        row.push_field(&sum?.to_string());\n        writer.write_record(row.iter())?;\n    }\n\n    writer.flush()?;\n    Ok(())\n}",
    "title": "CSV data manipulation",
    "url": "http://rosettacode.org/wiki/CSV_data_manipulation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "static INPUT : &'static str  =\n\"Character,Speech\nThe multitude,The messiah! Show us the messiah!\nBrians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>\nThe multitude,Who are you?\nBrians mother,I'm his mother; that's who!\nThe multitude,Behold his mother! Behold his mother!\";\n\nfn main() {\n    print!(\"<table>\\n<tr><td>\");\n    for c in INPUT.chars() {\n        match c {\n            '\\n' => print!(\"</td></tr>\\n<tr><td>\"),\n            ','  => print!(\"</td><td>\"),\n            '<'  => print!(\"&lt;\"),\n            '>'  => print!(\"&gt;\"),\n            '&'  => print!(\"&amp;\"),\n            _    => print!(\"{}\", c)\n        }\n    }\n    println!(\"</td></tr>\\n</table>\");\n}\n",
    "title": "CSV to HTML translation",
    "url": "http://rosettacode.org/wiki/CSV_to_HTML_translation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn cusip_check(cusip: &str) -> bool {\n    if cusip.len() != 9 {\n        return false;\n    }\n\n    let mut v = 0;\n    let capital_cusip = cusip.to_uppercase();\n    let char_indices = capital_cusip.as_str().char_indices().take(7);\n\n    let total = char_indices.fold(0, |total, (i, c)| {\n        v = match c {\n            '*' => 36,\n            '@' => 37,\n            '#' => 38,\n            _ if c.is_digit(10) => c.to_digit(10).unwrap() as u8,\n            _ if c.is_alphabetic() => (c as u8) - b'A' + 1 + 9,\n            _ => v,\n        };\n\n        if i % 2 != 0 {\n            v *= 2\n        }\n        total + (v / 10) + v % 10\n    });\n\n    let check = (10 - (total % 10)) % 10;\n    (check.to_string().chars().nth(0).unwrap()) == cusip.chars().nth(cusip.len() - 1).unwrap()\n}\n\nfn main() {\n    let codes = [\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\",\n    ];\n    for code in &codes {\n        println!(\"{} -> {}\", code, cusip_check(code))\n    }\n}",
    "title": "CUSIP",
    "url": "http://rosettacode.org/wiki/CUSIP"
  },
  {
    "local_code": "use std::fmt::Display;\nuse std::io::{self, Write};\nuse std::{env, process};\n\nfn main() {\n    let shift = env::args()\n        .nth(1)\n        .unwrap_or_else(|| exit_err(\"No shift provided\", 2))\n        .parse::<u8>()\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n    let plain = get_input().unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    let cipher = cipher(&plain, shift);\n\n    println!(\"Cipher text: {}\", cipher.trim());\n}\n\nfn cipher(input: &str, shift: u8) -> String {\n    input\n        .chars()\n        .map(|c| {\n            let case = if c.is_uppercase() { b'A' } else { b'a' };\n\n            if c.is_alphabetic() {\n                (((c as u8 - case + shift) % 26) + case) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}\n\nfn get_input() -> io::Result<String> {\n    print!(\"Plain text:  \");\n    io::stdout().flush()?;\n\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf)?;\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    writeln!(&mut io::stderr(), \"ERROR: {}\", msg).unwrap();\n    process::exit(code);\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn encode() {\n        let original = \"The five boxing wizards jump quickly\";\n        let encoded = \"Wkh ilyh eralqj zlcdugv mxps txlfnob\";\n        assert_eq!(super::cipher(original, 3), encoded);\n    }\n}\n",
    "path": "tasks/caesar-cipher",
    "remote_code": "use std::io::{self, Write};\nuse std::fmt::Display;\nuse std::{env, process};\n\nfn main() {\n    let shift: u8 = env::args().nth(1)\n        .unwrap_or_else(|| exit_err(\"No shift provided\", 2))\n        .parse()\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n    let plain = get_input()\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    let cipher = plain.chars()\n        .map(|c| {\n            let case = if c.is_uppercase() {'A'} else {'a'} as u8;\n            if c.is_alphabetic() { (((c as u8 - case + shift) % 26) + case) as char } else { c }\n        }).collect::<String>();\n\n    println!(\"Cipher text: {}\", cipher.trim());\n}\n\n\nfn get_input() -> io::Result<String> {\n    print!(\"Plain text:  \");\n    try!(io::stdout().flush());\n\n    let mut buf = String::new();\n    try!(io::stdin().read_line(&mut buf));\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"ERROR: {}\", msg);\n    process::exit(code);\n}",
    "title": "Caesar cipher",
    "url": "http://rosettacode.org/wiki/Caesar_cipher"
  },
  {
    "local_code": "const EPSILON: f64 = 1e-15;\n\nfn main() {\n    let mut fact: u64 = 1;\n    let mut e: f64 = 2.0;\n    let mut n: u64 = 2;\n    loop {\n        let e0 = e;\n        fact *= n;\n        n += 1;\n        e += 1.0 / fact as f64;\n        if (e - e0).abs() < EPSILON {\n            break;\n        }\n    }\n\n    println!(\"e = {:.15}\", e);\n}\n",
    "path": "tasks/calculating-the-value-of-e",
    "remote_code": "const EPSILON: f64 = 1e-15;\n\nfn main() {\n    let mut fact: u64 = 1;\n    let mut e: f64 = 2.0;\n    let mut n: u64 = 2;\n    loop {\n        let e0 = e;\n        fact *= n;\n        n += 1;\n        e += 1.0 / fact as f64;\n        if (e - e0).abs() < EPSILON {\n            break;\n        }\n    }\n    println!(\"e = {:.15}\", e);\n}",
    "title": "Calculating the value of e",
    "url": "http://rosettacode.org/wiki/Calculating_the_value_of_e"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Assume your binary name is 'calendar'.\n// Command line:\n// >>$ calendar 2019 150\n// First argument: year number.\n// Second argument (optional): text area width (in characters).\n\nextern crate chrono;\n\nuse std::{env, cmp};\nuse chrono::{NaiveDate, Datelike};\n\nconst MONTH_WIDTH: usize = 22;\n\nfn print_header(months: &[&str]) {\n    const DAYS_OF_WEEK: &str = \"SU MO TU WE TH FR SA  \";\n    println!();\n    for m in months {\n        print!(\"{:^20}  \", m);\n    }\n    println!(\"\\n{}\", DAYS_OF_WEEK.repeat(months.len()));\n}\n\nfn get_week_str(days: i32, week_num: i32, start_day_of_week: i32) -> Option<String> {\n    let start = week_num * 7 - start_day_of_week + 1;\n    let end = (week_num + 1) * 7 - start_day_of_week;\n    let mut ret = String::with_capacity(MONTH_WIDTH);\n    if start > days {\n        None\n    } else {\n        for i in start..(end + 1) {\n            if i <= 0 || i > days {\n                ret.push_str(\"  \");\n            } else {\n                if i < 10 {\n                    ret.push_str(\" \");\n                }\n                ret.push_str(&i.to_string());\n            }\n            ret.push_str(\" \");\n        }\n        ret.push_str(\" \");\n        Some(ret)\n    }\n}\n\nfn main() {\n    const MONTH_NAMES: [&str; 12] = [\"JANUARY\", \"FEBRUARY\", \"MARCH\", \"APRIL\", \"MAY\", \"JUNE\", \"JULY\",\n                                     \"AUGUST\", \"SEPTEMBER\", \"OCTOBER\", \"NOVEMBER\", \"DECEMBER\"];\n    const DEFAULT_TEXT_WIDTH: usize = 100;\n\n    let args: Vec<String> = env::args().collect();\n    let year: i32 = args[1].parse().expect(\"The first argument must be a year\");\n    let width: usize = if args.len() > 2 {\n        cmp::max(MONTH_WIDTH, args[2].parse().expect(\"The second argument should be text width\"))\n    } else {\n        DEFAULT_TEXT_WIDTH\n    };\n    let months_in_row = width / MONTH_WIDTH;\n    let month_rows = if MONTH_NAMES.len() % months_in_row == 0 {\n        MONTH_NAMES.len() / months_in_row\n    } else {\n        MONTH_NAMES.len() / months_in_row + 1\n    };\n\n    let start_days_of_week: Vec<i32> =\n        (1..13).map(|x| NaiveDate::from_ymd(year, x, 1).weekday().num_days_from_sunday() as i32).collect();\n\n    let month_days: [i32; 12] = if NaiveDate::from_ymd_opt(year, 2, 29).is_some() {\n        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    } else {\n        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n\n    println!(\"{year:^w$}\", w=width, year=year.to_string());\n    for i in 0..month_rows {\n        let start = i * months_in_row;\n        let end = cmp::min((i + 1) * months_in_row, MONTH_NAMES.len());\n        print_header(&MONTH_NAMES[start..end]);\n        let mut count = 0;\n        let mut row_num = 0;\n        while count < months_in_row {\n            let mut row_str = String::with_capacity(width);\n            for j in start..end {\n                match get_week_str(month_days[j], row_num, start_days_of_week[j]) {\n                    None => {\n                        count += 1;\n                        row_str.push_str(&\" \".repeat(MONTH_WIDTH));\n                    },\n                    Some(week_str) => row_str.push_str(&week_str)\n                }\n            }\n            if count < months_in_row {\n                println!(\"{}\", row_str);\n            }\n            row_num += 1;\n        }\n    }\n}\n",
    "title": "Calendar",
    "url": "http://rosettacode.org/wiki/Calendar"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Calendar - for \"REAL\" programmers",
    "url": "http://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// num = \"0.3\"\n\nuse num::rational::Rational;\n\nfn calkin_wilf_next(term: &Rational) -> Rational {\n    Rational::from_integer(1) / (Rational::from_integer(2) * term.floor() + 1 - term)\n}\n\nfn continued_fraction(r: &Rational) -> Vec<isize> {\n    let mut a = *r.numer();\n    let mut b = *r.denom();\n    let mut result = Vec::new();\n    loop {\n        let (q, r) = num::integer::div_rem(a, b);\n        result.push(q);\n        a = b;\n        b = r;\n        if a == 1 {\n            break;\n        }\n    }\n    let len = result.len();\n    if len != 0 && len % 2 == 0 {\n        result[len - 1] -= 1;\n        result.push(1);\n    }\n    result\n}\n\nfn term_number(r: &Rational) -> usize {\n    let mut result: usize = 0;\n    let mut d: usize = 1;\n    let mut p: usize = 0;\n    for n in continued_fraction(r) {\n        for _ in 0..n {\n            result |= d << p;\n            p += 1;\n        }\n        d ^= 1;\n    }\n    result\n}\n\nfn main() {\n    println!(\"First 20 terms of the Calkin-Wilf sequence are:\");\n    let mut term = Rational::from_integer(1);\n    for i in 1..=20 {\n        println!(\"{:2}: {}\", i, term);\n        term = calkin_wilf_next(&term);\n    }\n    let r = Rational::new(83116, 51639);\n    println!(\"{} is the {}th term of the sequence.\", r, term_number(&r));\n}",
    "title": "Calkin-Wilf sequence",
    "url": "http://rosettacode.org/wiki/Calkin-Wilf_sequence"
  },
  {
    "local_code": "extern crate libc;\n\nuse libc::c_char;\nuse std::ffi::CString;\n\n/// C functions are declared in an `extern \"C\"` block.\nextern \"C\" {\n    fn strcmp(a: *const c_char, b: *const c_char) -> i32;\n}\n\nfn main() {\n    let a = CString::new(\"a\").unwrap();\n    let b = CString::new(\"b\").unwrap();\n\n    println!(\"{}\", unsafe { strcmp(a.as_ptr(), b.as_ptr()) });\n}\n\n#[test]\nfn test_strcmp() {\n    let a = CString::new(\"a\").unwrap();\n    let b = CString::new(\"b\").unwrap();\n\n    assert_eq!(unsafe { strcmp(a.as_ptr(), b.as_ptr()) }, -1);\n}\n",
    "path": "tasks/call-a-foreign-language-function",
    "remote_code": "extern crate libc;\n\n//c function that returns the sum of two integers\nextern {\n    fn add_input(in1: libc::c_int, in2: libc::c_int) -> libc::c_int;\n}\n\nfn main() {\n    let (in1, in2) = (5, 4);\n    let output = unsafe {\n        add_input(in1, in2) };\n    assert!( (output == (in1 + in2) ),\"Error in sum calculation\") ;\n}",
    "title": "Call a foreign-language function",
    "url": "http://rosettacode.org/wiki/Call_a_foreign-language_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    // Rust has a lot of neat things you can do with functions: let's go over the basics first\n    fn no_args() {}\n    // Run function with no arguments\n    no_args();\n\n    // Calling a function with fixed number of arguments.\n    // adds_one takes a 32-bit signed integer and returns a 32-bit signed integer\n    fn adds_one(num: i32) -> i32 {\n        // the final expression is used as the return value, though `return` may be used for early returns\n        num + 1\n    }\n    adds_one(1);\n\n    // Optional arguments\n    // The language itself does not support optional arguments, however, you can take advantage of\n    // Rust's algebraic types for this purpose\n    fn prints_argument(maybe: Option<i32>) {\n        match maybe {\n            Some(num) => println!(\"{}\", num),\n            None => println!(\"No value given\"),\n        };\n    }\n    prints_argument(Some(3));\n    prints_argument(None);\n\n    // You could make this a bit more ergonomic by using Rust's Into trait\n    fn prints_argument_into<I>(maybe: I)\n        where I: Into<Option<i32>>\n    {\n        match maybe.into() {\n            Some(num) => println!(\"{}\", num),\n            None => println!(\"No value given\"),\n        };\n    }\n    prints_argument_into(3);\n    prints_argument_into(None);\n\n    // Rust does not support functions with variable numbers of arguments. Macros fill this niche\n    // (println! as used above is a macro for example)\n\n    // Rust does not support named arguments\n\n    // We used the no_args function above in a no-statement context\n\n    // Using a function in an expression context\n    adds_one(1) + adds_one(5); // evaluates to eight\n\n    // Obtain the return value of a function.\n    let two = adds_one(1);\n\n    // In Rust there are no real built-in functions (save compiler intrinsics but these must be\n    // manually imported)\n\n    // In rust there are no such thing as subroutines\n\n    // In Rust, there are three ways to pass an object to a function each of which have very important\n    // distinctions when it comes to Rust's ownership model and move semantics. We may pass by\n    // value, by immutable reference, or mutable reference.\n\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    // By mutable reference\n    fn add_one_to_first_element(vector: &mut Vec<i32>) {\n        vector[0] += 1;\n    }\n    add_one_to_first_element(&mut v);\n    // By immutable reference\n    fn print_first_element(vector: &Vec<i32>) {\n        println!(\"{}\", vector[0]);\n    }\n    print_first_element(&v);\n\n    // By value\n    fn consume_vector(vector: Vec<i32>) {\n        // We can do whatever we want to vector here\n    }\n    consume_vector(v);\n    // Due to Rust's move semantics, v is now inaccessible because it was moved into consume_vector\n    // and was then dropped when it went out of scope\n\n    // Partial application is not possible in rust without wrapping the function in another\n    // function/closure e.g.:\n    fn average(x: f64, y: f64) -> f64 {\n        (x + y) / 2.0\n    }\n    let average_with_four = |y| average(4.0, y);\n    average_with_four(2.0);\n\n\n}",
    "title": "Call a function",
    "url": "http://rosettacode.org/wiki/Call_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![allow(unused_unsafe)]\nextern crate libc;\n\nuse std::io::{self,Write};\nuse std::{mem,ffi,process};\n\nuse libc::{c_double, RTLD_NOW};\n\n// Small macro which wraps turning a string-literal into a c-string.\n// This is always safe to call, and the resulting pointer has 'static lifetime\nmacro_rules! to_cstr {\n    ($s:expr) => {unsafe {ffi::CStr::from_bytes_with_nul_unchecked(concat!($s, \"\\0\").as_bytes()).as_ptr()}}\n}\n\nmacro_rules! from_cstr {\n    ($p:expr) => {ffi::CStr::from_ptr($p).to_string_lossy().as_ref() }\n}\n\nfn main() {\n    unsafe {\n        let handle = libc::dlopen(to_cstr!(\"libm.so.6\"), RTLD_NOW);\n\n        if handle.is_null() {\n            writeln!(&mut io::stderr(), \"{}\", from_cstr!(libc::dlerror())).unwrap();\n            process::exit(1);\n        }\n\n        let extern_cos = libc::dlsym(handle, to_cstr!(\"cos\"))\n                .as_ref()\n                .map(mem::transmute::<_,fn (c_double) -> c_double)\n                .unwrap_or(builtin_cos);\n        println!(\"{}\", extern_cos(4.0));\n    }\n}\n\nfn builtin_cos(x: c_double) -> c_double {\n    x.cos()\n}",
    "title": "Call a function in a shared library",
    "url": "http://rosettacode.org/wiki/Call_a_function_in_a_shared_library"
  },
  {
    "local_code": "#![allow(clippy::blacklisted_name)]\n\nstruct Foo;\n\nimpl Foo {\n    // implementation of an instance method for struct Foo\n    // returning the answer to life\n    fn get_the_answer_to_life(&self) -> i32 {\n        42\n    }\n\n    // implementation of a static method for struct Foo\n    // returning a new instance object\n    fn new() -> Foo {\n        println!(\"Hello, world!\");\n        Foo // returning the new Foo object\n    }\n}\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    // create the instance object foo,\n    // by calling the static method new of struct Foo\n    let foo = Foo::new();\n\n    // get the answer to life\n    // by calling the instance method of object foo\n    println!(\"The answer to life is {}.\", foo.get_the_answer_to_life());\n}\n",
    "path": "tasks/call-an-object-method",
    "remote_code": "struct Foo;\n\nimpl Foo {\n    // implementation of an instance method for struct Foo\n    // returning the answer to life\n    fn get_the_answer_to_life(&self) -> i32 {\n        42\n    }\n\n    // implementation of a static method for struct Foo\n    // returning a new instance object\n    fn new() -> Foo {\n        println!(\"Hello, world!\");\n        Foo // returning the new Foo object\n    }\n}\n\nfn main() {\n    // create the instance object foo,\n    // by calling the static method new of struct Foo\n    let foo = Foo::new();\n\n    // get the answer to life \n    // by calling the instance method of object foo\n    println!(\"The answer to life is {}.\", foo.get_the_answer_to_life());\n    \n    // Note that in Rust, methods still work on references to the object.\n    // Rust will automatically do the appropriate dereferencing to get the method to work:\n    let lots_of_references = &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&foo;\n    println!(\"The answer to life is still {}.\" lots_of_references.get_the_answer_to_life());\n}",
    "title": "Call an object method",
    "url": "http://rosettacode.org/wiki/Call_an_object_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Canny edge detector",
    "url": "http://rosettacode.org/wiki/Canny_edge_detector"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::net::Ipv4Addr;\n\nfn canonical_cidr(cidr: &str) -> Result<String, &str> {\n    let mut split = cidr.splitn(2, '/');\n    if let (Some(addr), Some(mask)) = (split.next(), split.next()) {\n        let addr = addr.parse::<Ipv4Addr>().map(u32::from).map_err(|_| cidr)?;\n        let mask = mask.parse::<u8>().map_err(|_| cidr)?;\n        let bitmask = 0xff_ff_ff_ffu32 << (32 - mask);\n        let addr = Ipv4Addr::from(addr & bitmask);\n        Ok(format!(\"{}/{}\", addr, mask))\n    } else {\n        Err(cidr)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    #[test]\n    fn valid() {\n        [\n            (\"87.70.141.1/22\", \"87.70.140.0/22\"),\n            (\"36.18.154.103/12\", \"36.16.0.0/12\"),\n            (\"62.62.197.11/29\", \"62.62.197.8/29\"),\n            (\"67.137.119.181/4\", \"64.0.0.0/4\"),\n            (\"161.214.74.21/24\", \"161.214.74.0/24\"),\n            (\"184.232.176.184/18\", \"184.232.128.0/18\"),\n        ]\n        .iter()\n        .cloned()\n        .for_each(|(input, expected)| {\n            assert_eq!(expected, super::canonical_cidr(input).unwrap());\n        });\n    }\n}\n\nfn main() {\n    println!(\"{}\", canonical_cidr(\"127.1.2.3/24\").unwrap());\n}",
    "title": "Canonicalize CIDR",
    "url": "http://rosettacode.org/wiki/Canonicalize_CIDR"
  },
  {
    "local_code": "use convert_base::Convert;\nuse std::fmt;\n\nstruct CantorSet {\n    cells: Vec<Vec<bool>>,\n}\nfn number_to_vec(n: usize) -> Vec<u32> {\n    // for the conversion we need the digits in reverse order\n    // i.e the least significant digit in the first element of the vector\n    n.to_string()\n        .chars()\n        .rev()\n        .map(|c| c.to_digit(10).unwrap())\n        .collect()\n}\n\nimpl CantorSet {\n    fn new(lines: usize) -> CantorSet {\n        // Convert from base 10- to base 3\n        let mut base = Convert::new(10, 3);\n        let mut cells: Vec<Vec<bool>> = vec![];\n\n        for line in 0..lines {\n            // calculate how many repeating sequence will be in the given line\n            let segment_size = 3_usize.pow((lines - line - 1) as u32);\n            let segment: Vec<bool> = (0..3_usize.pow(line as u32))\n                .map(|n| {\n                    let output = base.convert::<u32, u32>(&number_to_vec(n));\n                    // return false in case the base 3 number contains at least one \"1\"\n                    // otherwise return true\n                    !output.contains(&1)\n                })\n                .collect();\n\n            // copy the segment \"segment_size\" time\n            let mut accum: Vec<bool> = Vec::with_capacity(segment.len() * segment_size);\n            for c in segment.iter() {\n                accum.extend(std::iter::repeat(*c).take(segment_size))\n            }\n\n            cells.push(accum);\n        }\n\n        CantorSet { cells }\n    }\n}\n\nimpl fmt::Display for CantorSet {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for line in self.cells.iter() {\n            for c in line {\n                write!(f, \"{}\", if *c { \"█\" } else { \" \" })?\n            }\n            writeln!(f)?;\n        }\n\n        Ok(())\n    }\n}\nfn main() {\n    let cs = CantorSet::new(5);\n    println!(\"Cantor set:\");\n    println!(\"{}\", cs);\n}\n",
    "path": "tasks/cantor-set",
    "remote_code": "\nuse convert_base::Convert;\nuse std::fmt;\n\nstruct CantorSet {\n    cells: Vec<Vec<bool>>,\n}\nfn number_to_vec(n: usize) -> Vec<u32> {\n    // for the conversion we need the digits in reverse order\n    // i.e the least significant digit in the first element of the vector\n    n.to_string()\n        .chars()\n        .rev()\n        .map(|c| c.to_digit(10).unwrap())\n        .collect()\n}\n\nimpl CantorSet {\n    fn new(lines: usize) -> CantorSet {\n        // Convert from base 10- to base 3\n        let mut base = Convert::new(10, 3);\n        let mut cells: Vec<Vec<bool>> = vec![];\n\n        for line in 0..lines {\n            // calculate how many repeating sequence will be in the given line\n            let segment_size = 3_usize.pow((lines - line - 1) as u32);\n            let segment: Vec<bool> = (0..3_usize.pow(line as u32))\n                .map(|n| {\n                    let output = base.convert::<u32, u32>(&number_to_vec(n));\n                    // return false in case the base 3 number contains at least one \"1\"\n                    // otherwise return true\n                    !output.contains(&1)\n                })\n                .collect();\n\n            // copy the segment \"segment_size\" time\n            let mut accum: Vec<bool> = Vec::with_capacity(segment.len() * segment_size);\n            for c in segment.iter() {\n                accum.extend(std::iter::repeat(*c).take(segment_size))\n            }\n\n            cells.push(accum);\n        }\n\n        CantorSet { cells }\n    }\n}\n\nimpl fmt::Display for CantorSet {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for line in self.cells.iter() {\n            for c in line {\n                write!(f, \"{}\", if *c { \"█\" } else { \" \" })?\n            }\n            writeln!(f)?;\n        }\n\n        Ok(())\n    }\n}\nfn main() {\n    let cs = CantorSet::new(5);\n    println!(\"Cantor set:\");\n    println!(\"{}\", cs);\n}\n\n",
    "title": "Cantor set",
    "url": "http://rosettacode.org/wiki/Cantor_set"
  },
  {
    "local_code": "fn is_prime(n: i64) -> bool {\n    if n > 1 {\n        (2..((n / 2) + 1)).all(|x| n % x != 0)\n    } else {\n        false\n    }\n}\n\n// The module operator actually calculates the remainder.\nfn modulo(n: i64, m: i64) -> i64 {\n    ((n % m) + m) % m\n}\n\nfn carmichael(p1: i64) -> Vec<(i64, i64, i64)> {\n    let mut results = Vec::new();\n    if !is_prime(p1) {\n        return results;\n    }\n\n    for h3 in 2..p1 {\n        for d in 1..(h3 + p1) {\n            if (h3 + p1) * (p1 - 1) % d != 0 || modulo(-p1 * p1, h3) != d % h3 {\n                continue;\n            }\n\n            let p2 = 1 + ((p1 - 1) * (h3 + p1) / d);\n            if !is_prime(p2) {\n                continue;\n            }\n\n            let p3 = 1 + (p1 * p2 / h3);\n            if !is_prime(p3) || ((p2 * p3) % (p1 - 1) != 1) {\n                continue;\n            }\n\n            results.push((p1, p2, p3));\n        }\n    }\n\n    results\n}\n\nfn main() {\n    (1..62)\n        .filter(|&x| is_prime(x))\n        .map(carmichael)\n        .filter(|x| !x.is_empty())\n        .flatten()\n        .inspect(|x| println!(\"{:?}\", x))\n        .count(); // Evaluate entire iterator\n}\n\n#[cfg(test)]\nmod tests {\n    use super::carmichael;\n\n    #[test]\n    fn test_primes() {\n        assert_eq!(carmichael(59), [(59, 1451, 2089)]);\n        assert_eq!(carmichael(19), [(19, 43, 409), (19, 199, 271)]);\n    }\n\n    #[test]\n    fn test_non_primes() {\n        assert_eq!(carmichael(20).len(), 0);\n        assert_eq!(carmichael(99).len(), 0);\n    }\n}\n",
    "path": "tasks/carmichael-3-strong-pseudoprimes",
    "remote_code": "\nfn is_prime(n: i64) -> bool {\n    if n > 1 {\n        (2..((n / 2) + 1)).all(|x| n % x != 0)\n    } else {\n        false\n    }\n}\n\n// The modulo operator actually calculates the remainder.\nfn modulo(n: i64, m: i64) -> i64 {\n    ((n % m) + m) % m\n}\n\nfn carmichael(p1: i64) -> Vec<(i64, i64, i64)> {\n    let mut results = Vec::new();\n    if !is_prime(p1) {\n        return results;\n    }\n\n    for h3 in 2..p1 {\n        for d in 1..(h3 + p1) {\n            if (h3 + p1) * (p1 - 1) % d != 0 || modulo(-p1 * p1, h3) != d % h3 {\n                continue;\n            }\n\n            let p2 = 1 + ((p1 - 1) * (h3 + p1) / d);\n            if !is_prime(p2) {\n                continue;\n            }\n\n            let p3 = 1 + (p1 * p2 / h3);\n            if !is_prime(p3) || ((p2 * p3) % (p1 - 1) != 1) {\n                continue;\n            }\n\n            results.push((p1, p2, p3));\n        }\n    }\n\n    results\n}\n\nfn main() {\n    (1..62)\n        .filter(|&x| is_prime(x))\n        .map(carmichael)\n        .filter(|x| !x.is_empty())\n        .flat_map(|x| x)\n        .inspect(|x| println!(\"{:?}\", x))\n        .count(); // Evaluate entire iterator\n}\n",
    "title": "Carmichael 3 strong pseudoprimes",
    "url": "http://rosettacode.org/wiki/Carmichael_3_strong_pseudoprimes"
  },
  {
    "local_code": "//! # Cartesian product of lists\n//!\n//! Solution for the \"cartesian product of two or more lists\" entry in rosetta code\n\nuse std::collections::VecDeque;\n\n/// Computes the cartesian product of two or more lists of clonable elements.\n///\n/// Uses a queue to iterate over the elements (Breadth-First-Search).\n///\nfn cartesian_product<T: Clone>(lists: &[&[T]]) -> Vec<Vec<T>> {\n    // If there are no lists, just returns an empty list.\n    if lists.is_empty() {\n        return vec![];\n    }\n    // Fills the queue with the first list.\n    let mut queue = lists[0]\n        .iter()\n        .map(|value| vec![value.clone()])\n        .collect::<VecDeque<Vec<T>>>();\n\n    let mut result = vec![];\n\n    while let Some(next) = queue.pop_front() {\n        // find the index of the next list to multiply with.\n        let next_list = next.len();\n\n        if lists.len() == next_list {\n            // If there are no more lists to multiply with, save the result.\n            result.push(next)\n        } else {\n            // Else add the products to the queue.\n            for value_to_add in lists[next_list] {\n                let mut nouv = next.clone();\n                nouv.push(value_to_add.clone());\n                queue.push_back(nouv);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"\\n{:?}\", cartesian_product(&[&[1, 2], &[3, 4]]));\n    println!(\"\\n{:?}\", cartesian_product(&[&[3, 4], &[1, 2]]));\n    /*\n        This will print :\n\n        [[1, 3], [1, 4], [2, 3], [2, 4]]\n\n        [[3, 1], [3, 2], [4, 1], [4, 2]]\n    */\n}\n\n#[cfg(test)]\nmod tests {\n    use super::cartesian_product;\n    #[test]\n    fn basic_test() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[3, 4]]),\n            vec![vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4]]\n        );\n    }\n\n    #[test]\n    fn empty_list() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[], &[3, 4]]),\n            Vec::<Vec<i32>>::new()\n        );\n    }\n\n    #[test]\n    fn many_lists_different_length() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[4], &[3, 4, 7]]),\n            vec![\n                vec![1, 4, 3],\n                vec![1, 4, 4],\n                vec![1, 4, 7],\n                vec![2, 4, 3],\n                vec![2, 4, 4],\n                vec![2, 4, 7],\n            ]\n        );\n    }\n\n    #[test]\n    fn different_types() {\n        assert_eq!(\n            cartesian_product(&[&[true, false], &[true], &[false, true]]),\n            vec![\n                vec![true, true, false],\n                vec![true, true, true],\n                vec![false, true, false],\n                vec![false, true, true],\n            ]\n        );\n    }\n\n    #[test]\n    fn no_list() {\n        assert_eq!(cartesian_product::<i32>(&[]), Vec::<Vec<i32>>::new());\n    }\n}\n",
    "path": "tasks/cartesian-product-of-two-or-more-lists",
    "remote_code": "fn cartesian_product(lists: &Vec<Vec<u32>>) -> Vec<Vec<u32>> {\n    let mut res = vec![];\n\n    let mut list_iter = lists.iter();\n    if let Some(first_list) = list_iter.next() {\n        for &i in first_list {\n            res.push(vec![i]);\n        }\n    }\n    for l in list_iter {\n        let mut tmp = vec![];\n        for r in res {\n            for &el in l {\n                let mut tmp_el = r.clone();\n                tmp_el.push(el);\n                tmp.push(tmp_el);\n            }\n        }\n        res = tmp;\n    }\n    res\n}\n \nfn main() {\n    let cases = vec![\n        vec![vec![1, 2], vec![3, 4]],\n        vec![vec![3, 4], vec![1, 2]],\n        vec![vec![1, 2], vec![]],\n        vec![vec![], vec![1, 2]],\n        vec![vec![1776, 1789], vec![7, 12], vec![4, 14, 23], vec![0, 1]],\n        vec![vec![1, 2, 3], vec![30], vec![500, 100]],\n        vec![vec![1, 2, 3], vec![], vec![500, 100]],\n    ];\n    for case in cases {\n        println!(\n            \"{}\\n{:?}\\n\",\n            case.iter().map(|c| format!(\"{:?}\", c)).collect::<Vec<_>>().join(\" × \"),\n            cartesian_product(&case)\n        )\n    }\n}\n",
    "title": "Cartesian product of two or more lists",
    "url": "http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists"
  },
  {
    "local_code": "#![allow(non_snake_case)]\n\nfn main() {\n    let dog = \"Benjamin\";\n    let Dog = \"Samba\";\n    let DOG = \"Bernie\";\n    println!(\"The three dogs are named {}, {} and {}.\", dog, Dog, DOG);\n}\n",
    "path": "tasks/case-sensitivity-of-identifiers",
    "remote_code": "fn main() {\n    let dog = \"Benjamin\";\n    let Dog = \"Samba\";\n    let DOG = \"Bernie\";\n    println!(\"The three dogs are named {}, {} and {}.\", dog, Dog, DOG);\n}",
    "title": "Case-sensitivity of identifiers",
    "url": "http://rosettacode.org/wiki/Case-sensitivity_of_identifiers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn compare_co9_efficiency(base: u64, upto: u64) {\n    let naive_candidates: Vec<u64> = (1u64..upto).collect();\n    let co9_candidates: Vec<u64> = naive_candidates.iter().cloned()\n        .filter(|&x| x % (base - 1) == (x * x) % (base - 1))\n        .collect();\n    for candidate in &co9_candidates {\n        print!(\"{} \", candidate);\n    }\n    println!();\n    println!(\n        \"Trying {} numbers instead of {} saves {:.2}%\",\n        co9_candidates.len(),\n        naive_candidates.len(),\n        100.0 - 100.0 * (co9_candidates.len() as f64 / naive_candidates.len() as f64)\n    );\n}\n\nfn main() {\n    compare_co9_efficiency(10, 100);\n    compare_co9_efficiency(16, 256);\n}",
    "title": "Casting out nines",
    "url": "http://rosettacode.org/wiki/Casting_out_nines"
  },
  {
    "local_code": "fn c_n(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => c_n(n - 1) * 2 * (2 * n - 1) / (n + 1),\n    }\n}\n\nfn main() {\n    for i in 1..16 {\n        println!(\"c_n({}) = {}\", i, c_n(i));\n    }\n}\n",
    "path": "tasks/catalan-numbers",
    "remote_code": "fn c_n(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => c_n(n - 1) * 2 * (2 * n - 1) / (n + 1)\n    }\n}\n\nfn main() {\n    for i in 1..16 {\n        println!(\"c_n({}) = {}\", i, c_n(i));\n    }\n}",
    "title": "Catalan numbers",
    "url": "http://rosettacode.org/wiki/Catalan_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n\nfn main()\n{let n=15usize;\n let mut t= [0; 17];\n t[1]=1;\n let mut j:usize;\n for i in 1..n+1\n {\n\tj=i;\n\tloop{\n\t    if j==1{\n\t\t      break; \n\t\t}\n\t\tt[j]=t[j] + t[j-1];\n\t\tj=j-1;\n\t}\n\tt[i+1]= t[i];\n\tj=i+1;\n\tloop{\n\t\tif j==1{\n\t\tbreak;\n\t\t}\n\t\tt[j]=t[j] + t[j-1];\n\t\tj=j-1;\n\t}\n\tprint!(\"{} \", t[i+1]-t[i]);\n }\n}\n",
    "title": "Catalan numbers/Pascal's triangle",
    "url": "http://rosettacode.org/wiki/Catalan_numbers/Pascal's_triangle"
  },
  {
    "local_code": "#![allow(clippy::unnecessary_fold)]\n\nfn main() {\n    let numbers = [1, 2, 3, 4, 5];\n    let sum = numbers.iter().fold(0, |a, n| a + n);\n    println!(\"{}\", sum);\n    let product = numbers.iter().fold(1, |a, n| a * n);\n    println!(\"{}\", product);\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_sum() {\n        let sum = [1, 2, 3, 4, 5].iter().fold(0, |a, n| a + n);\n        assert_eq!(sum, 15);\n    }\n    #[test]\n    fn test_product() {\n        let product = [1, 2, 3, 4, 5].iter().fold(1, |a, n| a * n);\n        assert_eq!(product, 120);\n    }\n}\n",
    "path": "tasks/catamorphism",
    "remote_code": "fn main() {\n    println!(\"Sum: {}\", (1..10).fold(0, |acc, n| acc + n));\n    println!(\"Product: {}\", (1..10).fold(1, |acc, n| acc * n));\n    let chars = ['a', 'b', 'c', 'd', 'e'];\n    println!(\"Concatenation: {}\",\n             chars.iter().map(|&c| (c as u8 + 1) as char).collect::<String>());\n}",
    "title": "Catamorphism",
    "url": "http://rosettacode.org/wiki/Catamorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\npub struct Vector3 {pub x: f64, pub y: f64, pub z: f64, pub w: f64}\n\npub struct Triangle {pub r: [usize; 3], pub(crate) col: [f32; 4], pub(crate) p: [Vector3; 3], n: Vector3, pub t: [Vector2; 3]}\npub struct Mesh{pub v: Vec<Vector3>, pub f: Vec<Triangle>}\n\nimpl Triangle{\n    pub fn new() -> Triangle {return Triangle {r: [0, 0, 0], col: [0.0; 4], p: [Vector3::new(0.0, 0.0, 0.0), Vector3::new(0.0, 0.0, 0.0), Vector3::new(0.0, 0.0, 0.0)], n: Vector3::new(0.0, 0.0, 0.0), t: [Vector2::new(0.0, 0.0), Vector2::new(0.0, 0.0), Vector2::new(0.0, 0.0)]}}\n    pub fn copy(&self) -> Triangle {return Triangle {r: self.r.clone(), col: self.col, p: [self.p[0].copy(), self.p[1].copy(), self.p[2].copy()], n: self.n.copy(), t: [self.t[0].copy(), self.t[1].copy(), self.t[2].copy()]}}\n}\n\n\nimpl Vector3 {\n    pub fn new(x: f64, y: f64, z: f64) -> Vector3 {return Vector3 {x, y, z, w: 1.0}}\n    pub fn normalize(&mut self) {\n        let l = (self.x * self.x + self.y * self.y + self.z * self.z).sqrt();\n        self.x /= l;\n        self.y /= l;\n        self.z /= l;\n    }\n    pub fn dot_product(v1: &Vector3, v2: &Vector3) -> f64 {return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z}\n    pub fn cross_product(v1: &Vector3, v2: &Vector3) -> Vector3 {return Vector3::new(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x)}\n    pub fn intersect_plane(plane_n: &Vector3, plane_p: &Vector3, line_start: &Vector3, line_end: &Vector3, mut t: f64) -> Vector3 {\n        let mut p_n = plane_n.copy();\n       \n        p_n.normalize();\n        let plane_d = -Vector3::dot_product(&p_n, plane_p);\n        let ad = Vector3::dot_product(line_start, &p_n);\n        let bd = Vector3::dot_product(line_end, &p_n);\n        t = (-plane_d - ad) / (bd - ad);\n        let line = line_end.copy() - line_start;\n        let line_i = line * t;\n        return line_start.copy() + &line_i;\n    }\n    pub fn copy(&self) -> Vector3 {return Vector3 {x: self.x, y: self.y, z: self.z, w: self.w}}\n}\n\nimpl Mesh {\n    pub fn get_face_points(&self) -> Vec<Vector3> {\n        let mut face_points: Vec<Vector3> = Vec::new();\n\n        for curr_face in &self.f {\n            let mut face_point = Vector3::new(0.0, 0.0, 0.0);\n            for curr_point_index in curr_face.r {\n                let curr_point = &self.v[curr_point_index];\n                face_point += &curr_point\n            }\n\n            face_point /= curr_face.r.len() as f64;\n            face_points.push(face_point.copy());\n        }\n        return face_points;\n    }\n    pub fn get_edges_faces(&self) -> Vec<[f64; 7]> {\n        let mut edges: Vec<[usize; 3]> = Vec::new();\n\n        for face_num in 0..self.f.len() {\n            let face: Triangle = self.f[face_num].copy();\n            let num_points = face.p.len();\n            for point_index in 0..num_points {\n                let mut point_num_1 = 0;\n                let mut point_num_2 = 0;\n                if point_index < num_points - 1 {\n                    point_num_1 = face.r[point_index];\n                    point_num_2 = face.r[point_index + 1];\n                } else {\n                    point_num_1 = face.r[point_index];\n                    point_num_2 = face.r[0];\n                }\n                if point_num_1 > point_num_2 {\n                    let temp = point_num_1;\n                    point_num_1 = point_num_2;\n                    point_num_2 = temp;\n                }\n                edges.push([point_num_1, point_num_2, face_num]);\n            }\n        }\n        edges.sort();\n\n        let num_edges = edges.len();\n        let mut index = 0;\n        let mut merged_edges: Vec<[f64; 4]> = Vec::new();\n\n        while index < num_edges {\n            let e1 = edges[index];\n            if index < num_edges - 1 {\n                let e2 = edges[index + 1];\n                if e1[0] == e2[0] && e1[1] == e2[1] {\n                    merged_edges.push([e1[0] as f64, e1[1] as f64, e1[2] as f64, e2[2] as f64]);\n                    index += 2;\n                } else {\n                    merged_edges.push([e1[0] as f64, e1[1] as f64, e1[2] as f64, -1.0]);\n                    index += 1;\n                }\n            } else {\n                merged_edges.push([e1[0] as f64, e1[1] as f64, e1[2] as f64, -1.0]);\n                index += 1\n            }\n        }\n\n        let mut edges_centers = Vec::new();\n\n        for me in merged_edges {\n            let p1 = self.v[me[0] as usize].copy();\n            let p2 = self.v[me[1] as usize].copy();\n            let cp: Vector3 = Mesh::center_point(&p1, &p2);\n            edges_centers.push([me[0] as f64, me[1] as f64, me[2] as f64, me[3] as f64, cp.x, cp.y, cp.z]);\n        }\n        return edges_centers;\n    }\n    pub fn get_edge_points(&self, edges_faces: &Vec<[f64; 7]>, face_points: &Vec<Vector3>) -> Vec<Vector3> {\n        let mut edge_points = Vec::new();\n\n        for edge in edges_faces {\n            let cp = Vector3::new(edge[4], edge[5], edge[6]);\n            let fp1: Vector3 = face_points[edge[2] as usize].copy();\n            let mut fp2: Vector3 = fp1.copy();\n            if edge[3] != -1.0 { fp2 = face_points[edge[3] as usize].copy() };\n            let cfp = Mesh::center_point(&fp1, &fp2);\n            let edge_point = Mesh::center_point(&cp, &cfp);\n            edge_points.push(edge_point);\n        }\n\n        return edge_points\n    }\n    pub fn get_avg_face_points(&self, face_points: &Vec<Vector3>) -> Vec<Vector3> {\n        let num_points = self.v.len();\n        let mut temp_points = Vec::new();\n        let mut div: Vec<i32> = Vec::new();\n\n        for _ in 0..num_points {\n            temp_points.push(Vector3::new(0.0, 0.0, 0.0));\n            div.push(0)\n        };\n\n        for face_num in 0..self.f.len() {\n            let mut fp = face_points[face_num].copy();\n            for point_num in self.f[face_num].r {\n                let tp = temp_points[point_num].copy();\n                temp_points[point_num] = tp + &fp;\n                div[point_num] += 1;\n            }\n        }\n\n        let mut avg_face_points: Vec<Vector3> = Vec::new();\n        for i in 0..temp_points.len() {\n            let tp: Vector3 = temp_points[i].copy();\n            let t = tp / (div[i] as f64);\n            avg_face_points.push(t.copy());\n        }\n\n        return avg_face_points;\n    }\n    pub fn get_avg_mid_edges(&self, edges_faces: &Vec<[f64; 7]>) -> Vec<Vector3> {\n        let num_points = self.v.len();\n        let mut temp_points = Vec::new();\n        let mut div: Vec<i32> = Vec::new();\n\n        for point_num in 0..num_points{ temp_points.push(Vector3::new(0.0, 0.0, 0.0)); div.push(0)}\n        for edge in edges_faces {\n            let cp = Vector3::new(edge[4], edge[5], edge[6]);\n            for point_num in [edge[0] as usize, edge[1] as usize] {\n                let tp = temp_points[point_num].copy();\n                temp_points[point_num] = tp + &cp;\n                div[point_num] += 1\n            }\n        }\n\n        let mut avg_mid_edges: Vec<Vector3> = Vec::new();\n\n        for i in 0..temp_points.len(){\n            let ame: Vector3 = temp_points[i].copy() / (div[i] as f64);\n            avg_mid_edges.push(ame)}\n\n        return avg_mid_edges\n    }\n    pub fn get_points_faces(&self) -> Vec<i32> {\n        let num_points = self.v.len();\n        let mut points_faces: Vec<i32> = Vec::new();\n\n        for point_num in 0..num_points{points_faces.push(0)}\n\n        for face_num in 0..self.f.len() {\n            for point_num in self.f[face_num].r {\n                points_faces[point_num] += 1;\n            }\n        }\n        return points_faces\n    }\n    pub fn get_new_points(&self, points_faces: &Vec<i32>, avg_face_points: &Vec<Vector3>, avg_mid_edges: &Vec<Vector3>) -> Vec<Vector3> {\n        let mut new_points: Vec<Vector3> = Vec::new();\n\n        for point_num in 0..self.v.len() {\n            let n = points_faces[point_num] as f64;\n            let m1 = (n - 3.0) / n;\n            let m2 = 1.0 / n;\n            let m3 = 2.0 / n;\n            let old_coords = self.v[point_num].copy();\n            let p1 = old_coords * m1;\n            let afp = avg_face_points[point_num].copy();\n            let p2 = afp * m2;\n            let ame = avg_mid_edges[point_num].copy();\n            let p3 = ame * m3;\n            let p4 = p1 + &p2;\n            let new_coords = p4 + &p3;\n\n            new_points.push(new_coords);\n        }\n\n        return new_points;\n    }\n\n    pub fn switch_nums(point_nums: [f64; 2]) -> [f64; 2] {\n        return if point_nums[0] < point_nums[1] { point_nums } else {[point_nums[1], point_nums[0]]}\n    }\n\n    pub fn get_key(points: [f64; 2]) -> String {\n        return points[0].to_string() + \";\" + &*points[1].to_string();\n    }\n\n    pub fn subdivide(&mut self) {\n        let face_points = self.get_face_points();\n        let edges_faces = self.get_edges_faces();\n        let edge_points = self.get_edge_points(&edges_faces, &face_points);\n        let avg_face_points = self.get_avg_face_points(&face_points);\n        let avg_mid_edges = self.get_avg_mid_edges(&edges_faces);\n        let points_faces = self.get_points_faces();\n        let mut new_points = self.get_new_points(&points_faces, &avg_face_points, &avg_mid_edges);\n\n        let mut face_point_nums = Vec::new();\n        let mut next_point_num = new_points.len();\n\n        for face_point in face_points {\n            new_points.push(face_point);\n            face_point_nums.push(next_point_num);\n            next_point_num += 1;\n        }\n\n        let mut edge_point_nums: HashMap<String, usize> = HashMap::new();\n\n        for edge_num in 0..edges_faces.len() {\n            let point_num_1 = edges_faces[edge_num][0];\n            let point_num_2 = edges_faces[edge_num][1];\n            let edge_point = edge_points[edge_num].copy();\n            new_points.push(edge_point);\n            edge_point_nums.insert(Mesh::get_key([point_num_1, point_num_2]), next_point_num);\n            next_point_num += 1;\n        }\n\n        let mut new_faces = Vec::new();\n\n        for old_face_num in 0..self.f.len() {\n            let old_face = self.f[old_face_num].copy();\n            let a = old_face.r[0] as f64;\n            let b = old_face.r[1] as f64;\n            let c = old_face.r[2] as f64;\n            let face_point_abc = face_point_nums[old_face_num];\n            let edge_point_ab = *edge_point_nums.get(&*Mesh::get_key(Mesh::switch_nums([a, b]))).unwrap();\n            let edge_point_bc = *edge_point_nums.get(&*Mesh::get_key(Mesh::switch_nums([b, c]))).unwrap();\n            let edge_point_ca = *edge_point_nums.get(&*Mesh::get_key(Mesh::switch_nums([c, a]))).unwrap();\n            new_faces.push([a, edge_point_ab as f64, face_point_abc as f64, edge_point_ca as f64]);\n            new_faces.push([b, edge_point_bc as f64, face_point_abc as f64, edge_point_ab as f64]);\n            new_faces.push([c, edge_point_ca as f64, face_point_abc as f64, edge_point_bc as f64]);\n        }\n        self.f = Vec::new();\n\n        for face_num in 0..new_faces.len() {\n            let curr_face = new_faces[face_num];\n            let mut t1: Triangle = Triangle::new();\n            let mut t2: Triangle = Triangle::new();\n            t1.p[0] = Vector3::new(new_points[curr_face[0] as usize].x, new_points[curr_face[0] as usize].y, new_points[curr_face[0] as usize].z);\n            t1.p[1] = Vector3::new(new_points[curr_face[1] as usize].x, new_points[curr_face[1] as usize].y, new_points[curr_face[1] as usize].z);\n            t1.p[2] = Vector3::new(new_points[curr_face[2] as usize].x, new_points[curr_face[2] as usize].y, new_points[curr_face[2] as usize].z);\n            t2.p[0] = Vector3::new(new_points[curr_face[2] as usize].x, new_points[curr_face[2] as usize].y, new_points[curr_face[2] as usize].z);\n            t2.p[1] = Vector3::new(new_points[curr_face[3] as usize].x, new_points[curr_face[3] as usize].y, new_points[curr_face[3] as usize].z);\n            t2.p[2] = Vector3::new(new_points[curr_face[0] as usize].x, new_points[curr_face[0] as usize].y, new_points[curr_face[0] as usize].z);\n            t1.r = [curr_face[0] as usize, curr_face[1] as usize, curr_face[2] as usize];\n            t2.r = [curr_face[2] as usize, curr_face[3] as usize, curr_face[0] as usize];\n            self.f.push(t1);\n            self.f.push(t2);\n        }\n        self.v = new_points;\n    }\n}\n",
    "title": "Catmull–Clark subdivision surface",
    "url": "http://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const LEFT_ALPHABET_CT: &str = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\nconst RIGHT_ALPHABET_PT: &str = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\nconst ZENITH: usize = 0;\nconst NADIR: usize = 12;\nconst SEQUENCE: &str = \"WELLDONEISBETTERTHANWELLSAID\";\n\nfn cipher(letter: &char, left: &String, right: &String) -> (usize, char) {\n    let pos = right.find(*letter).unwrap();\n    let cipher = left.chars().nth(pos).unwrap();\n    (pos, cipher)\n}\n\nfn main() {\n    let mut left = LEFT_ALPHABET_CT.to_string();\n    let mut right = RIGHT_ALPHABET_PT.to_string();\n\n    let ciphertext = SEQUENCE.chars()\n        .map(|letter| {\n            let (pos, cipher_char) = cipher(&letter, &left, &right);\n            left = format!(\"{}{}\", &left[pos..], &left[..pos]);\n            left = format!(\"{}{}{}{}\", &left[ZENITH..1], &left[2..NADIR+2], &left[1..2], &left[NADIR+2..]);\n            if pos != right.len() - 1 {\n                right = format!(\"{}{}\", &right[pos + 1..], &right[..pos + 1]);\n            }\n            right = format!(\"{}{}{}{}\", &right[ZENITH..2], &right[3..NADIR+2], &right[2..3], &right[NADIR+2..]);\n            cipher_char\n        })\n        .collect::<String>();\n\n    println!(\"Plaintext: {}\", SEQUENCE);\n    println!(\"Ciphertext: {}\", ciphertext);\n}",
    "title": "Chaocipher",
    "url": "http://rosettacode.org/wiki/Chaocipher"
  },
  {
    "local_code": "use std::f32::consts::PI;\n\nuse image::DynamicImage::ImageLuma8;\nuse rand::prelude::*;\n\nfn main() {\n    let max_iterations = 50_000;\n    let img_side = 800;\n    let tri_size = 400.0;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Create triangle vertices\n    let mut vertices = [(0.0, 0.0); 3];\n    for (i, (x, y)) in vertices.iter_mut().enumerate() {\n        *x = (img_side as f32 / 2.) + (tri_size / 2.) * (PI * i as f32 * 2. / 3.).cos();\n        *y = (img_side as f32 / 2.) + (tri_size / 2.) * (PI * i as f32 * 2. / 3.).sin();\n    }\n    for &(x, y) in &vertices {\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255]));\n    }\n\n    // Iterate chaos game\n    let mut rng = thread_rng();\n    let mut x = img_side as f32 / 2.0;\n    let mut y = img_side as f32 / 2.0;\n    for _ in 0..max_iterations {\n        let (choice_x, choice_y) = vertices.choose(&mut rng).unwrap();\n        x = (x + choice_x) / 2.0;\n        y = (y + choice_y) / 2.0;\n\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255]));\n    }\n\n    ImageLuma8(imgbuf).save(\"fractal.png\").unwrap();\n}\n",
    "path": "tasks/chaos-game",
    "remote_code": "\nextern crate image;\nextern crate rand;\n\nuse rand::prelude::*;\nuse std::f32;\n\nfn main() {\n    let max_iterations = 50_000;\n    let img_side = 800;\n    let tri_size = 400.0;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Create triangle vertices\n    let mut vertices: [[f32; 2]; 3] = [[0.0, 0.0]; 3];\n    for i in 0..vertices.len() {\n        vertices[i][0] = (img_side as f32 / 2.0)\n            + (tri_size / 2.0) * (f32::consts::PI * i as f32 * 2.0 / 3.0).cos();\n        vertices[i][1] = (img_side as f32 / 2.0)\n            + (tri_size / 2.0) * (f32::consts::PI * i as f32 * 2.0 / 3.0).sin();\n    }\n    for v in &vertices {\n        imgbuf.put_pixel(v[0] as u32, v[1] as u32, image::Luma([255u8]));\n    }\n    println!(\"Verticies: {:?}\", vertices);\n\n    // Iterate chaos game\n    let mut rng = rand::thread_rng();\n    let mut x = img_side as f32 / 2.0;\n    let mut y = img_side as f32 / 2.0;\n    for _ in 0..max_iterations {\n        let choice = rng.gen_range(0..vertices.len());\n        x = (x + vertices[choice][0]) / 2.0;\n        y = (y + vertices[choice][1]) / 2.0;\n\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255u8]));\n    }\n\n    // Save image\n    imgbuf.save(\"fractal.png\").unwrap();\n}\n",
    "title": "Chaos game",
    "url": "http://rosettacode.org/wiki/Chaos_game"
  },
  {
    "local_code": "#![allow(clippy::print_literal)]\n\nuse std::char;\n\nfn main() {\n    // ascii char\n    println!(\"{}\", b'a');\n    println!(\"{}\", 97 as char);\n\n    // unicode char\n    println!(\"{}\", 'π' as u32);\n    println!(\"{}\", char::from_u32(960).unwrap());\n}\n",
    "path": "tasks/character-codes",
    "remote_code": "use std::char::from_u32;\n\nfn main() {\n    //ascii char\n    println!(\"{}\", 'a' as u8);\n    println!(\"{}\", 97 as char);\n\n    //unicode char\n    println!(\"{}\", 'π' as u32);\n    println!(\"{}\", from_u32(960).unwrap());\n}",
    "title": "Character codes",
    "url": "http://rosettacode.org/wiki/Character_codes"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, RwLock};\nuse std::thread;\n\ntype Username = String;\n\n/// Sends a message to all clients except the sending client.\nfn broadcast_message(\n    user: &str,\n    clients: &mut HashMap<String, TcpStream>,\n    message: &str,\n) -> io::Result<()> {\n    for (client, stream) in clients.iter_mut() {\n        if client != user {\n            writeln!(stream, \"{}\", message)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn chat_loop(listener: &TcpListener) -> io::Result<()> {\n    let local_clients: Arc<RwLock<HashMap<Username, TcpStream>>> =\n        Arc::new(RwLock::new(HashMap::new()));\n\n    println!(\"Accepting connections on {}\", listener.local_addr()?.port());\n\n    for stream in listener.incoming() {\n        match stream {\n            Ok(stream) => {\n                let client_clients = Arc::clone(&local_clients);\n                thread::spawn(move || -> io::Result<()> {\n                    let mut reader = BufReader::new(stream.try_clone()?);\n                    let mut writer = stream;\n\n                    let mut name = String::new();\n                    loop {\n                        write!(writer, \"Please enter a username: \")?;\n                        reader.read_line(&mut name)?;\n                        name = name.trim().to_owned();\n\n                        let clients = client_clients.read().unwrap();\n                        if !clients.contains_key(&name) {\n                            writeln!(writer, \"Welcome, {}!\", &name)?;\n                            break;\n                        }\n\n                        writeln!(writer, \"That username is taken.\")?;\n                        name.clear();\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.insert(name.clone(), writer);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has joined the chat room.\", &name),\n                        )?;\n                    }\n\n                    for line in reader.lines() {\n                        let mut clients = client_clients.write().unwrap();\n                        broadcast_message(&name, &mut *clients, &format!(\"{}: {}\", &name, line?))?;\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.remove(&name);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has left the chat room.\", &name),\n                        )?;\n                    }\n\n                    Ok(())\n                });\n            }\n            Err(e) => {\n                println!(\"Connection failed: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn main() {\n    let listener = TcpListener::bind((\"localhost\", 7000)).unwrap();\n    chat_loop(&listener).unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::prelude::*;\n    use std::io::{BufReader, BufWriter};\n    use std::net::{TcpListener, TcpStream, ToSocketAddrs};\n    use std::thread;\n\n    fn create_client<A>(addr: A) -> (BufReader<TcpStream>, BufWriter<TcpStream>)\n    where\n        A: ToSocketAddrs,\n    {\n        let client = TcpStream::connect(addr).unwrap();\n        let reader = BufReader::new(client.try_clone().unwrap());\n        let writer = BufWriter::new(client.try_clone().unwrap());\n\n        (reader, writer)\n    }\n\n    /// In this test, a single client logs into the chat server. They should obtain a greeting once\n    /// they enter their name.\n    #[test]\n    fn single_client() {\n        let listener = TcpListener::bind((\"localhost\", 7000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader, mut writer) = create_client(\"localhost:7000\");\n\n        writeln!(writer, \"client\").unwrap();\n        writer.flush().unwrap();\n\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client!\\n\", line);\n        line.clear();\n\n        // Send a message.\n        writeln!(writer, \"Hello, world!\").unwrap();\n        writer.flush().unwrap();\n    }\n\n    /// In this test, there are two clients. One client will log in successfully. Then, a second\n    /// client will log in. The first client should see a message notifying them that the second\n    /// client has logged in. The first client will then send a chat message, which the second\n    /// client should see. Finally, the second client will close their connection, which should\n    /// generate a message for the first client indicating that the second client has logged out.\n    #[test]\n    fn multi_client() {\n        let listener = TcpListener::bind((\"localhost\", 8000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader1, mut writer1) = create_client(\"localhost:8000\");\n\n        writeln!(writer1, \"client_1\").unwrap();\n        writer1.flush().unwrap();\n\n        let mut line = String::new();\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client_1!\\n\", line);\n        line.clear();\n\n        let (mut reader2, mut writer2) = create_client(\"localhost:8000\");\n        writeln!(writer2, \"client_2\").unwrap();\n        writer2.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client_2!\\n\", line);\n        line.clear();\n\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"client_2 has joined the chat room.\\n\", line);\n        line.clear();\n\n        writeln!(writer1, \"Hello, world!\").unwrap();\n        writer1.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"client_1: Hello, world!\\n\", line);\n        line.clear();\n\n        drop(writer2);\n        drop(reader2);\n\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"client_2 has left the chat room.\\n\", line);\n    }\n\n    /// Ensures that a user cannot have the username of a user already in the chat room.\n    #[test]\n    fn existing_name() {\n        let listener = TcpListener::bind((\"localhost\", 9000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader1, mut writer1) = create_client(\"localhost:9000\");\n\n        writeln!(writer1, \"client\").unwrap();\n        writer1.flush().unwrap();\n\n        let mut line = String::new();\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client!\\n\", line);\n        line.clear();\n\n        let (mut reader2, mut writer2) = create_client(\"localhost:9000\");\n\n        writeln!(writer2, \"client\").unwrap();\n        writer2.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: That username is taken.\\n\", line);\n        line.clear();\n    }\n}\n",
    "path": "tasks/chat-server",
    "remote_code": "\nuse std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, RwLock};\nuse std::thread;\n\ntype Username = String;\n\n/// Sends a message to all clients except the sending client.\nfn broadcast_message(\n    user: &str,\n    clients: &mut HashMap<String, TcpStream>,\n    message: &str,\n) -> io::Result<()> {\n    for (client, stream) in clients.iter_mut() {\n        if client != user {\n            writeln!(stream, \"{}\", message)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn chat_loop(listener: &TcpListener) -> io::Result<()> {\n    let local_clients: Arc<RwLock<HashMap<Username, TcpStream>>> =\n        Arc::new(RwLock::new(HashMap::new()));\n\n    println!(\"Accepting connections on {}\", listener.local_addr()?.port());\n\n    for stream in listener.incoming() {\n        match stream {\n            Ok(stream) => {\n                let client_clients = Arc::clone(&local_clients);\n                thread::spawn(move || -> io::Result<()> {\n                    let mut reader = BufReader::new(stream.try_clone()?);\n                    let mut writer = stream;\n\n                    let mut name = String::new();\n                    loop {\n                        write!(writer, \"Please enter a username: \")?;\n                        reader.read_line(&mut name)?;\n                        name = name.trim().to_owned();\n\n                        let clients = client_clients.read().unwrap();\n                        if !clients.contains_key(&name) {\n                            writeln!(writer, \"Welcome, {}!\", &name)?;\n                            break;\n                        }\n\n                        writeln!(writer, \"That username is taken.\")?;\n                        name.clear();\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.insert(name.clone(), writer);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has joined the chat room.\", &name),\n                        )?;\n                    }\n\n                    for line in reader.lines() {\n                        let mut clients = client_clients.write().unwrap();\n                        broadcast_message(&name, &mut *clients, &format!(\"{}: {}\", &name, line?))?;\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.remove(&name);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has left the chat room.\", &name),\n                        )?;\n                    }\n\n                    Ok(())\n                });\n            }\n            Err(e) => {\n                println!(\"Connection failed: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn main() {\n    let listener = TcpListener::bind((\"localhost\", 7000)).unwrap();\n    chat_loop(&listener).unwrap();\n}\n",
    "title": "Chat server",
    "url": "http://rosettacode.org/wiki/Chat_server"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Check Machin-like formulas",
    "url": "http://rosettacode.org/wiki/Check_Machin-like_formulas"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(unix)]\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdin is tty\");\n    } else {\n        println!(\"stdin is not tty\");\n    }\n}\n\n#[cfg(not(unix))]\nfn main() {\n    unimplemented!();\n}\n",
    "path": "tasks/check-input-device-is-a-terminal",
    "remote_code": "/* Uses C library interface */\n\nextern crate libc;\n\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}",
    "title": "Check input device is a terminal",
    "url": "http://rosettacode.org/wiki/Check_input_device_is_a_terminal"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(unix)]\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDOUT_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}\n\n#[cfg(not(unix))]\nfn main() {\n    unimplemented!();\n}\n",
    "path": "tasks/check-output-device-is-a-terminal",
    "remote_code": "/* Uses C library interface */\n\nextern crate libc;\n\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDOUT_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}",
    "title": "Check output device is a terminal",
    "url": "http://rosettacode.org/wiki/Check_output_device_is_a_terminal"
  },
  {
    "local_code": "use std::path::Path;\n\nfn main() {\n    let paths = [\"input.txt\", \"docs\"];\n    for path in paths.iter().map(|&x| Path::new(x)) {\n        let msg = if path.exists() {\n            \"exists\"\n        } else {\n            \"does not exist\"\n        };\n\n        println!(\"{} {}.\", path.display(), msg);\n    }\n}\n",
    "path": "tasks/check-that-file-exists",
    "remote_code": "use std::fs;\n\nfn main() {\n    for file in [\"input.txt\", \"docs\", \"/input.txt\", \"/docs\"].iter() {\n        match fs::metadata(file) {\n            Ok(attr) => {\n                if attr.is_dir() {\n                    println!(\"{} is a directory\", file);\n                }else {\n                    println!(\"{} is a file\", file);\n                }\n            },\n            Err(_) => {\n                println!(\"{} does not exist\", file);\n            }\n        };\n    }\n}\n",
    "title": "Check that file exists",
    "url": "http://rosettacode.org/wiki/Check_that_file_exists"
  },
  {
    "local_code": "//! We implement this task using Rust's Barriers.  Barriers are simply thread synchronization\n//! points--if a task waits at a barrier, it will not continue until the number of tasks for which\n//! the variable was initialized are also waiting at the barrier, at which point all of them will\n//! stop waiting.  This can be used to allow threads to do asynchronous work and guarantee\n//! properties at checkpoints.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::mpsc::channel;\nuse std::sync::{Arc, Barrier};\nuse std::thread::spawn;\n\nuse array_init::array_init;\n\npub fn checkpoint() {\n    const NUM_TASKS: usize = 10;\n    const NUM_ITERATIONS: u8 = 10;\n\n    let barrier = Barrier::new(NUM_TASKS);\n    let events: [AtomicBool; NUM_TASKS] = array_init(|_| AtomicBool::new(false));\n\n    // Arc for sharing between tasks\n    let arc = Arc::new((barrier, events));\n    // Channel for communicating when tasks are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_TASKS {\n        let arc = Arc::clone(&arc);\n        let tx = tx.clone();\n        // Spawn a new worker\n        spawn(move || {\n            let (ref barrier, ref events) = *arc;\n            // Assign an event to this task\n            let event = &events[i];\n            // Start processing events\n            for _ in 0..NUM_ITERATIONS {\n                // Between checkpoints 4 and 1, turn this task's event on.\n                event.store(true, Ordering::Release);\n                // Checkpoint 1\n                barrier.wait();\n                // Between checkpoints 1 and 2, all events are on.\n                assert!(events.iter().all(|e| e.load(Ordering::Acquire)));\n                // Checkpoint 2\n                barrier.wait();\n                // Between checkpoints 2 and 3, turn this task's event off.\n                event.store(false, Ordering::Release);\n                // Checkpoint 3\n                barrier.wait();\n                // Between checkpoints 3 and 4, all events are off.\n                assert!(events.iter().all(|e| !e.load(Ordering::Acquire)));\n                // Checkpoint 4\n                barrier.wait();\n            }\n            // Finish processing events.\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // The main thread will not exit until all tasks have exited.\n    for _ in 0..NUM_TASKS {\n        rx.recv().unwrap();\n    }\n}\n\nfn main() {\n    checkpoint();\n}\n\n#[test]\nfn test_checkpoint() {\n    checkpoint();\n}\n",
    "path": "tasks/checkpoint-synchronization",
    "remote_code": "\n//! We implement this task using Rust's Barriers.  Barriers are simply thread synchronization\n//! points--if a task waits at a barrier, it will not continue until the number of tasks for which\n//! the variable was initialized are also waiting at the barrier, at which point all of them will\n//! stop waiting.  This can be used to allow threads to do asynchronous work and guarantee\n//! properties at checkpoints.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::mpsc::channel;\nuse std::sync::{Arc, Barrier};\nuse std::thread::spawn;\n\nuse array_init::array_init;\n\npub fn checkpoint() {\n    const NUM_TASKS: usize = 10;\n    const NUM_ITERATIONS: u8 = 10;\n\n    let barrier = Barrier::new(NUM_TASKS);\n    let events: [AtomicBool; NUM_TASKS] = array_init(|_| AtomicBool::new(false));\n\n    // Arc for sharing between tasks\n    let arc = Arc::new((barrier, events));\n    // Channel for communicating when tasks are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_TASKS {\n        let arc = Arc::clone(&arc);\n        let tx = tx.clone();\n        // Spawn a new worker\n        spawn(move || {\n            let (ref barrier, ref events) = *arc;\n            // Assign an event to this task\n            let event = &events[i];\n            // Start processing events\n            for _ in 0..NUM_ITERATIONS {\n                // Between checkpoints 4 and 1, turn this task's event on.\n                event.store(true, Ordering::Release);\n                // Checkpoint 1\n                barrier.wait();\n                // Between checkpoints 1 and 2, all events are on.\n                assert!(events.iter().all(|e| e.load(Ordering::Acquire)));\n                // Checkpoint 2\n                barrier.wait();\n                // Between checkpoints 2 and 3, turn this task's event off.\n                event.store(false, Ordering::Release);\n                // Checkpoint 3\n                barrier.wait();\n                // Between checkpoints 3 and 4, all events are off.\n                assert!(events.iter().all(|e| !e.load(Ordering::Acquire)));\n                // Checkpoint 4\n                barrier.wait();\n            }\n            // Finish processing events.\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // The main thread will not exit until all tasks have exited.\n    for _ in 0..NUM_TASKS {\n        rx.recv().unwrap();\n    }\n}\n\nfn main() {\n    checkpoint();\n}\n",
    "title": "Checkpoint synchronization",
    "url": "http://rosettacode.org/wiki/Checkpoint_synchronization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Chernick's Carmichael numbers",
    "url": "http://rosettacode.org/wiki/Chernick's_Carmichael_numbers"
  },
  {
    "local_code": "// This version is based on the Go version on Rosettacode\n\n#[derive(PartialEq, Debug, Copy, Clone)]\nenum Month {\n    May,\n    June,\n    July,\n    August,\n}\n\n#[derive(PartialEq, Debug, Copy, Clone)]\nstruct Birthday {\n    month: Month,\n    day: u8,\n}\n\nimpl Birthday {\n    fn month_unique_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .filter(|birthday| birthday.month == self.month)\n            .count()\n            == 1\n    }\n\n    fn day_unique_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .filter(|birthday| birthday.day == self.day)\n            .count()\n            == 1\n    }\n\n    fn month_with_unique_day_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .any(|birthday| self.month == birthday.month && birthday.day_unique_in(birthdays))\n    }\n}\n\nfn solution() -> Option<Birthday> {\n    let mut choices: Vec<Birthday> = vec![\n        Birthday {\n            month: Month::May,\n            day: 15,\n        },\n        Birthday {\n            month: Month::May,\n            day: 16,\n        },\n        Birthday {\n            month: Month::May,\n            day: 19,\n        },\n        Birthday {\n            month: Month::June,\n            day: 17,\n        },\n        Birthday {\n            month: Month::June,\n            day: 18,\n        },\n        Birthday {\n            month: Month::July,\n            day: 14,\n        },\n        Birthday {\n            month: Month::July,\n            day: 16,\n        },\n        Birthday {\n            month: Month::August,\n            day: 14,\n        },\n        Birthday {\n            month: Month::August,\n            day: 15,\n        },\n        Birthday {\n            month: Month::August,\n            day: 17,\n        },\n    ];\n\n    // Albert knows the month but doesn't know the day.\n    // So the month can't be unique within the choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| !(&birthday.month_unique_in(&choices_copy)));\n\n    // Albert also knows that Bernard doesn't know the answer.\n    // So the month can't have a unique day.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| !(birthday.month_with_unique_day_in(&choices_copy)));\n\n    // Bernard now knows the answer.\n    // So the day must be unique within the remaining choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| birthday.day_unique_in(&choices_copy));\n\n    // Albert now knows the answer too.\n    // So the month must be unique within the remaining choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| birthday.month_unique_in(&choices_copy));\n\n    if choices.len() == 1 {\n        Some(choices[0])\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match solution() {\n        Some(solution) => println!(\"Cheryl's birthday is {:?}\", solution),\n        None => panic!(\"Didn't work!\"),\n    }\n}\n\n#[test]\nfn test_solution_works() {\n    let solution = solution().unwrap();\n\n    let real_solution = Birthday {\n        month: Month::July,\n        day: 16,\n    };\n\n    assert_eq!(solution, real_solution);\n}\n",
    "path": "tasks/cheryl-birthday",
    "remote_code": "\n// This version is based on the Go version on Rosettacode\n\n#[derive(PartialEq, Debug, Copy, Clone)]\nenum Month {\n    May,\n    June,\n    July,\n    August,\n}\n\n#[derive(PartialEq, Debug, Copy, Clone)]\nstruct Birthday {\n    month: Month,\n    day: u8,\n}\n\nimpl Birthday {\n    fn month_unique_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .filter(|birthday| birthday.month == self.month)\n            .count()\n            == 1\n    }\n\n    fn day_unique_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .filter(|birthday| birthday.day == self.day)\n            .count()\n            == 1\n    }\n\n    fn month_with_unique_day_in(&self, birthdays: &[Birthday]) -> bool {\n        birthdays\n            .iter()\n            .any(|birthday| self.month == birthday.month && birthday.day_unique_in(birthdays))\n    }\n}\n\nfn solution() -> Option<Birthday> {\n    let mut choices: Vec<Birthday> = vec![\n        Birthday {\n            month: Month::May,\n            day: 15,\n        },\n        Birthday {\n            month: Month::May,\n            day: 16,\n        },\n        Birthday {\n            month: Month::May,\n            day: 19,\n        },\n        Birthday {\n            month: Month::June,\n            day: 17,\n        },\n        Birthday {\n            month: Month::June,\n            day: 18,\n        },\n        Birthday {\n            month: Month::July,\n            day: 14,\n        },\n        Birthday {\n            month: Month::July,\n            day: 16,\n        },\n        Birthday {\n            month: Month::August,\n            day: 14,\n        },\n        Birthday {\n            month: Month::August,\n            day: 15,\n        },\n        Birthday {\n            month: Month::August,\n            day: 17,\n        },\n    ];\n\n    // Albert knows the month but doesn't know the day.\n    // So the month can't be unique within the choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| !(&birthday.month_unique_in(&choices_copy)));\n\n    // Albert also knows that Bernard doesn't know the answer.\n    // So the month can't have a unique day.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| !(birthday.month_with_unique_day_in(&choices_copy)));\n\n    // Bernard now knows the answer.\n    // So the day must be unique within the remaining choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| birthday.day_unique_in(&choices_copy));\n\n    // Albert now knows the answer too.\n    // So the month must be unique within the remaining choices.\n    let choices_copy = choices.clone();\n    choices.retain(|birthday| birthday.month_unique_in(&choices_copy));\n\n    if choices.len() == 1 {\n        Some(choices[0])\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match solution() {\n        Some(solution) => println!(\"Cheryl's birthday is {:?}\", solution),\n        None => panic!(\"Didn't work!\"),\n    }\n}\n\n",
    "title": "Cheryl's birthday",
    "url": "http://rosettacode.org/wiki/Cheryl's_birthday"
  },
  {
    "local_code": "fn main() {\n    let l = [(2, 3), (3, 5), (2, 7)];\n    println!(\"{:?}\", chinese_remainder(&l));\n}\n\nfn chinese_remainder(l: &[(i32, i32)]) -> Option<i32> {\n    let product = l.iter().fold(1, |prod, &(_, n)| prod * n);\n\n    let mut sum = 0;\n    for &(a, n) in l {\n        let mut term = product / n;\n\n        let inv = match mul_inv(term, n) {\n            Some(inv) => inv,\n            None => return None,\n        };\n\n        term *= inv;\n        term *= a;\n        sum += term;\n    }\n    Some(sum % product)\n}\n\nfn mul_inv(a: i32, b: i32) -> Option<i32> {\n    let (gcd, mut x, _) = egcd(a, b);\n    if gcd != 1 {\n        // No multiplicative inverse exists\n        return None;\n    }\n    if x < 0 {\n        x += b;\n    }\n    Some(x % b)\n}\n\n#[allow(clippy::many_single_char_names)]\nfn egcd(a: i32, b: i32) -> (i32, i32, i32) {\n    if a == 0 {\n        return (b, 0, 1);\n    }\n\n    let (g, y, x) = egcd(b % a, a);\n    (g, x - (b / a) * y, y)\n}\n\n#[test]\nfn test() {\n    let l = [(2, 3), (3, 5), (2, 7)];\n    assert_eq!(chinese_remainder(&l), Some(23));\n\n    let l = [(10, 11), (4, 22), (9, 19)];\n    assert_eq!(chinese_remainder(&l), None);\n}\n",
    "path": "tasks/chinese-remainder-theorem",
    "remote_code": "fn egcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if a == 0 {\n        (b, 0, 1)\n    } else {\n        let (g, x, y) = egcd(b % a, a);\n        (g, y - (b / a) * x, x)\n    }\n}\n\nfn mod_inv(x: i64, n: i64) -> Option<i64> {\n    let (g, x, _) = egcd(x, n);\n    if g == 1 {\n        Some((x % n + n) % n)\n    } else {\n        None\n    }\n}\n\nfn chinese_remainder(residues: &[i64], modulii: &[i64]) -> Option<i64> {\n    let prod = modulii.iter().product::<i64>();\n\n    let mut sum = 0;\n\n    for (&residue, &modulus) in residues.iter().zip(modulii) {\n        let p = prod / modulus;\n        sum += residue * mod_inv(p, modulus)? * p\n    }\n\n    Some(sum % prod)\n}\n\nfn main() {\n    let modulii = [3,5,7];\n    let residues = [2,3,2];\n\n    match chinese_remainder(&residues, &modulii) {\n        Some(sol) => println!(\"{}\", sol),\n        None      => println!(\"modulii not pairwise coprime\")\n    }\n\n}",
    "title": "Chinese remainder theorem",
    "url": "http://rosettacode.org/wiki/Chinese_remainder_theorem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn chinese_zodiac(year: usize) -> String {\n    static ANIMALS: [&str; 12] = [\n        \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\",\n        \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\",\n    ];\n    static ASPECTS: [&str; 2] = [\"Yang\", \"Yin\"];\n    static ELEMENTS: [&str; 5] = [\"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\"];\n    static STEMS: [char; 10] = [\n        '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸',\n    ];\n    static BRANCHES: [char; 12] = [\n        '子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥',\n    ];\n    static S_NAMES: [&str; 10] = [\n        \"jiă\", \"yĭ\", \"bĭng\", \"dīng\", \"wù\", \"jĭ\", \"gēng\", \"xīn\", \"rén\", \"gŭi\",\n    ];\n    static B_NAMES: [&str; 12] = [\n        \"zĭ\", \"chŏu\", \"yín\", \"măo\", \"chén\", \"sì\",\n        \"wŭ\", \"wèi\", \"shēn\", \"yŏu\", \"xū\", \"hài\",\n    ];\n\n    let y = year - 4;\n    let s = y % 10;\n    let b = y % 12;\n\n    let stem = STEMS[s];\n    let branch = BRANCHES[b];\n    let s_name = S_NAMES[s];\n    let b_name = B_NAMES[b];\n    let element = ELEMENTS[s / 2];\n    let animal = ANIMALS[b];\n    let aspect = ASPECTS[s % 2];\n    let cycle = y % 60 + 1;\n\n    format!(\n        \"{}    {}{}    {:9}  {:7}  {:7}  {:6}  {:02}/60\",\n        year,\n        stem,\n        branch,\n        format!(\"{}-{}\", s_name, b_name),\n        element,\n        animal,\n        aspect,\n        cycle\n    )\n}\n\nfn main() {\n    let years = [1935, 1938, 1968, 1972, 1976, 1984, 2017];\n    println!(\"Year  Chinese  Pinyin     Element  Animal   Aspect  Cycle\");\n    println!(\"----  -------  ---------  -------  -------  ------  -----\");\n    for &year in &years {\n        println!(\"{}\", chinese_zodiac(year));\n    }\n}",
    "title": "Chinese zodiac",
    "url": "http://rosettacode.org/wiki/Chinese_zodiac"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn cholesky(mat: Vec<f64>, n: usize) -> Vec<f64> {\n    let mut res = vec![0.0; mat.len()];\n    for i in 0..n {\n        for j in 0..(i+1){\n            let mut s = 0.0;\n            for k in 0..j {\n                s += res[i * n + k] * res[j * n + k];\n            }\n            res[i * n + j] = if i == j { (mat[i * n + i] - s).sqrt() } else { (1.0 / res[j * n + j] * (mat[i * n + j] - s)) };\n        }\n    }\n    res\n}\n\nfn show_matrix(matrix: Vec<f64>, n: usize){\n    for i in 0..n {\n        for j in 0..n {\n            print!(\"{:.4}\\t\", matrix[i * n + j]);\n        }\n        println!(\"\");\n    }\n    println!(\"\");\n}\n\nfn main(){\n    let dimension = 3 as usize;\n    let m1 = vec![25.0, 15.0, -5.0,\n                  15.0, 18.0,  0.0,\n                  -5.0,  0.0, 11.0];\n    let res1 = cholesky(m1, dimension);\n    show_matrix(res1, dimension);\n\n    let dimension = 4 as usize;\n    let m2 = vec![18.0, 22.0,  54.0,  42.0,\n                  22.0, 70.0,  86.0,  62.0,\n                  54.0, 86.0, 174.0, 134.0,\n                  42.0, 62.0, 134.0, 106.0];\n    let res2 = cholesky(m2, dimension);\n    show_matrix(res2, dimension);\n}\n",
    "title": "Cholesky decomposition",
    "url": "http://rosettacode.org/wiki/Cholesky_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Chowla numbers",
    "url": "http://rosettacode.org/wiki/Chowla_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::rc::Rc;\nuse std::ops::{Add, Mul};\n\n#[derive(Clone)]\nstruct Church<'a, T: 'a> {\n    runner: Rc<dyn Fn(Rc<dyn Fn(T) -> T + 'a>) -> Rc<dyn Fn(T) -> T + 'a> + 'a>,\n}\n\nimpl<'a, T> Church<'a, T> {\n    fn zero() -> Self {\n        Church {\n            runner: Rc::new(|_f| {\n                Rc::new(|x| x)\n            })\n        }\n    }\n\n    fn succ(self) -> Self {\n        Church {\n            runner: Rc::new(move |f| {\n                let g = self.runner.clone();\n                Rc::new(move |x| f(g(f.clone())(x)))\n            })\n        }\n    }\n\n    fn run(&self, f: impl Fn(T) -> T + 'a) -> Rc<dyn Fn(T) -> T + 'a> {\n        (self.runner)(Rc::new(f))\n    }\n\n    fn exp(self, rhs: Church<'a, Rc<dyn Fn(T) -> T + 'a>>) -> Self\n    {\n        Church {\n            runner: (rhs.runner)(self.runner)\n        }\n    }\n}\n\nimpl<'a, T> Add for Church<'a, T> {\n    type Output = Church<'a, T>;\n\n    fn add(self, rhs: Church<'a, T>) -> Church<T> {\n        Church {\n            runner: Rc::new(move |f| {\n                let self_runner = self.runner.clone();\n                let rhs_runner = rhs.runner.clone();\n                Rc::new(move |x| (self_runner)(f.clone())((rhs_runner)(f.clone())(x)))\n            })\n        }\n    }\n}\n\nimpl<'a, T> Mul for Church<'a, T> {\n    type Output = Church<'a, T>;\n\n    fn mul(self, rhs: Church<'a, T>) -> Church<T> {\n        Church {\n            runner: Rc::new(move |f| {\n                (self.runner)((rhs.runner)(f))\n            })\n        }\n    }\n}\n\nimpl<'a, T> From<i32> for Church<'a, T> {\n    fn from(n: i32) -> Church<'a, T> {\n        let mut ret = Church::zero();\n        for _ in 0..n {\n            ret = ret.succ();\n        }\n        ret\n    }\n}\n\nimpl<'a> From<&Church<'a, i32>> for i32  {\n    fn from(c: &Church<'a, i32>) -> i32 {\n        c.run(|x| x + 1)(0)\n    }\n}\n\nfn three<'a, T>() -> Church<'a, T> {\n    Church::zero().succ().succ().succ()\n}\n\nfn four<'a, T>() -> Church<'a, T> {\n    Church::zero().succ().succ().succ().succ()\n}\n\nfn main() {\n    println!(\"three =\\t{}\", i32::from(&three()));\n    println!(\"four =\\t{}\", i32::from(&four()));\n\n    println!(\"three + four =\\t{}\", i32::from(&(three() + four())));\n    println!(\"three * four =\\t{}\", i32::from(&(three() * four())));\n\n    println!(\"three ^ four =\\t{}\", i32::from(&(three().exp(four()))));\n    println!(\"four ^ three =\\t{}\", i32::from(&(four().exp(three()))));\n}",
    "title": "Church numerals",
    "url": "http://rosettacode.org/wiki/Church_numerals"
  },
  {
    "local_code": "//! Translation of C.\n\nuse std::f64;\nuse std::fmt;\n\n#[derive(Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nfn distance(p1: Point, p2: Point) -> f64 {\n    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({:.4}, {:.4})\", self.x, self.y)\n    }\n}\n\nfn describe_circle(p1: Point, p2: Point, r: f64) {\n    let sep = distance(p1, p2);\n\n    if (sep - 0.).abs() < f64::EPSILON {\n        if r == 0. {\n            println!(\"No circles can be drawn through {}\", p1);\n        } else {\n            println!(\"Infinitely many circles can be drawn through {}\", p1);\n        }\n    } else if (sep - 2.0 * r).abs() < f64::EPSILON {\n        println!(\n            \"Given points are opposite ends of a diameter of the circle with center \\\n             ({:.4},{:.4}) and r {:.4}\",\n            (p1.x + p2.x) / 2.0,\n            (p1.y + p2.y) / 2.0,\n            r\n        );\n    } else if (sep - 2.0 * r).abs() < f64::EPSILON {\n        println!(\n            \"Given points are farther away from each other than a diameter of a circle with \\\n             r {:.4}\",\n            r\n        );\n    } else {\n        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();\n\n        println!(\"Two circles are possible.\");\n        println!(\n            \"Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center \\\n             ({:.4}, {:.4}), r {:.4}\",\n            ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y - p2.y) / sep,\n            (p1.y + p2.y) / 2.0 + mirror_dist * (p2.x - p1.x) / sep,\n            r,\n            (p1.x + p2.x) / 2.0 - mirror_dist * (p1.y - p2.y) / sep,\n            (p1.y + p2.y) / 2.0 - mirror_dist * (p2.x - p1.x) / sep,\n            r\n        );\n    }\n}\n\nfn main() {\n    let points = vec![\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.8765,\n                y: 0.2345,\n            },\n        ),\n        (\n            Point {\n                x: 0.0000,\n                y: 2.0000,\n            },\n            Point {\n                x: 0.0000,\n                y: 0.0000,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.8765,\n                y: 0.2345,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n        ),\n    ];\n    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];\n\n    for (p, r) in points.into_iter().zip(radii.into_iter()) {\n        println!(\"\\nPoints: ({}, {}), Radius: {:.4}\", p.0, p.1, r);\n        describe_circle(p.0, p.1, r);\n    }\n}\n",
    "path": "tasks/circles-of-given-radius-through-two-points",
    "remote_code": "use std::fmt;\n\n#[derive(Clone,Copy)]\nstruct Point {\n    x: f64,\n    y: f64\n}\n\nfn distance (p1: Point, p2: Point) -> f64 {\n    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({:.4}, {:.4})\", self.x, self.y)\n    }\n}\n\nfn describe_circle(p1: Point, p2: Point, r: f64) {\n    let sep = distance(p1, p2);\n\n    if sep == 0. {\n        if r == 0. {\n            println!(\"No circles can be drawn through {}\", p1);\n        } else {\n            println!(\"Infinitely many circles can be drawn through {}\", p1);\n        }\n    } else if sep == 2.0 * r {\n        println!(\"Given points are opposite ends of a diameter of the circle with center ({:.4},{:.4}) and r {:.4}\",\n                (p1.x+p2.x) / 2.0, (p1.y+p2.y) / 2.0, r);\n    } else if sep > 2.0 * r {\n        println!(\"Given points are farther away from each other than a diameter of a circle with r {:.4}\", r);\n    } else {\n        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();\n\n        println!(\"Two circles are possible.\");\n        println!(\"Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center ({:.4}, {:.4}), r {:.4}\",\n                ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 + mirror_dist*(p2.x-p1.x)/sep,\n                r,\n                (p1.x+p2.x) / 2.0 - mirror_dist*(p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 - mirror_dist*(p2.x-p1.x)/sep, r);\n    }\n}\n\nfn main() {\n    let points: Vec<(Point, Point)> = vec![\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.0000, y: 2.0000 }, Point { x: 0.0000, y: 0.0000 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 })\n    ];\n    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];\n\n    for (p, r) in points.into_iter().zip(radii.into_iter()) {\n        println!(\"\\nPoints: ({}, {}), Radius: {:.4}\", p.0, p.1, r);\n        describe_circle(p.0, p.1, r);\n    }\n}",
    "title": "Circles of given radius through two points",
    "url": "http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.8\"\n\nfn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn cycle(n: u32) -> u32 {\n    let mut m: u32 = n;\n    let mut p: u32 = 1;\n    while m >= 10 {\n        p *= 10;\n        m /= 10;\n    }\n    m + 10 * (n % p)\n}\n\nfn is_circular_prime(p: u32) -> bool {\n    if !is_prime(p) {\n        return false;\n    }\n    let mut p2: u32 = cycle(p);\n    while p2 != p {\n        if p2 < p || !is_prime(p2) {\n            return false;\n        }\n        p2 = cycle(p2);\n    }\n    true\n}\n\nfn test_repunit(digits: usize) {\n    use rug::{integer::IsPrime, Integer};\n    let repunit = \"1\".repeat(digits);\n    let bignum = Integer::from_str_radix(&repunit, 10).unwrap();\n    if bignum.is_probably_prime(10) != IsPrime::No {\n        println!(\"R({}) is probably prime.\", digits);\n    } else {\n        println!(\"R({}) is not prime.\", digits);\n    }\n}\n\nfn main() {\n    use rug::{integer::IsPrime, Integer};\n    println!(\"First 19 circular primes:\");\n    let mut count = 0;\n    let mut p: u32 = 2;\n    while count < 19 {\n        if is_circular_prime(p) {\n            if count > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", p);\n            count += 1;\n        }\n        p += 1;\n    }\n    println!();\n    println!(\"Next 4 circular primes:\");\n    let mut repunit: u32 = 1;\n    let mut digits: usize = 1;\n    while repunit < p {\n        repunit = 10 * repunit + 1;\n        digits += 1;\n    }\n    let mut bignum = Integer::from(repunit);\n    count = 0;\n    while count < 4 {\n        if bignum.is_probably_prime(15) != IsPrime::No {\n            if count > 0 {\n                print!(\", \");\n            }\n            print!(\"R({})\", digits);\n            count += 1;\n        }\n        digits += 1;\n        bignum = bignum * 10 + 1;\n    }\n    println!();\n    test_repunit(5003);\n    test_repunit(9887);\n    test_repunit(15073);\n    test_repunit(25031);\n    test_repunit(35317);\n    test_repunit(49081);\n}",
    "title": "Circular primes",
    "url": "http://rosettacode.org/wiki/Circular_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Cistercian numerals",
    "url": "http://rosettacode.org/wiki/Cistercian_numerals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct MyClass {\n    variable: i32, // member variable = instance variable\n}\n\nimpl MyClass {\n    // member function = method, with its implementation\n    fn some_method(&mut self) {\n        self.variable = 1;\n    }\n\n    // constructor, with its implementation\n    fn new() -> MyClass {\n        // Here could be more code.\n        MyClass { variable: 0 }\n    }\n}\n\nfn main () {\n    // Create an instance in the stack.\n    let mut instance = MyClass::new();\n\n    // Create an instance in the heap.\n    let mut p_instance = Box::new(MyClass::new());\n\n    // Invoke method on both istances,\n    instance.some_method();\n    p_instance.some_method();\n\n    // Both instances are automatically deleted when their scope ends.\n}\n",
    "title": "Classes",
    "url": "http://rosettacode.org/wiki/Classes"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Closest-pair_problem\n\n//! We interpret complex numbers as points in the Cartesian plane, here. We also use the\n//! [sweepline/plane sweep closest pairs algorithm][algorithm] instead of the divide-and-conquer\n//! algorithm, since it's (arguably) easier to implement, and an efficient implementation does not\n//! require use of unsafe.\n//!\n//! [algorithm]: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairPS.html\nextern crate num;\n\nuse num::complex::Complex;\nuse std::cmp::{Ordering, PartialOrd};\nuse std::collections::BTreeSet;\ntype Point = Complex<f32>;\n\n/// Wrapper around `Point` (i.e. `Complex<f32>`) so that we can use a `TreeSet`\n#[derive(PartialEq)]\nstruct YSortedPoint {\n    point: Point,\n}\n\nimpl PartialOrd for YSortedPoint {\n    fn partial_cmp(&self, other: &YSortedPoint) -> Option<Ordering> {\n        (self.point.im, self.point.re).partial_cmp(&(other.point.im, other.point.re))\n    }\n}\n\nimpl Ord for YSortedPoint {\n    fn cmp(&self, other: &YSortedPoint) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Eq for YSortedPoint {}\n\nfn closest_pair(points: &mut [Point]) -> Option<(Point, Point)> {\n    if points.len() < 2 {\n        return None;\n    }\n\n    points.sort_by(|a, b| (a.re, a.im).partial_cmp(&(b.re, b.im)).unwrap());\n\n    let mut closest_pair = (points[0], points[1]);\n    let mut closest_distance_sqr = (points[0] - points[1]).norm_sqr();\n    let mut closest_distance = closest_distance_sqr.sqrt();\n\n    // the strip that we inspect for closest pairs as we sweep right\n    let mut strip: BTreeSet<YSortedPoint> = BTreeSet::new();\n    strip.insert(YSortedPoint { point: points[0] });\n    strip.insert(YSortedPoint { point: points[1] });\n\n    // index of the leftmost point on the strip (on points)\n    let mut leftmost_idx = 0;\n\n    // Start the sweep!\n    for (idx, point) in points.iter().enumerate().skip(2) {\n        // Remove all points farther than `closest_distance` away from `point`\n        // along the x-axis\n        while leftmost_idx < idx {\n            let leftmost_point = &points[leftmost_idx];\n            if (leftmost_point.re - point.re).powi(2) < closest_distance_sqr {\n                break;\n            }\n            strip.remove(&YSortedPoint {\n                point: *leftmost_point,\n            });\n            leftmost_idx += 1;\n        }\n\n        // Compare to points in bounding box\n        {\n            let low_bound = YSortedPoint {\n                point: Point {\n                    re: ::std::f32::INFINITY,\n                    im: point.im - closest_distance,\n                },\n            };\n            let mut strip_iter = strip.iter().skip_while(|&p| p < &low_bound);\n            loop {\n                let point2 = match strip_iter.next() {\n                    None => break,\n                    Some(p) => p.point,\n                };\n                if point2.im - point.im >= closest_distance {\n                    // we've reached the end of the box\n                    break;\n                }\n                let dist_sqr = (*point - point2).norm_sqr();\n                if dist_sqr < closest_distance_sqr {\n                    closest_pair = (point2, *point);\n                    closest_distance_sqr = dist_sqr;\n                    closest_distance = dist_sqr.sqrt();\n                }\n            }\n        }\n\n        // Insert point into strip\n        strip.insert(YSortedPoint { point: *point });\n    }\n\n    Some(closest_pair)\n}\n\npub fn main() {\n    let mut test_data = [\n        Complex::new(0.654682, 0.925557),\n        Complex::new(0.409382, 0.619391),\n        Complex::new(0.891663, 0.888594),\n        Complex::new(0.716629, 0.996200),\n        Complex::new(0.477721, 0.946355),\n        Complex::new(0.925092, 0.818220),\n        Complex::new(0.624291, 0.142924),\n        Complex::new(0.211332, 0.221507),\n        Complex::new(0.293786, 0.691701),\n        Complex::new(0.839186, 0.728260),\n    ];\n    let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n    println!(\"Closest pair: {} and {}\", p1, p2);\n    println!(\"Distance: {}\", (p1 - p2).norm_sqr().sqrt());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::closest_pair;\n    use num::complex::Complex;\n\n    #[test]\n    fn random_floats() {\n        let mut test_data = [\n            Complex::new(0.654682, 0.925557),\n            Complex::new(0.409382, 0.619391),\n            Complex::new(0.891663, 0.888594),\n            Complex::new(0.716629, 0.996200),\n            Complex::new(0.477721, 0.946355),\n            Complex::new(0.925092, 0.818220),\n            Complex::new(0.624291, 0.142924),\n            Complex::new(0.211332, 0.221507),\n            Complex::new(0.293786, 0.691701),\n            Complex::new(0.839186, 0.728260),\n        ];\n        let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n        assert!((p1.re - 0.891663).abs() < 1e-6f32);\n        assert!((p1.im - 0.888594).abs() < 1e-6f32);\n        assert!((p2.re - 0.925092).abs() < 1e-6f32);\n        assert!((p2.im - 0.818220).abs() < 1e-6f32);\n        assert!(((p1 - p2).norm_sqr() - 0.0779102f32.powi(2)).abs() < 1e-6f32);\n    }\n}\n",
    "path": "tasks/closest-pair-problem",
    "remote_code": "\n//! We interpret complex numbers as points in the Cartesian plane, here. We also use the\n//! [sweepline/plane sweep closest pairs algorithm][algorithm] instead of the divide-and-conquer\n//! algorithm, since it's (arguably) easier to implement, and an efficient implementation does not\n//! require use of unsafe.\n//!\n//! [algorithm]: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairPS.html\nextern crate num;\n\nuse num::complex::Complex;\nuse std::cmp::{Ordering, PartialOrd};\nuse std::collections::BTreeSet;\ntype Point = Complex<f32>;\n\n/// Wrapper around `Point` (i.e. `Complex<f32>`) so that we can use a `TreeSet`\n#[derive(PartialEq)]\nstruct YSortedPoint {\n    point: Point,\n}\n\nimpl PartialOrd for YSortedPoint {\n    fn partial_cmp(&self, other: &YSortedPoint) -> Option<Ordering> {\n        (self.point.im, self.point.re).partial_cmp(&(other.point.im, other.point.re))\n    }\n}\n\nimpl Ord for YSortedPoint {\n    fn cmp(&self, other: &YSortedPoint) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Eq for YSortedPoint {}\n\nfn closest_pair(points: &mut [Point]) -> Option<(Point, Point)> {\n    if points.len() < 2 {\n        return None;\n    }\n\n    points.sort_by(|a, b| (a.re, a.im).partial_cmp(&(b.re, b.im)).unwrap());\n\n    let mut closest_pair = (points[0], points[1]);\n    let mut closest_distance_sqr = (points[0] - points[1]).norm_sqr();\n    let mut closest_distance = closest_distance_sqr.sqrt();\n\n    // the strip that we inspect for closest pairs as we sweep right\n    let mut strip: BTreeSet<YSortedPoint> = BTreeSet::new();\n    strip.insert(YSortedPoint { point: points[0] });\n    strip.insert(YSortedPoint { point: points[1] });\n\n    // index of the leftmost point on the strip (on points)\n    let mut leftmost_idx = 0;\n\n    // Start the sweep!\n    for (idx, point) in points.iter().enumerate().skip(2) {\n        // Remove all points farther than `closest_distance` away from `point`\n        // along the x-axis\n        while leftmost_idx < idx {\n            let leftmost_point = &points[leftmost_idx];\n            if (leftmost_point.re - point.re).powi(2) < closest_distance_sqr {\n                break;\n            }\n            strip.remove(&YSortedPoint {\n                point: *leftmost_point,\n            });\n            leftmost_idx += 1;\n        }\n\n        // Compare to points in bounding box\n        {\n            let low_bound = YSortedPoint {\n                point: Point {\n                    re: ::std::f32::INFINITY,\n                    im: point.im - closest_distance,\n                },\n            };\n            let mut strip_iter = strip.iter().skip_while(|&p| p < &low_bound);\n            loop {\n                let point2 = match strip_iter.next() {\n                    None => break,\n                    Some(p) => p.point,\n                };\n                if point2.im - point.im >= closest_distance {\n                    // we've reached the end of the box\n                    break;\n                }\n                let dist_sqr = (*point - point2).norm_sqr();\n                if dist_sqr < closest_distance_sqr {\n                    closest_pair = (point2, *point);\n                    closest_distance_sqr = dist_sqr;\n                    closest_distance = dist_sqr.sqrt();\n                }\n            }\n        }\n\n        // Insert point into strip\n        strip.insert(YSortedPoint { point: *point });\n    }\n\n    Some(closest_pair)\n}\n\npub fn main() {\n    let mut test_data = [\n        Complex::new(0.654682, 0.925557),\n        Complex::new(0.409382, 0.619391),\n        Complex::new(0.891663, 0.888594),\n        Complex::new(0.716629, 0.996200),\n        Complex::new(0.477721, 0.946355),\n        Complex::new(0.925092, 0.818220),\n        Complex::new(0.624291, 0.142924),\n        Complex::new(0.211332, 0.221507),\n        Complex::new(0.293786, 0.691701),\n        Complex::new(0.839186, 0.728260),\n    ];\n    let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n    println!(\"Closest pair: {} and {}\", p1, p2);\n    println!(\"Distance: {}\", (p1 - p2).norm_sqr().sqrt());\n}\n",
    "title": "Closest-pair problem",
    "url": "http://rosettacode.org/wiki/Closest-pair_problem"
  },
  {
    "local_code": "use std::iter::Map;\nuse std::ops::RangeFrom;\n\n#[allow(dead_code)]\nfn simple_unboxed() {\n    // simple usage when unboxed closures will do\n    let mut v = Vec::new();\n    for i in 0..10 {\n        v.push(move || i * i);\n    }\n    println!(\"7th val: {}\", v[7]());\n}\n\n// given a number x, return the (boxed) closure that\n// computes x squared\nfn closure_gen<'a>(x: u32) -> Box<dyn Fn() -> f64 + 'a> {\n    Box::new(move || f64::from(x).powi(2))\n}\n\n// type alias for the closure iterator\ntype ClosureIter<'a> = Map<RangeFrom<u32>, fn(u32) -> Box<dyn Fn() -> f64 + 'a>>;\n\n// return an iterator that on every iteration returns\n// a closure computing the index of the iteration squared\nfn closures_iterator<'a>() -> ClosureIter<'a> {\n    let cl_gen: fn(u32) -> Box<dyn Fn() -> f64 + 'a> = closure_gen;\n    (0..).map(cl_gen)\n}\n\nfn main() {\n    // Take the first 9 closures from the iterator and call them\n    for c in closures_iterator().take(9) {\n        println!(\"{}\", c())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{closure_gen, closures_iterator};\n\n    use std::f64;\n\n    #[test]\n    fn closure_generator() {\n        let five_squarer = closure_gen(5);\n        assert!((five_squarer() - 25f64).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn closure_iterator() {\n        for (idx, f) in closures_iterator().take(9).enumerate() {\n            assert!((f() - (idx as f64).powi(2)).abs() < f64::EPSILON);\n        }\n    }\n}\n",
    "path": "tasks/closures/value-capture",
    "remote_code": "fn main() {\n    let fs: Vec<_> = (0..10).map(|i| {move || i*i} ).collect();\n    println!(\"7th val: {}\", fs[7]());\n}",
    "title": "Closures/Value capture",
    "url": "http://rosettacode.org/wiki/Closures/Value_capture"
  },
  {
    "local_code": "//! Examples of various Rust collections. Contains both original examples and those taken from the\n//! standard API documentation.\n\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n\n#[allow(clippy::vec_init_then_push)]\nfn main() {\n    // Stack-allocated collections\n    // ---------------------------\n\n    // Array\n    //\n    // Arrays ([T]) are stack allocated, fixed size collections of items of the same type.\n    let a = [1u8, 2, 3, 4, 5]; // a is of type [u8; 5];\n    let b = [0; 256]; // Equivalent to `let b = [0, 0, 0, 0, 0, 0... repeat 256 times]`\n    assert_eq!(a.len(), 5);\n    assert_eq!(b.len(), 256);\n\n    // Slice\n    //\n    // Slices (&[T]) are dynamically sized views into contiguous sequences (arrays, vectors,\n    // strings)\n    let array = [1, 2, 3, 4, 5];\n    let slice = &array[0..2];\n    println!(\"{:?}\", slice); // Output: [1, 2]\n\n    // String slice\n    //\n    // String slices are (str) are slices of Unicode characters. Plain strs are almost never seen\n    // in Rust. Instead either heap-allocated Strings or borrowed string slices (&str which is\n    // basically equivalent to a slice of bytes: &[u8]) are more often used. It should be noted\n    // that strings are not indexable as they are UTF-8 (meaning that characters are not\n    // necessarily of a fixed size) however iterators can be created over codepoints or graphemes.\n    let string = \"this is a string slice\";\n    println!(\"{}\", string);\n\n    // Heap-allocated collections\n    // --------------------------\n\n    // Vector\n    //\n    // Vectors (Vec<T>) are a growable list type. According to the Rust documentation, you want to\n    // use a Vector if:\n    // - You want to collect items up to be processed or sent elsewhere later, and don't care about\n    //   any properties of the actual values being stored.\n    // - You want a sequence of elements in a particular order, and will only be appending to (or\n    //   near) the end.\n    // - You want a stack.\n    // - You want a resizable array.\n    // - You want a heap-allocated array.\n    let mut v1 = Vec::new();\n    v1.push(1);\n    v1.push(2);\n    v1.push(3);\n\n    // Or (mostly) equivalently via a convenient macro in the standard library,\n    let v2 = vec![1, 2, 3];\n    assert_eq!(v1, v2);\n\n    // String\n    //\n    // Strings are growable strings stored as a UTF-8 buffer which are just Vec<u8>s under the\n    // hood. Like strs, they are not indexable (for the same reasons) but iterators can be created\n    // over the graphemes, codepoints or bytes therein.\n    let x = \"abc\"; // x is of type &str (a borrowed string slice)\n    let s1 = String::from(x);\n    assert_eq!(x, &s1);\n\n    // or alternatively,\n    let s2 = x.to_owned();\n    assert_eq!(s1, s2);\n\n    // VecDequeue\n    //\n    // A growable ring buffer. According to the Rust documentation you should use VecDequeue<T>\n    // when:\n    // - You want a Vec that supports efficient insertion at both ends of the sequence.\n    // - You want a queue.\n    // - You want a double-ended queue (deque).\n    let mut deque = VecDeque::new();\n    deque.push_back(3);\n    deque.push_back(4);\n    deque.push_back(5);\n    assert_eq!(deque.get(1), Some(&4));\n\n    // Linked List\n    //\n    // A doubly-linked list. According to the Rust documentation, you should use it when:\n    // - You want a Vec or VecDeque of unknown size, and can't tolerate amortization.\n    // - You want to efficiently split and append lists.\n    // - You are absolutely certain you really, truly, want a doubly linked list.\n    let mut a = LinkedList::new();\n    let mut b = LinkedList::new();\n    a.push_back(1);\n    a.push_back(2);\n    b.push_back(3);\n    b.push_back(4);\n\n    // A constant-time and -memory operation.\n    a.append(&mut b);\n\n    for e in &a {\n        println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n    }\n\n    // HashMap\n    //\n    // A hash map implementation which uses linear probing with Robin Hood bucket stealing.\n    // According to the Rust documentation, you should use it when:\n    // - You want to associate arbitrary keys with an arbitrary value.\n    // - You want a cache.\n    // - You want a map, with no extra functionality.\n    let mut map = HashMap::new();\n    map.insert(1, \"a\");\n    map.insert(2, \"b\");\n    map.insert(3, \"c\");\n    for (key, value) in map {\n        println!(\"key: {}, value: {}\", key, value);\n    }\n\n    // BTreeMap\n    //\n    // A map based on a B-Tree. According to the Rust documentation, you should use it when:\n    // - You're interested in what the smallest or largest key-value pair is.\n    // - You want to find the largest or smallest key that is smaller or larger than something.\n    // - You want to be able to get all of the entries in order on-demand.\n    // - You want a sorted map.\n    let mut map = BTreeMap::new();\n    map.insert(1, \"a\");\n    map.insert(2, \"b\");\n    map.insert(3, \"c\");\n    assert_eq!(map.get(&1), Some(&\"a\"));\n\n    // HashSet/BTreeSet\n    //\n    // Set implementations that use an empty tuple () as the value of their respective maps (and\n    // implement different methods). They should be used when:\n    // - You just want to remember which keys you've seen.\n    // - There is no meaningful value to associate with your keys.\n    // - You just want a set.\n    let mut set = HashSet::new();\n    set.insert(1);\n    set.insert(2);\n    set.insert(3);\n    set.insert(2);\n    assert_eq!(set.len(), 3);\n\n    // BinaryHeap\n    //\n    // A priority queue implemented with a binary heap. You should use it when\n    // - You want to store a bunch of elements, but only ever want to process the \"biggest\" or\n    //   \"most important\" one at any given time.\n    // - You want a priority queue.\n    let mut heap = BinaryHeap::new();\n    heap.push(1);\n    heap.push(5);\n    heap.push(2);\n    assert_eq!(heap.peek(), Some(&5));\n}\n",
    "path": "tasks/collections",
    "remote_code": "let a = [1u8,2,3,4,5]; // a is of type [u8; 5];\nlet b = [0;256] // Equivalent to `let b = [0,0,0,0,0,0... repeat 256 times]`",
    "title": "Collections",
    "url": "http://rosettacode.org/wiki/Collections"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Color of a screen pixel",
    "url": "http://rosettacode.org/wiki/Color_of_a_screen_pixel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Color quantization",
    "url": "http://rosettacode.org/wiki/Color_quantization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// image = \"0.23\"\n\nuse image::error::ImageResult;\nuse image::{Rgb, RgbImage};\n\nfn hsv_to_rgb(h: f64, s: f64, v: f64) -> Rgb<u8> {\n    let hp = h / 60.0;\n    let c = s * v;\n    let x = c * (1.0 - (hp % 2.0 - 1.0).abs());\n    let m = v - c;\n    let mut r = 0.0;\n    let mut g = 0.0;\n    let mut b = 0.0;\n    if hp <= 1.0 {\n        r = c;\n        g = x;\n    } else if hp <= 2.0 {\n        r = x;\n        g = c;\n    } else if hp <= 3.0 {\n        g = c;\n        b = x;\n    } else if hp <= 4.0 {\n        g = x;\n        b = c;\n    } else if hp <= 5.0 {\n        r = x;\n        b = c;\n    } else {\n        r = c;\n        b = x;\n    }\n    r += m;\n    g += m;\n    b += m;\n    Rgb([(r * 255.0) as u8, (g * 255.0) as u8, (b * 255.0) as u8])\n}\n\nfn write_color_wheel(filename: &str, width: u32, height: u32) -> ImageResult<()> {\n    let mut image = RgbImage::new(width, height);\n    let margin = 10;\n    let diameter = std::cmp::min(width, height) - 2 * margin;\n    let xoffset = (width - diameter) / 2;\n    let yoffset = (height - diameter) / 2;\n    let radius = diameter as f64 / 2.0;\n    for x in 0..=diameter {\n        let rx = x as f64 - radius;\n        for y in 0..=diameter {\n            let ry = y as f64 - radius;\n            let r = ry.hypot(rx) / radius;\n            if r > 1.0 {\n                continue;\n            }\n            let a = 180.0 + ry.atan2(-rx).to_degrees();\n            image.put_pixel(x + xoffset, y + yoffset, hsv_to_rgb(a, r, 1.0));\n        }\n    }\n    image.save(filename)\n}\n\nfn main() {\n    match write_color_wheel(\"color_wheel.png\", 400, 400) {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"{}\", error),\n    }\n}",
    "title": "Color wheel",
    "url": "http://rosettacode.org/wiki/Color_wheel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colorful numbers",
    "url": "http://rosettacode.org/wiki/Colorful_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use pixels::{Pixels, SurfaceTexture}; // 0.2.0\nuse winit::event::*; // 0.24.0\nuse winit::event_loop::{ControlFlow, EventLoop};\nuse winit::window::{Fullscreen, WindowBuilder};\n\nfn main() {\n    let event_loop = EventLoop::new();\n    let window = WindowBuilder::new()\n        .with_title(\"Colour Bars\")\n        .with_decorations(false)\n        .with_fullscreen(Some(Fullscreen::Borderless(None)))\n        .build(&event_loop).unwrap();\n    let size = window.inner_size();\n    let texture = SurfaceTexture::new(size.width, size.height, &window);\n    let mut image_buffer = Pixels::new(8, 1, texture).unwrap();\n    let frame = image_buffer.get_frame();\n    frame.copy_from_slice(&[\n        0x00, 0x00, 0x00, 0xFF, // black\n        0xFF, 0x00, 0x00, 0xFF, // red\n        0x00, 0xFF, 0x00, 0xFF, // green\n        0x00, 0x00, 0xFF, 0xFF, // blue\n        0xFF, 0x00, 0xFF, 0xFF, // magenta\n        0x00, 0xFF, 0xFF, 0xFF, // cyan\n        0xFF, 0xFF, 0x00, 0xFF, // yellow\n        0xFF, 0xFF, 0xFF, 0xFF, // white\n    ]);\n\n    image_buffer.render().unwrap();\n\n    event_loop.run(move |ev, _, flow| {\n        match ev {\n            Event::WindowEvent {\n                event: WindowEvent::KeyboardInput { input, .. }, ..\n            } => {\n                if input.virtual_keycode == Some(VirtualKeyCode::Escape) {\n                    *flow = ControlFlow::Exit;\n                }\n            }\n            Event::RedrawRequested(_) | Event::WindowEvent {\n                event: WindowEvent::Focused(true), ..\n            } => {\n                image_buffer.render().unwrap();\n            }\n            _ => {}\n        }\n    });\n}",
    "title": "Colour bars/Display",
    "url": "http://rosettacode.org/wiki/Colour_bars/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colour pinstripe/Display",
    "url": "http://rosettacode.org/wiki/Colour_pinstripe/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colour pinstripe/Printer",
    "url": "http://rosettacode.org/wiki/Colour_pinstripe/Printer"
  },
  {
    "local_code": "use std::fmt::Display;\n\nfn comb<T>(arr: &[T], n: u32)\nwhere\n    T: Display,\n{\n    let mut incl_arr = vec![false; arr.len()];\n    comb_intern(arr, n as usize, &mut incl_arr, 0);\n}\n\nfn comb_intern<T>(arr: &[T], n: usize, incl_arr: &mut [bool], index: usize)\nwhere\n    T: Display,\n{\n    if arr.len() < n + index {\n        return;\n    }\n    if n == 0 {\n        let it = arr.iter().zip(incl_arr.iter()).filter_map(\n            |(val, incl)| {\n                if *incl {\n                    Some(val)\n                } else {\n                    None\n                }\n            },\n        );\n        for val in it {\n            print!(\"{} \", *val);\n        }\n        println!();\n        return;\n    }\n\n    incl_arr[index] = true;\n    comb_intern(arr, n - 1, incl_arr, index + 1);\n    incl_arr[index] = false;\n\n    comb_intern(arr, n, incl_arr, index + 1);\n}\n\nfn main() {\n    let vec1 = vec![1, 2, 3, 4, 5];\n    comb(&vec1, 3);\n\n    let vec2 = vec![\"A\", \"B\", \"C\", \"D\", \"E\"];\n    comb(&vec2, 3);\n}\nfn comb<T>(slice: &[T], k: usize) -> Vec<Vec<T>>\nwhere\n    T: Copy,\n{\n    // If k == 1, return a vector containing a vector for each element of the slice.\n    if k == 1 {\n        return slice.iter().map(|x| vec![*x]).collect::<Vec<Vec<T>>>();\n    }\n    // If k is exactly the slice length, return the slice inside a vector.\n    if k == slice.len() {\n        return vec![slice.to_vec()];\n    }\n    // Make a vector from the first element + all combinations of k - 1 elements of the rest of the slice.\n    let mut result = comb(&slice[1..], k - 1)\n        .into_iter()\n        .map(|x| [&slice[..1], x.as_slice()].concat())\n        .collect::<Vec<Vec<T>>>();\n    // Extend this last vector with the all the combinations of k elements after from index 1 onward.\n    result.extend(comb(&slice[1..], k));\n    // Return final vector.\n    result\n}\n\nfn main() {\n    let vec1 = vec![1, 2, 3, 4, 5];\n    println!(\"{:?}\", comb(&vec1, 3));\n\n    let vec2 = vec![\"A\", \"B\", \"C\", \"D\", \"E\"];\n    println!(\"{:?}\", comb(&vec2, 3));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn five_numbers_choose_three() {\n        let computed = comb(&[1, 2, 3, 4, 5], 3);\n        let expected = vec![\n            vec![1, 2, 3],\n            vec![1, 2, 4],\n            vec![1, 2, 5],\n            vec![1, 3, 4],\n            vec![1, 3, 5],\n            vec![1, 4, 5],\n            vec![2, 3, 4],\n            vec![2, 3, 5],\n            vec![2, 4, 5],\n            vec![3, 4, 5],\n        ];\n\n        assert_eq!(computed, expected);\n    }\n\n    #[test]\n    fn four_letters_choose_two() {\n        let computed = comb(&[\"h\", \"e\", \"l\", \"l\", \"o\"], 2);\n        let expected = vec![\n            vec![\"h\", \"e\"],\n            vec![\"h\", \"l\"],\n            vec![\"h\", \"l\"],\n            vec![\"h\", \"o\"],\n            vec![\"e\", \"l\"],\n            vec![\"e\", \"l\"],\n            vec![\"e\", \"o\"],\n            vec![\"l\", \"l\"],\n            vec![\"l\", \"o\"],\n            vec![\"l\", \"o\"],\n        ];\n\n        assert_eq!(computed, expected);\n    }\n}\n",
    "path": "tasks/combinations",
    "remote_code": "\nfn comb<T: std::fmt::Default>(arr: &[T], n: uint) {\n  let mut incl_arr: ~[bool] = std::vec::from_elem(arr.len(), false);\n  comb_intern(arr, n, incl_arr, 0);\n}\n\nfn comb_intern<T: std::fmt::Default>(arr: &[T], n: uint, incl_arr: &mut [bool], index: uint) {\n  if (arr.len() < n + index) { return; }\n  if (n == 0) {\n    let mut it = arr.iter().zip(incl_arr.iter()).filter_map(|(val, incl)|\n      if (*incl) { Some(val) } else { None }\n    );\n    for val in it { print!(\"{} \", *val); }\n    print(\"\\n\");\n    return;\n  }\n\n  incl_arr[index] = true;\n  comb_intern(arr, n-1, incl_arr, index+1);\n  incl_arr[index] = false;\n\n  comb_intern(arr, n, incl_arr, index+1);\n}\n\nfn main() {\n  let arr1 = ~[1, 2, 3, 4, 5];\n  comb(arr1, 3);\n\n  let arr2 = ~[\"A\", \"B\", \"C\", \"D\", \"E\"];\n  comb(arr2, 3);\n}\n",
    "title": "Combinations",
    "url": "http://rosettacode.org/wiki/Combinations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Combinations and permutations",
    "url": "http://rosettacode.org/wiki/Combinations_and_permutations"
  },
  {
    "local_code": "// Iterator for the combinations of `arr` with `k` elements with repetitions.\n// Yields the combinations in lexicographical order.\nstruct CombinationsWithRepetitions<'a, T: 'a> {\n    // source array to get combinations from\n    arr: &'a [T],\n    // length of the combinations\n    k: u32,\n    // current counts of each object that represent the next combination\n    counts: Vec<u32>,\n    // whether there are any combinations left\n    remaining: bool,\n}\n\nimpl<'a, T> CombinationsWithRepetitions<'a, T> {\n    fn new(arr: &[T], k: u32) -> CombinationsWithRepetitions<T> {\n        let mut counts = vec![0; arr.len()];\n        counts[arr.len() - 1] = k;\n        CombinationsWithRepetitions {\n            arr,\n            k,\n            counts,\n            remaining: true,\n        }\n    }\n}\n\nimpl<'a, T> Iterator for CombinationsWithRepetitions<'a, T> {\n    type Item = Vec<&'a T>;\n\n    fn next(&mut self) -> Option<Vec<&'a T>> {\n        if !self.remaining {\n            return None;\n        }\n        let mut comb = Vec::new();\n        for (count, item) in self.counts.iter().zip(self.arr.iter()) {\n            for _ in 0..*count {\n                comb.push(item);\n            }\n        }\n        // this is lexicographically largest, and thus the last combination\n        if self.counts[0] == self.k {\n            self.remaining = false;\n        } else {\n            let n = self.counts.len();\n            for i in (1..n).rev() {\n                if self.counts[i] > 0 {\n                    let original_value = self.counts[i];\n                    self.counts[i - 1] += 1;\n                    for j in i..(n - 1) {\n                        self.counts[j] = 0;\n                    }\n                    self.counts[n - 1] = original_value - 1;\n                    break;\n                }\n            }\n        }\n        Some(comb)\n    }\n}\n\nfn main() {\n    let collection = vec![\"iced\", \"jam\", \"plain\"];\n    for comb in CombinationsWithRepetitions::new(&collection, 2) {\n        for item in &comb {\n            print!(\"{} \", item)\n        }\n        println!()\n    }\n}\n",
    "path": "tasks/combinations-with-repetitions",
    "remote_code": "\n// Iterator for the combinations of `arr` with `k` elements with repetitions.\n// Yields the combinations in lexicographical order.\nstruct CombinationsWithRepetitions<'a, T: 'a> {\n    // source array to get combinations from\n    arr: &'a [T],\n    // length of the combinations\n    k: u32,\n    // current counts of each object that represent the next combination\n    counts: Vec<u32>,\n    // whether there are any combinations left\n    remaining: bool,\n}\n\nimpl<'a, T> CombinationsWithRepetitions<'a, T> {\n    fn new(arr: &[T], k: u32) -> CombinationsWithRepetitions<T> {\n        let mut counts = vec![0; arr.len()];\n        counts[arr.len() - 1] = k;\n        CombinationsWithRepetitions {\n            arr,\n            k,\n            counts,\n            remaining: true,\n        }\n    }\n}\n\nimpl<'a, T> Iterator for CombinationsWithRepetitions<'a, T> {\n    type Item = Vec<&'a T>;\n\n    fn next(&mut self) -> Option<Vec<&'a T>> {\n        if !self.remaining {\n            return None;\n        }\n        let mut comb = Vec::new();\n        for (count, item) in self.counts.iter().zip(self.arr.iter()) {\n            for _ in 0..*count {\n                comb.push(item);\n            }\n        }\n        // this is lexicographically largest, and thus the last combination\n        if self.counts[0] == self.k {\n            self.remaining = false;\n        } else {\n            let n = self.counts.len();\n            for i in (1..n).rev() {\n                if self.counts[i] > 0 {\n                    let original_value = self.counts[i];\n                    self.counts[i - 1] += 1;\n                    for j in i..(n - 1) {\n                        self.counts[j] = 0;\n                    }\n                    self.counts[n - 1] = original_value - 1;\n                    break;\n                }\n            }\n        }\n        Some(comb)\n    }\n}\n\nfn main() {\n    let collection = vec![\"iced\", \"jam\", \"plain\"];\n    for comb in CombinationsWithRepetitions::new(&collection, 2) {\n        for item in &comb {\n            print!(\"{} \", item)\n        }\n        println!()\n    }\n}\n\n",
    "title": "Combinations with repetitions",
    "url": "http://rosettacode.org/wiki/Combinations_with_repetitions"
  },
  {
    "local_code": "fn quibble(seq: &[&str]) -> String {\n    match seq.len() {\n        0 => \"{}\".to_string(),\n        1 => format!(\"{{{}}}\", seq[0]),\n        _ => format!(\n            \"{{{} and {}}}\",\n            seq[..seq.len() - 1].join(\", \"),\n            seq.last().unwrap()\n        ),\n    }\n}\n\nfn main() {\n    println!(\"{}\", quibble(&[]));\n    println!(\"{}\", quibble(&[\"ABC\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]));\n}\n\n#[test]\nfn output() {\n    assert_eq!(quibble(&[]), \"{}\");\n    assert_eq!(quibble(&[\"ABC\"]), \"{ABC}\");\n    assert_eq!(quibble(&[\"ABC\", \"DEF\"]), \"{ABC and DEF}\");\n    assert_eq!(quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]), \"{ABC, DEF, G and H}\");\n}\n",
    "path": "tasks/comma-quibbling",
    "remote_code": "\nfn quibble(seq: &[&str]) -> String {\n    match seq.len() {\n        0 => \"{}\".to_string(),\n        1 => format!(\"{{{}}}\", seq[0]),\n        _ => {\n            format!(\"{{{} and {}}}\",\n                    seq[..seq.len() - 1].join(\", \"),\n                    seq.last().unwrap())\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", quibble(&[]));\n    println!(\"{}\", quibble(&[\"ABC\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]));\n}\n",
    "title": "Comma quibbling",
    "url": "http://rosettacode.org/wiki/Comma_quibbling"
  },
  {
    "local_code": "use std::env;\n\nfn main() {\n    for arg in env::args() {\n        println!(\"{}\", arg);\n    }\n}\n",
    "path": "tasks/command-line-arguments",
    "remote_code": "use std::env;\n\nfn main(){\n    let args: Vec<_> = env::args().collect();\n    println!(\"{:?}\", args);\n}",
    "title": "Command-line arguments",
    "url": "http://rosettacode.org/wiki/Command-line_arguments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Commatizing numbers",
    "url": "http://rosettacode.org/wiki/Commatizing_numbers"
  },
  {
    "local_code": "//! A module level comment\n\n// A single line comment\n\n/*\n *  This is a multi-line (aka block) comment\n *\n *  /*\n *   *  containing nested multi-line comment\n *   *  (nesting supported since 0.9-pre https://github.com/rust-lang/rust/issues/9468)\n *   */\n*/\n\n/// Outer single line Rustdoc comments apply to the next item.\n\n/**\n *  Outer multi-line Rustdoc comments.\n *\n *  Leading asterisk (*) in multi-line Rustdoc comments\n *  is not considered to be part of the comment text,\n *  blanks and tabs preceding the initial asterisk (*) are also stripped.\n */\nfn example1() {\n    //! Inner single line Rustdoc comments apply to their enclosing item.\n\n    /*!\n     *  Inner multi-line Rustdoc comments.\n     *  See also https://doc.rust-lang.org/book/documentation.html\n     */\n}\n\n#[doc = \"Unsugared outer Rustdoc comments.\n        (outer attributes are not terminated by a semi-colon)\"]\nfn example2() {\n    #![doc = \"Unsugared inner Rustdoc comments.\n              See also https://doc.rust-lang.org/book/documentation.html\"]\n}\n\nfn main() {\n    example1();\n    example2();\n}\n",
    "path": "tasks/comments",
    "remote_code": "// A single line comment\n\n/*\n    This is a multi-line (aka block) comment\n\n    /*\n        containing nested multi-line comment\n        (nesting supported since 0.9-pre https://github.com/mozilla/rust/issues/9468)\n    */\n*/\n\n\n/// Outer single line Rustdoc comments apply to the next item.\n\n/**\n    Outer multi-line Rustdoc comments.\n\n *  Leading asterisk (*) in multi-line Rustdoc comments\n *  is not considered to be part of the comment text,\n *  blanks and tabs preceding the initial asterisk (*) are also stripped.\n*/\n\nfn example() {\n\n    //! Inner single line Rustdoc comments apply to their enclosing item.\n\n    /*!\n        Inner multi-line Rustdoc comments.\n        See also https://github.com/mozilla/rust/wiki/Doc-using-rustdoc\n    */\n}\n\n#[doc = \"Unsugared outer Rustdoc comments.\n        (outer attributes are not terminated by a semi-colon)\"]\nfn example() {\n    #[doc = \"Unsugared inner Rustdoc comments.\n            (inner attributes are terminated by a semi-colon)\n            See also https://github.com/mozilla/rust/blob/master/doc/rust.md#attributes\"];\n}",
    "title": "Comments",
    "url": "http://rosettacode.org/wiki/Comments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn strings_are_equal(seq: &[&str]) -> bool {\n    match seq {\n        &[] | &[_] => true,\n        &[x, y, ref tail @ ..] if x == y => strings_are_equal(&[&[y], tail].concat()),\n        _ => false\n    }\n}\n\nfn asc_strings(seq: &[&str]) -> bool {\n    match seq {\n        &[] | &[_] => true,\n        &[x, y, ref tail @ ..] if x < y => asc_strings(&[&[y], tail].concat()),\n        _ => false\n    }\n}",
    "title": "Compare a list of strings",
    "url": "http://rosettacode.org/wiki/Compare_a_list_of_strings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn compare_and_report<T: ToString>(string1: T, string2: T) -> String {\n    let strings = [string1.to_string(), string2.to_string()];\n    let difference = strings[0].len() as i32 - strings[1].len() as i32;\n    if difference == 0 { // equal\n        format!(\"\\\"{}\\\" and \\\"{}\\\" are of equal length, {}\", strings[0], strings[1], strings[0].len())\n    } else if difference > 1 { // string1 > string2\n        format!(\"\\\"{}\\\" has length {} and is the longest\\n\\\"{}\\\" has length {} and is the shortest\", strings[0], strings[0].len(), strings[1], strings[1].len())\n    } else { // string2 > string1\n        format!(\"\\\"{}\\\" has length {} and is the longest\\n\\\"{}\\\" has length {} and is the shortest\", strings[1], strings[1].len(), strings[0], strings[0].len())\n    }\n}\n\nfn main() {\n    println!(\"{}\", compare_and_report(\"a\", \"b\"));\n    println!(\"\\n{}\", compare_and_report(\"cd\", \"e\"));\n    println!(\"\\n{}\", compare_and_report(\"f\", \"gh\"));\n}\n",
    "title": "Compare length of two strings",
    "url": "http://rosettacode.org/wiki/Compare_length_of_two_strings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compare sorting algorithms' performance",
    "url": "http://rosettacode.org/wiki/Compare_sorting_algorithms'_performance"
  },
  {
    "local_code": "use static_assertions::const_assert_eq;\n\nconst fn factorial(n: u64) -> u64 {\n    match n {\n        0 | 1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}\n\nfn main() {\n    // We can invoke factorial as a regular function\n    println!(\"{}\", factorial(10));\n}\n\n// This assertion runs at compile time.\nconst_assert_eq!(factorial(10), 3628800);\n",
    "path": "tasks/compile-time-calculation",
    "remote_code": "fn factorial(n: i64) -> i64 {\n    let mut total = 1;\n    for i in 1..n+1 {\n        total *= i;\n    }\n    return total;\n}\n\nfn main() {\n    println!(\"Factorial of 10 is {}.\", factorial(10));\n}",
    "title": "Compile-time calculation",
    "url": "http://rosettacode.org/wiki/Compile-time_calculation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/AST interpreter",
    "url": "http://rosettacode.org/wiki/Compiler/AST_interpreter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/code generator",
    "url": "http://rosettacode.org/wiki/Compiler/code_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/lexical analyzer",
    "url": "http://rosettacode.org/wiki/Compiler/lexical_analyzer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/syntax analyzer",
    "url": "http://rosettacode.org/wiki/Compiler/syntax_analyzer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/virtual machine interpreter",
    "url": "http://rosettacode.org/wiki/Compiler/virtual_machine_interpreter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Composite numbers k with no single digit factors whose factors are all substrings of k",
    "url": "http://rosettacode.org/wiki/Composite_numbers_k_with_no_single_digit_factors_whose_factors_are_all_substrings_of_k"
  },
  {
    "local_code": "//! There are three kinds of `structs` in Rust, two of which would be suitable to represent a\n//! point.\n\n/// C-like struct.\n///\n/// Defines a generic struct where x and y can be of any type `T`.\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\n/// Tuple struct\n///\n/// These are basically just named tuples.\nstruct TuplePoint<T>(T, T);\n\nfn main() {\n    let p1 = Point { x: 1.0, y: 2.5 }; // p is of type Point<f64>\n    println!(\"{}, {}\", p1.x, p1.y);\n\n    let p2 = TuplePoint(1.0, 2.5);\n    println!(\"{}, {}\", p2.0, p2.1);\n\n    // A plain tuple may also be used.\n    let p3 = (1.0, 2.5);\n    println!(\"{}, {}\", p3.0, p3.1)\n}\n",
    "path": "tasks/compound-data-type",
    "remote_code": " // Defines a generic struct where x and y can be of any type T\nstruct Point<T> {\n    x: T,\n    y: T,\n}\nfn main() {\n    let p = Point { x: 1.0, y: 2.5 }; // p is of type Point<f64>\n    println!(\"{}, {}\", p.x, p.y);\n} ",
    "title": "Compound data type",
    "url": "http://rosettacode.org/wiki/Compound_data_type"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::thread;\nuse std::time::Duration;\n\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut thread_spawn = |string| {\n        // We use a random u8 (so an integer from 0 to 255)\n        let duration = u64::from(rng.gen::<u8>());\n        thread::spawn(move || {\n            thread::sleep(Duration::from_millis(duration));\n            println!(\"{}\", string);\n        })\n    };\n\n    let children = vec![\n        thread_spawn(\"Enjoy\"),\n        thread_spawn(\"Rosetta\"),\n        thread_spawn(\"Code\"),\n    ];\n\n    for child in children {\n        child.join().unwrap();\n    }\n}\n",
    "path": "tasks/concurrent-computing",
    "remote_code": "extern crate rand;\nuse std::thread;\nuse rand::thread_rng;\nuse rand::distributions::{Range, IndependentSample};\n\nfn main() {\n    let mut rng = thread_rng();\n    let rng_range = Range::new(0u32, 100);\n    for word in \"Enjoy Rosetta Code\".split_whitespace() {\n        let snooze_time = rng_range.ind_sample(&mut rng);\n        let local_word = word.to_owned();\n        std::thread::spawn(move || {\n            thread::sleep_ms(snooze_time);\n            println!(\"{}\", local_word);\n        });\n    }\n    thread::sleep_ms(1000);\n}",
    "title": "Concurrent computing",
    "url": "http://rosettacode.org/wiki/Concurrent_computing"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// This function will only be compiled if we are compiling on Linux\n#[cfg(target_os = \"linux\")]\nfn running_linux() {\n    println!(\"This is linux\");\n}\n#[cfg(not(target_os = \"linux\"))]\nfn running_linux() {\n    println!(\"This is not linux\");\n}\n\n// If we are on linux, we must be using glibc\n#[cfg_attr(target_os = \"linux\", target_env = \"gnu\")]\n// We must either be compiling for ARM or on a little endian machine that doesn't have 32-bit pointers pointers, on a\n// UNIX like OS and only if we are doing a test build\n#[cfg(all(\n        any(target_arch = \"arm\", target_endian = \"little\"),\n        not(target_pointer_width = \"32\"),\n        unix,\n        test\n        ))]\nfn highly_specific_function() {}\n",
    "title": "Conditional structures",
    "url": "http://rosettacode.org/wiki/Conditional_structures"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate num; // crate for complex numbers\n\nuse num::complex::Complex;\nuse std::ops::Mul;\nuse std::fmt;\n\n\n#[derive(Debug, PartialEq)]\nstruct Matrix<f32> {\n    grid: [[Complex<f32>; 2]; 2], // used to represent matrix\n}\n\n\nimpl Matrix<f32> { // implements a method call for calculating the conjugate transpose\n    fn conjugate_transpose(&self) -> Matrix<f32> {\n        Matrix {grid: [[self.grid[0][0].conj(), self.grid[1][0].conj()],\n        [self.grid[0][1].conj(), self.grid[1][1].conj()]]}\n    }\n}\n\nimpl Mul for Matrix<f32> { // implements '*' (multiplication) for the matrix\n    type Output = Matrix<f32>;\n\n    fn mul(self, other: Matrix<f32>) -> Matrix<f32> {\n        Matrix {grid: [[self.grid[0][0]*other.grid[0][0] + self.grid[0][1]*other.grid[1][0],\n            self.grid[0][0]*other.grid[0][1] + self.grid[0][1]*other.grid[1][1]],\n            [self.grid[1][0]*other.grid[0][0] + self.grid[1][1]*other.grid[1][0],\n            self.grid[1][0]*other.grid[1][0] + self.grid[1][1]*other.grid[1][1]]]}\n    }\n}\n\nimpl Copy for Matrix<f32> {} // implemented to prevent 'moved value' errors in if statements below\nimpl Clone for Matrix<f32> {\n    fn clone(&self) -> Matrix<f32> {\n        *self\n    }\n}\n\nimpl fmt::Display for Matrix<f32> { // implemented to make output nicer\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\\n({}, {})\", self.grid[0][0], self.grid[0][1], self.grid[1][0], self.grid[1][1])\n    }\n}\n\nfn main() {\n    let a = Matrix {grid: [[Complex::new(3.0, 0.0), Complex::new(2.0, 1.0)],\n        [Complex::new(2.0, -1.0), Complex::new(1.0, 0.0)]]};\n\n    let b = Matrix {grid: [[Complex::new(0.5, 0.5), Complex::new(0.5, -0.5)],\n        [Complex::new(0.5, -0.5), Complex::new(0.5, 0.5)]]};\n\n    test_type(a);\n    test_type(b);\n}\n\nfn test_type(mat: Matrix<f32>) {\n    let identity = Matrix {grid: [[Complex::new(1.0, 0.0), Complex::new(0.0, 0.0)],\n        [Complex::new(0.0, 0.0), Complex::new(1.0, 0.0)]]};\n    let mat_conj = mat.conjugate_transpose();\n\n    println!(\"Matrix: \\n{}\\nConjugate transpose: \\n{}\", mat, mat_conj);\n\n    if mat == mat_conj {\n        println!(\"Hermitian?: TRUE\");\n    } else {\n        println!(\"Hermitian?: FALSE\");\n    }\n\n    if mat*mat_conj == mat_conj*mat {\n        println!(\"Normal?: TRUE\");\n    } else {\n        println!(\"Normal?: FALSE\");\n    }\n\n    if mat*mat_conj == identity {\n        println!(\"Unitary?: TRUE\");\n    } else {\n        println!(\"Unitary?: FALSE\");\n    }\n}",
    "title": "Conjugate transpose",
    "url": "http://rosettacode.org/wiki/Conjugate_transpose"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n\nfn print_diffs(vec: &[usize]) {\n    for i in 0..vec.len() {\n        if i > 0 {\n            print!(\" ({}) \", vec[i] - vec[i - 1]);\n        }\n        print!(\"{}\", vec[i]);\n    }\n    println!();\n}\n\nfn main() {\n    let limit = 1000000;\n    let mut asc = Vec::new();\n    let mut desc = Vec::new();\n    let mut max_asc = Vec::new();\n    let mut max_desc = Vec::new();\n    let mut max_asc_len = 0;\n    let mut max_desc_len = 0;\n    for p in primal::Sieve::new(limit)\n        .primes_from(2)\n        .take_while(|x| *x < limit)\n    {\n        let alen = asc.len();\n        if alen > 1 && p - asc[alen - 1] <= asc[alen - 1] - asc[alen - 2] {\n            asc = asc.split_off(alen - 1);\n        }\n        asc.push(p);\n        if asc.len() >= max_asc_len {\n            if asc.len() > max_asc_len {\n                max_asc_len = asc.len();\n                max_asc.clear();\n            }\n            max_asc.push(asc.clone());\n        }\n        let dlen = desc.len();\n        if dlen > 1 && p - desc[dlen - 1] >= desc[dlen - 1] - desc[dlen - 2] {\n            desc = desc.split_off(dlen - 1);\n        }\n        desc.push(p);\n        if desc.len() >= max_desc_len {\n            if desc.len() > max_desc_len {\n                max_desc_len = desc.len();\n                max_desc.clear();\n            }\n            max_desc.push(desc.clone());\n        }\n    }\n    println!(\"Longest run(s) of ascending prime gaps up to {}:\", limit);\n    for v in max_asc {\n        print_diffs(&v);\n    }\n    println!(\"\\nLongest run(s) of descending prime gaps up to {}:\", limit);\n    for v in max_desc {\n        print_diffs(&v);\n    }\n}",
    "title": "Consecutive primes with ascending or descending differences",
    "url": "http://rosettacode.org/wiki/Consecutive_primes_with_ascending_or_descending_differences"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n// This declares the \"Eatable\" constraint. It could contain no function.\ntrait Eatable {\n    fn eat();\n}\n\n// This declares the generic \"FoodBox\" type,\n// whose parameter must satisfy the \"Eatable\" constraint.\n// The objects of this type contain a vector of eatable objects.\nstruct FoodBox<T: Eatable> {\n    _data: Vec<T>,\n}\n\n// This implements the functions associated with the \"FoodBox\" type.\n// This statement is not required, but here it is used\n// to declare a handy \"new\" constructor.\nimpl<T: Eatable> FoodBox<T> {\n    fn new() -> FoodBox<T> {\n        FoodBox::<T> { _data: Vec::<T>::new() }\n    }\n}\n\n// This declares a simple type.\nstruct Banana {}\n\n// This makes the \"Banana\" type satisfy the \"Eatable\" constraint.\n// For that, every declaration inside the declaration of \"Eatable\"\n// must be implemented here.\nimpl Eatable for Banana {\n    fn eat() {}\n}\n\n// This makes also the primitive \"char\" type satisfy the \"Eatable\" constraint.\nimpl Eatable for char {\n    fn eat() {}\n}\n\nfn main() {\n    // This instantiate a \"FoodBox\" parameterized by the \"Banana\" type.\n    // It is allowed as \"Banana\" implements \"Eatable\".\n    let _fb1 = FoodBox::<Banana>::new();\n\n    // This instantiate a \"FoodBox\" parameterized by the \"char\" type.\n    // It is allowed, as \"char\" implements \"Eatable\".\n    let _fb2 = FoodBox::<char>::new();\n\n    // This instantiate a \"FoodBox\" parameterized by the \"bool\" type.\n    // It is NOT allowed, as \"bool\" does not implement \"Eatable\".\n    //let _fb3 = FoodBox::<bool>::new();\n}\n",
    "title": "Constrained genericity",
    "url": "http://rosettacode.org/wiki/Constrained_genericity"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nconst POINTS_N: usize = 100;\n\nfn generate_point<R: Rng>(rng: &mut R) -> (i32, i32) {\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new_inclusive(-15, 15);\n    loop {\n        let x = rng.sample(range); // exclusive\n        let y = rng.sample(range);\n\n        let r2 = x * x + y * y;\n        if (100..=225).contains(&r2) {\n            return (x, y);\n        }\n    }\n}\n\nfn filtering_method<R: Rng>(rng: &mut R) {\n    let mut rows = [[\" \"; 62]; 31];\n\n    // Generate points\n    for _ in 0..POINTS_N {\n        let (x, y) = generate_point(rng);\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the points\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn precalculating_method<R: Rng>(rng: &mut R) {\n    // Generate all possible points\n    let mut possible_points = Vec::with_capacity(404);\n    for y in -15..=15 {\n        for x in -15..=15 {\n            let r2 = x * x + y * y;\n            if (100..=225).contains(&r2) {\n                possible_points.push((x, y));\n            }\n        }\n    }\n\n    // A truncated Fisher-Yates shuffle\n    let len = possible_points.len();\n    for i in (len - POINTS_N..len).rev() {\n        let j = rng.gen_range(0, i + 1);\n        possible_points.swap(i, j);\n    }\n\n    // turn the selected points into \"pixels\"\n    let mut rows = [[\" \"; 62]; 31];\n    for &(x, y) in &possible_points[len - POINTS_N..] {\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the \"pixels\"\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn main() {\n    let mut rng = thread_rng();\n\n    filtering_method(&mut rng);\n\n    precalculating_method(&mut rng);\n}\n",
    "path": "tasks/constrained-random-points-on-a-circle",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\nconst POINTS_N: usize = 100;\n\nfn generate_point<R: Rng>(rng: &mut R) -> (i32, i32) {\n    loop {\n        let x = rng.gen_range(-15, 16); // exclusive\n        let y = rng.gen_range(-15, 16);\n\n        let r2 = x * x + y * y;\n        if r2 >= 100 && r2 <= 225 {\n            return (x, y);\n        }\n    }\n}\n\nfn filtering_method<R: Rng>(rng: &mut R) {\n    let mut rows = [[\" \"; 62]; 31];\n\n    // Generate points\n    for _ in 0..POINTS_N {\n        let (x, y) = generate_point(rng);\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the points\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn precalculating_method<R: Rng>(rng: &mut R) {\n    // Generate all possible points\n    let mut possible_points = Vec::with_capacity(404);\n    for y in -15..=15 {\n        for x in -15..=15 {\n            let r2 = x * x + y * y;\n            if r2 >= 100 && r2 <= 225 {\n                possible_points.push((x, y));\n            }\n        }\n    }\n\n    // A truncated Fisher-Yates shuffle\n    let len = possible_points.len();\n    for i in (len - POINTS_N..len).rev() {\n        let j = rng.gen_range(0, i + 1);\n        possible_points.swap(i, j);\n    }\n\n    // turn the selected points into \"pixels\"\n    let mut rows = [[\" \"; 62]; 31];\n    for &(x, y) in &possible_points[len - POINTS_N..] {\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the \"pixels\"\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn main() {\n    let mut rng = rand::weak_rng();\n\n    filtering_method(&mut rng);\n\n    precalculating_method(&mut rng);\n}",
    "title": "Constrained random points on a circle",
    "url": "http://rosettacode.org/wiki/Constrained_random_points_on_a_circle"
  },
  {
    "local_code": "struct R2cf {\n    n1: i64,\n    n2: i64,\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        } else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1, n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => {\n        println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>())\n    };\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::r2cf;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_misc() {\n        assert!(Iterator::eq(r2cf(-151, 77), vec![-1, -1, -24, -1, -2]));\n        assert!(Iterator::eq(r2cf(22, 7), vec![3, 7]));\n        assert!(Iterator::eq(r2cf(23, 8), vec![2, 1, 7]));\n    }\n\n    #[test]\n    fn test_sqrt2() {\n        assert!(Iterator::eq(\n            r2cf(14_142, 10_000),\n            vec![1, 2, 2, 2, 2, 2, 1, 1, 29]\n        ));\n        assert!(Iterator::eq(\n            r2cf(14_142_136, 10_000_000),\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]\n        ));\n    }\n\n    #[test]\n    fn test_pi() {\n        assert!(Iterator::eq(r2cf(31, 10), vec![3, 10]));\n        assert!(Iterator::eq(r2cf(314, 100), vec![3, 7, 7]));\n        assert!(Iterator::eq(r2cf(3_142, 1_000), vec![3, 7, 23, 1, 2]));\n    }\n}\nuse std::iter;\n\n// Calculating a continued fraction is quite easy with iterators, however\n// writing a proper iterator adapter is less so. We settle for a macro which\n// for most purposes works well enough.\n//\n// One limitation with this iterator based approach is that we cannot reverse\n// input iterators since they are not usually DoubleEnded. To circumvent this\n// we can collect the elements and then reverse them, however this isn't ideal\n// as we now have to store elements equal to the number of iterations.\n//\n// Another is that iterators cannot be resused once consumed, so it is often\n// required to make many clones of iterators.\nmacro_rules! continued_fraction {\n    ($a:expr, $b:expr; $iterations:expr) => {\n        ($a).zip($b)\n            .take($iterations)\n            .collect::<Vec<_>>()\n            .iter()\n            .rev()\n            .fold(0f64, |acc: f64, &(x, y)| {\n                f64::from(x) + (f64::from(y) / acc)\n            })\n    };\n\n    ($a:expr, $b:expr) => {\n        continued_fraction!($a, $b ; 1000)\n    };\n}\n\nfn main() {\n    // Sqrt(2)\n    let sqrt2_a = (1..2).chain(iter::repeat(2));\n    let sqrt2_b = iter::repeat(1);\n    println!(\"{}\", continued_fraction!(sqrt2_a, sqrt2_b));\n\n    // Napier's Constant\n    let napier_a = (2..3).chain(1..);\n    let napier_b = (1..2).chain(1..);\n    println!(\"{}\", continued_fraction!(napier_a, napier_b));\n\n    // Pi\n    let pi_a = (3..4).chain(iter::repeat(6));\n    let pi_b = (1i32..).map(|x| (2 * x - 1).pow(2));\n    println!(\"{}\", continued_fraction!(pi_a, pi_b));\n}\n\n#[allow(clippy::approx_constant)]\n#[allow(clippy::float_cmp)]\n#[cfg(test)]\nmod tests {\n    use std::iter;\n\n    #[test]\n    fn test_sqrt2() {\n        let sqrt2_a = (1..2).chain(iter::repeat(2));\n        let sqrt2_b = iter::repeat(1);\n\n        // Note that we must clone the iterator here if we want to reuse\n        assert_eq!(\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone() ; 10),\n            1.4142131979695431f64\n        );\n\n        assert_eq!(\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone()),\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone() ; 1000)\n        );\n\n        assert_eq!(\n            continued_fraction!(sqrt2_a, sqrt2_b ; 73),\n            1.4142135623730951f64\n        );\n    }\n}\n",
    "path": "tasks/continued-fraction",
    "remote_code": "\nuse std::iter;\n\n// Calculating a continued fraction is quite easy with iterators, however\n// writing a proper iterator adapter is less so. We settle for a macro which\n// for most purposes works well enough.\n//\n// One limitation with this iterator based approach is that we cannot reverse\n// input iterators since they are not usually DoubleEnded. To circumvent this\n// we can collect the elements and then reverse them, however this isn't ideal\n// as we now have to store elements equal to the number of iterations.\n//\n// Another is that iterators cannot be resused once consumed, so it is often\n// required to make many clones of iterators.\nmacro_rules! continued_fraction {\n    ($a:expr, $b:expr ; $iterations:expr) => (\n        ($a).zip($b)\n            .take($iterations)\n            .collect::<Vec<_>>().iter()\n            .rev()\n            .fold(0 as f64, |acc: f64, &(x, y)| {\n                x as f64 + (y as f64 / acc)\n            })\n    );\n\n    ($a:expr, $b:expr) => (continued_fraction!($a, $b ; 1000));\n}\n\nfn main() {\n    // Sqrt(2)\n    let sqrt2a = (1..2).chain(iter::repeat(2));\n    let sqrt2b = iter::repeat(1);\n    println!(\"{}\", continued_fraction!(sqrt2a, sqrt2b));\n\n\n    // Napier's Constant\n    let napiera = (2..3).chain(1..);\n    let napierb = (1..2).chain(1..);\n    println!(\"{}\", continued_fraction!(napiera, napierb));\n\n\n    // Pi\n    let pia = (3..4).chain(iter::repeat(6));\n    let pib = (1i64..).map(|x| (2 * x - 1).pow(2));\n    println!(\"{}\", continued_fraction!(pia, pib));\n}\n",
    "title": "Continued fraction",
    "url": "http://rosettacode.org/wiki/Continued_fraction"
  },
  {
    "local_code": "struct R2cf {\n    n1: i64,\n    n2: i64,\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        } else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1, n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => {\n        println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>())\n    };\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::r2cf;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_misc() {\n        assert!(Iterator::eq(r2cf(-151, 77), vec![-1, -1, -24, -1, -2]));\n        assert!(Iterator::eq(r2cf(22, 7), vec![3, 7]));\n        assert!(Iterator::eq(r2cf(23, 8), vec![2, 1, 7]));\n    }\n\n    #[test]\n    fn test_sqrt2() {\n        assert!(Iterator::eq(\n            r2cf(14_142, 10_000),\n            vec![1, 2, 2, 2, 2, 2, 1, 1, 29]\n        ));\n        assert!(Iterator::eq(\n            r2cf(14_142_136, 10_000_000),\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]\n        ));\n    }\n\n    #[test]\n    fn test_pi() {\n        assert!(Iterator::eq(r2cf(31, 10), vec![3, 10]));\n        assert!(Iterator::eq(r2cf(314, 100), vec![3, 7, 7]));\n        assert!(Iterator::eq(r2cf(3_142, 1_000), vec![3, 7, 23, 1, 2]));\n    }\n}\n",
    "path": "tasks/continued-fraction/arithmetic/construct-from-rational-number",
    "remote_code": "\nstruct R2cf {\n    n1: i64,\n    n2: i64\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        }\n        else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1: n1, n2: n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => (println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>()));\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n",
    "title": "Continued fraction/Arithmetic/Construct from rational number",
    "url": "http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Convert decimal number to rational",
    "url": "http://rosettacode.org/wiki/Convert_decimal_number_to_rational"
  },
  {
    "local_code": "fn seconds_to_compound(secs: u32) -> String {\n    let part = |comps: &mut String, c: &str, one: u32, secs: &mut u32| {\n        if *secs >= one {\n            let div = *secs / one;\n            comps.push_str(&(div.to_string() + c));\n            *secs -= one * div;\n            if *secs > 0 {\n                comps.push_str(\", \");\n            }\n        }\n    };\n\n    let mut secs = secs;\n    let mut comps = String::new();\n    part(&mut comps, \" wk\", 60 * 60 * 24 * 7, &mut secs);\n    part(&mut comps, \" d\", 60 * 60 * 24, &mut secs);\n    part(&mut comps, \" hr\", 60 * 60, &mut secs);\n    part(&mut comps, \" min\", 60, &mut secs);\n    part(&mut comps, \" sec\", 1, &mut secs);\n    comps\n}\n\n#[test]\nfn hours_and_seconds() {\n    assert_eq!(seconds_to_compound(7259), \"2 hr, 59 sec\");\n}\n\n#[test]\nfn one_day() {\n    assert_eq!(seconds_to_compound(86_400), \"1 d\");\n}\n\n#[test]\nfn six_million_seconds() {\n    assert_eq!(seconds_to_compound(6_000_000), \"9 wk, 6 d, 10 hr, 40 min\");\n}\n\nfn main() {\n    println!(\"7,259 seconds = {}\", seconds_to_compound(7259));\n    println!(\"86,400 seconds = {}\", seconds_to_compound(86_400));\n    println!(\"6,000,000 seconds = {}\", seconds_to_compound(6_000_000));\n}\n",
    "path": "tasks/convert-seconds-to-compound-duration",
    "remote_code": "use std::fmt;\n\n\nstruct CompoundTime {\n    w: usize,\n    d: usize,\n    h: usize,\n    m: usize,\n    s: usize,\n}\n\nmacro_rules! reduce {\n    ($s: ident, $(($from: ident, $to: ident, $factor: expr)),+) => {{\n        $(\n            $s.$to += $s.$from / $factor;\n            $s.$from %= $factor;\n        )+\n    }}\n}\n\nimpl CompoundTime {\n    #[inline]\n    fn new(w: usize, d: usize, h: usize, m: usize, s: usize) -> Self{\n        CompoundTime { w: w, d: d, h: h, m: m, s: s, }\n    }\n\n    #[inline]\n    fn balance(&mut self) {\n        reduce!(self, (s, m, 60), (m, h, 60),\n                      (h, d, 24), (d, w, 7));\n    }\n}\n\nimpl fmt::Display for CompoundTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}w {}d {}h {}m {}s\", \n               self.w, self.d, self.h, self.m, self.s)\n    }\n}\n\nfn main() {\n    let mut ct = CompoundTime::new(0,3,182,345,2412);\n    println!(\"Before: {}\", ct);\n    ct.balance();\n    println!(\"After: {}\", ct);\n}",
    "title": "Convert seconds to compound duration",
    "url": "http://rosettacode.org/wiki/Convert_seconds_to_compound_duration"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#[derive(Debug, Clone)]\nstruct Point {\n    x: f32,\n    y: f32\n}\n\nfn calculate_convex_hull(points: &Vec<Point>) -> Vec<Point> {\n    //There must be at least 3 points\n    if points.len() < 3 { return points.clone(); }\n\n    let mut hull = vec![];\n\n    //Find the left most point in the polygon\n    let (left_most_idx, _) = points.iter()\n        .enumerate()\n        .min_by(|lhs, rhs| lhs.1.x.partial_cmp(&rhs.1.x).unwrap())\n        .expect(\"No left most point\");\n\n    \n    let mut p = left_most_idx;\n    let mut q = 0_usize;\n\n    loop {\n        //The left most point must be part of the hull\n        hull.push(points[p].clone());\n\n        q = (p + 1) % points.len();\n\n        for i in 0..points.len() {\n            if orientation(&points[p], &points[i], &points[q]) == 2 {\n                q = i;\n            }\n        }\n\n        p = q;\n\n        //Break from loop once we reach the first point again\n        if p == left_most_idx { break; }\n    }\n\n    return hull;\n}\n\n//Calculate orientation for 3 points\n//0 -> Straight line\n//1 -> Clockwise\n//2 -> Counterclockwise\nfn orientation(p: &Point, q: &Point, r: &Point) -> usize {\n    let val = (q.y - p.y) * (r.x - q.x) -\n        (q.x - p.x) * (r.y - q.y);\n\n    if val == 0. { return 0 };\n    if val > 0. { return 1; } else { return 2; }\n}\n\nfn main(){\n    let points = vec![pt(16,3), pt(12,17), pt(0,6), pt(-4,-6), pt(16,6), pt(16,-7), pt(16,-3), pt(17,-4), pt(5,19), pt(19,-8), pt(3,16), pt(12,13), pt(3,-4), pt(17,5), pt(-3,15), pt(-3,-9), pt(0,11), pt(-9,-3), pt(-4,-2), pt(12,10)];\n    let hull = calculate_convex_hull(&points);\n    \n    hull.iter()\n        .for_each(|pt| println!(\"{:?}\", pt));\n}\n\nfn pt(x: i32, y: i32) -> Point {\n    return Point {x:x as f32, y:y as f32};\n}\n",
    "title": "Convex hull",
    "url": "http://rosettacode.org/wiki/Convex_hull"
  },
  {
    "local_code": "use std::mem;\nuse std::thread;\nuse std::time::Duration;\n\n#[derive(Copy, Clone)]\nenum Cell {\n    Empty(char),\n    Alive,\n    Dead,\n}\nimpl Cell {\n    fn from_char(c: char) -> Cell {\n        match c {\n            ' ' => Cell::Dead,\n            '#' => Cell::Alive,\n            c => Cell::Empty(c),\n        }\n    }\n    fn to_char(self) -> char {\n        match self {\n            Cell::Dead => ' ',\n            Cell::Alive => '#',\n            Cell::Empty(c) => c,\n        }\n    }\n}\n\n#[allow(clippy::match_same_arms)]\nfn next_world(input: &[Cell], output: &mut [Cell], w: usize, h: usize) {\n    for i in 0..(w * h) {\n        match input[i] {\n            Cell::Empty(c) => output[i] = Cell::Empty(c),\n            cell => {\n                let live = vec![\n                    input.get(i - w - 1),\n                    input.get(i - w),\n                    input.get(i - w + 1),\n                    input.get(i - 1),\n                    input.get(i + 1),\n                    input.get(i + w - 1),\n                    input.get(i + w),\n                    input.get(i + w + 1),\n                ]\n                .iter()\n                .fold(0, |sum, &o| {\n                    if let Some(&Cell::Alive) = o {\n                        sum + 1\n                    } else {\n                        sum\n                    }\n                });\n                output[i] = match (cell, live) {\n                    (Cell::Alive, 0..=1) => Cell::Dead,  // Lonely\n                    (Cell::Alive, 4..=8) => Cell::Dead,  // Overcrowded\n                    (Cell::Alive, 2..=3) => Cell::Alive, // Lives\n                    (Cell::Dead, 3) => Cell::Alive,      // It takes three to give birth!\n                    _ => Cell::Dead,                     // Barren\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let (w, h) = (100usize, 9usize);\n    let mut world: Vec<Cell> = r\"\n+-------------------------------------------------------------------------------------------------+\n|                                                                                                 |\n|                                                                                        #  #     |\n|                                                                                       #         |\n|                                                                                       #   #     |\n|                                                                                       ####      |\n|                                                                                                 |\n|                                                                                                 |\n+-------------------------------------------------------------------------------------------------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    loop {\n        for cell in &world {\n            print!(\"{}\", cell.to_char());\n        }\n        println!();\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n\n        // Use VT100 cursor control sequences to animate in-place.\n        print!(\"\\x1b[{}A\", h + 1);\n        print!(\"\\x1b[{}D\", w + 1);\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n\n#[test]\nfn test() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|           |\n|     #     |\n|     #     |\n|     #     |\n|           |\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    next_world(&world, &mut next, w, h);\n    mem::swap(&mut world, &mut next);\n\n    let result: String = world.iter().map(|c| c.to_char()).collect();\n    let correct = r\"\n+-----------+\n|           |\n|           |\n|    ###    |\n|           |\n|           |\n+-----------+\n\";\n    assert_eq!(result, correct);\n}\n",
    "path": "tasks/conways-game-of-life",
    "remote_code": "\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\ntype Cell = (i32, i32);\ntype Colony = HashSet<Cell>;\n\nfn print_colony(col: &Colony, width: i32, height: i32) {\n    for y in 0..height {\n        for x in 0..width {\n            print!(\"{} \",\n                if col.contains(&(x, y)) {\"O\"}\n                else {\".\"}\n            );\n        }\n        println!();\n    }\n}\n\nfn neighbours(&(x,y): &Cell) -> Vec<Cell> {\n    vec![\n        (x-1,y-1), (x,y-1), (x+1,y-1),\n        (x-1,y),            (x+1,y),\n        (x-1,y+1), (x,y+1), (x+1,y+1),\n    ]\n}\n\nfn neighbour_counts(col: &Colony) -> HashMap<Cell, i32> {\n    let mut ncnts = HashMap::new();\n    for cell in col.iter().flat_map(neighbours) {\n        *ncnts.entry(cell).or_insert(0) += 1;\n    }\n    ncnts\n}\n\nfn generation(col: Colony) -> Colony {\n    neighbour_counts(&col)\n        .into_iter()\n        .filter_map(|(cell, cnt)|\n            match (cnt, col.contains(&cell)) {\n                (2, true) |\n                (3, ..) => Some(cell),\n                _ => None\n        })\n        .collect()\n}\n\nfn life(init: Vec<Cell>, iters: i32, width: i32, height: i32) {\n    let mut col: Colony = init.into_iter().collect(); \n    for i in 0..iters+1\n    {\n        println!(\"({})\", &i);\n        if i != 0 {\n            col = generation(col);\n        }\n        print_colony(&col, width, height);\n    }\n}\n\nfn main() {\n    let blinker = vec![\n        (1,0),\n        (1,1),\n        (1,2)];\n\n    life(blinker, 3, 3, 3);\n\n    let glider = vec![\n                (1,0),\n                        (2,1),\n        (0,2),  (1,2),  (2,2)];\n\n    life(glider, 20, 8, 8);\n}\n",
    "title": "Conway's Game of Life",
    "url": "http://rosettacode.org/wiki/Conway's_Game_of_Life"
  },
  {
    "local_code": "fn main() {\n    let s1 = \"A String\";\n\n    // Create an additional reference to \"A String\".\n    let s2: &str = s1;\n\n    // Create a copy of \"A String\"\n    let s3: String = s1.to_string();\n\n    println!(\"s1 = {}, s2 = {}, s3 = {}\", s1, s2, s3);\n}\n",
    "path": "tasks/copy-a-string",
    "remote_code": "fn main() {\n    let s1 = \"A String\";\n    let mut s2 = s1;\n\n    s2 = \"Another String\";\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}",
    "title": "Copy a string",
    "url": "http://rosettacode.org/wiki/Copy_a_string"
  },
  {
    "local_code": "use std::io;\n\nfn main() {\n    io::copy(&mut io::stdin().lock(), &mut io::stdout().lock()).expect(\"failed to copy\");\n}\n",
    "path": "tasks/copy-stdin-to-stdout",
    "remote_code": "use std::io;\n\nfn main() {\n    io::copy(&mut io::stdin().lock(), &mut io::stdout().lock());\n}",
    "title": "Copy stdin to stdout",
    "url": "http://rosettacode.org/wiki/Copy_stdin_to_stdout"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let n = if args.len() > 1 {\n        args[1].parse().expect(\"Not a valid number to count to\")\n    }\n    else {\n        20\n    };\n    count_in_factors_to(n);\n}\n\nfn count_in_factors_to(n: u64) {\n    println!(\"1\");\n    let mut primes = vec![];\n    for i in 2..=n {\n        let fs = factors(&primes, i);\n        if fs.len() <= 1 {\n            primes.push(i);\n            println!(\"{}\", i);\n        }\n        else {\n            println!(\"{} = {}\", i, fs.iter().map(|f| f.to_string()).collect::<Vec<String>>().join(\" x \"));\n        }\n    }\n}\n\nfn factors(primes: &[u64], mut n: u64) -> Vec<u64> {\n    let mut result = Vec::new();\n    for p in primes {\n        while n % p == 0 {\n            result.push(*p);\n            n /= p;\n        }\n        if n == 1 {\n            return result;\n        }\n    }\n    vec![n]\n}",
    "title": "Count in factors",
    "url": "http://rosettacode.org/wiki/Count_in_factors"
  },
  {
    "local_code": "use std::u8;\n\nfn main() {\n    // We count from 0 to 255 (377 in octal)\n    for i in 0..=u8::MAX {\n        println!(\"{:o}\", i);\n    }\n}\n",
    "path": "tasks/count-in-octal",
    "remote_code": "fn main() {\n    for i in 0..std::usize::MAX {\n        println!(\"{:o}\", i);\n    }\n}",
    "title": "Count in octal",
    "url": "http://rosettacode.org/wiki/Count_in_octal"
  },
  {
    "local_code": "// Author : Rahul Sharma\n// Github : github.com/creativcoder\n\n// The rest of the `Pattern` and `split` APIs could make this much more powerful\nfn count_sub_string(src: &str, target: &str) -> usize {\n    src.split(target).count() - 1\n}\n\nfn main() {\n    let text = \"this is three of the four\";\n    let sub_str = \"th\";\n    println!(\"{:?}\", count_sub_string(text, sub_str));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trailing() {\n        assert_eq!(count_sub_string(\"adssdadaadaddaadad\", \"ad\"), 6);\n    }\n\n    #[test]\n    fn none() {\n        assert_eq!(count_sub_string(\"rustisawesome\", \"zz\"), 0);\n    }\n}\n",
    "path": "tasks/count-occurrences-of-a-substring",
    "remote_code": "\nfn main() {\n    println!(\"{}\",\"the three truths\".matches(\"th\").count());\n    println!(\"{}\",\"ababababab\".matches(\"abab\").count());\n}\n",
    "title": "Count occurrences of a substring",
    "url": "http://rosettacode.org/wiki/Count_occurrences_of_a_substring"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn make_change(coins: &[usize], cents: usize) -> usize {\n    let size = cents + 1;\n    let mut ways = vec![0; size];\n    ways[0] = 1;\n    for &coin in coins {\n        for amount in coin..size {\n            ways[amount] += ways[amount - coin];\n        }\n    }\n    ways[cents]\n}\n\nfn main() {\n    println!(\"{}\", make_change(&[1,5,10,25], 100));\n    println!(\"{}\", make_change(&[1,5,10,25,50,100], 100_000));\n}",
    "title": "Count the coins",
    "url": "http://rosettacode.org/wiki/Count_the_coins"
  },
  {
    "local_code": "use std::ops::{Index, IndexMut};\n\nfn main() {\n    let m = matrix(\n        vec![\n            2., -1., 5., 1., 3., 2., 2., -6., 1., 3., 3., -1., 5., -2., -3., 3.,\n        ],\n        4,\n    );\n    let mm = m.solve(&[-3., -32., -47., 49.]);\n    println!(\"{:?}\", mm);\n}\n\n#[derive(Clone)]\nstruct Matrix {\n    elts: Vec<f64>,\n    dim: usize,\n}\n\nimpl Matrix {\n    // Compute determinant using cofactor method\n    // Using Gaussian elimination would have been more efficient, but it also solves the linear\n    // system, so…\n    fn det(&self) -> f64 {\n        match self.dim {\n            0 => 0.,\n            1 => self[0][0],\n            2 => self[0][0] * self[1][1] - self[0][1] * self[1][0],\n            d => {\n                let mut acc = 0.;\n                let mut signature = 1.;\n                for k in 0..d {\n                    acc += signature * self[0][k] * self.comatrix(0, k).det();\n                    signature *= -1.\n                }\n                acc\n            }\n        }\n    }\n\n    // Solve linear systems using Cramer's method\n    #[allow(clippy::needless_range_loop)]\n    fn solve(&self, target: &[f64]) -> Vec<f64> {\n        let mut solution: Vec<f64> = vec![0.; self.dim];\n        let denominator = self.det();\n        for j in 0..self.dim {\n            let mut mm = self.clone();\n            for i in 0..self.dim {\n                mm[i][j] = target[i]\n            }\n            solution[j] = mm.det() / denominator\n        }\n        solution\n    }\n\n    // Compute the cofactor matrix for determinant computations\n    fn comatrix(&self, k: usize, l: usize) -> Matrix {\n        let mut v: Vec<f64> = vec![];\n        for i in 0..self.dim {\n            for j in 0..self.dim {\n                if i != k && j != l {\n                    v.push(self[i][j])\n                }\n            }\n        }\n        matrix(v, self.dim - 1)\n    }\n}\n\nfn matrix(elts: Vec<f64>, dim: usize) -> Matrix {\n    assert_eq!(elts.len(), dim * dim);\n    Matrix { elts, dim }\n}\n\nimpl Index<usize> for Matrix {\n    type Output = [f64];\n\n    fn index(&self, i: usize) -> &Self::Output {\n        let m = self.dim;\n        &self.elts[m * i..m * (i + 1)]\n    }\n}\n\nimpl IndexMut<usize> for Matrix {\n    fn index_mut(&mut self, i: usize) -> &mut Self::Output {\n        let m = self.dim;\n        &mut self.elts[m * i..m * (i + 1)]\n    }\n}\n\n#[allow(clippy::float_cmp)]\n#[test]\nfn test_create_and_access() {\n    let m = matrix(vec![1., 2., 3., 4.], 2);\n    assert_eq!(m[0][0], 1.);\n    assert_eq!(m[0][1], 2.);\n    assert_eq!(m[1][0], 3.);\n    assert_eq!(m[1][1], 4.);\n}\n\n#[allow(clippy::float_cmp)]\n#[test]\nfn test_determinant() {\n    let dim = 5;\n    let mut m = matrix(vec![0.; dim * dim], dim);\n    (0..dim).for_each(|i| (0..=i).for_each(|j| m[i][j] = 1.));\n    assert_eq!(m.det(), 1.);\n    let m = matrix(\n        vec![\n            1., -5., 2., 1., -5., -7., 0., 3., 0., 3., 4., 1., 41., 0., -1., 0.,\n        ],\n        4,\n    );\n    assert_eq!(m.det(), -2680.);\n}\n\n#[test]\nfn test_solve() {\n    let m = matrix(\n        vec![\n            1., -5., 2., 1., -5., -7., 0., 3., 0., 3., 4., 1., 41., 0., -1., 0.,\n        ],\n        4,\n    );\n    let b = vec![153., 219., -94., -41.];\n    assert_eq!(m.solve(&b), vec![-1., -31., 0., -1.])\n}\n",
    "path": "tasks/cramers-rule",
    "remote_code": "use std::ops::{Index, IndexMut};\n\nfn main() {\n    let m = matrix(\n        vec![\n            2., -1., 5., 1., 3., 2., 2., -6., 1., 3., 3., -1., 5., -2., -3., 3.,\n        ],\n        4,\n    );\n    let mm = m.solve(&vec![-3., -32., -47., 49.]);\n    println!(\"{:?}\", mm);\n}\n\n#[derive(Clone)]\nstruct Matrix {\n    elts: Vec<f64>,\n    dim: usize,\n}\n\nimpl Matrix {\n    // Compute determinant using cofactor method\n    // Using Gaussian elimination would have been more efficient, but it also solves the linear\n    // system, so…\n    fn det(&self) -> f64 {\n        match self.dim {\n            0 => 0.,\n            1 => self[0][0],\n            2 => self[0][0] * self[1][1] - self[0][1] * self[1][0],\n            d => {\n                let mut acc = 0.;\n                let mut signature = 1.;\n                for k in 0..d {\n                    acc += signature * self[0][k] * self.comatrix(0, k).det();\n                    signature *= -1.\n                }\n                acc\n            }\n        }\n    }\n\n    // Solve linear systems using Cramer's method\n    fn solve(&self, target: &Vec<f64>) -> Vec<f64> {\n        let mut solution: Vec<f64> = vec![0.; self.dim];\n        let denominator = self.det();\n        for j in 0..self.dim {\n            let mut mm = self.clone();\n            for i in 0..self.dim {\n                mm[i][j] = target[i]\n            }\n            solution[j] = mm.det() / denominator\n        }\n        solution\n    }\n\n    // Compute the cofactor matrix for determinant computations\n    fn comatrix(&self, k: usize, l: usize) -> Matrix {\n        let mut v: Vec<f64> = vec![];\n        for i in 0..self.dim {\n            for j in 0..self.dim {\n                if i != k && j != l {\n                    v.push(self[i][j])\n                }\n            }\n        }\n        matrix(v, self.dim - 1)\n    }\n}\n\nfn matrix(elts: Vec<f64>, dim: usize) -> Matrix {\n    assert_eq!(elts.len(), dim * dim);\n    Matrix { elts, dim }\n}\n\nimpl Index<usize> for Matrix {\n    type Output = [f64];\n\n    fn index(&self, i: usize) -> &Self::Output {\n        let m = self.dim;\n        &self.elts[m * i..m * (i + 1)]\n    }\n}\n\nimpl IndexMut<usize> for Matrix {\n    fn index_mut(&mut self, i: usize) -> &mut Self::Output {\n        let m = self.dim;\n        &mut self.elts[m * i..m * (i + 1)]\n    }\n}",
    "title": "Cramer's rule",
    "url": "http://rosettacode.org/wiki/Cramer's_rule"
  },
  {
    "local_code": "use std::fs::{self, File};\nuse std::io::Write;\n\nfn main() {\n    // Create a new file.  We get a `Result` object from `File::create`. We could check if there is\n    // an error by using `.is_err()` or by using pattern matching. We choose here to ignore the\n    // possibility of an error and just unwrap the value contained in the `Result` object.  This\n    // means that an error will cause the program to fail at runtime.\n    let mut new_file = File::create(\"build/output.txt\").unwrap();\n\n    // Write something trivial to the file. Now we are handling a possible error by using pattern\n    // matching.\n    match new_file.write_all(b\"Nothing here...\") {\n        Ok(()) => (),\n        Err(e) => println!(\"Failed to write to file: {}\", e),\n    }\n\n    // Create a directory. Here we handle a possible error by using the functions provided by\n    // result.  The second argument sets the file permissions\n    let result = fs::create_dir(\"build/docs\");\n    if result.is_err() {\n        println!(\"Failed to create a directory: {}\", result.err().unwrap());\n    }\n}\n\n#[test]\nfn test_create_file() {\n    use std::fs;\n    use std::path::Path;\n\n    let build_dir = Path::new(\"build-tests\");\n    if !(build_dir.exists() && build_dir.is_dir()) {\n        let r = fs::create_dir(&build_dir);\n        assert!(r.is_ok());\n    }\n\n    let file_path = Path::new(\"build-tests/create_file_test.txt\");\n    if file_path.exists() && file_path.is_file() {\n        let r = fs::remove_file(&file_path);\n        assert!(r.is_ok());\n    }\n    match File::create(&file_path) {\n        Ok(_) => (),\n        Err(e) => panic!(\n            \"failed to create_file at {}, error: {}\",\n            file_path.display(),\n            e\n        ),\n    }\n\n    // Remove the build dir, but only after making sure there's only one file in it.\n    let contents = build_dir\n        .read_dir()\n        .unwrap()\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    assert!(contents.len() == 1);\n    assert!(contents[0].path() == file_path);\n\n    fs::remove_dir_all(build_dir).unwrap();\n}\n",
    "path": "tasks/create-a-file",
    "remote_code": "use std::io::{self, Write};\nuse std::fs::{DirBuilder, File};\nuse std::path::Path;\nuse std::{process,fmt};\n\nconst FILE_NAME: &'static str = \"output.txt\";\nconst DIR_NAME : &'static str = \"docs\";\n\nfn main() {\n    create(\".\").and(create(\"/\"))\n               .unwrap_or_else(|e| error_handler(e,1));\n}\n\n\nfn create<P>(root: P) -> io::Result<File>\n    where P: AsRef<Path>\n{\n    let f_path = root.as_ref().join(FILE_NAME);\n    let d_path = root.as_ref().join(DIR_NAME);\n    DirBuilder::new().create(d_path).and(File::create(f_path))\n}\n\nfn error_handler<E: fmt::Display>(error: E, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", error);\n    process::exit(code)\n}",
    "title": "Create a file",
    "url": "http://rosettacode.org/wiki/Create_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io::Write;\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    File::open(\"/dev/tape\")?.write_all(b\"Hello from Rosetta Code!\")\n}",
    "title": "Create a file on magnetic tape",
    "url": "http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let mut args = env::args().skip(1).flat_map(|num| num.parse());\n    let rows = args.next().expect(\"Expected number of rows as first argument\");\n    let cols = args.next().expect(\"Expected number of columns as second argument\");\n\n    assert_ne!(rows, 0, \"rows were zero\");\n    assert_ne!(cols, 0, \"cols were zero\");\n\n    // Creates a vector of vectors with all elements initialized to 0.\n    let mut v = vec![vec![0; cols]; rows];\n    v[0][0] = 1;\n    println!(\"{}\", v[0][0]);\n}",
    "title": "Create a two-dimensional array at runtime",
    "url": "http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn random_cell<R: Rng>(rng: &mut R) -> u32 {\n    // Anything between 0 and 10_000 (exclusive) has 4 digits or fewer. Using `gen_range::<u32>`\n    // is faster for smaller RNGs.  Because the parameters are constant, the compiler can do all\n    // the range construction at compile time, removing the need for\n    // `rand::distributions::range::Range`\n    rng.gen_range(0, 10_000)\n}\n\nfn main() {\n    let mut rng = rand::thread_rng(); // Cache the RNG for reuse\n\n    println!(\"<table><thead><tr><th></th><td>X</td><td>Y</td><td>Z</td></tr></thead>\");\n\n    for row in 0..3 {\n        let x = random_cell(&mut rng);\n        let y = random_cell(&mut rng);\n        let z = random_cell(&mut rng);\n        println!(\"<tr><th>{}</th><td>{}</td><td>{}</td><td>{}</td></tr>\", row, x, y, z);\n    }\n\n    println!(\"</table>\");\n}",
    "title": "Create an HTML table",
    "url": "http://rosettacode.org/wiki/Create_an_HTML_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{mem,ptr};\n\nfn main() {\n    let mut data: i32;\n\n    // Rust does not allow us to use uninitialized memory but the STL provides an `unsafe`\n    // function to override this protection.\n    unsafe {data = mem::uninitialized()}\n\n    // Construct a raw pointer (perfectly safe)\n    let address = &mut data as *mut _;\n\n    unsafe {ptr::write(address, 5)}\n    println!(\"{0:p}: {0}\", &data);\n\n    unsafe {ptr::write(address, 6)}\n    println!(\"{0:p}: {0}\", &data);\n\n}",
    "title": "Create an object at a given address",
    "url": "http://rosettacode.org/wiki/Create_an_object_at_a_given_address"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::time::Instant;\nuse separator::Separatable;\n\nconst NUMBER_OF_CUBAN_PRIMES: usize = 200;\nconst COLUMNS: usize = 10;\nconst LAST_CUBAN_PRIME: usize = 100_000;\n\nfn main() {\n    println!(\"Calculating the first {} cuban primes and the {}th cuban prime...\", NUMBER_OF_CUBAN_PRIMES, LAST_CUBAN_PRIME);\n    let start = Instant::now();\n\n    let mut i: u64 = 0;\n    let mut j: u64 = 1;\n    let mut index: usize = 0;\n    let mut cuban_primes = Vec::new();\n    let mut cuban: u64 = 0;\n    while index < 100_000 {\n        cuban = {j += 1; j}.pow(3) - {i += 1; i}.pow(3);\n        if primal::is_prime(cuban) {\n            if index < NUMBER_OF_CUBAN_PRIMES {\n                cuban_primes.push(cuban);\n            }\n            index += 1;\n        }\n    }\n\n    let elapsed = start.elapsed();\n    println!(\"THE {} FIRST CUBAN PRIMES:\", NUMBER_OF_CUBAN_PRIMES);\n    cuban_primes\n        .chunks(COLUMNS)\n        .map(|chunk| {\n            chunk.iter()\n                .map(|item| {\n                    print!(\"{}\\t\", item)\n                })\n                .for_each(drop);\n            println!(\"\");\n        })\n        .for_each(drop);\n    println!(\"The {}th cuban prime number is {}\", LAST_CUBAN_PRIME, cuban.separated_string());\n    println!(\"Elapsed time: {:?}\", elapsed);\n}",
    "title": "Cuban primes",
    "url": "http://rosettacode.org/wiki/Cuban_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.15.0\"\n\nuse rug::integer::IsPrime;\nuse rug::Integer;\n\nfn cullen_number(n: u32) -> Integer {\n    let num = Integer::from(n);\n    (num << n) + 1\n}\n\nfn woodall_number(n: u32) -> Integer {\n    let num = Integer::from(n);\n    (num << n) - 1\n}\n\nfn main() {\n    println!(\"First 20 Cullen numbers:\");\n    let cullen: Vec<String> = (1..21).map(|x| cullen_number(x).to_string()).collect();\n    println!(\"{}\", cullen.join(\" \"));\n\n    println!(\"\\nFirst 20 Woodall numbers:\");\n    let woodall: Vec<String> = (1..21).map(|x| woodall_number(x).to_string()).collect();\n    println!(\"{}\", woodall.join(\" \"));\n\n    println!(\"\\nFirst 5 Cullen primes in terms of n:\");\n    let cullen_primes: Vec<String> = (1..)\n        .filter_map(|x| match cullen_number(x).is_probably_prime(25) {\n            IsPrime::No => None,\n            _ => Some(x.to_string()),\n        })\n        .take(5)\n        .collect();\n    println!(\"{}\", cullen_primes.join(\" \"));\n\n    println!(\"\\nFirst 12 Woodall primes in terms of n:\");\n    let woodall_primes: Vec<String> = (1..)\n        .filter_map(|x| match woodall_number(x).is_probably_prime(25) {\n            IsPrime::No => None,\n            _ => Some(x.to_string()),\n        })\n        .take(12)\n        .collect();\n    println!(\"{}\", woodall_primes.join(\" \"));\n}",
    "title": "Cullen and Woodall numbers",
    "url": "http://rosettacode.org/wiki/Cullen_and_Woodall_numbers"
  },
  {
    "local_code": "struct StDev {\n    len: usize,\n    sum: f32,\n    sum_sq: f32,\n}\n\nimpl StDev {\n    fn new() -> StDev {\n        StDev {\n            len: 0,\n            sum: 0.0,\n            sum_sq: 0.0,\n        }\n    }\n\n    fn stdev(&mut self, n: f32) -> f32 {\n        self.len += 1;\n        self.sum += n;\n        self.sum_sq += n.powi(2);\n        let f32_len = self.len as f32;\n        f32::sqrt(self.sum_sq / f32_len - self.sum.powi(2) / f32_len.powi(2))\n    }\n}\n\nimpl Default for StDev {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let test_data: [i32; 8] = [2, 4, 4, 4, 5, 5, 7, 9];\n    let mut sd = StDev::new();\n    for i in &test_data {\n        println!(\"{}\", &sd.stdev(*i as f32));\n    }\n}\n\n#[test]\nfn test_stdev() {\n    let eps = 0.000001;\n    let mut sd = StDev::new();\n    // must be equal with up to eps precision\n    assert!((sd.stdev(2.0) - 0.0).abs() < eps);\n    assert!((sd.stdev(4.0) - 1.0).abs() < eps);\n    assert!((sd.stdev(4.0) - 0.942809).abs() < eps);\n    assert!((sd.stdev(4.0) - 0.866025).abs() < eps);\n    assert!((sd.stdev(5.0) - 0.979796).abs() < eps);\n    assert!((sd.stdev(5.0) - 1.0).abs() < eps);\n    assert!((sd.stdev(7.0) - 1.399708).abs() < eps);\n    assert!((sd.stdev(9.0) - 2.0).abs() < eps);\n}\n",
    "path": "tasks/standard-deviation",
    "remote_code": "pub struct CumulativeStandardDeviation {\n    n: f64,\n    sum: f64,\n    sum_sq: f64\n}\n\nimpl CumulativeStandardDeviation {\n    pub fn new() -> Self {\n        CumulativeStandardDeviation {\n            n: 0.,\n            sum: 0.,\n            sum_sq: 0.\n        }\n    }\n\n    fn push(&mut self, x: f64) -> f64 {\n        self.n += 1.;\n        self.sum += x;\n        self.sum_sq += x * x;\n\n        (self.sum_sq / self.n - self.sum * self.sum / self.n / self.n).sqrt()\n    }\n}\n\nfn main() {\n    let nums = [2, 4, 4, 4, 5, 5, 7, 9];\n\n    let mut cum_stdev = CumulativeStandardDeviation::new();\n    for num in nums.iter() {\n        println!(\"{}\", cum_stdev.push(*num as f64));\n    }\n}",
    "title": "Cumulative standard deviation",
    "url": "http://rosettacode.org/wiki/Cumulative_standard_deviation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate num_bigint; // 0.3.0\nextern crate num_rational; // 0.3.0\n\nuse num_bigint::BigInt;\nuse num_rational::BigRational;\n\n\nuse std::ops::{Add, Mul};\nuse std::fmt;\n\nfn main() {\n    let hamburger = Currency::new(5.50);\n    let milkshake = Currency::new(2.86);\n    let pre_tax = hamburger * 4_000_000_000_000_000 + milkshake * 2;\n    println!(\"Price before tax: {}\", pre_tax);\n    let tax = pre_tax.calculate_tax();\n    println!(\"Tax: {}\", tax);\n    let post_tax = pre_tax + tax;\n    println!(\"Price after tax: {}\", post_tax);\n}\n\n#[derive(Debug)]\nstruct Currency {\n    amount: BigRational,\n}\n\nimpl Add for Currency {\n\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            amount: self.amount + other.amount,\n        }\n    }    \n}\n\nimpl Mul<u64> for Currency {\n    \n    type Output = Self;\n    \n    fn mul(self, other: u64) -> Self {\n        Self {\n            amount: self.amount * BigInt::from(other),\n        }\n    }\n}\n\nimpl fmt::Display for Currency {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let cents = (&self.amount * BigInt::from(100)).to_integer();\n        write!(f, \"${}.{}\", &cents / 100, &cents % 100)\n    }\n}\n\nimpl Currency {\n    \n    fn new(num: f64) -> Self {\n        Self {\n            amount: BigRational::new(((num * 100.0) as i64).into(), 100.into())\n        }\n    }\n\n    fn calculate_tax(&self) -> Self {\n        let tax_val = BigRational::new(765.into(), 100.into());// 7,65 -> 0.0765 after the next line\n        let amount = (&self.amount * tax_val).ceil() / BigInt::from(100); \n        Self {\n            amount\n        }\n    }\n}",
    "title": "Currency",
    "url": "http://rosettacode.org/wiki/Currency"
  },
  {
    "local_code": "/// `add_n` returns a closure.\nfn add_n(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\nfn main() {\n    let adder = add_n(40);\n    println!(\"The answer to life is {}.\", adder(2));\n}\n",
    "path": "tasks/currying",
    "remote_code": "fn add_n(n : i32) -> impl Fn(i32) -> i32 {\n    move |x| n + x\n}\n\nfn main() {\n    let adder = add_n(40);\n    println!(\"The answer to life is {}.\", adder(2));\n}",
    "title": "Currying",
    "url": "http://rosettacode.org/wiki/Currying"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.15.0\"\n\nfn is_curzon(n: u32, k: u32) -> bool {\n    use rug::{Complete, Integer};\n    (Integer::u_pow_u(k, n).complete() + 1) % (k * n + 1) == 0\n}\n\nfn main() {\n    for k in (2..=10).step_by(2) {\n        println!(\"Curzon numbers with base {k}:\");\n        let mut count = 0;\n        let mut n = 1;\n        while count < 50 {\n            if is_curzon(n, k) {\n                count += 1;\n                print!(\"{:4}{}\", n, if count % 10 == 0 { \"\\n\" } else { \" \" });\n            }\n            n += 1;\n        }\n        loop {\n            if is_curzon(n, k) {\n                count += 1;\n                if count == 1000 {\n                    break;\n                }\n            }\n            n += 1;\n        }\n        println!(\"1000th Curzon number with base {k}: {n}\\n\");\n    }\n}",
    "title": "Curzon numbers",
    "url": "http://rosettacode.org/wiki/Curzon_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn cwalk(mut vis: &mut Vec<Vec<bool>>, count: &mut isize, w: usize, h: usize, y: usize, x: usize, d: usize) {\n    if x == 0 || y == 0 || x == w || y == h {\n        *count += 1;\n        return;\n    }\n \n    vis[y][x] = true;\n    vis[h - y][w - x] = true;\n\n    if x != 0 && ! vis[y][x - 1] {\n        cwalk(&mut vis, count, w, h, y, x - 1, d | 1);\n    }\n    if d & 1 != 0 && x < w && ! vis[y][x+1] {\n        cwalk(&mut vis, count, w, h, y, x + 1, d | 1);\n    }\n    if y != 0 && ! vis[y - 1][x] {\n        cwalk(&mut vis, count, w, h, y - 1, x, d | 2);\n    }\n    if d & 2 != 0 && y < h && ! vis[y + 1][x] {\n        cwalk(&mut vis, count, w, h, y + 1, x, d | 2);\n    }\n\n    vis[y][x] = false;\n    vis[h - y][w - x] = false;\n}\n\nfn count_only(x: usize, y: usize) -> isize {\n    let mut count = 0;\n    let mut w = x;\n    let mut h = y;\n \n    if (h * w) & 1 != 0 {\n        return count;\n    }\n    if h & 1 != 0 {\n        std::mem::swap(&mut w, &mut h);\n    }\n \n    let mut vis = vec![vec![false; w + 1]; h + 1];\n    vis[h / 2][w / 2] = true;\n \n    if w & 1 != 0 {\n        vis[h / 2][w / 2 + 1] = true;\n    }\n    let mut res;\n    if w > 1 {\n        cwalk(&mut vis, &mut count, w, h, h / 2, w / 2 - 1, 1);\n        res = 2 * count - 1;\n        count = 0;\n        if w != h {\n            cwalk(&mut vis, &mut count, w, h, h / 2 + 1, w / 2, if w & 1 != 0 { 3 } else { 2 });\n        } \n        res += 2 * count - if w & 1 == 0 { 1 } else { 0 };\n    }\n    else {\n        res = 1;\n    }\n \n    if w == h {\n        res = 2 * res + 2;\n    }\n    res\n}\n\nfn main() {\n    for y in 1..10 {\n        for x in 1..y + 1 {\n            if x & 1 == 0 || y & 1 == 0 {\n                println!(\"{} x {}: {}\", y, x, count_only(x, y));\n            }\n        }\n    }\n}\n",
    "title": "Cut a rectangle",
    "url": "http://rosettacode.org/wiki/Cut_a_rectangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Cyclops numbers",
    "url": "http://rosettacode.org/wiki/Cyclops_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Cyclotomic polynomial",
    "url": "http://rosettacode.org/wiki/Cyclotomic_polynomial"
  },
  {
    "local_code": "use std::io;\nuse std::net::ToSocketAddrs;\n\nfn main() -> io::Result<()> {\n    let host = \"www.kame.net:80\";\n\n    for ip in host.to_socket_addrs()?.map(|addr| addr.ip()) {\n        println!(\"{}\", ip);\n    }\n\n    Ok(())\n}\n",
    "path": "tasks/dns-query",
    "remote_code": "use std::net::ToSocketAddrs;\n\nfn main() {\n    let host = \"www.kame.net\";\n    // Ideally, we would want to use std::net::lookup_host to resolve the host ips,\n    // but at time of writing this, it is still unstable. Fortunately, we can\n    // still resolve using the ToSocketAddrs trait, but we need to add a port,\n    // so we use the dummy port 0.\n    let host_port = (host, 0);\n    let ip_iter = host_port.to_socket_addrs().unwrap();\n\n\n    for ip_port in ip_iter {\n        println!(\"{}\", ip_port.ip());\n    }\n}",
    "title": "DNS query",
    "url": "http://rosettacode.org/wiki/DNS_query"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn damm(number: &str) -> u8 {\n    static TABLE: [[u8; 10]; 10] = [\n        [0, 3, 1, 7, 5, 9, 8, 6, 4, 2],\n        [7, 0, 9, 2, 1, 5, 4, 8, 6, 3],\n        [4, 2, 0, 6, 8, 7, 1, 3, 5, 9],\n        [1, 7, 5, 0, 9, 8, 3, 4, 2, 6],\n        [6, 1, 2, 3, 0, 4, 5, 9, 7, 8],\n        [3, 6, 7, 4, 2, 0, 9, 5, 8, 1],\n        [5, 8, 6, 9, 7, 2, 0, 1, 3, 4],\n        [8, 9, 4, 5, 3, 6, 2, 0, 1, 7],\n        [9, 4, 3, 8, 6, 1, 7, 2, 0, 5],\n        [2, 5, 8, 1, 4, 3, 6, 7, 9, 0],\n    ];\n\n    number.chars().fold(0, |row, digit| {\n        let digit = digit.to_digit(10).unwrap();\n        TABLE[row as usize][digit as usize]\n    })\n}\n\nfn damm_validate(number: &str) -> bool {\n    damm(number) == 0\n}\n\nfn main() {\n    let numbers = &[\"5724\", \"5727\", \"112946\"];\n    for number in numbers {\n        let is_valid = damm_validate(number);\n        if is_valid {\n            println!(\"{:>6} is valid\", number);\n        } else {\n            println!(\"{:>6} is invalid\", number);\n        }\n    }\n}",
    "title": "Damm algorithm",
    "url": "http://rosettacode.org/wiki/Damm_algorithm"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nfn main() {\n    let now = Utc::now();\n    println!(\"{}\", now.format(\"%Y-%m-%d\"));\n    println!(\"{}\", now.format(\"%A, %B %d, %Y\"));\n}\n",
    "path": "tasks/date-format",
    "remote_code": "fn main() {\n    let now = chrono::Utc::now();\n    println!(\"{}\", now.format(\"%Y-%m-%d\"));\n    println!(\"{}\", now.format(\"%A, %B %d, %Y\"));\n}",
    "title": "Date format",
    "url": "http://rosettacode.org/wiki/Date_format"
  },
  {
    "local_code": "use chrono::prelude::*;\nuse chrono::Duration;\n\nfn main() {\n    // Chrono allows parsing time zone abbreviations like \"EST\", but\n    // their meaning is ignored due to a lack of standardization.\n    //\n    // This solution compromises by augmenting the parsed datetime\n    // with the timezone using the IANA abbreviation.\n    let ndt =\n        NaiveDateTime::parse_from_str(\"March 7 2009 7:30pm EST\", \"%B %e %Y %l:%M%P %Z\").unwrap();\n\n    // add TZ manually\n    let dt = chrono_tz::EST.from_local_datetime(&ndt).unwrap();\n    println!(\"Date parsed: {:?}\", dt);\n\n    let new_date = dt + Duration::hours(12);\n    println!(\"+12 hrs in EST: {:?}\", new_date);\n    println!(\n        \"+12 hrs in CET: {:?}\",\n        new_date.with_timezone(&chrono_tz::CET)\n    );\n}\n",
    "path": "tasks/date-manipulation",
    "remote_code": "\nuse chrono::prelude::*;\nuse chrono::Duration;\n\nfn main() {\n    // Chrono allows parsing time zone abbreviations like \"EST\", but\n    // their meaning is ignored due to a lack of standardization.\n    //\n    // This solution compromises by augmenting the parsed datetime\n    // with the timezone using the IANA abbreviation.\n    let ndt =\n        NaiveDateTime::parse_from_str(\"March 7 2009 7:30pm EST\", \"%B %e %Y %l:%M%P %Z\").unwrap();\n\n    // add TZ manually\n    let dt = chrono_tz::EST.from_local_datetime(&ndt).unwrap();\n    println!(\"Date parsed: {:?}\", dt);\n\n    let new_date = dt + Duration::hours(12);\n    println!(\"+12 hrs in EST: {:?}\", new_date);\n    println!(\n        \"+12 hrs in CET: {:?}\",\n        new_date.with_timezone(&chrono_tz::CET)\n    );\n}\n\n",
    "title": "Date manipulation",
    "url": "http://rosettacode.org/wiki/Date_manipulation"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nfn main() {\n    for i in 2008..2121 {\n        let dt = Utc.ymd(i, 12, 25);\n        if dt.weekday() == Weekday::Sun {\n            println!(\"{} is a Sunday.\", dt.format(\"%Y-%m-%d\"));\n        }\n    }\n}\n",
    "path": "tasks/day-of-the-week",
    "remote_code": "extern crate chrono;\n\nuse chrono::prelude::*;\n\nfn main() {\n    let years = (2008..2121).filter(|&y| Local.ymd(y, 12, 25).weekday() == Weekday::Sun).collect::<Vec<i32>>();\n    println!(\"Years = {:?}\", years);\n}",
    "title": "Day of the week",
    "url": "http://rosettacode.org/wiki/Day_of_the_week"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "De Bruijn sequences",
    "url": "http://rosettacode.org/wiki/De_Bruijn_sequences"
  },
  {
    "local_code": "// Code available at https://rosettacode.org/wiki/Linear_congruential_generator#Rust\nextern crate linear_congruential_generator;\nextern crate rand;\n\nuse linear_congruential_generator::MsLcg;\nuse rand::prelude::*;\n\n// We can't use `rand::Rng::shuffle` because it uses the more uniform\n// `rand::Rng::gen_range` (`% range` is subject to modulo bias).  If an exact match\n// of the old dealer is not needed, `rand::Rng::shuffle` should be used. Though you also\n// likely should use a better PRNG, `rand` offers a few.\nfn shuffle<T>(rng: &mut MsLcg, deck: &mut [T]) {\n    let len = deck.len() as u32;\n    for i in (1..len).rev() {\n        let j = rng.gen::<u32>() % (i + 1);\n        deck.swap(i as usize, j as usize);\n    }\n}\n\nfn gen_deck() -> Vec<String> {\n    const RANKS: [char; 13] = [\n        'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K',\n    ];\n    const SUITS: [char; 4] = ['C', 'D', 'H', 'S'];\n\n    let render_card = |card: usize| {\n        let (suit, rank) = (card % 4, card / 4);\n        format!(\"{}{}\", RANKS[rank], SUITS[suit])\n    };\n\n    (0..52).map(render_card).collect()\n}\n\nfn deal_ms_fc_board(seed: u32) -> Vec<String> {\n    let mut rng = MsLcg::from_seed_u32(seed);\n    let mut deck = gen_deck();\n\n    shuffle(&mut rng, &mut deck);\n    deck.reverse();\n\n    deck.chunks(8).map(|row| row.join(\" \")).collect::<Vec<_>>()\n}\n\nfn main() {\n    let seed = std::env::args()\n        .nth(1)\n        .and_then(|n| n.parse().ok())\n        .expect(\"A 32-bit seed is required\");\n\n    for row in deal_ms_fc_board(seed) {\n        println!(\": {}\", row);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn seed_one() {\n        assert_eq!(\n            deal_ms_fc_board(1),\n            [\n                \"JD 2D 9H JC 5D 7H 7C 5H\",\n                \"KD KC 9S 5S AD QC KH 3H\",\n                \"2S KS 9D QD JS AS AH 3C\",\n                \"4C 5C TS QH 4H AC 4D 7S\",\n                \"3S TD 4S TH 8H 2C JH 7D\",\n                \"6D 8S 8D QS 6C 3D 8C TC\",\n                \"6S 9C 2H 6H\",\n            ]\n        );\n    }\n\n    #[test]\n    fn seed_617() {\n        assert_eq!(\n            deal_ms_fc_board(617),\n            [\n                \"7D AD 5C 3S 5S 8C 2D AH\",\n                \"TD 7S QD AC 6D 8H AS KH\",\n                \"TH QC 3H 9D 6S 8D 3D TC\",\n                \"KD 5H 9S 3C 8S 7H 4D JS\",\n                \"4C QS 9C 9H 7C 6H 2C 2S\",\n                \"4S TS 2H 5D JC 6C JH QH\",\n                \"JD KS KC 4H\",\n            ]\n        );\n    }\n}\n",
    "path": "tasks/deal-cards-for-freecell",
    "remote_code": "// Code available at https://rosettacode.org/wiki/Linear_congruential_generator#Rust\nextern crate linear_congruential_generator;\n\nuse linear_congruential_generator::{MsLcg, Rng, SeedableRng};\n\n// We can't use `rand::Rng::shuffle` because it uses the more uniform `rand::Rng::gen_range`\n// (`% range` is subject to modulo bias).  If an exact match of the old dealer is not needed,\n// `rand::Rng::shuffle` should be used.\nfn shuffle<T>(rng: &mut MsLcg, deck: &mut [T]) {\n    let len = deck.len() as u32;\n    for i in (1..len).rev() {\n        let j = rng.next_u32() % (i + 1);\n        deck.swap(i as usize, j as usize);\n    }\n}\n\nfn gen_deck() -> Vec<String> {\n    const RANKS: [char; 13] = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'];\n    const SUITS: [char; 4] = ['C', 'D', 'H', 'S'];\n\n    let render_card = |card: usize| {\n        let (suit, rank) = (card % 4, card / 4);\n        format!(\"{}{}\", RANKS[rank], SUITS[suit])\n    };\n\n    (0..52).map(render_card).collect()\n}\n\nfn deal_ms_fc_board(seed: u32) -> Vec<String> {\n    let mut rng = MsLcg::from_seed(seed);\n    let mut deck = gen_deck();\n\n    shuffle(&mut rng, &mut deck);\n    deck.reverse();\n\n    deck.chunks(8).map(|row| row.join(\" \")).collect::<Vec<_>>()\n}\n\nfn main() {\n    let seed = std::env::args()\n        .nth(1)\n        .and_then(|n| n.parse().ok())\n        .expect(\"A 32-bit seed is required\");\n\n    for row in deal_ms_fc_board(seed) {\n        println!(\": {}\", row);\n    }\n}\n",
    "title": "Deal cards for FreeCell",
    "url": "http://rosettacode.org/wiki/Deal_cards_for_FreeCell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Death Star",
    "url": "http://rosettacode.org/wiki/Death_Star"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// rug = \"1.15.0\"\n\nfn main() {\n    println!(\"First 100 deceptive numbers:\");\n    use rug::Integer;\n    let mut repunit = Integer::from(11);\n    let mut n: u32 = 3;\n    let mut count = 0;\n    while count != 100 {\n        if n % 3 != 0 && n % 5 != 0 && !primal::is_prime(n as u64) && repunit.is_divisible_u(n) {\n            print!(\"{:6}\", n);\n            count += 1;\n            if count % 10 == 0 {\n                println!();\n            } else {\n                print!(\" \");\n            }\n        }\n        n += 2;\n        repunit *= 100;\n        repunit += 11;\n    }\n}",
    "title": "Deceptive numbers",
    "url": "http://rosettacode.org/wiki/Deceptive_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deconvolution/1D",
    "url": "http://rosettacode.org/wiki/Deconvolution/1D"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deconvolution/2D+",
    "url": "http://rosettacode.org/wiki/Deconvolution/2D%2B"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// The compiler can automatically implement Clone on structs (assuming all members have implemented Clone).\n#[derive(Clone)]\nstruct Tree<T> {\n    left: Leaf<T>,\n    data: T,\n    right: Leaf<T>,\n}\n\ntype Leaf<T> = Option<Box<Tree<T>>>;\n\nimpl<T> Tree<T> {\n    fn root(data: T) -> Self {\n        Self { left: None, data, right: None }\n    }\n\n    fn leaf(d: T) -> Leaf<T> {\n        Some(Box::new(Self::root(d)))\n    }\n}\n\nfn main() {\n    let mut tree = Tree::root([4, 5, 6]);\n    tree.right = Tree::leaf([1, 2, 3]);\n    tree.left = Tree::leaf([7, 8, 9]);\n\n    let newtree = tree.clone();\n}",
    "title": "Deepcopy",
    "url": "http://rosettacode.org/wiki/Deepcopy"
  },
  {
    "local_code": "//! Implements a custom type named `CustomInt`.\n//! This type only implements a subset of all traits within `std::ops`.\n\nuse std::ops;\n\n#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Copy, Clone)]\nstruct CustomInt {\n    value: i8,\n}\n\n#[derive(Debug)]\nenum CustomIntError {\n    OutOfBoundsAssn,\n}\n\nimpl CustomInt {\n    fn new(v: u8) -> Result<CustomInt, CustomIntError> {\n        if !(1..=10).contains(&v) {\n            Err(CustomIntError::OutOfBoundsAssn)\n        } else {\n            Ok(CustomInt { value: v as i8 })\n        }\n    }\n}\n\n// custom trait to specify bounds\ntrait Bounded {\n    fn in_bounds(&self);\n}\n\nimpl Bounded for CustomInt {\n    fn in_bounds(&self) {\n        if self.value < 1 || self.value > 10 {\n            panic(self.value);\n        }\n        #[cold]\n        #[inline(never)]\n        fn panic(v: i8) -> ! {\n            panic!(\"CustomInt is out of bounds! {} was value\", v);\n        }\n    }\n}\n\nimpl ops::Add for CustomInt {\n    type Output = CustomInt;\n    fn add(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value + rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Sub for CustomInt {\n    type Output = CustomInt;\n    fn sub(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value - rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Mul for CustomInt {\n    type Output = CustomInt;\n    fn mul(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value * rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Div for CustomInt {\n    type Output = CustomInt;\n    fn div(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value / rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitAnd for CustomInt {\n    type Output = CustomInt;\n    fn bitand(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value & rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitOr for CustomInt {\n    type Output = CustomInt;\n    fn bitor(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value | rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitXor for CustomInt {\n    type Output = CustomInt;\n    fn bitxor(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value ^ rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nfn main() {\n    let cint_2: CustomInt = CustomInt::new(2).unwrap();\n    let cint_3: CustomInt = CustomInt::new(3).unwrap();\n    let cint_4: CustomInt = CustomInt::new(4).unwrap();\n    assert_eq!(cint_2 + cint_4, CustomInt { value: 6 });\n    assert_eq!(cint_4 - cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_4 * cint_2, CustomInt { value: 8 });\n    assert_eq!(cint_4 / cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_3 & cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_3 | cint_2, CustomInt { value: 3 });\n    assert_eq!(cint_3 ^ cint_2, CustomInt { value: 1 });\n}\n\n#[cfg(test)]\nmod tests {\n    use super::CustomInt;\n\n    #[test]\n    fn add_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(6).unwrap(), cint_2 + cint_4);\n    }\n\n    #[test]\n    fn sub_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_4 - cint_2);\n    }\n\n    #[test]\n    fn mul_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(8).unwrap(), cint_4 * cint_2);\n    }\n\n    #[test]\n    fn div_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_4 / cint_2);\n    }\n\n    #[test]\n    fn and_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_3 & cint_2);\n    }\n\n    #[test]\n    fn or_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(3).unwrap(), cint_3 | cint_2);\n    }\n\n    #[test]\n    fn xor_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(1).unwrap(), cint_3 ^ cint_2);\n    }\n\n    #[test]\n    fn assn_out_of_bounds_test() {\n        let cint_error = CustomInt::new(0);\n        assert!(cint_error.is_err());\n    }\n\n    #[test]\n    #[should_panic(expected = \"CustomInt is out of bounds! 11 was value\")]\n    fn above_out_of_bounds_test() {\n        let cint_10: CustomInt = CustomInt::new(10).unwrap();\n        let cint_1: CustomInt = CustomInt::new(1).unwrap();\n        let _ = cint_10 + cint_1; // should panic here\n    }\n\n    #[test]\n    #[should_panic(expected = \"CustomInt is out of bounds! -9 was value\")]\n    fn below_out_of_bounds_test() {\n        let cint_1: CustomInt = CustomInt::new(1).unwrap();\n        let cint_10: CustomInt = CustomInt::new(10).unwrap();\n        let _ = cint_1 - cint_10; // should panic here\n    }\n}\n",
    "path": "tasks/define-a-primitive-data-type",
    "remote_code": "use std::convert::TryFrom;\n\nmod test_mod {\n    use std::convert::TryFrom;\n    use std::fmt;\n\n    // Because the `i8` is not `pub` this cannot be directly constructed\n    // by code outside this module\n    #[derive(Copy, Clone, Debug)]\n    pub struct TwoDigit(i8);\n\n    impl TryFrom<i8> for TwoDigit {\n        type Error = &'static str;\n\n        fn try_from(value: i8) -> Result<Self, Self::Error> {\n            if value < -99 || value > 99 {\n                Err(\"Number cannot fit into two decimal digits\")\n            } else {\n                Ok(TwoDigit(value))\n            }\n        }\n    }\n\n    impl Into<i8> for TwoDigit {\n        fn into(self) -> i8 { self.0 }\n    }\n\n    // This powers `println!`'s `{}` token.\n    impl fmt::Display for TwoDigit {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n\npub fn main() {\n    let foo = test_mod::TwoDigit::try_from(50).unwrap();\n    let bar: i8 = foo.into();\n    println!(\"{} == {}\", foo, bar);\n}",
    "title": "Define a primitive data type",
    "url": "http://rosettacode.org/wiki/Define_a_primitive_data_type"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "trait Thingable {\n    fn thing(&self) -> &str;\n}\n\nstruct Delegator<T>(Option<T>);\n\nstruct Delegate {}\n\nimpl Thingable for Delegate {\n    fn thing(&self) -> &'static str {\n        \"Delegate implementation\"\n    }\n}\n\nimpl<T: Thingable> Thingable for Delegator<T> {\n    fn thing(&self) -> &str {\n        self.0.as_ref().map(|d| d.thing()).unwrap_or(\"Default implmementation\")\n    }\n}\n\nfn main() {\n    let d: Delegator<Delegate> = Delegator(None);\n    println!(\"{}\", d.thing());\n    \n    let d: Delegator<Delegate> = Delegator(Some(Delegate {}));\n    println!(\"{}\", d.thing());\n}",
    "title": "Delegates",
    "url": "http://rosettacode.org/wiki/Delegates"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    fs::remove_file(\"input.txt\").unwrap();\n    fs::remove_file(\"/input.txt\").unwrap();\n    fs::remove_dir_all(\"docs\").unwrap();\n    fs::remove_dir_all(\"/docs\").unwrap();\n}\n",
    "path": "tasks/delete-a-file",
    "remote_code": "use std::io::{self, Write};\nuse std::fs::{remove_file,remove_dir};\nuse std::path::Path;\nuse std::{process,display};\n \nconst FILE_NAME: &'static str = \"output.txt\";\nconst DIR_NAME : &'static str = \"docs\";\n \nfn main() {\n    delete(\".\").and(delete(\"/\"))\n               .unwrap_or_else(|e| error_handler(e,1));\n}\n \n \nfn delete<P>(root: P) -> io::Result<()>\n    where P: AsRef<Path>\n{\n    remove_file(root.as_ref().join(FILE_NAME))\n        .and(remove_dir(root.as_ref().join(DIR_NAME)))\n}\n \nfn error_handler<E: fmt::Display>(error: E, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"{:?}\", error);\n    process::exit(code)\n}",
    "title": "Delete a file",
    "url": "http://rosettacode.org/wiki/Delete_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deming's funnel",
    "url": "http://rosettacode.org/wiki/Deming's_funnel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate num_iter;\nfn main() {\n    println!(\"Police Sanitation Fire\");\n    println!(\"----------------------\");\n\n    for police in num_iter::range_step(2, 7, 2) {\n        for sanitation in 1..8 {\n            for fire in 1..8 {\n                if police != sanitation\n                    && sanitation != fire\n                    && fire != police\n                    && police + fire + sanitation == 12\n                {\n                    println!(\"{:6}{:11}{:4}\", police, sanitation, fire);\n                }\n            }\n        }\n    }\n}",
    "title": "Department numbers",
    "url": "http://rosettacode.org/wiki/Department_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Descending primes",
    "url": "http://rosettacode.org/wiki/Descending_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn test_division(numerator: u32, denominator: u32) {\n    match numerator.checked_div(denominator) {\n        Some(result) => println!(\"{} / {} = {}\", numerator, denominator, result),\n        None => println!(\"{} / {} results in a division by zero\", numerator, denominator)\n    }\n}\n\nfn main() {\n    test_division(5, 4);\n    test_division(4, 0);\n}",
    "title": "Detect division by zero",
    "url": "http://rosettacode.org/wiki/Detect_division_by_zero"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\nlet mut m1: Vec<Vec<f64>> = vec![vec![1.0,2.0],vec![3.0,4.0]];\n    let mut r_m1 = &mut m1;\n    let rr_m1 = &mut r_m1;\n    let mut m2: Vec<Vec<f64>> = vec![vec![1.0, 2.0, 3.0, 4.0], vec![4.0, 5.0, 6.0, 7.0], vec![7.0, 8.0, 9.0, 10.0], vec![10.0, 11.0, 12.0, 13.0]];\n    let mut r_m2 = &mut m2;\n    let rr_m2 = &mut r_m2;\n    let mut m3: Vec<Vec<f64>> = vec![vec![0.0, 1.0, 2.0, 3.0, 4.0],\n                                vec![5.0, 6.0, 7.0, 8.0, 9.0],\n                                vec![10.0, 11.0, 12.0, 13.0, 14.0],\n                                vec![15.0, 16.0, 17.0, 18.0, 19.0], \n                                vec![20.0, 21.0, 22.0, 23.0, 24.0]];\n    let mut r_m3 = &mut m3;\n    let rr_m3 = &mut r_m3;\n\n    println!(\"Determinant of m1: {}\", determinant(rr_m1));\n    println!(\"Permanent of m1: {}\", permanent(rr_m1));\n\n    println!(\"Determinant of m2: {}\", determinant(rr_m2));\n    println!(\"Permanent of m2: {}\", permanent(rr_m2));\n\n    println!(\"Determinant of m3: {}\", determinant(rr_m3));\n    println!(\"Permanent of m3: {}\", permanent(rr_m3));\n\n}\n\nfn minor( a: &mut Vec<Vec<f64>>, x: usize, y: usize) ->  Vec<Vec<f64>> {\n    let mut out_vec: Vec<Vec<f64>> = vec![vec![0.0; a.len() - 1]; a.len() -1];\n    for i in 0..a.len()-1 {\n        for j in 0..a.len()-1 {\n            match () {\n                _ if (i < x && j < y) => {\n                    out_vec[i][j] = a[i][j];\n                },\n                _ if (i >= x && j < y) => {\n                    out_vec[i][j] = a[i + 1][j];\n                },\n                _ if (i < x && j >= y) => {\n                    out_vec[i][j] = a[i][j + 1];\n                },\n                _ => { //i > x && j > y \n                    out_vec[i][j] = a[i + 1][j + 1];\n                },\n            }\n        }\n    }\n    out_vec\n}\n\nfn determinant (matrix: &mut Vec<Vec<f64>>) -> f64 {\n    match () {\n        _ if (matrix.len() == 1) => {\n            matrix[0][0]\n        },\n        _ => {\n            let mut sign = 1.0;\n            let mut sum = 0.0;\n            for i in 0..matrix.len() {\n                sum = sum + sign * matrix[0][i] * determinant(&mut minor(matrix, 0, i));\n                sign = sign * -1.0;\n            }\n            sum\n        }\n    }\n}\n\nfn permanent (matrix: &mut Vec<Vec<f64>>) -> f64 {\n    match () {\n        _ if (matrix.len() == 1) => {\n            matrix[0][0]\n        },\n        _ => {\n            let mut sum = 0.0;\n            for i in 0..matrix.len() {\n                sum = sum + matrix[0][i] * permanent(&mut minor(matrix, 0, i));\n            }\n            sum\n        }\n    }\n}\n\n",
    "title": "Determinant and permanent",
    "url": "http://rosettacode.org/wiki/Determinant_and_permanent"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn test_string(input: &str) {\n    println!(\"Checking string {:?} of length {}:\", input, input.chars().count());\n\n    let mut chars = input.chars();\n\n    match chars.next() {\n        Some(first) => {\n            if let Some((character, pos)) = chars.zip(2..).filter(|(c, _)| *c != first).next() {\n                println!(\"\\tNot all characters are the same.\");\n                println!(\"\\t{:?} (0x{:X}) at position {} differs.\", character, character as u32, pos);\n\n                return;\n            }\n        },\n        None => {}\n    }\n\n    println!(\"\\tAll characters in the string are the same\");\n}\n\nfn main() {\n    let tests = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\", \"pépé\", \"🐶🐶🐺🐶\", \"🎄🎄🎄🎄\"];\n\n    for string in &tests {\n        test_string(string);\n    }\n}",
    "title": "Determine if a string has all the same characters",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn unique(s: &str) -> Option<(usize, usize, char)> {\n    s.chars().enumerate().find_map(|(i, c)| {\n        s.chars()\n            .enumerate()\n            .skip(i + 1)\n            .find(|(_, other)| c == *other)\n            .map(|(j, _)| (i, j, c))\n    })\n}\n\nfn main() {\n    let strings = [\n        \"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"hétérogénéité\",\n        \"🎆🎃🎇🎈\",\n        \"😍😀🙌💃😍🙌\",\n        \"🐠🐟🐡🦈🐬🐳🐋🐡\",\n    ];\n\n    for string in &strings {\n        print!(\"\\\"{}\\\" (length {})\", string, string.chars().count());\n        match unique(string) {\n            None => println!(\" is unique\"),\n            Some((i, j, c)) => println!(\n                \" is not unique\\n\\tfirst duplicate: \\\"{}\\\" (U+{:0>4X}) at indices {} and {}\",\n                c, c as usize, i, j\n            ),\n        }\n    }\n}\n",
    "title": "Determine if a string has all unique characters",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn collapse_string(val: &str) -> String {\n    let mut output = String::new();\n    let mut chars = val.chars().peekable();\n\n    while let Some(c) = chars.next() {\n        while let Some(&b) = chars.peek() {\n            if b == c {\n                chars.next();\n            } else {\n                break;\n            }\n        }\n\n        output.push(c);\n    }\n\n    output\n}\n\nfn main() {\n    let tests = [\n        \"122333444455555666666777777788888888999999999\",\n        \"\",\n        \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                    --- Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n    ];\n\n    for s in &tests {\n        println!(\"Old: {:>3} <<<{}>>>\", s.len(), s);\n        let collapsed = collapse_string(s);\n        println!(\"New: {:>3} <<<{}>>>\", collapsed.len(), collapsed);\n\n        println!();\n    }\n}",
    "title": "Determine if a string is collapsible",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible"
  },
  {
    "local_code": "fn is_numeric(s: &str) -> bool {\n    s.parse::<f64>().is_ok()\n}\n\nfn main() {\n    println!(\"{}\", is_numeric(\"4.034\"));\n}\n\n#[test]\nfn test_isize() {\n    assert!(is_numeric(\"4\"));\n    assert!(is_numeric(\"-4\"));\n}\n\n#[test]\nfn test_str() {\n    assert!(!is_numeric(\"j\"));\n}\n\n#[test]\nfn test_float() {\n    assert!(is_numeric(\"1.034\"));\n    assert!(is_numeric(\"-1.034\"));\n}\n",
    "path": "tasks/determine-if-a-string-is-numeric",
    "remote_code": "// This function is not limited to just numeric types but rather anything that implements the FromStr trait.\nfn parsable<T: FromStr>(s: &str) -> bool {\n    s.parse::<T>().is_ok()\n}",
    "title": "Determine if a string is numeric",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_numeric"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn squeezable_string<'a>(s: &'a str, squeezable: char) -> impl Iterator<Item = char> + 'a {\n    let mut previous = None;\n\n    s.chars().filter(move |c| match previous {\n        Some(p) if p == squeezable && p == *c => false,\n        _ => {\n            previous = Some(*c);\n            true\n        }\n    })\n}\n\nfn main() {\n    fn show(input: &str, c: char) {\n        println!(\"Squeeze: '{}'\", c);\n        println!(\"Input ({} chars): \\t{}\", input.chars().count(), input);\n        let output: String = squeezable_string(input, c).collect();\n        println!(\"Output ({} chars): \\t{}\", output.chars().count(), output);\n        println!();\n    }\n\n    let harry = r#\"I never give 'em hell, I just tell the truth, and they think it's hell.\n    ---  Harry S Truman\"#;\n\n    #[rustfmt::skip]\n    let inputs = [\n        (\"\", ' '),\n        (r#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#, '-'),\n        (\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7'),\n        (harry, ' '),\n        (harry, '-'),\n        (harry, 'r'),\n        (\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\", 'e'),\n        (\"headmistressship\", 's'),\n    ];\n\n    inputs.iter().for_each(|(input, c)| show(input, *c));\n}",
    "title": "Determine if a string is squeezable",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable"
  },
  {
    "local_code": "use std::net::TcpListener;\n\nfn create_app_lock(port: u16) -> TcpListener {\n    match TcpListener::bind((\"0.0.0.0\", port)) {\n        Ok(socket) => socket,\n        Err(e) => {\n            panic!(\n                \"Couldn't lock port {}: another instance already running? ({})\",\n                port, e\n            );\n        }\n    }\n}\n\nfn remove_app_lock(socket: TcpListener) {\n    drop(socket);\n}\n\nfn main() {\n    #[allow(clippy::unreadable_literal)]\n    let lock_socket = create_app_lock(12345);\n    // ...\n    // your code here\n    // ...\n    remove_app_lock(lock_socket);\n}\n",
    "path": "tasks/determine-if-only-one-instance-is-running",
    "remote_code": "use std::net::TcpListener;\n\nfn create_app_lock(port: u16) -> TcpListener {\n    match TcpListener::bind((\"0.0.0.0\", port)) {\n        Ok(socket) => {\n            socket\n        },\n        Err(_) => {\n            panic!(\"Couldn't lock port {}: another instance already running?\", port);\n        }\n    }\n}\n\nfn remove_app_lock(socket: TcpListener) {\n    drop(socket);\n}\n\nfn main() {\n    let lock_socket = create_app_lock(12345);\n    // ...\n    // your code here\n    // ...\n    remove_app_lock(lock_socket);\n}",
    "title": "Determine if only one instance is running",
    "url": "http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Determine if two triangles overlap",
    "url": "http://rosettacode.org/wiki/Determine_if_two_triangles_overlap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Determine sentence type",
    "url": "http://rosettacode.org/wiki/Determine_sentence_type"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Returns a vector containing the number of ways each possible sum of face\n// values can occur.\nfn get_totals(dice: usize, faces: usize) -> Vec<f64> {\n    let mut result = vec![1.0; faces + 1];\n    for d in 2..=dice {\n        let mut tmp = vec![0.0; d * faces + 1];\n        for i in d - 1..result.len() {\n            for j in 1..=faces {\n                tmp[i + j] += result[i];\n            }\n        }\n        result = tmp;\n    }\n    result\n}\n\nfn probability(dice1: usize, faces1: usize, dice2: usize, faces2: usize) -> f64 {\n    let totals1 = get_totals(dice1, faces1);\n    let totals2 = get_totals(dice2, faces2);\n    let mut wins = 0.0;\n    let mut total = 0.0;\n    for i in dice1..totals1.len() {\n        for j in dice2..totals2.len() {\n            let n = totals1[i] * totals2[j];\n            total += n;\n            if j < i {\n                wins += n;\n            }\n        }\n    }\n    wins / total\n}\n\nfn main() {\n    println!(\"{}\", probability(9, 4, 6, 6));\n    println!(\"{}\", probability(5, 10, 6, 7));\n}",
    "title": "Dice game probabilities",
    "url": "http://rosettacode.org/wiki/Dice_game_probabilities"
  },
  {
    "local_code": "fn sum_digits(mut n: u64, base: u64) -> u64 {\n    let mut sum = 0u64;\n    while n > 0 {\n        sum += n % base;\n        n /= base;\n    }\n    sum\n}\n\n// Returns tuple of (additive-persistence, digital-root)\nfn digital_root(mut num: u64, base: u64) -> (u64, u64) {\n    let mut pers = 0;\n    while num >= base {\n        pers += 1;\n        num = sum_digits(num, base);\n    }\n    (pers, num)\n}\n\nfn main() {\n    // Test base 10\n    let values = [627_615u64, 39_390u64, 588_225u64, 393_900_588_225u64];\n    for &value in &values {\n        let (pers, root) = digital_root(value, 10);\n        println!(\n            \"{} has digital root {} and additive persistance {}\",\n            value, root, pers\n        );\n    }\n\n    println!();\n\n    // Test base 16\n    let values_base16 = [0x7e0, 0x14_e344, 0xd6_0141, 0x1234_3210];\n    for &value in &values_base16 {\n        let (pers, root) = digital_root(value, 16);\n        println!(\n            \"0x{:x} has digital root 0x{:x} and additive persistance 0x{:x}\",\n            value, root, pers\n        );\n    }\n}\n\n#[test]\nfn test_sum_digits() {\n    let sum = sum_digits(15u64, 10u64);\n    assert_eq!(sum, 6);\n}\n\n#[test]\nfn test_base_ten() {\n    // Test tuples: (value, root, pers)\n    let test_pairs = [\n        (627_615u64, 9, 2),\n        (39_390u64, 6, 2),\n        (588_225u64, 3, 2),\n        (393_900_588_225u64, 9, 2),\n    ];\n\n    for &(value, result_root, result_pers) in test_pairs.iter() {\n        let (pers, root) = digital_root(value, 10u64);\n        println!(\n            \"{} has digital root {} and additive persistance {}\",\n            value, root, pers\n        );\n        assert_eq!(pers, result_pers);\n        assert_eq!(root, result_root);\n    }\n}\n\n#[test]\nfn test_base_16() {\n    // Test tuples: (value, root, pers)\n    let test_pairs = [\n        (0x7e0, 0x6, 0x2),\n        (0x14e344, 0xf, 0x2),\n        (0xd60141, 0xa, 0x2),\n        (0x12343210, 0x1, 0x2),\n    ];\n\n    for &(value, result_root, result_pers) in test_pairs.iter() {\n        let (pers, root) = digital_root(value, 16u64);\n        println!(\n            \"{:x} has digital root {:x} and additive persistance {:x}\",\n            value, root, pers\n        );\n        assert_eq!(pers, result_pers);\n        assert_eq!(root, result_root);\n    }\n}\n",
    "path": "tasks/digital-root",
    "remote_code": "fn sum_digits(mut n: u64, base: u64) -> u64 {\n    let mut sum = 0u64;\n    while n > 0 {\n        sum = sum + (n % base);\n        n = n / base;\n    }\n    sum\n}\n\n// Returns tuple of (additive-persistence, digital-root)\nfn digital_root(mut num: u64, base: u64) -> (u64, u64) {\n    let mut pers = 0;\n    while num >= base {\n        pers = pers + 1;\n        num = sum_digits(num, base);\n    }\n    (pers, num)\n}\n\nfn main() {\n\n    // Test base 10\n    let values = [627615u64, 39390u64, 588225u64, 393900588225u64];\n    for &value in values.iter() {\n        let (pers, root) = digital_root(value, 10);\n        println!(\"{} has digital root {} and additive persistance {}\",\n                 value,\n                 root,\n                 pers);\n    }\n\n    println!(\"\");\n\n    // Test base 16\n    let values_base16 = [0x7e0, 0x14e344, 0xd60141, 0x12343210];\n    for &value in values_base16.iter() {\n        let (pers, root) = digital_root(value, 16);\n        println!(\"0x{:x} has digital root 0x{:x} and additive persistance 0x{:x}\",\n                 value,\n                 root,\n                 pers);\n    }\n}",
    "title": "Digital root",
    "url": "http://rosettacode.org/wiki/Digital_root"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Digital root/Multiplicative digital root",
    "url": "http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root"
  },
  {
    "local_code": "use std::cmp::Ordering;\nuse std::collections::{BinaryHeap, HashMap, VecDeque};\nuse std::usize;\n\ntype Node = usize;\ntype Cost = usize;\ntype Edge = (Node, Node);\n\n/// The `DistPair` struct is for the priority queue.\n#[derive(Eq, PartialEq)]\nstruct DistPair(Node, Cost);\n\nimpl Ord for DistPair {\n    fn cmp(&self, other: &DistPair) -> Ordering {\n        let DistPair(_, dist_a) = *self;\n        let DistPair(_, dist_b) = *other;\n        dist_b.cmp(&dist_a) // Intentionally reversed\n    }\n}\n\nimpl PartialOrd for DistPair {\n    fn partial_cmp(&self, other: &DistPair) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// Graph structure, represented as an adjacency List.\nstruct Graph<'a> {\n    vertices: Vec<&'a str>,\n    adj_list: Vec<Vec<Node>>,\n    costs: HashMap<Edge, Cost>,\n}\n\nimpl<'a> Graph<'a> {\n    fn new() -> Graph<'a> {\n        Graph {\n            vertices: Vec::new(),\n            adj_list: Vec::new(),\n            costs: HashMap::new(),\n        }\n    }\n\n    /// Returns the index of the vertex, or `None` if vertex not found.\n    fn vertex_index(&self, vertex: &str) -> Option<Node> {\n        self.vertices.iter().position(|&v| v == vertex)\n    }\n\n    /// Returns the index of the vertex. If vertex is not found, inserts the vertex.\n    fn get_or_insert_vertex(&mut self, vertex: &'a str) -> Node {\n        self.vertex_index(vertex).unwrap_or_else(|| {\n            self.adj_list.push(Vec::new());\n            self.vertices.push(vertex);\n            self.vertices.len() - 1\n        })\n    }\n\n    /// Adds the given edge to the graph.\n    fn add_edge(&mut self, from: &'a str, to: &'a str, cost: usize) {\n        let from_idx = self.get_or_insert_vertex(from);\n        let to_idx = self.get_or_insert_vertex(to);\n\n        // Insert, and then if the insertion added a new key-value pair...\n        if self.costs.insert((from_idx, to_idx), cost).is_none() {\n            self.adj_list[from_idx].push(to_idx);\n        }\n    }\n\n    /// Implements Dijkstra's algorithm. This uses a priority queue to determine which vertex to\n    /// visit first. Terminates on discovering the target vertex.\n    ///\n    /// Returns vector of vertices representing the path, or an empty vector if there's no path, or\n    /// if the source or target is not in the graph.\n    fn dijkstra(&self, source: &str, target: &str) -> Vec<&str> {\n        let num_vert = self.vertices.len();\n        let mut dist = vec![usize::MAX; num_vert]; // Close enough to infinity\n        let mut prev: HashMap<Node, Node> = HashMap::new();\n        let mut queue: BinaryHeap<DistPair> = BinaryHeap::new();\n\n        let source_idx = match self.vertex_index(source) {\n            Some(idx) => idx,\n            None => return Vec::new(), // Source not in graph, return empty path.\n        };\n\n        let target_idx = match self.vertex_index(target) {\n            Some(idx) => idx,\n            None => return Vec::new(), // Target not in graph, return empty path.\n        };\n\n        dist[source_idx] = 0;\n        queue.push(DistPair(source_idx, dist[source_idx]));\n\n        while let Some(DistPair(u, dist_u)) = queue.pop() {\n            for &v in &(self.adj_list[u]) {\n                let cost_uv = self.costs.get(&(u, v)).unwrap_or(&usize::MAX);\n                let alt = dist_u + cost_uv;\n                if alt < dist[v] {\n                    prev.insert(v, u);\n                    dist[v] = alt;\n                    queue.push(DistPair(v, dist[v]));\n                }\n                if v == target_idx {\n                    break;\n                }\n            }\n        }\n\n        let mut temp_path: VecDeque<&str> = VecDeque::new();\n        let mut curr = target_idx;\n        temp_path.push_front(self.vertices[curr]);\n        while let Some(&parent) = prev.get(&curr) {\n            curr = parent;\n            temp_path.push_front(self.vertices[curr]);\n            if curr == source_idx {\n                return Vec::from(temp_path);\n            }\n        }\n        Vec::new()\n    }\n}\n\nimpl<'a> Default for Graph<'a> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"a\", \"c\", 9);\n    graph.add_edge(\"a\", \"f\", 14);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"b\", \"d\", 15);\n    graph.add_edge(\"c\", \"d\", 11);\n    graph.add_edge(\"c\", \"f\", 2);\n    graph.add_edge(\"d\", \"e\", 6);\n    graph.add_edge(\"e\", \"f\", 9);\n\n    let path = graph.dijkstra(\"a\", \"e\");\n    println!(\"Path is: {:?}\", path);\n}\n\n#[test]\nfn test_dijkstras() {\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"c\", \"d\", 5);\n    graph.add_edge(\"a\", \"d\", 30);\n    graph.add_edge(\"y\", \"z\", 10); //Disconnected from the rest\n\n    assert_eq!(graph.dijkstra(\"a\", \"d\"), [\"a\", \"b\", \"c\", \"d\"]);\n    assert!(graph.dijkstra(\"a\", \"y\").is_empty());\n    assert!(graph.dijkstra(\"e\", \"y\").is_empty());\n    assert!(graph.dijkstra(\"a\", \"e\").is_empty());\n\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"a\", \"c\", 9);\n    graph.add_edge(\"a\", \"f\", 14);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"b\", \"d\", 15);\n    graph.add_edge(\"c\", \"d\", 11);\n    graph.add_edge(\"c\", \"f\", 2);\n    graph.add_edge(\"d\", \"e\", 6);\n    graph.add_edge(\"e\", \"f\", 9);\n\n    assert_eq!(graph.dijkstra(\"a\", \"e\"), [\"a\", \"c\", \"d\", \"e\"]);\n}\n",
    "path": "tasks/dijkstras-algorithm",
    "remote_code": "use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::usize;\n\n\nstruct Grid<T> {\n    nodes: Vec<Node<T>>,\n}\n\nstruct Node<T> {\n    data: T,\n    edges: Vec<(usize,usize)>,\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct State {\n    node: usize,\n    cost: usize,\n}\n\n// Manually implement Ord so we get a min-heap instead of a max-heap\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.cost.cmp(&self.cost)\n    }\n}\n\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\ntype WeightedEdge = (usize, usize, usize);\n\nimpl<T> Grid<T> {\n    fn new() -> Self {\n        Grid { nodes: Vec::new() }\n    }\n\n    fn add_node(&mut self, data: T) -> usize {\n        let node = Node {\n            edges: Vec::new(),\n            data: data,\n        };\n        self.nodes.push(node);\n        self.nodes.len() - 1\n    }\n\n    fn create_edges<'a, I>(&mut self, iterator: I) where I: IntoIterator<Item=&'a WeightedEdge> {\n        for &(start,end,weight) in iterator.into_iter() {\n            self.nodes[start].edges.push((end,weight));\n            self.nodes[end].edges.push((start,weight));\n        }\n    \n    }\n\n    fn find_path(&self, start: usize, end: usize) -> Option<(Vec<usize>, usize)> {\n        let mut dist = vec![(usize::MAX, None); self.nodes.len()];\n\n        let mut heap = BinaryHeap::new();\n        dist[start] = (0, None);\n        heap.push(State {\n            node: start,\n            cost: 0,\n        });\n\n        while let Some(State { node, cost }) = heap.pop() {\n            if node == end {\n                let mut path = Vec::with_capacity(dist.len() / 2);\n                let mut current_dist = dist[end];\n                path.push(end);\n                while let Some(prev) = current_dist.1 {\n                    path.push(prev);\n                    current_dist = dist[prev];\n                }\n                path.reverse();\n                return Some((path, cost));\n            }\n\n            if cost > dist[node].0 {\n                continue;\n            }\n            for edge in &self.nodes[node].edges {\n                let next = State {\n                    node: edge.0,\n                    cost: cost + edge.1,\n                };\n                if next.cost < dist[next.node].0 {\n                    dist[next.node] = (next.cost, Some(node));\n                    heap.push(next);\n                }\n            }\n        }\n        None\n    }\n}\n\nfn main() {\n    let mut grid = Grid::new();\n    let (a,b,c,d,e,f) = (grid.add_node(\"a\"), grid.add_node(\"b\"),\n                         grid.add_node(\"c\"), grid.add_node(\"d\"),\n                         grid.add_node(\"e\"), grid.add_node(\"f\"));\n\n    grid.create_edges(&[\n        (a,b,7) ,(a,c,9) ,(a,f,14),\n        (b,c,10),(b,d,15),(c,d,11),\n        (c,f,2) ,(d,e,6) ,(e,f,9) ,\n    ]);\n\n    let (path, cost) = grid.find_path(a,e).unwrap();\n\n    print!(\"{}\", grid.nodes[path[0]].data);\n    for i in path.iter().skip(1) {\n        print!(\" -> {}\", grid.nodes[*i].data);\n    }\n    println!(\"\\nCost: {}\", cost);\n\n}",
    "title": "Dijkstra's algorithm",
    "url": "http://rosettacode.org/wiki/Dijkstra's_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Dinesman's multiple-dwelling problem",
    "url": "http://rosettacode.org/wiki/Dinesman's_multiple-dwelling_problem"
  },
  {
    "local_code": "//! A Rust implementation of a solution for the Dining Philosophers Problem. We prevent a deadlock\n//! by using Dijkstra's solution of making a single diner \"left-handed.\" That is, all diners except\n//! one pick up the chopstick \"to their left\" and then the chopstick \"to their right.\" The\n//! remaining diner performs this in reverse.\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct Philosopher {\n    name: String,\n    left: usize,\n    right: usize,\n}\n\nimpl Philosopher {\n    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n        Philosopher {\n            name: name.to_string(),\n            left,\n            right,\n        }\n    }\n\n    fn eat(&self, table: &Table) {\n        let _left = table.forks[self.left].lock().unwrap();\n        let _right = table.forks[self.right].lock().unwrap();\n\n        println!(\"{} is eating.\", self.name);\n\n        thread::sleep(Duration::from_secs(1));\n\n        println!(\"{} is done eating.\", self.name);\n    }\n}\n\nstruct Table {\n    forks: Vec<Mutex<()>>,\n}\n\nfn main() {\n    let table = Arc::new(Table {\n        forks: vec![\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n        ],\n    });\n\n    let philosophers = vec![\n        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n        Philosopher::new(\"Karl Marx\", 2, 3),\n        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n        Philosopher::new(\"Michel Foucault\", 0, 4),\n    ];\n\n    let handles: Vec<_> = philosophers\n        .into_iter()\n        .map(|p| {\n            let table = Arc::clone(&table);\n\n            thread::spawn(move || {\n                p.eat(&table);\n            })\n        })\n        .collect();\n\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "path": "tasks/dining-philosophers",
    "remote_code": "use std::thread;\nuse std::sync::{Mutex, Arc};\n\nstruct Philosopher {\n    name: String,\n    left: usize,\n    right: usize,\n}\n\nimpl Philosopher {\n    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n        Philosopher {\n            name: name.to_string(),\n            left: left,\n            right: right,\n        }\n    }\n\n    fn eat(&self, table: &Table) {\n        let _left = table.forks[self.left].lock().unwrap();\n        let _right = table.forks[self.right].lock().unwrap();\n\n        println!(\"{} is eating.\", self.name);\n\n        thread::sleep_ms(1000);\n\n        println!(\"{} is done eating.\", self.name);\n    }\n}\n\nstruct Table {\n    forks: Vec<Mutex<()>>,\n}\n\nfn main() {\n    let table = Arc::new(Table { forks: vec![\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n    ]});\n\n    let philosophers = vec![\n        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n        Philosopher::new(\"Karl Marx\", 2, 3),\n        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n        Philosopher::new(\"Michel Foucault\", 0, 4),\n    ];\n\n    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n        let table = table.clone();\n\n        thread::spawn(move || {\n            p.eat(&table);\n        })\n    }).collect();\n\n    for h in handles {\n        h.join().unwrap();\n    }\n}",
    "title": "Dining philosophers",
    "url": "http://rosettacode.org/wiki/Dining_philosophers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Disarium numbers",
    "url": "http://rosettacode.org/wiki/Disarium_numbers"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nconst SEASONS: [&str; 5] = [\n    \"Chaos\",\n    \"Discord\",\n    \"Confusion\",\n    \"Bureaucracy\",\n    \"The Aftermath\",\n];\nconst WEEKDAYS: [&str; 5] = [\n    \"Sweetmorn\",\n    \"Boomtime\",\n    \"Pungenday\",\n    \"Prickle-Prickle\",\n    \"Setting Orange\",\n];\nconst YEAR_OFFSET: i32 = 1166;\n\nfn discordian_day(day: usize, leap: bool) -> String {\n    if day == 59 && leap {\n        return String::from(\"St. Tib's Day\");\n    }\n    let offset = if day > 59 && leap { 1 } else { 0 };\n    let day_off = day - offset;\n    let day_num = day_off % 73 + 1;\n    let season = SEASONS[day_off / 73];\n    let weekday = WEEKDAYS[day_off % 5];\n    format!(\"{}, {} {}\", weekday, season, day_num)\n}\n\nfn discordian_date<T: Datelike>(date: &T) -> String {\n    let dday = discordian_day(date.ordinal0() as usize, is_leap_year(date.year()));\n    let year = date.year() + YEAR_OFFSET;\n    format!(\"{}, YOLD {}\", dday, year)\n}\n\n// implementation from https://en.wikipedia.org/wiki/Leap_year#Algorithm\n#[allow(clippy::if_same_then_else)]\n#[allow(clippy::needless_bool)]\nfn is_leap_year(year: i32) -> bool {\n    if year % 4 != 0 {\n        false\n    } else if year % 100 != 0 {\n        true\n    } else if year % 400 != 0 {\n        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    // sample date\n    let utc = Utc::now();\n    println!(\"{} in the Discordian Calendar is:\", utc);\n    println!(\"{}\", discordian_date(&utc));\n    let local: DateTime<Local> = Local::now();\n    println!(\"{} in the Discordian Calendar is:\", local);\n    println!(\"{}\", discordian_date(&local));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::discordian_date;\n    use chrono::*;\n\n    #[test]\n    fn curse_of_greyface_test() {\n        let dt = Utc.ymd(-1166, 1, 1);\n        assert_eq!(\"Sweetmorn, Chaos 1, YOLD 0\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn before_leap_day_test() {\n        let dt = Utc.ymd(2016, 2, 28);\n        assert_eq!(\"Prickle-Prickle, Chaos 59, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn leap_day_test() {\n        let dt = Utc.ymd(2016, 2, 29);\n        assert_eq!(\"St. Tib's Day, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn after_leap_day_test() {\n        let dt = Utc.ymd(2016, 3, 1);\n        assert_eq!(\"Setting Orange, Chaos 60, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn before_not_leap_day_test() {\n        let dt = Utc.ymd(2015, 2, 28);\n        assert_eq!(\"Prickle-Prickle, Chaos 59, YOLD 3181\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn not_leap_day_test() {\n        let dt = Utc.ymd(2015, 3, 1);\n        assert_eq!(\"Setting Orange, Chaos 60, YOLD 3181\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn birthday_test() {\n        let dt = Utc.ymd(1994, 5, 14);\n        assert_eq!(\n            \"Prickle-Prickle, Discord 61, YOLD 3160\",\n            discordian_date(&dt)\n        );\n    }\n\n    #[test]\n    fn magna_carta_test() {\n        let dt = Utc.ymd(1215, 6, 15);\n        assert_eq!(\"Sweetmorn, Confusion 20, YOLD 2381\", discordian_date(&dt));\n    }\n}\n",
    "path": "tasks/discordian-date",
    "remote_code": "extern crate chrono;\n\nuse chrono::NaiveDate;\nuse std::str::FromStr;\n\nfn main() {\n    let date = std::env::args().nth(1).expect(\"Please provide a YYYY-MM-DD date.\");\n    println!(\"{} is {}\", date, NaiveDate::from_str(&date).unwrap().to_poee());\n}\n\n// The necessary constants for the seasons, weekdays, and holydays.\nconst APOSTLES: [&str; 5] = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"];\nconst HOLYDAYS: [&str; 5] = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"];\nconst SEASONS: [&str; 5] = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"];\nconst WEEKDAYS: [&str; 5] = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"];\n\n// The necessary constants for the conversion.\nconst APOSTLE_HOLYDAY: usize = 5;\nconst CURSE_OF_GREYFACE: i32 = 1166;\nconst SEASON_DAYS: usize = 73;\nconst SEASON_HOLYDAY: usize = 50;\nconst ST_TIBS_DAY: usize = 59;\nconst WEEK_DAYS: usize = 5;\n\n// This extends the `Datelike` trait of Rust's Chrono crate with a method that\n// prints any Datelike type as a String.\nimpl<T: Datelike> DiscordianDate for T {}\npub trait DiscordianDate: Datelike {\n    fn to_poee(&self) -> String {\n        let day = self.ordinal0() as usize;\n        let leap = self.year() % 4 == 0 && self.year() % 100 != 0 || self.year() % 400 == 0;\n        let year = self.year() + CURSE_OF_GREYFACE;\n\n        if leap && day == ST_TIBS_DAY { return format!(\"St. Tib's Day, in the YOLD {}\", year); }\n\n        let day_offset = if leap && day > ST_TIBS_DAY { day - 1 } else { day };\n\n        let day_of_season = day_offset % SEASON_DAYS + 1;\n\n        let season = SEASONS[day_offset / SEASON_DAYS];\n        let weekday = WEEKDAYS[day_offset % WEEK_DAYS];\n\n        let holiday = if day_of_season == APOSTLE_HOLYDAY {\n            format!(\"\\nCelebrate {}\", APOSTLES[day_offset / SEASON_DAYS])\n        } else if day_of_season == SEASON_HOLYDAY {\n            format!(\"\\nCelebrate {}\", HOLYDAYS[day_offset / SEASON_DAYS])\n        } else {\n            String::with_capacity(0)\n        };\n\n        format!(\"{}, the {} day of {} in the YOLD {}{}\",\n            weekday, ordinalize(day_of_season), season, year, holiday)\n    }\n}\n\n/// A helper function to ordinalize a numeral.\nfn ordinalize(num: usize) -> String {\n    let s = format!(\"{}\", num);\n\n    let suffix = if s.ends_with('1') && !s.ends_with(\"11\") {\n        \"st\"\n    } else if s.ends_with('2') && !s.ends_with(\"12\") {\n        \"nd\"\n    } else if s.ends_with('3') && !s.ends_with(\"13\") {\n        \"rd\"\n    } else {\n        \"th\"\n    };\n\n    format!(\"{}{}\", s, suffix)\n}\n",
    "title": "Discordian date",
    "url": "http://rosettacode.org/wiki/Discordian_date"
  },
  {
    "local_code": "use std::fmt::{Display, Formatter, Result};\nuse std::process::exit;\n\nstruct Coefficient(usize, f64);\n\nimpl Display for Coefficient {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let i = self.0;\n        let c = self.1;\n\n        if c == 0. {\n            return Ok(());\n        }\n\n        write!(\n            f,\n            \" {} {}e({})\",\n            if c < 0. {\n                \"-\"\n            } else if f.alternate() {\n                \" \"\n            } else {\n                \"+\"\n            },\n            if (c.abs() - 1.).abs() < f64::EPSILON {\n                \"\".to_string()\n            } else {\n                c.abs().to_string() + \"*\"\n            },\n            i + 1\n        )\n    }\n}\n\nfn usage() {\n    println!(\"Usage: display-linear-combination a1 [a2 a3 ...]\");\n}\n\nfn linear_combination(coefficients: &[f64]) -> String {\n    let mut string = String::new();\n\n    let mut iter = coefficients.iter().enumerate();\n\n    // find first nonzero argument\n    loop {\n        match iter.next() {\n            Some((_, &c)) if c == 0. => {\n                continue;\n            }\n            Some((i, &c)) => {\n                string.push_str(format!(\"{:#}\", Coefficient(i, c)).as_str());\n                break;\n            }\n            None => {\n                string.push('0');\n                return string;\n            }\n        }\n    }\n\n    // print subsequent arguments\n    for (i, &c) in iter {\n        string.push_str(format!(\"{}\", Coefficient(i, c)).as_str());\n    }\n\n    string\n}\n\nfn main() {\n    let mut coefficients = Vec::new();\n    let mut args = std::env::args();\n\n    args.next(); // drop first argument\n\n    // parse arguments into floats\n    for arg in args {\n        let c = arg.parse::<f64>().unwrap_or_else(|e| {\n            eprintln!(\"Failed to parse argument \\\"{}\\\": {}\", arg, e);\n            exit(-1);\n        });\n        coefficients.push(c);\n    }\n\n    // no arguments, print usage and exit\n    if coefficients.is_empty() {\n        usage();\n        return;\n    }\n\n    println!(\"{}\", linear_combination(&coefficients));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::linear_combination;\n\n    #[test]\n    fn test01() {\n        assert_eq!(\n            \"   e(1) + 2*e(2) + 3*e(3)\",\n            linear_combination(&[1., 2., 3.])\n        )\n    }\n\n    #[test]\n    fn test02() {\n        assert_eq!(\n            \"   e(2) + 2*e(3) + 3*e(4)\",\n            linear_combination(&[0., 1., 2., 3.])\n        )\n    }\n\n    #[test]\n    fn test03() {\n        assert_eq!(\n            \"   e(1) + 3*e(3) + 4*e(4)\",\n            linear_combination(&[1., 0., 3., 4.])\n        )\n    }\n\n    #[test]\n    fn test04() {\n        assert_eq!(\"   e(1) + 2*e(2)\", linear_combination(&[1., 2., 0.]))\n    }\n\n    #[test]\n    fn test05() {\n        assert_eq!(\"0\", linear_combination(&[0., 0., 0.]))\n    }\n\n    #[test]\n    fn test06() {\n        assert_eq!(\"0\", linear_combination(&[0.]))\n    }\n\n    #[test]\n    fn test07() {\n        assert_eq!(\"   e(1) + e(2) + e(3)\", linear_combination(&[1., 1., 1.]))\n    }\n\n    #[test]\n    fn test08() {\n        assert_eq!(\n            \" - e(1) - e(2) - e(3)\",\n            linear_combination(&[-1., -1., -1.])\n        )\n    }\n\n    #[test]\n    fn test09() {\n        assert_eq!(\n            \" - e(1) - 2*e(2) - 3*e(4)\",\n            linear_combination(&[-1., -2., 0., -3.])\n        )\n    }\n\n    #[test]\n    fn test10() {\n        assert_eq!(\" - e(1)\", linear_combination(&[-1.]))\n    }\n}\n",
    "path": "tasks/display-linear-combination",
    "remote_code": "\nuse std::fmt::{Display, Formatter, Result};\nuse std::process::exit;\n\nstruct Coefficient(usize, f64);\n\nimpl Display for Coefficient {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let i = self.0;\n        let c = self.1;\n\n        if c == 0. {\n            return Ok(());\n        }\n\n        write!(\n            f,\n            \" {} {}e({})\",\n            if c < 0. {\n                \"-\"\n            } else if f.alternate() {\n                \" \"\n            } else {\n                \"+\"\n            },\n            if (c.abs() - 1.).abs() < f64::EPSILON {\n                \"\".to_string()\n            } else {\n                c.abs().to_string() + \"*\"\n            },\n            i + 1\n        )\n    }\n}\n\nfn usage() {\n    println!(\"Usage: display-linear-combination a1 [a2 a3 ...]\");\n}\n\nfn linear_combination(coefficients: &[f64]) -> String {\n    let mut string = String::new();\n\n    let mut iter = coefficients.iter().enumerate();\n\n    // find first nonzero argument\n    loop {\n        match iter.next() {\n            Some((_, &c)) if c == 0. => {\n                continue;\n            }\n            Some((i, &c)) => {\n                string.push_str(format!(\"{:#}\", Coefficient(i, c)).as_str());\n                break;\n            }\n            None => {\n                string.push('0');\n                return string;\n            }\n        }\n    }\n\n    // print subsequent arguments\n    for (i, &c) in iter {\n        string.push_str(format!(\"{}\", Coefficient(i, c)).as_str());\n    }\n\n    string\n}\n\nfn main() {\n    let mut coefficients = Vec::new();\n    let mut args = std::env::args();\n\n    args.next(); // drop first argument\n\n    // parse arguments into floats\n    for arg in args {\n        let c = arg.parse::<f64>().unwrap_or_else(|e| {\n            eprintln!(\"Failed to parse argument \\\"{}\\\": {}\", arg, e);\n            exit(-1);\n        });\n        coefficients.push(c);\n    }\n\n    // no arguments, print usage and exit\n    if coefficients.is_empty() {\n        usage();\n        return;\n    }\n\n    println!(\"{}\", linear_combination(&coefficients));\n}\n",
    "title": "Display a linear combination",
    "url": "http://rosettacode.org/wiki/Display_a_linear_combination"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Display an outline as a nested table",
    "url": "http://rosettacode.org/wiki/Display_an_outline_as_a_nested_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Distributed programming",
    "url": "http://rosettacode.org/wiki/Distributed_programming"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Diversity prediction theorem",
    "url": "http://rosettacode.org/wiki/Diversity_prediction_theorem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Documentation for the module\n//!\n//! **Lorem ipsum** dolor sit amet, consectetur adipiscing elit. Aenean a\n//! sagittis sapien, eu pellentesque ex. Nulla facilisi. Praesent eget sapien\n//! sollicitudin, laoreet ipsum at, fringilla augue. In hac habitasse platea\n//! dictumst. Nunc in neque sed magna suscipit mattis sed quis mi. Curabitur\n//! quis mi a ante mollis commodo. Sed tincidunt ut metus vel accumsan.\n#![doc(html_favicon_url = \"https://example.com/favicon.ico\")]\n#![doc(html_logo_url = \"https://example.com/logo.png\")]\n\n/// Documentation for a constant\npub const THINGY: u32 = 42;\n\n/// Documentation for a Rust `enum` (tagged union)\npub enum Whatsit {\n    /// Documentation for the `Yo` variant\n    Yo(Whatchamabob),\n    /// Documentation for the `HoHo` variant\n    HoHo,\n}\n\n/// Documentation for a data structure\npub struct Whatchamabob {\n    /// Doodads do dad\n    pub doodad: f64,\n    /// Whether or not this is a thingamabob\n    pub thingamabob: bool\n}\n\n/// Documentation for a trait (interface)\npub trait Frobnify {\n    /// `Frobnify` something\n    fn frob(&self);\n}\n\n/// Documentation specific to this struct's implementation of `Frobnify`\nimpl Frobnify for Whatchamabob {\n    /// `Frobnify` the `Whatchamabob`\n    fn frob(&self) {\n        println!(\"Frobbed: {}\", self.doodad);\n    }\n}\n\n/// Documentation for a function\n///\n/// Pellentesque sodales lacus nisi, in malesuada lectus vestibulum eget.\n/// Integer rhoncus imperdiet justo. Pellentesque egestas sem ac\n/// consectetur suscipit. Maecenas tempus dignissim purus, eu tincidunt mi\n/// tincidunt id. Morbi ac laoreet erat, eu ultricies neque. Fusce molestie\n/// urna quis nisl condimentum, sit amet fringilla nunc ornare. Pellentesque\n/// vestibulum ac nibh eu accumsan. In ornare orci at rhoncus finibus. Donec\n/// sed ipsum ex. Pellentesque ante nisl, pharetra id purus auctor, euismod\n/// semper erat. Nunc sit amet eros elit.\npub fn main() {\n    let foo = Whatchamabob{ doodad: 1.2, thingamabob: false };\n    foo.frob();\n}",
    "title": "Documentation",
    "url": "http://rosettacode.org/wiki/Documentation"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Dot_product\nextern crate num;\n\nuse num::traits::Zero;\nuse std::ops::Mul;\n\nfn dotp<T: Zero + Mul<Output = T> + Copy>(this: &[T], other: &[T]) -> T {\n    assert!(this.len() == other.len(), \"The dimensions must be equal\");\n\n    let zero: T = Zero::zero();\n    this.iter()\n        .zip(other.iter())\n        .map(|(&a, &b)| a * b)\n        .fold(zero, |sum, n| sum + n)\n}\n\nfn main() {\n    let a = &[1.0f32, 3.0, -5.0];\n    let b = &[4.0f32, -2.0, -1.0];\n    println!(\"{}\", dotp(a, b));\n}\n\n#[test]\nfn test_dotp() {\n    let result = dotp(&[1i32, 3, -5], &[4i32, -2, -1]);\n    assert_eq!(result, 3);\n}\n",
    "path": "tasks/dot-product",
    "remote_code": "// alternatively, fn dot_product(a: &Vec<u32>, b: &Vec<u32>)\n// but using slices is more general and rustic\nfn dot_product(a: &[i32], b: &[i32]) -> Option<i32> {\n    if a.len() != b.len() { return None }\n    Some(\n        a.iter()\n            .zip( b.iter() )\n            .fold(0, |sum, (el_a, el_b)| sum + el_a*el_b)\n    )\n}\n\n\nfn main() {\n    let v1 = vec![1, 3, -5];\n    let v2 = vec![4, -2, -1];\n\n    println!(\"{}\", dot_product(&v1, &v2).unwrap());\n}",
    "title": "Dot product",
    "url": "http://rosettacode.org/wiki/Dot_product"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Doubly-linked list/Definition",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Definition"
  },
  {
    "local_code": "//! Doubly linked lists present a problem in Rust due to its ownership model. There cannot be two\n//! mutable references to the same object, so what are we to do? Below are the relevant lines (with\n//! added comments) from the `std` implementation ([Documentation][doc] [Source][src]).\n//!\n//! In order to circumvent the multiple mutable references, raw C-like pointers are used. Note that\n//! these cannot be dereferenced with guaranteed safety and thus dereferencing is relegated to\n//! `unsafe {}` blocks.\n//!\n//! [doc]: https://doc.rust-lang.org/std/collections/struct.LinkedList.html\n//! [src]: https://github.com/rust-lang/rust/blob/master/src/libcollections/linked_list.rs\n\n#![allow(dead_code)]\n\nuse std::ptr;\n\n/// User-facing implementation\npub struct LinkedList<T> {\n    length: usize,\n    list_head: Link<T>,\n    list_tail: Rawlink<Node<T>>,\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> LinkedList<T> {\n        LinkedList {\n            length: 0,\n            list_head: None,\n            list_tail: Rawlink { p: ptr::null_mut() },\n        }\n    }\n}\n\nimpl<T> Default for LinkedList<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Type definition\ntype Link<T> = Option<Box<Node<T>>>;\n\n/// Pointer is wrapped in struct so that Option-like methods can be added to it later (wrappers\n/// around NULL checks)\nstruct Rawlink<T> {\n    /// Raw mutable pointer\n    p: *mut T,\n}\n\nstruct Node<T> {\n    next: Link<T>,\n    prev: Rawlink<Node<T>>,\n    value: T,\n}\n\nfn main() {\n    // Note: you can just import the standard definition.\n    use std::collections;\n\n    // Doubly linked list containing 32-bit integers\n    let list1 = collections::LinkedList::<i32>::new();\n\n    // Doubly linked list containing 32-bit integers\n    let list2 = self::LinkedList::<i32>::new();\n\n    drop(list1);\n    drop(list2);\n}\n",
    "path": "tasks/doubly-linked-list/element-definition",
    "remote_code": "use std::collections::LinkedList;\nfn main() {\n     // Doubly linked list containing 32-bit integers\n     let list = LinkedList::<i32>::new();\n}",
    "title": "Doubly-linked list/Element definition",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Element_definition"
  },
  {
    "local_code": "//! This expands upon the implementation defined on [Rosetta Code][element definition] and consists\n//! of the relevant lines from the `LinkedList` implementation in the Rust standard library.\n//!\n//! [element definition]: http://rosettacode.org/wiki/Doubly-linked_list/Element_definition\n\n#![allow(dead_code)]\n\nuse std::mem;\nuse std::ptr;\n\npub struct LinkedList<T> {\n    length: usize,\n    list_head: Link<T>,\n    list_tail: Rawlink<Node<T>>,\n}\n\ntype Link<T> = Option<Box<Node<T>>>;\n\nstruct Rawlink<T> {\n    p: *mut T,\n}\n\nstruct Node<T> {\n    next: Link<T>,\n    prev: Rawlink<Node<T>>,\n    value: T,\n}\n\nimpl<T> Node<T> {\n    fn new(v: T) -> Node<T> {\n        Node {\n            value: v,\n            next: None,\n            prev: Rawlink::none(),\n        }\n    }\n}\n\nimpl<T> Rawlink<T> {\n    fn none() -> Self {\n        Rawlink { p: ptr::null_mut() }\n    }\n\n    fn some(n: &mut T) -> Rawlink<T> {\n        Rawlink { p: n }\n    }\n}\n\nimpl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n    fn from(node: &'a mut Link<T>) -> Self {\n        match node.as_mut() {\n            None => Rawlink::none(),\n            Some(ptr) => Rawlink::some(ptr),\n        }\n    }\n}\n\nfn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {\n    next.prev = Rawlink::none();\n    Some(next)\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> LinkedList<T> {\n        LinkedList {\n            length: 0,\n            list_head: None,\n            list_tail: Rawlink { p: ptr::null_mut() },\n        }\n    }\n\n    #[inline]\n    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n        match self.list_head {\n            None => {\n                self.list_head = link_no_prev(new_head);\n                self.list_tail = Rawlink::from(&mut self.list_head);\n            }\n            Some(ref mut head) => {\n                new_head.prev = Rawlink::none();\n                head.prev = Rawlink::some(&mut *new_head);\n                mem::swap(head, &mut new_head);\n                head.next = Some(new_head);\n            }\n        }\n        self.length += 1;\n    }\n    pub fn push_front(&mut self, elt: T) {\n        self.push_front_node(Box::new(Node::new(elt)));\n    }\n}\n\nimpl<T> Default for LinkedList<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    use std::collections;\n    let mut list1 = collections::LinkedList::new();\n    list1.push_front(8);\n\n    let mut list2 = LinkedList::new();\n    list2.push_front(8);\n}\n",
    "path": "tasks/doubly-linked-list/element-insertion",
    "remote_code": "use std::collections::LinkedList;\nfn main() {\n    let mut list = LinkedList::new();\n    list.push_front(8);\n}",
    "title": "Doubly-linked list/Element insertion",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Doubly-linked list/Traversal",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Traversal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse ggez::{\n    conf::{WindowMode, WindowSetup},\n    error::GameResult,\n    event,\n    graphics::{clear, draw, present, Color, MeshBuilder},\n    nalgebra::Point2,\n    Context,\n};\nuse std::time::Duration;\n\n// L-System to create the sequence needed for a Dragon Curve.\n// This function creates the next generation given the current one\n// L-System from https://www.cs.unm.edu/~joel/PaperFoldingFractal/L-system-rules.html\n//\nfn l_system_next_generation(current_generation: &str) -> String {\n    let f_rule = \"f-h\";\n    let h_rule = \"f+h\";\n    let mut next_gen = String::new();\n    for char in current_generation.chars() {\n        match char {\n            'f' => next_gen.push_str(f_rule),\n            'h' => next_gen.push_str(h_rule),\n            '-' | '+' => next_gen.push(char),\n            _ => panic!(\"Unknown char {}\", char),\n        }\n    }\n    next_gen\n}\n\n// The rest of the code is for drawing the output and is specific to using the\n// ggez 2d game library: https://ggez.rs/\n\nconst WINDOW_WIDTH: f32 = 700.0;\nconst WINDOW_HEIGHT: f32 = 700.0;\nconst START_X: f32 = WINDOW_WIDTH / 6.0;\nconst START_Y: f32 = WINDOW_HEIGHT / 6.0;\nconst MAX_DEPTH: i32 = 15;\nconst LINE_LENGTH: f32 = 20.0;\n\nstruct MainState {\n    start_gen: String,\n    next_gen: String,\n    line_length: f32,\n    max_depth: i32,\n    current_depth: i32,\n}\n\nimpl MainState {\n    fn new() -> GameResult<MainState> {\n        let start_gen = \"f\";\n        let next_gen = String::new();\n        let line_length = LINE_LENGTH;\n        let max_depth = MAX_DEPTH;\n        let current_depth = 0;\n        Ok(MainState {\n            start_gen: start_gen.to_string(),\n            next_gen,\n            line_length,\n            max_depth,\n            current_depth,\n        })\n    }\n}\n\nimpl event::EventHandler for MainState {\n    // In each repetition of the event loop a new generation of the L-System\n    // is generated and drawn, until the maximum depth is reached.\n    // Each time the line length is reduced so that the overall dragon curve\n    // can be seen in the window as it spirals and gets bigger.\n    // The update sleeps for 0.5 seconds just so that its pogression can be watched.\n    //\n    fn update(&mut self, _ctx: &mut Context) -> GameResult {\n        if self.current_depth < self.max_depth {\n            self.next_gen = l_system_next_generation(&self.start_gen);\n            self.start_gen = self.next_gen.clone();\n            self.line_length -= (self.line_length / self.max_depth as f32) * 1.9;\n            self.current_depth += 1;\n        }\n        ggez::timer::sleep(Duration::from_millis(500));\n        Ok(())\n    }\n\n    fn draw(&mut self, ctx: &mut Context) -> GameResult {\n        let grey = Color::from_rgb(77, 77, 77);\n        let blue = Color::from_rgb(51, 153, 255);\n        let initial_point_blue = Point2::new(START_X, START_Y);\n        clear(ctx, grey);\n        draw_lines(\n            &self.next_gen,\n            ctx,\n            self.line_length,\n            blue,\n            initial_point_blue,\n        )?;\n        present(ctx)?;\n        Ok(())\n    }\n}\n\nfn next_point(current_point: Point2<f32>, heading: f32, line_length: f32) -> Point2<f32> {\n    let next_point = (\n        (current_point.x + (line_length * heading.to_radians().cos().trunc() as f32)),\n        (current_point.y + (line_length * heading.to_radians().sin().trunc() as f32)),\n    );\n    Point2::new(next_point.0, next_point.1)\n}\n\nfn draw_lines(\n    instructions: &str,\n    ctx: &mut Context,\n    line_length: f32,\n    colour: Color,\n    initial_point: Point2<f32>,\n) -> GameResult {\n    let line_width = 2.0;\n    let mut heading = 0.0;\n    let turn_angle = 90.0;\n    let mut start_point = initial_point;\n    let mut line_builder = MeshBuilder::new();\n    for char in instructions.chars() {\n        let end_point = next_point(start_point, heading, line_length);\n        match char {\n            'f' | 'h' => {\n                line_builder.line(&[start_point, end_point], line_width, colour)?;\n                start_point = end_point;\n            }\n            '+' => heading += turn_angle,\n            '-' => heading -= turn_angle,\n            _ => panic!(\"Unknown char {}\", char),\n        }\n    }\n    let lines = line_builder.build(ctx)?;\n    draw(ctx, &lines, (initial_point,))?;\n    Ok(())\n}\n\nfn main() -> GameResult {\n    let cb = ggez::ContextBuilder::new(\"dragon curve\", \"huw\")\n        .window_setup(WindowSetup::default().title(\"Dragon curve\"))\n        .window_mode(WindowMode::default().dimensions(WINDOW_WIDTH, WINDOW_HEIGHT));\n    let (ctx, event_loop) = &mut cb.build()?;\n    let state = &mut MainState::new()?;\n    event::run(ctx, event_loop, state)\n}\n",
    "title": "Dragon curve",
    "url": "http://rosettacode.org/wiki/Dragon_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// cargo-deps: time=\"0.1\"\nextern crate time;\n\nuse std::thread;\nuse std::time::Duration;\n\nconst TOP: &str = \" ⡎⢉⢵ ⠀⢺⠀ ⠊⠉⡱ ⠊⣉⡱ ⢀⠔⡇ ⣏⣉⡉ ⣎⣉⡁ ⠊⢉⠝ ⢎⣉⡱ ⡎⠉⢱ ⠀⠶⠀\";\nconst BOT: &str = \" ⢗⣁⡸ ⢀⣸⣀ ⣔⣉⣀ ⢄⣀⡸ ⠉⠉⡏ ⢄⣀⡸ ⢇⣀⡸ ⢰⠁⠀ ⢇⣀⡸ ⢈⣉⡹ ⠀⠶⠀\";\n\nfn main() {\n    let top: Vec<&str> = TOP.split_whitespace().collect();\n    let bot: Vec<&str> = BOT.split_whitespace().collect();\n\n    loop {\n        let tm = &time::now().rfc822().to_string()[17..25];\n        let top_str: String = tm.chars().map(|x| top[x as usize - '0' as usize]).collect();\n        let bot_str: String = tm.chars().map(|x| bot[x as usize - '0' as usize]).collect();\n\n        clear_screen();\n        println!(\"{}\", top_str);\n        println!(\"{}\", bot_str);\n\n        thread::sleep(Duration::from_secs(1));\n    }\n}\n\nfn clear_screen() {\n    println!(\"{}[H{}[J\", 27 as char, 27 as char);\n}",
    "title": "Draw a clock",
    "url": "http://rosettacode.org/wiki/Draw_a_clock"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Draw a cuboid",
    "url": "http://rosettacode.org/wiki/Draw_a_cuboid"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate piston_window;\nextern crate image;\n\nuse piston_window::*;\n\nfn main() {\n    let (width, height) = (320, 240);\n    \n    let mut window: PistonWindow =\n        WindowSettings::new(\"Red Pixel\", [width, height])\n        .exit_on_esc(true).build().unwrap();\n\n    // Since we cant manipulate pixels directly, we need to manipulate the pixels on a canvas.\n    // Only issue is that sub-pixels exist (which is probably why the red pixel looks like a smear on the output image)\n    let mut canvas = image::ImageBuffer::new(width, height);\n    canvas.put_pixel(100, 100, image::Rgba([0xff, 0, 0, 0xff]));\n\n    // Transform into a texture so piston can use it.\n    let texture: G2dTexture = Texture::from_image(\n        &mut window.factory,\n        &canvas,\n        &TextureSettings::new()\n    ).unwrap();\n\n    // The window event loop.\n    while let Some(event) = window.next() {\n        window.draw_2d(&event, |context, graphics| {\n            clear([1.0; 4], graphics);\n            image(&texture,\n            context.transform,\n            graphics);\n        });\n    }\n}\n",
    "title": "Draw a pixel",
    "url": "http://rosettacode.org/wiki/Draw_a_pixel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Draw a rotating cube",
    "url": "http://rosettacode.org/wiki/Draw_a_rotating_cube"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// image = \"0.23\"\n\nuse image::{GrayImage, Luma};\n\ntype Vector = [f64; 3];\n\nfn normalize(v: &mut Vector) {\n    let inv_len = 1.0/dot_product(v, v).sqrt();\n    v[0] *= inv_len;\n    v[1] *= inv_len;\n    v[2] *= inv_len;\n}\n\nfn dot_product(v1: &Vector, v2: &Vector) -> f64 {\n    v1.iter().zip(v2.iter()).map(|(x, y)| *x * *y).sum()\n}\n\nfn draw_sphere(radius: u32, k: f64, ambient: f64, dir: &Vector) -> GrayImage {\n    let width = radius * 4;\n    let height = radius * 3;\n    let mut image = GrayImage::new(width, height);\n    let mut vec = [0.0; 3];\n    let diameter = radius * 2;\n    let r = radius as f64;\n    let xoffset = (width - diameter)/2;\n    let yoffset = (height - diameter)/2;\n    for i in 0..diameter {\n        let x = i as f64 - r;\n        for j in 0..diameter {\n            let y = j as f64 - r;\n            let z = r * r - x * x - y * y;\n            if z >= 0.0 {\n                vec[0] = x;\n                vec[1] = y;\n                vec[2] = z.sqrt();\n                normalize(&mut vec);\n                let mut s = dot_product(&dir, &vec);\n                if s < 0.0 {\n                    s = 0.0;\n                }\n                let mut lum = 255.0 * (s.powf(k) + ambient)/(1.0 + ambient);\n                if lum < 0.0 {\n                    lum = 0.0;\n                } else if lum > 255.0 {\n                    lum = 255.0;\n                }\n                image.put_pixel(i + xoffset, j + yoffset, Luma([lum as u8]));\n            }\n        }\n    }\n    image\n}\n\nfn main() {\n    let mut dir = [-30.0, -30.0, 50.0];\n    normalize(&mut dir);\n    match draw_sphere(200, 1.5, 0.2, &dir).save(\"sphere.png\") {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"{}\", error),\n    }\n}",
    "title": "Draw a sphere",
    "url": "http://rosettacode.org/wiki/Draw_a_sphere"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Duffinian numbers",
    "url": "http://rosettacode.org/wiki/Duffinian_numbers"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\n// if you use an enum you will have to implement a lot of traits for it before you can\n// iterate and sort it my proposal is to just use u8 and image a C like enum thus\n// 0 = red\n// 1 = white\n// 2 = blue\n//\n// look up table\nconst COLOR: &[&str] = &[\"Red\", \"White\", \"Blue\"];\n\nfn check_sorted(color_array: &[u8]) -> bool {\n    let mut test_color = 0;\n    for color in color_array {\n        if *color < test_color {\n            return false;\n        }\n        test_color = *color;\n    }\n    true\n}\n\nfn color_to_string(color_array: &[u8]) -> String {\n    color_array\n        .iter()\n        .fold(\"\".to_string(), |string, &x| string + COLOR[x as usize])\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut color_array = [0u8; 20];\n\n    for color in &mut color_array {\n        *color = rng.gen_range(0, 3);\n    }\n\n    if check_sorted(&color_array) {\n        println!(\n            \"oops i generated a sorted array {}\",\n            color_to_string(&color_array)\n        );\n    } else {\n        println!(\"random flag {}\", color_to_string(&color_array));\n    }\n\n    color_array.sort_unstable();\n    println!(\"a dutch flag {}\", color_to_string(&color_array));\n}\n\n#[test]\nfn test_dutch_national_flag() {\n    let flag_array = [0, 1, 2];\n    assert_eq!(true, check_sorted(&flag_array));\n\n    let mut color_array = [2, 0, 1];\n    assert_eq!(false, check_sorted(&color_array));\n    color_array.sort_unstable();\n    assert_eq!(flag_array, color_array);\n}\n",
    "path": "tasks/dutch-national-flag-problem",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\n// Color enums will be sorted by their top-to-bottom declaration order\n#[derive(Eq,Ord,PartialOrd,PartialEq,Debug)]\nenum Color {\n    Red,\n    White,\n    Blue\n}\n\nfn is_sorted(list: &Vec<Color>) -> bool {\n    let mut state = &Color::Red;\n    for current in list.iter() {\n        if current < state { return false; }\n        if current > state { state = current; }\n    }\n    true\n}\n\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut colors: Vec<Color> = Vec::new();\n\n    for _ in 1..10 {\n        let r = rng.gen_range(0, 3);\n        if      r == 0 { colors.push(Color::Red); }\n        else if r == 1 { colors.push(Color::White); }\n        else if r == 2 { colors.push(Color::Blue); }\n    }\n\n    while is_sorted(&colors) {\n        rng.shuffle(&mut colors);\n    }\n\n    println!(\"Before: {:?}\", colors);\n    colors.sort();\n    println!(\"After:  {:?}\", colors);\n    if !is_sorted(&colors) {\n        println!(\"Oops, did not sort colors correctly!\");\n    }\n}",
    "title": "Dutch national flag problem",
    "url": "http://rosettacode.org/wiki/Dutch_national_flag_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Dynamic variable names",
    "url": "http://rosettacode.org/wiki/Dynamic_variable_names"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "EKG sequence convergence",
    "url": "http://rosettacode.org/wiki/EKG_sequence_convergence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n\nfn main() {\n    use std::collections::HashMap;\n\n    let mut primes = primal::Primes::all();\n    let mut last_prime = primes.next().unwrap();\n    let mut gap_starts = HashMap::new();\n\n    let mut find_gap_start = move |gap: usize| -> usize {\n        if let Some(start) = gap_starts.get(&gap) {\n            return *start;\n        }\n        loop {\n            let prev = last_prime;\n            last_prime = primes.next().unwrap();\n            let diff = last_prime - prev;\n            if !gap_starts.contains_key(&diff) {\n                gap_starts.insert(diff, prev);\n            }\n            if gap == diff {\n                return prev;\n            }\n        }\n    };\n\n    let limit = 100000000000;\n\n    let mut pm = 10;\n    let mut gap1 = 2;\n    loop {\n        let start1 = find_gap_start(gap1);\n        let gap2 = gap1 + 2;\n        let start2 = find_gap_start(gap2);\n        let diff = if start2 > start1 {\n            start2 - start1\n        } else {\n            start1 - start2\n        };\n        if diff > pm {\n            println!(\n                \"Earliest difference > {} between adjacent prime gap starting primes:\\n\\\n                Gap {} starts at {}, gap {} starts at {}, difference is {}.\\n\",\n                pm, gap1, start1, gap2, start2, diff\n            );\n            if pm == limit {\n                break;\n            }\n            pm *= 10;\n        } else {\n            gap1 = gap2;\n        }\n    }\n}",
    "title": "Earliest difference between prime gaps",
    "url": "http://rosettacode.org/wiki/Earliest_difference_between_prime_gaps"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Eban numbers",
    "url": "http://rosettacode.org/wiki/Eban_numbers"
  },
  {
    "local_code": "use std::io::{self, BufRead, BufReader, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\n\n// The actual echo server\nfn echo_server(host: &'static str, port: u16) -> io::Result<()> {\n    // Create a new TCP listener at host:port.\n    let listener = TcpListener::bind((host, port))?;\n    println!(\"Starting echo server on {:?}\", listener.local_addr());\n\n    // Process each new connection to the server\n    for stream in listener.incoming() {\n        match stream {\n            Err(e) => println!(\"Connection failed: {}\", e),\n            Ok(stream) => {\n                let addr = stream.peer_addr()?;\n                println!(\"New connection: {}\", addr);\n                // Launch a new thread to deal with the connection.\n                thread::spawn(move || {\n                    if let Err(e) = echo_session(stream) {\n                        println!(\"I/O error: {} -- {}\", addr, e);\n                    }\n                    println!(\"Closing connection: {}\", addr);\n                });\n            }\n        }\n    }\n    Ok(())\n    // Server closes automatically at end of block\n}\n\n// Each connection gets its own session.\nfn echo_session(stream: TcpStream) -> io::Result<()> {\n    let addr = stream.peer_addr()?;\n    let mut writer = stream.try_clone().unwrap();\n    let reader = BufReader::new(stream);\n    for line in reader.lines() {\n        let line = line?;\n        println!(\"Received line from {}: {}\", addr, line);\n        writer.write_all(line.as_bytes())?;\n        println!(\"Wrote line to {}: {}\", addr, line);\n    }\n    Ok(())\n}\n\nconst HOST: &str = \"127.0.0.1\";\n#[allow(clippy::unreadable_literal)]\nconst PORT: u16 = 12321;\n\npub fn main() {\n    echo_server(HOST, PORT).unwrap();\n}\n",
    "path": "tasks/echo-server",
    "remote_code": "\nuse std::net::{TcpListener, TcpStream};\nuse std::io::{BufReader, BufRead, Write};\nuse std::thread;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:12321\").unwrap();\n    println!(\"server is running on 127.0.0.1:12321 ...\");\n    \n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        thread::spawn(move || handle_client(stream));\n    }\n}\n\nfn handle_client(stream: TcpStream) {\n    let mut stream = BufReader::new(stream);\n    loop {\n        let mut buf = String::new();\n        if stream.read_line(&mut buf).is_err() {\n            break;\n        }\n        stream\n            .get_ref()\n            .write(buf.as_bytes())\n            .unwrap();\n    }\n}\n",
    "title": "Echo server",
    "url": "http://rosettacode.org/wiki/Echo_server"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Eertree",
    "url": "http://rosettacode.org/wiki/Eertree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn egyptian_divide(dividend: u32, divisor: u32) -> (u32, u32) {\n    let dividend = dividend as u64;\n    let divisor = divisor as u64;\n    \n    let pows = (0..32).map(|p| 1 << p);\n    let doublings = (0..32).map(|p| divisor << p);\n    \n    let (answer, sum) = doublings\n        .zip(pows)\n        .rev()\n        .skip_while(|(i, _)| i > &dividend )\n        .fold((0, 0), |(answer, sum), (double, power)| {\n            if sum + double < dividend {\n                (answer + power, sum + double)\n            } else {\n                (answer, sum)\n            }\n        });\n    \n    (answer as u32, (dividend - sum) as u32)\n}\n\nfn main() {\n    let (div, rem) = egyptian_divide(580, 34);\n    println!(\"580 divided by 34 is {} remainder {}\", div, rem);\n}",
    "title": "Egyptian division",
    "url": "http://rosettacode.org/wiki/Egyptian_division"
  },
  {
    "local_code": "use num_bigint::BigInt;\nuse num_integer::Integer;\nuse num_traits::{One, Zero};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\nstruct Rational {\n    nominator: BigInt,\n    denominator: BigInt,\n}\n\nimpl Rational {\n    fn new(n: &BigInt, d: &BigInt) -> Rational {\n        assert!(!d.is_zero(), \"denominator cannot be 0\");\n        // simplify if possible\n        let c = n.gcd(d);\n        Rational {\n            nominator: n / &c,\n            denominator: d / &c,\n        }\n    }\n\n    fn is_proper(&self) -> bool {\n        self.nominator < self.denominator\n    }\n    fn to_egyptian(&self) -> Vec<Rational> {\n        let mut frac: Vec<Rational> = Vec::new();\n\n        let mut current = if !self.is_proper() {\n            // input is grater than 1\n            // store the integer part\n            frac.push(Rational::new(\n                &self.nominator.div_floor(&self.denominator),\n                &One::one(),\n            ));\n\n            // calculate the remainder\n            Rational::new(\n                &self.nominator.mod_floor(&self.denominator),\n                &self.denominator,\n            )\n        } else {\n            self.clone()\n        };\n\n        while !current.nominator.is_one() {\n            let div = current.denominator.div_ceil(&current.nominator);\n\n            // store the term\n            frac.push(Rational::new(&One::one(), &div));\n\n            current = Rational::new(\n                &(-&current.denominator).mod_floor(&current.nominator),\n                match current.denominator.checked_mul(&div).as_ref() {\n                    Some(r) => r,\n                    _ => break,\n                },\n            );\n        }\n\n        frac.push(current);\n        frac\n    }\n}\n\nimpl fmt::Display for Rational {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.denominator.is_one() {\n            // for integers only display the integer part\n            write!(f, \"{}\", self.nominator)\n        } else {\n            write!(f, \"{}/{}\", self.nominator, self.denominator)\n        }\n    }\n}\n\nfn rational_vec_to_string(vec: Vec<Rational>) -> String {\n    let mut p = vec\n        .iter()\n        .fold(String::new(), |acc, num| (acc + &num.to_string() + \", \"));\n\n    if p.len() > 1 {\n        p.truncate(p.len() - 2);\n    }\n    format!(\"[{}]\", p)\n}\n\nfn run_max_searches(x: usize) {\n    // generate all proper fractions with 2 digits\n    let pairs = (1..x).flat_map(move |i| (i + 1..x).map(move |j| (i, j)));\n\n    let mut max_length = (0, Rational::new(&BigInt::from(1), &BigInt::from(1)));\n    let mut max_denom = (\n        Zero::zero(),\n        Rational::new(&BigInt::from(1), &BigInt::from(1)),\n    );\n\n    for (i, j) in pairs {\n        let e = Rational::new(&BigInt::from(i), &BigInt::from(j)).to_egyptian();\n        if e.len() > max_length.0 {\n            max_length = (e.len(), Rational::new(&BigInt::from(i), &BigInt::from(j)));\n        }\n\n        if e.last().unwrap().denominator > max_denom.0 {\n            max_denom = (\n                e.last().unwrap().denominator.clone(),\n                Rational::new(&BigInt::from(i), &BigInt::from(j)),\n            );\n        }\n    }\n\n    println!(\n        \"Maximum length of terms is for {} with {} terms\",\n        max_length.1, max_length.0\n    );\n    println!(\"{}\", rational_vec_to_string(max_length.1.to_egyptian()));\n\n    println!(\n        \"Maximum denominator is for {} with {} terms\",\n        max_denom.1, max_denom.0\n    );\n    println!(\"{}\", rational_vec_to_string(max_denom.1.to_egyptian()));\n}\nfn main() {\n    let tests = [\n        Rational::new(&BigInt::from(43), &BigInt::from(48)),\n        Rational::new(&BigInt::from(5), &BigInt::from(121)),\n        Rational::new(&BigInt::from(2014), &BigInt::from(59)),\n    ];\n\n    for test in tests.iter() {\n        println!(\"{} -> {}\", test, rational_vec_to_string(test.to_egyptian()));\n    }\n\n    run_max_searches(100);\n    run_max_searches(1000);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Rational;\n    use num_bigint::BigInt;\n\n    #[test]\n    fn test_egyptian() {\n        // case: 1/2 -> 1.2\n        let e = Rational::new(&BigInt::from(1), &BigInt::from(2));\n        println!(\"{}\", e);\n        assert_eq!(\n            e.to_egyptian(),\n            vec![Rational::new(&BigInt::from(1), &BigInt::from(2)),]\n        );\n\n        // case: 5/6 -> 1/2 + 1/3\n        let e = Rational::new(&BigInt::from(5), &BigInt::from(6));\n        println!(\"{}\", e);\n        assert_eq!(\n            e.to_egyptian(),\n            vec![\n                Rational::new(&BigInt::from(1), &BigInt::from(2)),\n                Rational::new(&BigInt::from(1), &BigInt::from(3)),\n            ]\n        );\n\n        // case 3/2 (improper fraction) -> 1 + 1/2\n        let e = Rational::new(&BigInt::from(3), &BigInt::from(2));\n        println!(\"{}\", e);\n        assert_eq!(\n            e.to_egyptian(),\n            vec![\n                Rational::new(&BigInt::from(1), &BigInt::from(1)),\n                Rational::new(&BigInt::from(1), &BigInt::from(2)),\n            ]\n        );\n\n        // case 43/48 -> 1/2 + 1/3 + /16\n        let e = Rational::new(&BigInt::from(43), &BigInt::from(48));\n        println!(\"{}\", e);\n        assert_eq!(\n            e.to_egyptian(),\n            vec![\n                Rational::new(&BigInt::from(1), &BigInt::from(2)),\n                Rational::new(&BigInt::from(1), &BigInt::from(3)),\n                Rational::new(&BigInt::from(1), &BigInt::from(16)),\n            ]\n        );\n    }\n\n    #[test]\n    #[should_panic]\n    fn zero_denominator() {\n        let e = Rational::new(&BigInt::from(1), &BigInt::from(0));\n        println!(\"{}\", e);\n    }\n}\n",
    "path": "tasks/egyptian-fractions",
    "remote_code": "\nuse num_bigint::BigInt;\nuse num_integer::Integer;\nuse num_traits::{One, Zero};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\nstruct Rational {\n    nominator: BigInt,\n    denominator: BigInt,\n}\n\nimpl Rational {\n    fn new(n: &BigInt, d: &BigInt) -> Rational {\n        assert!(!d.is_zero(), \"denominator cannot be 0\");\n        // simplify if possible\n        let c = n.gcd(d);\n        Rational {\n            nominator: n / &c,\n            denominator: d / &c,\n        }\n    }\n\n    fn is_proper(&self) -> bool {\n        self.nominator < self.denominator\n    }\n    fn to_egyptian(&self) -> Vec<Rational> {\n        let mut frac: Vec<Rational> = Vec::new();\n\n        let mut current: Rational;\n        if !self.is_proper() {\n            // input is grater than 1\n            // store the integer part\n            frac.push(Rational::new(\n                &self.nominator.div_floor(&self.denominator),\n                &One::one(),\n            ));\n\n            // calculate the remainder\n            current = Rational::new(\n                &self.nominator.mod_floor(&self.denominator),\n                &self.denominator,\n            );\n        } else {\n            current = self.clone();\n        }\n\n        while !current.nominator.is_one() {\n            let div = current.denominator.div_ceil(&current.nominator);\n\n            // store the term\n            frac.push(Rational::new(&One::one(), &div));\n\n            current = Rational::new(\n                &(-&current.denominator).mod_floor(&current.nominator),\n                match current.denominator.checked_mul(&div).as_ref() {\n                    Some(r) => r,\n                    _ => break,\n                },\n            );\n        }\n\n        frac.push(current);\n        frac\n    }\n}\n\nimpl fmt::Display for Rational {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.denominator.is_one() {\n            // for integers only display the integer part\n            write!(f, \"{}\", self.nominator)\n        } else {\n            write!(f, \"{}/{}\", self.nominator, self.denominator)\n        }\n    }\n}\n\nfn rational_vec_to_string(vec: Vec<Rational>) -> String {\n    let mut p = vec\n        .iter()\n        .fold(String::new(), |acc, num| (acc + &num.to_string() + \", \"));\n\n    if p.len() > 1 {\n        p.truncate(p.len() - 2);\n    }\n    format!(\"[{}]\", p)\n}\n\nfn run_max_searches(x: usize) {\n    // generate all proper fractions with 2 digits\n    let pairs = (1..x).flat_map(move |i| (i + 1..x).map(move |j| (i, j)));\n\n    let mut max_length = (0, Rational::new(&BigInt::from(1), &BigInt::from(1)));\n    let mut max_denom = (\n        Zero::zero(),\n        Rational::new(&BigInt::from(1), &BigInt::from(1)),\n    );\n\n    for (i, j) in pairs {\n        let e = Rational::new(&BigInt::from(i), &BigInt::from(j)).to_egyptian();\n        if e.len() > max_length.0 {\n            max_length = (e.len(), Rational::new(&BigInt::from(i), &BigInt::from(j)));\n        }\n\n        if e.last().unwrap().denominator > max_denom.0 {\n            max_denom = (\n                e.last().unwrap().denominator.clone(),\n                Rational::new(&BigInt::from(i), &BigInt::from(j)),\n            );\n        }\n    }\n\n    println!(\n        \"Maximum length of terms is for {} with {} terms\",\n        max_length.1, max_length.0\n    );\n    println!(\"{}\", rational_vec_to_string(max_length.1.to_egyptian()));\n\n    println!(\n        \"Maximum denominator is for {} with {} terms\",\n        max_denom.1, max_denom.0\n    );\n    println!(\"{}\", rational_vec_to_string(max_denom.1.to_egyptian()));\n}\nfn main() {\n    let tests = [\n        Rational::new(&BigInt::from(43), &BigInt::from(48)),\n        Rational::new(&BigInt::from(5), &BigInt::from(121)),\n        Rational::new(&BigInt::from(2014), &BigInt::from(59)),\n    ];\n\n    for test in tests.iter() {\n        println!(\"{} -> {}\", test, rational_vec_to_string(test.to_egyptian()));\n    }\n\n    run_max_searches(100);\n    run_max_searches(1000);\n}\n\n",
    "title": "Egyptian fractions",
    "url": "http://rosettacode.org/wiki/Egyptian_fractions"
  },
  {
    "local_code": "struct Matrix {\n    elements: Vec<f32>,\n    pub height: u32,\n    pub width: u32,\n}\n\nimpl Matrix {\n    fn new(elements: Vec<f32>, height: u32, width: u32) -> Matrix {\n        // Should check for dimensions but omitting to be succient\n        Matrix {\n            elements,\n            height,\n            width,\n        }\n    }\n\n    fn get(&self, row: u32, col: u32) -> f32 {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)]\n    }\n\n    fn set(&mut self, row: u32, col: u32, value: f32) {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)] = value;\n    }\n\n    fn print(&self) {\n        for row in 0..self.height {\n            for col in 0..self.width {\n                print!(\"{:3.0}\", self.get(row, col));\n            }\n            println!();\n        }\n        println!();\n    }\n}\n\n// Matrix addition will perform element-wise addition\nfn matrix_addition(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let mut result = Matrix::new(\n            vec![0.0f32; (first.height * first.width) as usize],\n            first.height,\n            first.width,\n        );\n        for row in 0..first.height {\n            for col in 0..first.width {\n                let first_value = first.get(row, col);\n                let second_value = second.get(row, col);\n                result.set(row, col, first_value + second_value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\nfn scalar_multiplication(scalar: f32, matrix: &Matrix) -> Matrix {\n    let mut result = Matrix::new(\n        vec![0.0f32; (matrix.height * matrix.width) as usize],\n        matrix.height,\n        matrix.width,\n    );\n    for row in 0..matrix.height {\n        for col in 0..matrix.width {\n            let value = matrix.get(row, col);\n            result.set(row, col, scalar * value);\n        }\n    }\n    result\n}\n\n// Subtract second from first\nfn matrix_subtraction(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let negative_matrix = scalar_multiplication(-1.0, second);\n        let result = matrix_addition(first, &negative_matrix).unwrap();\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\n// First must be a l x m matrix and second a m x n matrix for this to work.\nfn matrix_multiplication(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.height {\n        let mut result = Matrix::new(\n            vec![0.0f32; (first.height * second.width) as usize],\n            first.height,\n            second.width,\n        );\n        for row in 0..result.height {\n            for col in 0..result.width {\n                let mut value = 0.0;\n                for it in 0..first.width {\n                    value += first.get(row, it) * second.get(it, col);\n                }\n                result.set(row, col, value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match. Width of first must equal height of second\".to_owned())\n    }\n}\n\nfn main() {\n    let height = 2;\n    let width = 3;\n    // Matrix will look like:\n    // | 1.0  2.0  3.0  |\n    // | 4.0  5.0  6.0 |\n    let matrix1 = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], height, width);\n\n    // Matrix will look like:\n    // | 6.0  5.0  4.0  |\n    // | 3.0  2.0  1.0 |\n    let matrix2 = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], height, width);\n\n    // | 7.0  7.0  7.0  |\n    // | 7.0  7.0  7.0 |\n    matrix_addition(&matrix1, &matrix2).unwrap().print();\n    // | 2.0   4.0   6.0  |\n    // | 8.0  10.0  12.0 |\n    scalar_multiplication(2.0, &matrix1).print();\n    // | -5.0  -3.0  -1.0  |\n    // |  1.0   3.0   5.0 |\n    matrix_subtraction(&matrix1, &matrix2).unwrap().print();\n\n    // | 1.0 |\n    // | 1.0 |\n    // | 1.0 |\n    let matrix3 = Matrix::new(vec![1.0, 1.0, 1.0], width, 1);\n    // |  6 |\n    // | 15 |\n    matrix_multiplication(&matrix1, &matrix3).unwrap().print();\n}\n\n#[allow(clippy::float_cmp)]\n#[cfg(test)]\nmod tests {\n    use super::{\n        matrix_addition, matrix_multiplication, matrix_subtraction, scalar_multiplication, Matrix,\n    };\n\n    const HEIGHT: u32 = 2;\n    const WIDTH: u32 = 3;\n    #[test]\n    fn matrix_addition_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2: Matrix = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], HEIGHT, WIDTH);\n        let result = matrix_addition(&matrix1, &matrix2).unwrap();\n        for col in 0..result.width {\n            for row in 0..result.height {\n                assert_eq!(result.get(row, col), 7.0);\n            }\n        }\n    }\n\n    #[test]\n    fn scalar_multiplication_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let result = scalar_multiplication(2.0, &matrix1);\n        assert_eq!(result.get(0, 0), 2.0);\n        assert_eq!(result.get(0, 1), 4.0);\n        assert_eq!(result.get(0, 2), 6.0);\n        assert_eq!(result.get(1, 0), 8.0);\n        assert_eq!(result.get(1, 1), 10.0);\n        assert_eq!(result.get(1, 2), 12.0);\n    }\n\n    #[test]\n    fn matrix_subtraction_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2: Matrix = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], HEIGHT, WIDTH);\n        let result = matrix_subtraction(&matrix1, &matrix2).unwrap();\n        assert_eq!(result.get(0, 0), -5.0);\n        assert_eq!(result.get(0, 1), -3.0);\n        assert_eq!(result.get(0, 2), -1.0);\n        assert_eq!(result.get(1, 0), 1.0);\n        assert_eq!(result.get(1, 1), 3.0);\n        assert_eq!(result.get(1, 2), 5.0);\n    }\n\n    #[test]\n    fn matrix_multiplication_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2 = Matrix::new(vec![1.0, 1.0, 1.0], WIDTH, 1);\n        let result = matrix_multiplication(&matrix1, &matrix2).unwrap();\n        assert_eq!(result.get(0, 0), 6.0);\n        assert_eq!(result.get(1, 0), 15.0);\n    }\n}\n",
    "path": "tasks/element-wise-operations",
    "remote_code": "struct Matrix {\n    elements: Vec<f32>,\n    pub height: u32,\n    pub width: u32,\n}\n\nimpl Matrix {\n    fn new(elements: Vec<f32>, height: u32, width: u32) -> Matrix {\n        // Should check for dimensions but omitting to be succient\n        Matrix {\n            elements: elements,\n            height: height,\n            width: width,\n        }\n    }\n\n    fn get(&self, row: u32, col: u32) -> f32 {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)]\n    }\n\n    fn set(&mut self, row: u32, col: u32, value: f32) {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)] = value;\n    }\n\n    fn print(&self) {\n        for row in 0..self.height {\n            for col in 0..self.width {\n                print!(\"{:3.0}\", self.get(row, col));\n            }\n            println!(\"\");\n        }\n        println!(\"\");\n    }\n}\n\n// Matrix addition will perform element-wise addition\nfn matrix_addition(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let mut result = Matrix::new(vec![0.0f32; (first.height * first.width) as usize],\n                                     first.height,\n                                     first.width);\n        for row in 0..first.height {\n            for col in 0..first.width {\n                let first_value = first.get(row, col);\n                let second_value = second.get(row, col);\n                result.set(row, col, first_value + second_value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\nfn scalar_multiplication(scalar: f32, matrix: &Matrix) -> Matrix {\n    let mut result = Matrix::new(vec![0.0f32; (matrix.height * matrix.width) as usize],\n                                 matrix.height,\n                                 matrix.width);\n    for row in 0..matrix.height {\n        for col in 0..matrix.width {\n            let value = matrix.get(row, col);\n            result.set(row, col, scalar * value);\n        }\n    }\n    result\n}\n\n// Subtract second from first\nfn matrix_subtraction(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let negative_matrix = scalar_multiplication(-1.0, second);\n        let result = matrix_addition(first, &negative_matrix).unwrap();\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\n// First must be a l x m matrix and second a m x n matrix for this to work.\nfn matrix_multiplication(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.height {\n        let mut result = Matrix::new(vec![0.0f32; (first.height * second.width) as usize],\n                                     first.height,\n                                     second.width);\n        for row in 0..result.height {\n            for col in 0..result.width {\n                let mut value = 0.0;\n                for it in 0..first.width {\n                    value += first.get(row, it) * second.get(it, col);\n                }\n                result.set(row, col, value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match. Width of first must equal height of second\".to_owned())\n    }\n}\n\n\nfn main() {\n    let height = 2;\n    let width = 3;\n    // Matrix will look like:\n    // | 1.0  2.0  3.0  |\n    // | 4.0  5.0  6.0 |\n    let matrix1 = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], height, width);\n\n    // Matrix will look like:\n    // | 6.0  5.0  4.0  |\n    // | 3.0  2.0  1.0 |\n    let matrix2 = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], height, width);\n\n    // | 7.0  7.0  7.0  |\n    // | 7.0  7.0  7.0 |\n    matrix_addition(&matrix1, &matrix2).unwrap().print();\n    // | 2.0   4.0   6.0  |\n    // | 8.0  10.0  12.0 |\n    scalar_multiplication(2.0, &matrix1).print();\n    // | -5.0  -3.0  -1.0  |\n    // |  1.0   3.0   5.0 |\n    matrix_subtraction(&matrix1, &matrix2).unwrap().print();\n\n    // | 1.0 |\n    // | 1.0 |\n    // | 1.0 |\n    let matrix3 = Matrix::new(vec![1.0, 1.0, 1.0], width, 1);\n    // |  6 |\n    // | 15 |\n    matrix_multiplication(&matrix1, &matrix3).unwrap().print();\n}",
    "title": "Element-wise operations",
    "url": "http://rosettacode.org/wiki/Element-wise_operations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\n    struct ElementaryCA {\n        rule: u8,\n        state: u64,\n    }\n    impl ElementaryCA {\n        fn new(rule: u8) -> (u64, ElementaryCA) {\n            let out = ElementaryCA {\n                rule,\n                state: 1,\n            };\n            (out.state, out)\n        }\n        fn next(&mut self) -> u64 {\n            let mut next_state = 0u64;\n            let state = self.state;\n            for i in 0..64 {\n                next_state |= (((self.rule as u64)>>(7 & (state.rotate_left(1).rotate_right(i as u32)))) & 1)<<i;\n            }\n            self.state = next_state;\n            self.state\n        }\n    }\n    fn rep_u64(val: u64) -> String {\n        let mut out = String::new();\n        for i in (0..64).rev() {\n            if 1<<i & val != 0 {\n                out = out + \"\\u{2588}\";\n            } else {\n                out = out + \"-\";\n            }\n        }\n        out\n    }\n\n    let (i, mut thirty) = ElementaryCA::new(154);\n    println!(\"{}\",rep_u64(i));\n    for _ in 0..32 {\n        let s = thirty.next();\n        println!(\"{}\", rep_u64(s));\n    }\n}\n",
    "title": "Elementary cellular automaton",
    "url": "http://rosettacode.org/wiki/Elementary_cellular_automaton"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Elementary cellular automaton/Infinite length",
    "url": "http://rosettacode.org/wiki/Elementary_cellular_automaton/Infinite_length"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n//Assuming the code from the Elementary cellular automaton task is in the namespace.\nfn main() {\n    struct WolfGen(ElementaryCA);\n    impl WolfGen {\n        fn new() -> WolfGen {\n            let (_, ca) = ElementaryCA::new(30);\n            WolfGen(ca)\n        }\n        fn next(&mut self) -> u8 {\n            let mut out = 0;\n            for i in 0..8 {\n                out |= ((1 & self.0.next())<<i)as u8;\n            }\n            out\n        }\n    }\n    let mut gen = WolfGen::new();\n    for _ in 0..10 {\n        print!(\"{} \", gen.next());\n    }\n}\n",
    "title": "Elementary cellular automaton/Random number generator",
    "url": "http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_number_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Elliptic Curve Digital Signature Algorithm",
    "url": "http://rosettacode.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Elliptic curve arithmetic",
    "url": "http://rosettacode.org/wiki/Elliptic_curve_arithmetic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Emirp primes",
    "url": "http://rosettacode.org/wiki/Emirp_primes"
  },
  {
    "local_code": "use std::env::args;\nuse std::fs;\n\nfn main() {\n    // Open path\n    let dir = if let Some(arg) = args().nth(1) {\n        arg\n    } else {\n        println!(\"You must give a path as argument\");\n        return;\n    };\n\n    // map function for type Result executes a function (closure)\n    // on Ok(_) types but leaves Err(_) untouched.\n    //\n    // The directory is empty if the result of paths.count() == Ok(0)\n    // In any other case, the directory is not empty\n    match fs::read_dir(dir).map(|paths| paths.count()) {\n        Err(e) => println!(\"Error: {}\", e),\n        Ok(0) => println!(\"Directory is empty\"),\n        Ok(_) => println!(\"Directory is not empty\"),\n    }\n}\n",
    "path": "tasks/empty-directory",
    "remote_code": "use std::fs::read_dir;\nuse std::error::Error;\n\nfn main() {\n    for path in std::env::args().skip(1) { // iterate over the arguments, skipping the first (which is the executable)\n        match read_dir(path.as_str()) { // try to read the directory specified\n            Ok(contents) => {\n                let len = contents.collect::<Vec<_>>().len(); // calculate the amount of items in the directory\n                if len == 0 {\n                    println!(\"{} is empty\", path);\n                } else {\n                    println!(\"{} is not empty\", path);\n                }\n            },\n            Err(e) => { // If the attempt failed, print the corresponding error msg\n                println!(\"Failed to read directory \\\"{}\\\": {}\", path, e.description());\n            }\n        }\n    }\n}",
    "title": "Empty directory",
    "url": "http://rosettacode.org/wiki/Empty_directory"
  },
  {
    "local_code": "fn main() {}\n",
    "path": "tasks/empty-program",
    "remote_code": "fn main(){}",
    "title": "Empty program",
    "url": "http://rosettacode.org/wiki/Empty_program"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "let s = \"\";\nprintln!(\"is empty: {}\", s.is_empty());\nlet t = \"x\";\nprintln!(\"is empty: {}\", t.is_empty());\nlet a = String::new();\nprintln!(\"is empty: {}\", a.is_empty());\nlet b = \"x\".to_string();\nprintln!(\"is empty: {}\", b.is_empty());\nprintln!(\"is not empty: {}\", !b.is_empty());",
    "title": "Empty string",
    "url": "http://rosettacode.org/wiki/Empty_string"
  },
  {
    "local_code": "#![allow(unused_variables)]\n\nfn main() {\n    // Rust let bindings are immutable by default.\n    let z = 3;\n    // This will raise a compiler error:\n    // z += 2; //~ ERROR cannot assign twice to immutable variable `z`\n\n    // You must declare a variable mutable explicitly:\n    let mut x = 3;\n\n    // Similarly, references are immutable by default e.g.\n    // The following lines would raise a compiler error. Even though x is mutable, y is an\n    // immutable reference.\n    // let y = &x;\n    // *y += 2; //~ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n\n    let y = &mut x;\n    *y += 2; // Works\n\n    // Note that though y is now a mutable reference, y itself is still immutable e.g.\n    // let mut z = 5;\n    // y = &mut z; //~ ERROR re-assignment of immutable variable `y`\n}\n",
    "path": "tasks/enforced-immutability",
    "remote_code": "let x = 3;\nx += 2;",
    "title": "Enforced immutability",
    "url": "http://rosettacode.org/wiki/Enforced_immutability"
  },
  {
    "local_code": "extern crate entropy;\n\nuse entropy::shannon_entropy;\n\nfn main() {\n    println!(\"{}\", shannon_entropy(\"1223334444\"));\n}\nuse std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::HashMap;\n\npub fn shannon_entropy(s: &str) -> f64 {\n    let mut map = HashMap::new();\n\n    // Count occurrences of each char\n    for c in s.chars() {\n        match map.entry(c) {\n            Vacant(entry) => {\n                entry.insert(1);\n            }\n            Occupied(mut entry) => {\n                *entry.get_mut() += 1;\n            }\n        };\n    }\n\n    // Calculate the entropy\n    let len = s.len() as f64;\n    map.iter().fold(0f64, |acc, (_, &nb)| {\n        let p = f64::from(nb) / len;\n        acc - p * p.log2()\n    })\n}\n\n#[test]\nfn test_entropy() {\n    let tests = vec![\n        (\"1223334444\", 1.846439344671f64),\n        (\"1223334444555555555\", 1.969811065121),\n        (\"122333\", 1.459147917061),\n        (\"1227774444\", 1.846439344671),\n        (\"aaBBcccDDDD\", 1.936260027482),\n        (\"1234567890abcdefghijklmnopqrstuvwxyz\", 5.169925004424),\n        (\"Rosetta Code\", 3.084962500407),\n    ];\n    // Good enough, actual float epsilon is much smaller\n    let epsilon: f64 = 0.0000001;\n    for (input, expected) in tests {\n        let output = shannon_entropy(input);\n        assert!((output - expected).abs() < epsilon);\n    }\n}\n",
    "path": "tasks/entropy",
    "remote_code": "fn entropy(s: &[u8]) -> f32 {\n    let mut histogram = [0u64; 256];\n\n    for &b in s {\n        histogram[b as usize] += 1;\n    }\n\n    histogram\n        .iter()\n        .cloned()\n        .filter(|&h| h != 0)\n        .map(|h| h as f32 / s.len() as f32)\n        .map(|ratio| -ratio * ratio.log2())\n        .sum()\n}\n\nfn main() {\n    let arg = std::env::args().nth(1).expect(\"Need a string.\");\n    println!(\"Entropy of {} is {}.\", arg, entropy(arg.as_bytes()));\n}",
    "title": "Entropy",
    "url": "http://rosettacode.org/wiki/Entropy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs::File;\nuse std::io::{Read, BufReader};\n\nfn entropy<I: IntoIterator<Item = u8>>(iter: I) -> f32 {\n    let mut histogram = [0u64; 256];\n    let mut len = 0u64;\n\n    for b in iter {\n        histogram[b as usize] += 1;\n        len += 1;\n    }\n    \n    histogram\n        .iter()\n        .cloned()\n        .filter(|&h| h > 0)\n        .map(|h| h as f32 / len as f32)\n        .map(|ratio| -ratio * ratio.log2())\n        .sum()\n}\n\nfn main() {\n    let name = std::env::args().nth(0).expect(\"Could not get program name.\");\n    let file = BufReader::new(File::open(name).expect(\"Could not read file.\"));\n    println!(\"Entropy is {}.\", entropy(file.bytes().flatten()));\n}",
    "title": "Entropy/Narcissist",
    "url": "http://rosettacode.org/wiki/Entropy/Narcissist"
  },
  {
    "local_code": "#[allow(dead_code)]\nenum Fruits {\n    Apple,\n    Banana,\n    Cherry,\n}\n\n#[allow(dead_code)]\nenum Days {\n    Monday = 0,\n    Tuesday = 1,\n    Wednesday = 2, // You know the rest...\n}\n\nfn main() {}\n",
    "path": "tasks/enumerations",
    "remote_code": "enum Fruits {\n    Apple,\n    Banana,\n    Cherry\n}\n\nenum FruitsWithNumbers {\n    Strawberry = 0,\n    Pear = 27,\n}\n\nfn main() {\n    // Access to numerical value by conversion\n    println!(\"{}\", FruitsWithNumbers::Pear as u8);\n}",
    "title": "Enumerations",
    "url": "http://rosettacode.org/wiki/Enumerations"
  },
  {
    "local_code": "use std::env;\n\nfn main() {\n    let variables = [\"PATH\", \"HOME\", \"USER\"];\n\n    for variable in &variables {\n        match env::var(variable) {\n            Ok(value) => println!(\"{}={}\", variable, value),\n            Err(e) => println!(\"Could not read {}: {}.\", variable, e),\n        }\n    }\n}\n",
    "path": "tasks/environment-variables",
    "remote_code": "use std::env;\n\nfn main() {\n    println!(\"{:?}\", env::var(\"HOME\"));\n    println!();\n    for (k, v) in env::vars().filter(|(k, _)| k.starts_with('P')) {\n        println!(\"{}: {}\", k, v);\n    }\n}\n",
    "title": "Environment variables",
    "url": "http://rosettacode.org/wiki/Environment_variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Equal prime and composite sums",
    "url": "http://rosettacode.org/wiki/Equal_prime_and_composite_sums"
  },
  {
    "local_code": "extern crate num;\n\nuse num::traits::Zero;\n\nfn equilibrium_indices(v: &[i32]) -> Vec<usize> {\n    let mut right = v.iter().sum();\n    let mut left = i32::zero();\n\n    v.iter().enumerate().fold(vec![], |mut out, (i, &el)| {\n        right -= el;\n        if left == right {\n            out.push(i);\n        }\n        left += el;\n\n        out\n    })\n}\n\nfn main() {\n    let v = [-7i32, 1, 5, 2, -4, 3, 0];\n    let indices = equilibrium_indices(&v);\n    println!(\"Equilibrium indices for {:?} are: {:?}\", v, indices);\n}\n\n#[test]\nfn test_equilibrium_indices() {\n    let v = &[-7i32, 1, 5, 2, -4, 3, 0];\n    assert_eq!(equilibrium_indices(v), vec![3, 6]);\n}\n",
    "path": "tasks/equilibrium-index",
    "remote_code": "\nextern crate num;\n\nuse num::traits::Zero;\n\nfn equilibrium_indices(v: &[i32]) -> Vec<usize> {\n    let mut right = v.iter().sum();\n    let mut left = i32::zero();\n\n    v.iter().enumerate().fold(vec![], |mut out, (i, &el)| {\n        right -= el;\n        if left == right {\n            out.push(i);\n        }\n        left += el;\n\n        out\n    })\n}\n\nfn main() {\n    let v = [-7i32, 1, 5, 2, -4, 3, 0];\n    let indices = equilibrium_indices(&v);\n    println!(\"Equilibrium indices for {:?} are: {:?}\", v, indices);\n}\n",
    "title": "Equilibrium index",
    "url": "http://rosettacode.org/wiki/Equilibrium_index"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n\nuse std::collections::BTreeMap;\n\nstruct ErdosSelfridge {\n    primes: Vec<usize>,\n    category: Vec<u32>,\n}\n\nimpl ErdosSelfridge {\n    fn new(limit: usize) -> ErdosSelfridge {\n        let mut es = ErdosSelfridge {\n            primes: primal::Primes::all().take(limit).collect(),\n            category: Vec::new(),\n        };\n        es.category.resize(es.primes.len(), 0);\n        es\n    }\n\n    fn get_category(&mut self, index: usize) -> u32 {\n        if self.category[index] != 0 {\n            return self.category[index];\n        }\n        let mut max_category = 0;\n        let mut n = self.primes[index] + 1;\n        for i in 0.. {\n            let p = self.primes[i];\n            if p * p > n {\n                break;\n            }\n            let mut count = 0;\n            while n % p == 0 {\n                n /= p;\n                count += 1;\n            }\n            if count != 0 {\n                let category = if p <= 3 { 1 } else { 1 + self.get_category(i) };\n                max_category = std::cmp::max(max_category, category);\n            }\n        }\n        if n > 1 {\n            let i = self.get_index(n);\n            let category = if n <= 3 { 1 } else { 1 + self.get_category(i) };\n            max_category = std::cmp::max(max_category, category);\n        }\n        self.category[index] = max_category;\n        max_category\n    }\n\n    fn get_index(&self, prime: usize) -> usize {\n        self.primes.binary_search(&prime).unwrap()\n    }\n\n    fn get_primes_by_category(&mut self, limit: usize) -> BTreeMap<u32, Vec<usize>> {\n        let mut primes_by_category: BTreeMap<u32, Vec<usize>> = BTreeMap::new();\n        for i in 0..limit {\n            let category = self.get_category(i);\n            let prime = self.primes[i];\n            if let Some(primes) = primes_by_category.get_mut(&category) {\n                primes.push(prime);\n            } else {\n                let mut primes = Vec::new();\n                primes.push(prime);\n                primes_by_category.insert(category, primes);\n            }\n        }\n        primes_by_category\n    }\n}\n\nfn main() {\n    let mut es = ErdosSelfridge::new(1000000);\n    let primes_by_category = es.get_primes_by_category(200);\n    println!(\"First 200 primes:\");\n    for (category, primes) in primes_by_category.iter() {\n        println!(\"Category {}:\", category);\n        for i in 0..primes.len() {\n            print!(\n                \"{:4}{}\",\n                primes[i],\n                if (i + 1) % 15 == 0 { \"\\n\" } else { \" \" }\n            );\n        }\n        print!(\"\\n\\n\");\n    }\n    println!(\"First 1,000,000 primes:\");\n    let primes_by_category = es.get_primes_by_category(1000000);\n    for (category, primes) in primes_by_category.iter() {\n        let first = primes[0];\n        let count = primes.len();\n        let last = primes[count - 1];\n        println!(\n            \"Category {:2}: first = {:7}  last = {:8}  count = {}\",\n            category, first, last, count\n        );\n    }\n}",
    "title": "Erdös-Selfridge categorization of primes",
    "url": "http://rosettacode.org/wiki/Erd%C3%B6s-Selfridge_categorization_of_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// radix_fmt = \"1.0\"\n\n// Returns the next esthetic number in the given base after n, where n is an\n// esthetic number in that base or one less than a power of base.\nfn next_esthetic_number(base: u64, n: u64) -> u64 {\n    if n + 1 < base {\n        return n + 1;\n    }\n    let mut a = n / base;\n    let mut b = a % base;\n    if n % base + 1 == b && b + 1 < base {\n        return n + 2;\n    }\n    a = next_esthetic_number(base, a);\n    b = a % base;\n    a * base + if b == 0 { 1 } else { b - 1 }\n}\n\nfn print_esthetic_numbers(min: u64, max: u64, numbers_per_line: usize) {\n    let mut numbers = Vec::new();\n    let mut n = next_esthetic_number(10, min - 1);\n    while n <= max {\n        numbers.push(n);\n        n = next_esthetic_number(10, n);\n    }\n    let count = numbers.len();\n    println!(\n        \"Esthetic numbers in base 10 between {} and {} ({}):\",\n        min, max, count\n    );\n    if count > 200 {\n        for i in 0..numbers_per_line {\n            if i != 0 {\n                print!(\" \");\n            }\n            print!(\"{}\", numbers[i]);\n        }\n        println!(\"\\n............\\n\");\n        for i in 0..numbers_per_line {\n            if i != 0 {\n                print!(\" \");\n            }\n            print!(\"{}\", numbers[count - numbers_per_line + i]);\n        }\n        println!();\n    } else {\n        for i in 0..count {\n            print!(\"{}\", numbers[i]);\n            if (i + 1) % numbers_per_line == 0 {\n                println!();\n            } else {\n                print!(\" \");\n            }\n        }\n        if count % numbers_per_line != 0 {\n            println!();\n        }\n    }\n}\n\nfn main() {\n    for base in 2..=16 {\n        let min = base * 4;\n        let max = base * 6;\n        println!(\n            \"Esthetic numbers in base {} from index {} through index {}:\",\n            base, min, max\n        );\n        let mut n = 0;\n        for index in 1..=max {\n            n = next_esthetic_number(base, n);\n            if index >= min {\n                print!(\"{} \", radix_fmt::radix(n, base as u8));\n            }\n        }\n        println!(\"\\n\");\n    }\n\n    let mut min = 1000;\n    let mut max = 9999;\n    print_esthetic_numbers(min, max, 16);\n    println!();\n\n    min = 100000000;\n    max = 130000000;\n    print_esthetic_numbers(min, max, 8);\n    println!();\n\n    for i in 0..3 {\n        min *= 1000;\n        max *= 1000;\n        let numbers_per_line = match i {\n            0 => 7,\n            1 => 5,\n            _ => 4,\n        };\n        print_esthetic_numbers(min, max, numbers_per_line);\n        println!();\n    }\n}",
    "title": "Esthetic numbers",
    "url": "http://rosettacode.org/wiki/Esthetic_numbers"
  },
  {
    "local_code": "fn double(a: i32) -> i32 {\n    2 * a\n}\n\nfn halve(a: i32) -> i32 {\n    a / 2\n}\n\nfn is_even(a: i32) -> bool {\n    a % 2 == 0\n}\n\nfn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {\n    let mut sum = 0;\n\n    while x >= 1 {\n        print!(\"{} \\t {}\", x, y);\n        if is_even(x) {\n            println!(\"\\t Not Kept\");\n        } else {\n            println!(\"\\t Kept\");\n            sum += y;\n        }\n        x = halve(x);\n        y = double(y);\n    }\n    sum\n}\n\nfn main() {\n    let output = ethiopian_multiplication(17, 34);\n    println!(\"---------------------------------\");\n    println!(\"\\t {}\", output);\n}\n",
    "path": "tasks/ethiopian-multiplication",
    "remote_code": "fn double(a: i32) -> i32 {\n    2*a\n}\n\nfn halve(a: i32) -> i32 {\n    a/2\n}\n\nfn is_even(a: i32) -> bool {\n    a % 2 == 0\n}\n\nfn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {\n    let mut sum = 0;\n\n    while x >= 1 {\n        print!(\"{} \\t {}\", x, y);\n        match is_even(x) {\n            true  => println!(\"\\t Not Kept\"),\n            false => {\n                println!(\"\\t Kept\");\n                sum += y;\n            }\n        }\n        x = halve(x);\n        y = double(y);\n    }\n    sum\n}\n\nfn main() {\n    let output = ethiopian_multiplication(17, 34);\n    println!(\"---------------------------------\");\n    println!(\"\\t {}\", output);\n}",
    "title": "Ethiopian multiplication",
    "url": "http://rosettacode.org/wiki/Ethiopian_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn header() {\n    print!(\"    Time: \");\n    for t in (0..100).step_by(10) {\n        print!(\" {:7}\", t);\n    }\n    println!();\n}\n\nfn analytic() {\n    print!(\"Analytic: \");\n    for t in (0..=100).step_by(10) {\n        print!(\" {:7.3}\", 20.0 + 80.0 * (-0.07 * f64::from(t)).exp());\n    }\n    println!();\n}\n\nfn euler<F: Fn(f64) -> f64>(f: F, mut y: f64, step: usize, end: usize) {\n    print!(\" Step {:2}: \", step);\n    for t in (0..=end).step_by(step) {\n        if t % 10 == 0 {\n            print!(\" {:7.3}\", y);\n        }\n        y += step as f64 * f(y);\n    }\n    println!();\n}\n\nfn main() {\n    header();\n    analytic();\n    for &i in &[2, 5, 10] {\n        euler(|temp| -0.07 * (temp - 20.0), 100.0, i, 100);\n    }\n}",
    "title": "Euler method",
    "url": "http://rosettacode.org/wiki/Euler_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// 20220322 Rust programming solution\n\nfn gamma(N: u32) -> f64 { // Vacca series https://w.wiki/4ybp\n\n    return 1f64 / 2f64 - 1f64 / 3f64\n        + ((2..=N).map(|n| {\n            let power: u32 = 2u32.pow(n);\n            let mut sign: f64 = -1f64;\n            let mut term: f64 = 0f64;\n\n            for denominator in power..=(2 * power - 1) {\n                sign *= -1f64;\n                term += sign / f64::from(denominator);\n            }\n\n            return f64::from(n) * term;\n        }))\n        .sum::<f64>();\n}\n\nfn main() {\n    println!(\"{}\", gamma(23));\n}",
    "title": "Euler's constant 0.5772...",
    "url": "http://rosettacode.org/wiki/Euler's_constant_0.5772..."
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::f64::consts::PI;\n\nextern crate num_complex;\nuse num_complex::Complex;\n\nfn main() {\n    println!(\"{:e}\", Complex::new(0.0, PI).exp() + 1.0);\n}",
    "title": "Euler's identity",
    "url": "http://rosettacode.org/wiki/Euler's_identity"
  },
  {
    "local_code": "const MAX_N: usize = 250;\n\nfn eulers_sum_of_powers() -> (usize, usize, usize, usize, usize) {\n    let pow5: Vec<u64> = (0..MAX_N).map(|i| (i as u64).pow(5)).collect();\n    let pow5_to_n = |pow| pow5.binary_search(&pow);\n\n    for x0 in 1..MAX_N as usize {\n        for x1 in 1..x0 {\n            for x2 in 1..x1 {\n                for x3 in 1..x2 {\n                    let pow_sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];\n                    if let Ok(n) = pow5_to_n(pow_sum) {\n                        return (x0, x1, x2, x3, n);\n                    }\n                }\n            }\n        }\n    }\n\n    panic!();\n}\n\nfn main() {\n    let (x0, x1, x2, x3, y) = eulers_sum_of_powers();\n    println!(\"{}^5 + {}^5 + {}^5 + {}^5 == {}^5\", x0, x1, x2, x3, y)\n}\n",
    "path": "tasks/eulers-sum-of-powers-conjecture",
    "remote_code": "const MAX_N : u64 = 250;\n\nfn eulers_sum_of_powers() -> (usize, usize, usize, usize, usize) {\n    let pow5: Vec<u64> = (0..MAX_N).map(|i| i.pow(5)).collect();\n    let pow5_to_n = |pow| pow5.binary_search(&pow);\n\n    for x0 in 1..MAX_N as usize {\n        for x1 in 1..x0 {\n            for x2 in 1..x1 {\n                for x3 in 1..x2 {\n                    let pow_sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];\n                    if let Ok(n) = pow5_to_n(pow_sum) {\n                        return (x0, x1, x2, x3, n)\n                    }\n                }\n            }\n        }\n    }\n\n    panic!();\n}\n\nfn main() {\n\tlet (x0, x1, x2, x3, y) = eulers_sum_of_powers();\n\tprintln!(\"{}^5 + {}^5 + {}^5 + {}^5 == {}^5\", x0, x1, x2, x3, y)\n}",
    "title": "Euler's sum of powers conjecture",
    "url": "http://rosettacode.org/wiki/Euler's_sum_of_powers_conjecture"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::One;\n\nfn binomial(n: usize, mut k: usize) -> BigUint {\n    // Since binomial(n, k) = binomial(n, n - k), we might as well use\n    // the smaller k to optimize\n    if n - k < k {\n        k = n - k;\n    }\n\n    // Compute the coefficient\n    let mut res: BigUint = One::one();\n    for i in 1..(k + 1) {\n        let m: BigUint = (n - k + i).to_biguint().unwrap();\n        res *= m;\n        let d: BigUint = (i).to_biguint().unwrap();\n        res /= d;\n    }\n\n    res\n}\n\nfn main() {\n    println!(\"{}\", binomial(5, 3));\n}\n\n#[test]\nfn test_binomial() {\n    use num::traits::Num;\n\n    assert_eq!(binomial(20, 0), binomial(20, 20));\n    assert_eq!(binomial(20, 15), binomial(19, 14) + binomial(19, 15));\n    assert_eq!(binomial(5, 3), 10.to_biguint().unwrap());\n    assert_eq!(binomial(31, 17), 265182525.to_biguint().unwrap());\n    assert_eq!(\n        binomial(300, 30),\n        BigUint::from_str_radix(\"173193226149263513034110205899732811401360\", 10).unwrap()\n    );\n}\n",
    "path": "tasks/evaluate-binomial-coefficients",
    "remote_code": "fn fact(n:u32) -> u64 {\n  let mut f:u64 = n as u64;\n  for i in 2..n {\n    f *= i as u64;\n  }\n  return f;\n}\n\nfn choose(n: u32, k: u32)  -> u64 {\n   let mut num:u64 = n as u64;\n   for i in 1..k {\n     num *= (n-i) as u64;\n   }\n   return num / fact(k);\n}\n\nfn main() {\n  println!(\"{}\", choose(5,3));\n}",
    "title": "Evaluate binomial coefficients",
    "url": "http://rosettacode.org/wiki/Evaluate_binomial_coefficients"
  },
  {
    "local_code": "#![allow(unused_variables)]\n\nfn main() {\n    // Checking the last significant digit:\n    let is_odd = |x: i32| x & 1 == 1;\n    let is_even = |x: i32| x & 1 == 0;\n\n    // Using modular congruences:\n    let is_odd = |x: i32| x % 2 != 0;\n    let is_even = |x: i32| x % 2 == 0;\n}\n",
    "path": "tasks/even-or-odd",
    "remote_code": "let is_odd = |x: i32| x & 1 == 1;\nlet is_even = |x: i32| x & 1 == 0;",
    "title": "Even or odd",
    "url": "http://rosettacode.org/wiki/Even_or_odd"
  },
  {
    "local_code": "//! Rust uses condition variables (Condvars) for asynchronous event processing.  Each Mutex has a\n//! list of zero or more Condvars, which are essentially events that the task may wait on or signal\n//! when it holds the mutex.  When a task begins to wait on a condvar, it enters a waiting state\n//! until the condvar is signaled by another task, at which point it resumes processing.  Thus,\n//! each condvar represents an event on which a task may wait.  The one subtlety is that condvar\n//! signals are only received if there is actually a task waiting on the signal--see the below\n//! program for an example of how this may be achieved in practice.\n\nuse std::sync::{Arc, Condvar, Mutex};\nuse std::thread::{self, spawn};\nuse std::time::{Duration, Instant};\n\n/// Given a duration to wait before sending an event from one process to another, returns the\n/// elapsed time before the event was actually sent.\n#[allow(clippy::mutex_atomic)]\nfn handle_event(duration: Duration) -> Duration {\n    // Create a Mutex.  By default a Mutex is created with a single condition variable (condvar_id\n    // 0) but it can be created with an arbitrary number using Mutex::new_with_condvars();\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair_ = Arc::clone(&pair);\n    let start = Instant::now();\n    // Lock the mutex\n    let &(ref mutex, ref cond) = &*pair;\n    let mut guard = mutex.lock().unwrap();\n    // Start our secondary task (which will signal our waiting main task)\n    spawn(move || {\n        let &(ref mutex_, ref cond_) = &*pair_;\n        // Lock the mutex\n        let mut guard = mutex_.lock().unwrap();\n        *guard = true;\n\n        // Sleep for `duration`.\n        thread::sleep(duration);\n        // Signal the waiting mutex (equivalent to guard.cond.signal_on(0)).\n        // One can also signal to all tasks on the waiting mutex with broadcast (broadcast_on(0)).\n        //\n        // Note that if no tasks are actually waiting yet (which is possible, if we got the lock\n        // before the other task), then this might report that it failed to wake up any tasks.\n        // That is why the mutex was locked before the task was spawned--we know we cannot possibly\n        // get past the mutex at the top of the task until the wait() statement below is reached.\n        cond_.notify_one();\n        // Although we signaled the waiting mutex, it will not awaken until this guard is dropped.\n    });\n    // Wait for the event state to be set to signaled (equivalent to guard.cond.wait_on(0)).\n    while !*guard {\n        guard = cond.wait(guard).unwrap();\n    }\n    // Should be done signaling (i.e. we've waited for `duration`).\n    let elapsed = start.elapsed();\n    // When the guard exits scope, the condvar is reset.\n    drop(guard);\n    // Return the elapsed time\n    elapsed\n}\n\npub fn main() {\n    let duration = Duration::from_secs(1); // Process event after one second.\n    println!(\n        \"{} seconds elapsed before event triggered\",\n        handle_event(duration).as_secs()\n    );\n}\n\n#[test]\npub fn test_events() {\n    // Process event after one tenth of a second.\n    let duration = Duration::from_secs(1) / 10;\n\n    // Make sure it really did take at least that long for the event to be processed.\n    let out = handle_event(duration);\n    assert!(duration <= out);\n}\n",
    "path": "tasks/events",
    "remote_code": "\nuse std::{sync::mpsc, thread, time::Duration};\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    println!(\"[1] Starting\");\n    let (tx, rx) = mpsc::channel();\n    thread::spawn(move || {\n        println!(\"[2] Waiting for event\");\n        rx.recv();\n        println!(\"[2] Received event\");\n    });\n    thread::sleep(Duration::from_secs(1));\n    println!(\"[1] Sending event\");\n    tx.send(())?;\n    thread::sleep(Duration::from_secs(1));\n\n    Ok(())\n}\n",
    "title": "Events",
    "url": "http://rosettacode.org/wiki/Events"
  },
  {
    "local_code": "//! Author : Thibault Barbie\n//!\n//! A simple evolutionary algorithm written in Rust.\n\nextern crate rand;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nfn main() {\n    let target = \"METHINKS IT IS LIKE A WEASEL\";\n    let copies = 100;\n    let mutation_rate = 1.0 / 20.0; // = 0.05 = 5%\n\n    let mut rng = thread_rng();\n\n    // Generate first sentence, mutating each character\n    let start = mutate(&mut rng, target, 1.0); // = 100%\n\n    println!(\"{}\", target);\n    println!(\"{}\", start);\n\n    evolve(&mut rng, target, start, copies, mutation_rate);\n}\n\n/// Evolution algorithm\n///\n/// Evolves `parent` to match `target`.  Returns the number of evolutions performed.\nfn evolve<R: Rng>(\n    rng: &mut R,\n    target: &str,\n    mut parent: String,\n    copies: usize,\n    mutation_rate: f64,\n) -> usize {\n    let mut counter = 0;\n    let mut parent_fitness = target.len() + 1;\n\n    loop {\n        counter += 1;\n\n        let (best_fitness, best_sentence) = (0..copies)\n            .map(|_| {\n                // Copy and mutate a new sentence.\n                let sentence = mutate(rng, &parent, mutation_rate);\n                // Find the fitness of the new mutation\n                (fitness(target, &sentence), sentence)\n            })\n            .min_by_key(|&(f, _)| f)\n            .expect(\"copies must be non-zero\");\n\n        // If the best mutation of this generation is better than `parent` then \"the fittest\n        // survives\" and the next parent becomes the best of this generation.\n        if best_fitness < parent_fitness {\n            parent = best_sentence;\n            parent_fitness = best_fitness;\n            println!(\n                \"{} : generation {} with fitness {}\",\n                parent, counter, best_fitness\n            );\n\n            if best_fitness == 0 {\n                return counter;\n            }\n        }\n    }\n}\n\n/// Computes the fitness of a sentence against a target string, returning the number of\n/// incorrect characters.\nfn fitness(target: &str, sentence: &str) -> usize {\n    sentence\n        .chars()\n        .zip(target.chars())\n        .filter(|&(c1, c2)| c1 != c2)\n        .count()\n}\n\n/// Mutation algorithm.\n///\n/// It mutates each character of a string, according to a `mutation_rate`.\nfn mutate<R: Rng>(rng: &mut R, sentence: &str, mutation_rate: f64) -> String {\n    let maybe_mutate = |c| {\n        if rng.gen_bool(mutation_rate) {\n            random_char(rng)\n        } else {\n            c\n        }\n    };\n    sentence.chars().map(maybe_mutate).collect()\n}\n\n/// Generates a random letter or space.\nfn random_char<R: Rng>(rng: &mut R) -> char {\n    // Something similar to `rand::distributions::Alphanumeric` might be faster.\n\n    // Returns a value in the range [A, Z] + an extra slot for the space character.\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new_inclusive(b'A', b'Z' + 1);\n    match rng.sample(range) {\n        c if c == b'Z' + 1 => ' ', // the `char` after 'Z'\n        c => c as char,\n    }\n}\n",
    "path": "tasks/evolutionary-algorithm",
    "remote_code": "//! Author : Thibault Barbie\n//!\n//! A simple evolutionary algorithm written in Rust.\n\nextern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let target = \"METHINKS IT IS LIKE A WEASEL\";\n    let copies = 100;\n    let mutation_rate = 20; // 1/20 = 0.05 = 5%\n\n    let mut rng = rand::weak_rng();\n\n    // Generate first sentence, mutating each character\n    let start = mutate(&mut rng, target, 1); // 1/1 = 1 = 100%\n\n    println!(\"{}\", target);\n    println!(\"{}\", start);\n\n    evolve(&mut rng, target, start, copies, mutation_rate);\n}\n\n/// Evolution algorithm\n///\n/// Evolves `parent` to match `target`.  Returns the number of evolutions performed.\nfn evolve<R: Rng>(\n    rng: &mut R,\n    target: &str,\n    mut parent: String,\n    copies: usize,\n    mutation_rate: u32,\n) -> usize {\n    let mut counter = 0;\n    let mut parent_fitness = target.len() + 1;\n\n    loop {\n        counter += 1;\n\n        let (best_fitness, best_sentence) = (0..copies)\n            .map(|_| {\n                // Copy and mutate a new sentence.\n                let sentence = mutate(rng, &parent, mutation_rate);\n                // Find the fitness of the new mutation\n                (fitness(target, &sentence), sentence)\n            })\n            .min_by_key(|&(f, _)| f) // find the closest mutation to the target\n            .unwrap(); // fails if `copies == 0`\n\n        // If the best mutation of this generation is better than `parent` then \"the fittest\n        // survives\" and the next parent becomes the best of this generation.\n        if best_fitness < parent_fitness {\n            parent = best_sentence;\n            parent_fitness = best_fitness;\n            println!(\n                \"{} : generation {} with fitness {}\",\n                parent, counter, best_fitness\n            );\n\n            if best_fitness == 0 {\n                return counter;\n            }\n        }\n    }\n}\n\n/// Computes the fitness of a sentence against a target string, returning the number of\n/// incorrect characters.\nfn fitness(target: &str, sentence: &str) -> usize {\n    sentence\n        .chars()\n        .zip(target.chars())\n        .filter(|&(c1, c2)| c1 != c2)\n        .count()\n}\n\n/// Mutation algorithm.\n///\n/// It mutates each character of a string, according to a `mutation_rate`.\nfn mutate<R: Rng>(rng: &mut R, sentence: &str, mutation_rate: u32) -> String {\n    let maybe_mutate = |c| {\n        if rng.gen_weighted_bool(mutation_rate) {\n            random_char(rng)\n        } else {\n            c\n        }\n    };\n    sentence.chars().map(maybe_mutate).collect()\n}\n\n/// Generates a random letter or space.\nfn random_char<R: Rng>(rng: &mut R) -> char {\n    // Returns a value in the range [A, Z] + an extra slot for the space character.  (The `u8`\n    // values could be cast to larger integers for a better chance of the RNG hitting the proper\n    // range).\n    match rng.gen_range(b'A', b'Z' + 2) {\n        c if c == b'Z' + 1 => ' ', // the `char` after 'Z'\n        c => c as char,\n    }\n}",
    "title": "Evolutionary algorithm",
    "url": "http://rosettacode.org/wiki/Evolutionary_algorithm"
  },
  {
    "local_code": "// IO error is used here just as an example of an already existing\n// Error\nuse std::io::{Error, ErrorKind};\n\n// Rust technically doesn't have exception, but different\n// types of error handling. Here are two examples of results.\n\npub fn valid_function() -> Result<usize, Error> {\n    Ok(100)\n}\n\npub fn errored_function() -> Result<usize, Error> {\n    Err(Error::new(ErrorKind::Other, \"Something wrong happened.\"))\n}\n\n// This should happen only when an unrecoverable error happened\npub fn panicking_function() {\n    panic!(\"Unrecoverable state reached\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_function() {\n        let result = match valid_function() {\n            Ok(number) => number,\n            Err(_) => panic!(\"This is not going to happen\"),\n        };\n        assert_eq!(result, 100);\n    }\n\n    #[test]\n    fn test_errored_function() {\n        let result = match errored_function() {\n            Ok(_) => panic!(\"This is not going to happen\"),\n            Err(e) => {\n                assert_eq!(e.to_string(), \"Something wrong happened.\");\n                0\n            }\n        };\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_panicking_function() {\n        panicking_function();\n    }\n}\n",
    "path": "tasks/exceptions",
    "remote_code": "// IO error is used here just as an example of an already existing\n// Error\nuse std::io::{Error, ErrorKind};\n\n// Rust technically doesn't have exception, but different\n// types of error handling. Here are two examples of results.\n\nfn valid_function() -> Result<usize, Error> {\n    Ok(100)\n}\n\nfn errored_function() -> Result<usize, Error> {\n    Err(Error::new(ErrorKind::Other, \"Something wrong happened.\"))\n}\n\n// This should happen only when an unrecoverable error happened\nfn panicking_function() {\n    panic!(\"Unrecoverable state reached\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_function() {\n        let result = match valid_function() {\n            Ok(number) => number,\n            Err(_) => panic!(\"This is not going to happen\"),\n        };\n        assert_eq!(result, 100);\n    }\n\n    #[test]\n    fn test_errored_function() {\n        let result = match errored_function() {\n            Ok(_) => panic!(\"This is not going to happen\"),\n            Err(e) => {\n                assert_eq!(e.to_string(), \"Something wrong happened.\");\n                0\n            }\n        };\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_panicking_function() {\n        panicking_function();\n    }\n}",
    "title": "Exceptions",
    "url": "http://rosettacode.org/wiki/Exceptions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Debug)]\nenum U {\n    U0(i32),\n    U1(String),\n}\n\nfn baz(i: u8) -> Result<(), U> {\n    match i {\n        0 => Err(U::U0(42)),\n        1 => Err(U::U1(\"This will be returned from main\".into())),\n        _ => Ok(()),\n    }\n}\n\nfn bar(i: u8) -> Result<(), U> {\n    baz(i)\n}\n\nfn foo() -> Result<(), U> {\n    for i in 0..2 {\n        match bar(i) {\n            Ok(()) => {},\n            Err(U::U0(n)) => eprintln!(\"Caught U0 in foo: {}\", n),\n            Err(e) => return Err(e),\n        }\n    }\n    Ok(())\n}\n\nfn main() -> Result<(), U> {\n    foo()\n}",
    "title": "Exceptions/Catch an exception thrown in a nested call",
    "url": "http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Executable library",
    "url": "http://rosettacode.org/wiki/Executable_library"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::stdin;\nuse std::num::Wrapping;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} [path] (--debug)\", args[0]);\n        return;\n    }\n\n    let src: Vec<char> = {\n        let mut buf = String::new();\n        match File::open(&args[1]) {\n            Ok(mut f) => {\n                f.read_to_string(&mut buf).unwrap();\n            }\n            Err(e) => {\n                println!(\"Error opening '{}': {}\", args[1], e);\n                return;\n            }\n        }\n\n        buf.chars().collect()\n    };\n\n    // Launch options\n    let debug = args.contains(&\"--debug\".to_owned());\n\n    // One pass to find bracket pairs.\n    let brackets: HashMap<usize, usize> = {\n        let mut m = HashMap::new();\n        let mut scope_stack = Vec::new();\n        for (idx, ch) in src.iter().enumerate() {\n            match *ch {\n                '[' => {\n                    scope_stack.push(idx);\n                }\n                ']' => {\n                    m.insert(scope_stack.pop().unwrap(), idx);\n                }\n                _ => (),\n            }\n        }\n\n        m\n    };\n\n    // Program counter\n    let mut pc: usize = 0;\n\n    // Program memory\n    let mut mem: [Wrapping<u8>; 5000] = [Wrapping(0); 5000];\n\n    // Pointer\n    let mut ptr: usize = 0;\n\n    // Bracket stack\n    let mut stack: Vec<usize> = Vec::new();\n\n    let stdin_ = stdin();\n    let mut reader = stdin_.lock().bytes();\n    while pc < src.len() {\n        let Wrapping(val) = mem[ptr];\n\n        if debug {\n            println!(\n                \"(BFDB) PC: {:04} \\tPTR: {:04} \\t$PTR: {:03} \\tSTACK_DEPTH: {} \\tSYMBOL: {}\",\n                pc,\n                ptr,\n                val,\n                stack.len(),\n                src[pc]\n            );\n        }\n\n        const ONE: Wrapping<u8> = Wrapping(1);\n        match src[pc] {\n            '>' => {\n                ptr += 1;\n            }\n            '<' => {\n                ptr -= 1;\n            }\n            '+' => {\n                mem[ptr] += ONE;\n            }\n            '-' => {\n                mem[ptr] -= ONE;\n            }\n            '[' => {\n                if val == 0 {\n                    pc = brackets[&pc];\n                } else {\n                    stack.push(pc);\n                }\n            }\n            ']' => {\n                let matching_bracket = stack.pop().unwrap();\n                if val != 0 {\n                    pc = matching_bracket - 1;\n                }\n            }\n            '.' => {\n                if debug {\n                    println!(\"(BFDB) STDOUT: '{}'\", val as char); // Intercept output\n                } else {\n                    print!(\"{}\", val as char);\n                }\n            }\n            ',' => {\n                mem[ptr] = Wrapping(reader.next().unwrap().unwrap());\n            }\n            _ => (),\n        }\n\n        pc += 1;\n    }\n}\n",
    "path": "tasks/execute-brainfuck",
    "remote_code": "use std::collections::HashMap;\nuse std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::stdin;\nuse std::num::Wrapping;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} [path] (--debug)\", args[0]);\n        return;\n    }\n\n    let src: Vec<char> = {\n        let mut buf = String::new();\n        match File::open(&args[1])\n        {\n            Ok(mut f) => { f.read_to_string(&mut buf).unwrap(); }\n            Err(e)    => {\n                println!(\"Error opening '{}': {}\", args[1], e);\n                return;\n            }\n        }\n\n        buf.chars().collect()\n    };\n\n    // Launch options\n    let debug = args.contains(&\"--debug\".to_owned());\n\n    // One pass to find bracket pairs.\n    let brackets: HashMap<usize, usize> = {\n        let mut m = HashMap::new();\n        let mut scope_stack = Vec::new();\n        for (idx, ch) in src.iter().enumerate() {\n            match ch {\n                &'[' => { scope_stack.push(idx); }\n                &']' => { m.insert(scope_stack.pop().unwrap(), idx); }\n                _    => { /* ignore */ }\n            }\n        }\n\n        m\n    };\n\n    let mut pc: usize = 0;                                  // Program counter\n    let mut mem: [Wrapping<u8>;5000] = [Wrapping(0);5000];  // Program cemory\n    let mut ptr: usize = 0;                                 // Pointer\n    let mut stack: Vec<usize> = Vec::new();                 // Bracket stack\n\n    let stdin_ = stdin();\n    let mut reader = stdin_.lock().bytes();\n    while pc < src.len() {\n        let Wrapping(val) = mem[ptr];\n\n        if debug {\n            println!(\"(BFDB) PC: {:04} \\tPTR: {:04} \\t$PTR: {:03} \\tSTACK_DEPTH: {} \\tSYMBOL: {}\", pc, ptr, val, stack.len(), src[pc]);\n        }\n\n        const ONE: Wrapping<u8> = Wrapping(1);\n        match src[pc] {\n            '>' => { ptr += 1; }\n            '<' => { ptr -= 1; }\n\n            '+' => { mem[ptr] = mem[ptr] + ONE; }\n            '-' => { mem[ptr] = mem[ptr] - ONE; }\n\n            '[' => {\n                if val == 0 {\n                    pc = brackets[&pc];\n                } else {\n                    stack.push(pc);\n                }\n            }\n            ']' => {\n                let matching_bracket = stack.pop().unwrap();\n                if val != 0 {\n                    pc = matching_bracket - 1;\n                }\n            }\n\n            '.' => {\n                if debug {\n                    println!(\"(BFDB) STDOUT: '{}'\", val as char);  // Intercept output\n                } else {\n                    print!(\"{}\", val as char);\n                }\n            }\n            ',' => {\n                mem[ptr] = Wrapping(reader.next().unwrap().unwrap());\n            }\n\n            _   => { /* ignore */ }\n        }\n\n        pc += 1;\n    }\n}",
    "title": "Execute Brain****",
    "url": "http://rosettacode.org/wiki/Execute_Brain****"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Execute Computer/Zero",
    "url": "http://rosettacode.org/wiki/Execute_Computer/Zero"
  },
  {
    "local_code": "use std::env;\n\n// HQ9+ requires that '+' increments an accumulator, but it's inaccessible (and thus, unused).\n#[allow(unused_variables)]\nfn execute(code: &str) {\n    let mut accumulator = 0;\n\n    for c in code.chars() {\n        match c {\n            'Q' => println!(\"{}\", code),\n            'H' => println!(\"Hello, World!\"),\n            '9' => {\n                for n in (1..100).rev() {\n                    println!(\"{} bottles of beer on the wall\", n);\n                    println!(\"{} bottles of beer\", n);\n                    println!(\"Take one down, pass it around\");\n                    if (n - 1) > 1 {\n                        println!(\"{} bottles of beer on the wall\\n\", n - 1);\n                    } else {\n                        println!(\"1 bottle of beer on the wall\\n\");\n                    }\n                }\n            }\n            '+' => accumulator += 1,\n            _ => panic!(\"Invalid character '{}' found in source.\", c),\n        }\n    }\n}\n\nfn main() {\n    execute(&env::args().nth(1).unwrap());\n}\n",
    "path": "tasks/execute-hq9-plus",
    "remote_code": "use std::env;\n\n// HQ9+ requires that '+' increments an accumulator, but it's inaccessible (and thus, unused).\n#[allow(unused_variables)]\nfn execute(code: &str) {\n    let mut accumulator = 0;\n\n    for c in code.chars() {\n        match c {\n            'Q' => println!(\"{}\", code),\n            'H' => println!(\"Hello, World!\"),\n            '9' => {\n                for n in (1..100).rev() {\n                    println!(\"{} bottles of beer on the wall\", n);\n                    println!(\"{} bottles of beer\", n);\n                    println!(\"Take one down, pass it around\");\n                    if (n - 1) > 1 {\n                        println!(\"{} bottles of beer on the wall\\n\", n - 1);\n                    } else {\n                        println!(\"1 bottle of beer on the wall\\n\");\n                    }\n                }\n            }\n            '+' => accumulator += 1,\n            _ => panic!(\"Invalid character '{}' found in source.\", c),\n        }\n    }\n}\n\nfn main() {\n    execute(&env::args().nth(1).unwrap());\n}",
    "title": "Execute HQ9+",
    "url": "http://rosettacode.org/wiki/Execute_HQ9%2B"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Execute SNUSP",
    "url": "http://rosettacode.org/wiki/Execute_SNUSP"
  },
  {
    "local_code": "/// Individual markov rule\nstruct MarkovRule {\n    pattern: String,\n    replacement: String,\n    stop: bool,\n}\n\nimpl MarkovRule {\n    fn new(pattern: String, replacement: String, stop: bool) -> MarkovRule {\n        MarkovRule {\n            pattern,\n            replacement,\n            stop,\n        }\n    }\n}\n\n/// The complete markov algorithm\nstruct MarkovAlgorithm {\n    rules: Vec<MarkovRule>,\n}\n\nimpl MarkovAlgorithm {\n    /// Parse an algorithm description to build a markov algorithm\n    pub fn parse(s: &str) -> Result<MarkovAlgorithm, String> {\n        let mut rules: Vec<MarkovRule> = vec![];\n        for line in s\n            .lines()\n            .map(|l| l.trim())\n            .filter(|l| matches!(l.chars().next(), Some(c) if c != '#'))\n        {\n            // Ignore comments\n\n            // check for -> (must be preceded by whitespace)\n            // invalid ruleset if absent\n            // whitespace rules mean there's 2 possible variations: \" ->\" and \"\\t->\"\n            let arrow_pos = line.find(\" ->\").or_else(|| line.find(\"\\t->\"));\n            match arrow_pos {\n                None => {\n                    // Ruleset is invalid\n                    return Err(format!(\"Invalid rule \\\"{}\\\"\", line));\n                }\n                Some(arrow) => {\n                    // extract pattern (trim trailing whitespace)\n                    let pattern = line[..arrow].trim_end();\n\n                    // get the string after the arrow\n                    // this adds 3 to skip the arrow itself\n                    let line_end = line[arrow + 3..].trim_start();\n\n                    // check for . (stop)\n                    let stop = matches!(line_end.chars().next(), Some('.'));\n\n                    // extract replacement\n                    let replacement = if stop { &line_end[1..] } else { line_end };\n\n                    // add to rules\n                    let new_rule =\n                        MarkovRule::new(pattern.to_string(), replacement.to_string(), stop);\n                    rules.push(new_rule);\n                }\n            }\n        }\n        let rule_set = MarkovAlgorithm { rules };\n        Ok(rule_set)\n    }\n\n    /// Transform a text string by applying the markov algorithm\n    pub fn apply(&self, input: &str) -> String {\n        // get a writable version of the input to work with\n        let mut state = input.to_string();\n\n        // loop while operations are possible\n        loop {\n            // find the first rule that is applicable\n            // (pattern string is in state)\n            let possible_rule = self\n                .rules\n                .iter()\n                .find(|rule| state.contains(&rule.pattern[..]));\n\n            match possible_rule {\n                // stop if no rule found\n                None => {\n                    break;\n                }\n                Some(rule) => {\n                    // replace the first instance (only) of the pattern\n                    // Note: cannot use str::replace as that replaces all instances\n\n                    // unwrap is safe here as the code for finding a rule\n                    // already established that the pattern is present\n                    let pos = state.find(&rule.pattern[..]).unwrap();\n                    let width = rule.pattern.len();\n\n                    // string parts\n                    let left = state[..pos].to_string();\n                    let right = state[pos + width..].to_string();\n\n                    // construct new string\n                    state = format!(\"{}{}{}\", left, rule.replacement, right);\n\n                    // stop if required\n                    if rule.stop {\n                        break;\n                    }\n                }\n            }\n        }\n\n        state\n    }\n}\n\n/// A Rosetta Code sample\nstruct RCSample<'a> {\n    ruleset: &'a str,\n    input: &'a str,\n    expected_result: &'a str,\n}\n\n// Sample markov algorithms from Rosetta Code\n// The extra whitespaces are trimmed when MarkovAlgorithm::parse is called.\nfn get_samples<'a>() -> [RCSample<'a>; 5] {\n    [\n        RCSample {\n            ruleset: r\"# This rules file is extracted from Wikipedia:\n                # http://en.wikipedia.org/wiki/Markov_Algorithm\n                A -> apple\n                B -> bag\n                S -> shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As from T S.\",\n            expected_result: \"I bought a bag of apples from my brother.\",\n        },\n        RCSample {\n            ruleset: r\"# Slightly modified from the rules on Wikipedia\n                A -> apple\n                B -> bag\n                S -> .shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As from T S.\",\n            expected_result: \"I bought a bag of apples from T shop.\",\n        },\n        RCSample {\n            ruleset: r\"# BNF Syntax testing rules\n                A -> apple\n                WWWW -> with\n                Bgage -> ->.*\n                B -> bag\n                ->.* -> money\n                W -> WW\n                S -> .shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As W my Bgage from T S.\",\n            expected_result: \"I bought a bag of apples with my money from T shop.\",\n        },\n        RCSample {\n            ruleset: r\"### Unary Multiplication Engine, for testing Markov Algorithm implementations\n                ### By Donal Fellows.\n                # Unary addition engine\n                _+1 -> _1+\n                1+1 -> 11+\n                # Pass for converting from the splitting of multiplication into ordinary\n                # addition\n                1! -> !1\n                ,! -> !+\n                _! -> _\n                # Unary multiplication by duplicating left side, right side times\n                1*1 -> x,@y\n                1x -> xX\n                X, -> 1,1\n                X1 -> 1X\n                _x -> _X\n                ,x -> ,X\n                y1 -> 1y\n                y_ -> _\n                # Next phase of applying\n                1@1 -> x,@y\n                1@_ -> @_\n                ,@_ -> !_\n                ++ -> +\n                # Termination cleanup for addition\n                _1 -> 1\n                1+_ -> 1\n                _+_ -> \",\n            input: \"_1111*11111_\",\n            expected_result: \"11111111111111111111\",\n        },\n        RCSample {\n            ruleset: r\"# Turing machine: three-state busy beaver\n                #\n                # state A, symbol 0 => write 1, move right, new state B\n                A0 -> 1B\n                # state A, symbol 1 => write 1, move left, new state C\n                0A1 -> C01\n                1A1 -> C11\n                # state B, symbol 0 => write 1, move left, new state A\n                0B0 -> A01\n                1B0 -> A11\n                # state B, symbol 1 => write 1, move right, new state B\n                B1 -> 1B\n                # state C, symbol 0 => write 1, move left, new state B\n                0C0 -> B01\n                1C0 -> B11\n                # state C, symbol 1 => write 1, move left, halt\n                0C1 -> H01\n                1C1 -> H11\",\n            input: \"000000A000000\",\n            expected_result: \"00011H1111000\",\n        },\n    ]\n}\n\nfn main() {\n    for (index, sample) in get_samples().iter().enumerate() {\n        match MarkovAlgorithm::parse(sample.ruleset) {\n            Ok(algorithm) => {\n                println!(\"Sample {}\", (index + 1));\n                println!(\"Output: {}\", algorithm.apply(sample.input));\n                println!(\"Expected result: {}\", sample.expected_result);\n            }\n            Err(message) => println!(\"{}\", message),\n        }\n    }\n}\n\n#[test]\nfn test_samples() {\n    for sample in &get_samples() {\n        match MarkovAlgorithm::parse(sample.ruleset) {\n            Ok(algorithm) => assert_eq!(sample.expected_result, algorithm.apply(sample.input)),\n            Err(message) => panic!(\"{}\", message),\n        }\n    }\n}\n",
    "path": "tasks/execute-a-markov-algorithm",
    "remote_code": "use std::str::FromStr;\n\n#[derive(Clone, Debug)]\npub struct Rule {\n    pub pat: String,\n    pub rep: String,\n    pub terminal: bool,\n}\n\nimpl Rule {\n    pub fn new(pat: String, rep: String, terminal: bool) -> Self {\n        Self { pat, rep, terminal }\n    }\n\n    pub fn applicable_range(&self, input: impl AsRef<str>) -> Option<std::ops::Range<usize>> {\n        input\n            .as_ref()\n            .match_indices(&self.pat)\n            .next()\n            .map(|(start, slice)| start..start + slice.len())\n    }\n\n    pub fn apply(&self, s: &mut String) -> bool {\n        self.applicable_range(s.as_str()).map_or(false, |range| {\n            s.replace_range(range, &self.rep);\n            true\n        })\n    }\n}\n\nimpl FromStr for Rule {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut split = s.splitn(2, \" -> \");\n        let pat = split.next().ok_or_else(|| s.to_string())?;\n        let rep = split.next().ok_or_else(|| s.to_string())?;\n\n        let pat = pat.to_string();\n        if rep.starts_with('.') {\n            Ok(Self::new(pat, rep[1..].to_string(), true))\n        } else {\n            Ok(Self::new(pat, rep.to_string(), false))\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Rules {\n    rules: Vec<Rule>,\n}\n\nimpl Rules {\n    pub fn new(rules: Vec<Rule>) -> Self {\n        Self { rules }\n    }\n\n    pub fn apply(&self, s: &mut String) -> Option<&Rule> {\n        self.rules\n            .iter()\n            .find(|rule| rule.apply(s))\n    }\n\n    pub fn execute(&self, mut buffer: String) -> String {\n        while let Some(rule) = self.apply(&mut buffer) {\n            if rule.terminal {\n                break;\n            }\n        }\n\n        buffer\n    }\n}\n\nimpl FromStr for Rules {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut rules = Vec::new();\n\n        for line in s.lines().filter(|line| !line.starts_with('#')) {\n            rules.push(line.parse::<Rule>()?);\n        }\n\n        Ok(Rules::new(rules))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::Rules;\n\n    #[test]\n    fn case_01() -> Result<(), String> {\n        let input = \"I bought a B of As from T S.\";\n        let rules = \"\\\n# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\";\n\n        assert_eq!(\n            rules.parse::<Rules>()?.execute(input.to_string()),\n            \"I bought a bag of apples from my brother.\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn case_02() -> Result<(), String> {\n        let input = \"I bought a B of As from T S.\";\n        let rules = \"\\\n# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\";\n\n        assert_eq!(\n            rules.parse::<Rules>()?.execute(input.to_string()),\n            \"I bought a bag of apples from T shop.\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn case_03() -> Result<(), String> {\n        let input = \"I bought a B of As W my Bgage from T S.\";\n        let rules = \"\\\n# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\";\n\n        assert_eq!(\n            rules.parse::<Rules>()?.execute(input.to_string()),\n            \"I bought a bag of apples with my money from T shop.\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn case_04() -> Result<(), String> {\n        let input = \"_1111*11111_\";\n        let rules = \"\\\n### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ -> \";\n\n        assert_eq!(\n            rules.parse::<Rules>()?.execute(input.to_string()),\n            \"11111111111111111111\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn case_05() -> Result<(), String> {\n        let input = \"000000A000000\";\n        let rules = \"\\\n# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\";\n\n        assert_eq!(\n            rules.parse::<Rules>()?.execute(input.to_string()),\n            \"00011H1111000\"\n        );\n\n        Ok(())\n    }\n}\n",
    "title": "Execute a Markov algorithm",
    "url": "http://rosettacode.org/wiki/Execute_a_Markov_algorithm"
  },
  {
    "local_code": "use std::process::Command;\n\nfn main() {\n    let output = Command::new(\"ls\")\n        .output()\n        .unwrap_or_else(|e| panic!(\"failed to execute process: {}\", e));\n    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n}\n",
    "path": "tasks/execute-a-system-command",
    "remote_code": "use std::process::Command;\nfn main() {\n    let output = Command::new(\"ls\").output().unwrap_or_else(|e| {\n        panic!(\"failed to execute process: {}\", e)\n    });\n    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n}\n",
    "title": "Execute a system command",
    "url": "http://rosettacode.org/wiki/Execute_a_system_command"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate num;\nuse num::traits::One;\nuse std::ops::Mul;\n\nfn pow<T>(mut base: T, mut exp: usize) -> T \n    where T: Clone + One + Mul<T, Output=T>\n{\n    if exp == 0 { return T::one() }\n    while exp & 1 == 0 {\n        base = base.clone() * base;\n        exp >>= 1;\n    }\n    if exp == 1 { return base }\n    let mut acc = base.clone();\n\n    while exp > 1 {\n        exp >>= 1;\n        base = base.clone() * base;\n        if exp & 1 == 1 {\n            acc = acc * base.clone();\n        }\n    }\n    acc\n}",
    "title": "Exponentiation operator",
    "url": "http://rosettacode.org/wiki/Exponentiation_operator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\"5**3**2   = {:7}\", 5u32.pow(3).pow(2));\n    println!(\"(5**3)**2 = {:7}\", (5u32.pow(3)).pow(2));\n    println!(\"5**(3**2) = {:7}\", 5u32.pow(3u32.pow(2)));\n}",
    "title": "Exponentiation order",
    "url": "http://rosettacode.org/wiki/Exponentiation_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Exponentiation with infix operators in (or operating on) the base",
    "url": "http://rosettacode.org/wiki/Exponentiation_with_infix_operators_in_(or_operating_on)_the_base"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![allow(unused_variables)]\nmacro_rules! if2 {\n    ($cond1: expr, $cond2: expr \n        => $both:expr \n        => $first: expr \n        => $second:expr \n        => $none:expr) \n    => {\n        match ($cond1, $cond2) {\n            (true, true) => $both,\n            (true, _   ) => $first,\n            (_   , true) => $second,\n            _            => $none\n        }\n    }\n}\n\nfn main() {\n    let i = 1;\n    let j = 2;\n    if2!(i > j, i + j >= 3\n        => {\n            // code blocks and statements can go here also\n            let k = i + j;\n            println!(\"both were true\")\n        }\n        => println!(\"the first was true\")\n        => println!(\"the second was true\")\n        => println!(\"neither were true\")\n    )\n}",
    "title": "Extend your language",
    "url": "http://rosettacode.org/wiki/Extend_your_language"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "mod pagesieve;\n\nuse pagesieve::{count_primes_paged, primes_paged};\n\nfn main() {\n    println!(\"First 20 primes:\\n {:?}\",\n             primes_paged().take(20).collect::<Vec<_>>());\n    println!(\"Primes between 100 and 150:\\n {:?}\",\n             primes_paged().skip_while(|&x| x < 100)\n                           .take_while(|&x| x < 150)\n                           .collect::<Vec<_>>());\n    let diff = count_primes_paged(8000) - count_primes_paged(7700);\n    println!(\"There are {} primes between 7,700 and 8,000\", diff);\n    // rust enumerations are zero base, so need to subtract 1!!!\n    println!(\"The 10,000th prime is {}\", primes_paged().nth(10_000 - 1).unwrap());\n}",
    "title": "Extensible prime generator",
    "url": "http://rosettacode.org/wiki/Extensible_prime_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let inf: f64 = 1. / 0.;          // or std::f64::INFINITY\n    let minus_inf: f64 = -1. / 0.;   // or std::f64::NEG_INFINITY\n    let minus_zero: f64 = -1. / inf; // or -0.0\n    let nan: f64 = 0. / 0.;          // or std::f64::NAN\n                                     // or std::f32 for the above\n    println!(\"positive infinity: {:+}\", inf);\n    println!(\"negative infinity: {:+}\", minus_inf);\n    println!(\"negative zero: {:+?}\", minus_zero);\n    println!(\"not a number: {:+}\", nan);\n    println!();\n    println!(\"+inf + 2.0 = {:+}\", inf + 2.);\n    println!(\"+inf - 10.0 = {:+}\", inf - 10.);\n    println!(\"+inf + -inf = {:+}\", inf + minus_inf);\n    println!(\"0.0 * inf = {:+}\", 0. * inf);\n    println!(\"1.0 / -0.0 = {:+}\", 1. / -0.);\n    println!(\"NaN + 1.0 = {:+}\", nan + 1.);\n    println!(\"NaN + NaN = {:+}\", nan + nan);\n    println!();\n    println!(\"NaN == NaN = {}\", nan == nan);\n    println!(\"0.0 == -0.0 = {}\", 0. == -0.);\n}",
    "title": "Extreme floating point values",
    "url": "http://rosettacode.org/wiki/Extreme_floating_point_values"
  },
  {
    "local_code": "//! Ported and adapted from rosettacode D example\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn format_fasta<T: BufRead>(reader: &mut T) -> String {\n    reader\n        .lines()\n        .map(|l| l.unwrap())\n        .fold(String::new(), |mut out, line| {\n            // We need to trim new lines\n            let ln = line.trim();\n\n            // Lines that begin with '>' require special treatment\n            match &ln[..1] {\n                \">\" => {\n                    if !out.is_empty() {\n                        out.push('\\n');\n                    }\n\n                    // Push skipping the '>'\n                    out.push_str(&ln[1..]);\n                    out.push_str(\": \");\n                }\n                // Other lines are just pushed\n                _ => out.push_str(ln),\n            }\n            out\n        })\n}\n\nfn read_file() -> String {\n    let file = File::open(\"resources/test_data.fasta\").unwrap();\n    format_fasta(&mut BufReader::new(file))\n}\n\nfn main() {\n    let s = read_file();\n    println!(\"{}\", s);\n}\n\n#[test]\nfn test_format_fasta() {\n    let s = read_file();\n    assert_eq!(\n        s,\n        r\"Rosetta_Example_1: THERECANBENOSPACE\nRosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\"\n    );\n}\n",
    "path": "tasks/fasta-format",
    "remote_code": "\nuse std::env;\nuse std::io::{BufReader, Lines};\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let f = File::open(&args[1]).unwrap();\n    for line in FastaIter::new(f) {\n        println!(\"{}\", line);\n    }\n}\n\nstruct FastaIter<T> {\n    buffer_lines: Lines<BufReader<T>>,\n    current_name: Option<String>,\n    current_sequence: String\n}\n\nimpl<T: Read> FastaIter<T> {\n    fn new(file: T) -> FastaIter<T> {\n        FastaIter { buffer_lines: BufReader::new(file).lines(),\n                    current_name: None,\n                    current_sequence: String::new() }\n    }\n}\n\nimpl<T: Read> Iterator for FastaIter<T> {\n    type Item = String;\n\n    fn next(&mut self) -> Option<String> {\n        while let Some(l) = self.buffer_lines.next() {\n            let line = l.unwrap();\n            if line.starts_with(\">\") {\n                if self.current_name.is_some() {                    \n                    let mut res = String::new();\n                    res.push_str(self.current_name.as_ref().unwrap());\n                    res.push_str(\": \");\n                    res.push_str(&self.current_sequence);\n                    self.current_name = Some(String::from(&line[1..]));\n                    self.current_sequence.clear();\n                    return Some(res);\n                } else {\n                    self.current_name = Some(String::from(&line[1..]));\n                    self.current_sequence.clear();\n                }\n                continue;\n            }\n            self.current_sequence.push_str(line.trim());\n        }\n        if self.current_name.is_some() {\n            let mut res = String::new();\n            res.push_str(self.current_name.as_ref().unwrap());\n            res.push_str(\": \");\n            res.push_str(&self.current_sequence);\n            self.current_name = None;\n            self.current_sequence.clear();\n            self.current_sequence.shrink_to_fit();\n            return Some(res);\n        }\n        None\n    }\n}\n",
    "title": "FASTA format",
    "url": "http://rosettacode.org/wiki/FASTA_format"
  },
  {
    "local_code": "use std::error::Error;\nuse std::io;\n\nuse ftp::types::{FileType, FtpError};\nuse ftp::FtpStream;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // connect to the server\n    let mut ftp = FtpStream::connect(\"mirrors.sonic.net:21\")?;\n    ftp.login(\"anonymous\", \"\")?;\n\n    // change working directory\n    ftp.cwd(\"/pub/OpenBSD/doc\")?;\n\n    // list files in the current directory\n    for line in ftp.list(None)? {\n        println!(\"{}\", line);\n    }\n\n    // download a file a write it on the disk\n    let file_name = \"README\";\n    ftp.transfer_type(FileType::Binary)?;\n    ftp.retr(file_name, move |data| {\n        let mut local_file = File::create(file_name).map_err(FtpError::ConnectionError)?;\n        io::copy(data, &mut local_file).map_err(FtpError::ConnectionError)\n    })?;\n\n    Ok(())\n}\n",
    "path": "tasks/ftp",
    "remote_code": "use std::{error::Error, fs::File, io::copy};\nuse ftp::FtpStream;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut ftp = FtpStream::connect(\"ftp.easynet.fr:21\")?;\n    ftp.login(\"anonymous\", \"\")?;\n    ftp.cwd(\"debian\")?;\n    for file in ftp.list(None)? {\n        println!(\"{}\", file);\n    }\n    let mut stream = ftp.get(\"README\")?;\n    let mut file = File::create(\"README\")?;\n    copy(&mut stream, &mut file)?;\n    Ok(())\n}",
    "title": "FTP",
    "url": "http://rosettacode.org/wiki/FTP"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Faces from a mesh",
    "url": "http://rosettacode.org/wiki/Faces_from_a_mesh"
  },
  {
    "local_code": "/// Calculate the factorial using recursion\npub fn factorial_recursive(n: usize) -> usize {\n    match n {\n        0 => 1,\n        _ => n * factorial_recursive(n - 1),\n    }\n}\n\n/// Calculate the factorial using a fold\npub fn factorial_iterative(n: usize) -> usize {\n    (1..n + 1).product()\n}\n\n/// Calculate the factorial using a for loop\npub fn factorial_loop(n: usize) -> usize {\n    let mut fac = 1;\n    for x in 1..n + 1 {\n        fac *= x;\n    }\n    fac\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{factorial_iterative, factorial_loop, factorial_recursive};\n\n    /// Tests\n    fn t(f: fn(usize) -> usize) {\n        assert_eq!(f(0), 1);\n        assert_eq!(f(1), 1);\n        assert_eq!(f(2), 2);\n        assert_eq!(f(3), 6);\n        assert_eq!(f(4), 24);\n        assert_eq!(f(5), 120);\n        assert_eq!(f(6), 720);\n        assert_eq!(f(7), 5040);\n        assert_eq!(f(8), 40320);\n        assert_eq!(f(9), 362880);\n        assert_eq!(f(10), 3628800);\n    }\n\n    #[test]\n    fn test_fac_recursive() {\n        t(factorial_recursive as fn(usize) -> usize)\n    }\n\n    #[test]\n    fn test_fac_iterative() {\n        t(factorial_iterative as fn(usize) -> usize)\n    }\n\n    #[test]\n    fn test_fac_loop() {\n        t(factorial_loop as fn(usize) -> usize)\n    }\n}\nuse factorial::{factorial_iterative, factorial_loop, factorial_recursive};\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn benchmark(c: &mut Criterion) {\n    c.bench_function(\"iterative\", |b| {\n        b.iter(|| factorial_iterative(black_box(20)))\n    });\n    c.bench_function(\"recursive\", |b| {\n        b.iter(|| factorial_recursive(black_box(20)))\n    });\n    c.bench_function(\"loop\", |b| b.iter(|| factorial_loop(black_box(20))));\n}\n\ncriterion_group!(benches, benchmark);\ncriterion_main!(benches);\nuse factorial::{factorial_iterative, factorial_loop, factorial_recursive};\n\nfn main() {\n    let fs = vec![\n        (\"Recursive\", factorial_recursive as fn(usize) -> usize),\n        (\"Iterative\", factorial_iterative as fn(usize) -> usize),\n        (\"Looooooop\", factorial_loop as fn(usize) -> usize),\n    ];\n    for (name, f) in fs {\n        println!(\"---------\\n{}\", name);\n        for i in 1..10 {\n            println!(\"{}\", f(i))\n        }\n    }\n}\n",
    "path": "tasks/factorial",
    "remote_code": "fn factorial_recursive (n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => n * factorial_recursive(n-1)\n    }\n}\n\nfn factorial_iterative(n: u64) -> u64 {\n    (1..=n).product()\n}\n\nfn main () {\n    for i in 1..10 {\n        println!(\"{}\", factorial_recursive(i))\n    }\n    for i in 1..10 {\n        println!(\"{}\", factorial_iterative(i))\n    }\n}\n",
    "title": "Factorial",
    "url": "http://rosettacode.org/wiki/Factorial"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Factorial base numbers indexing permutations of a collection",
    "url": "http://rosettacode.org/wiki/Factorial_base_numbers_indexing_permutations_of_a_collection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Factorions",
    "url": "http://rosettacode.org/wiki/Factorions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn bit_count(mut n: usize) -> usize {\n    let mut count = 0;\n    while n > 0 {\n        n >>= 1;\n        count += 1;\n    }\n    count\n}\n\nfn mod_pow(p: usize, n: usize) -> usize {\n    let mut square = 1;\n    let mut bits = bit_count(p);\n    while bits > 0 {\n        square = square * square;\n        bits -= 1;\n        if (p & (1 << bits)) != 0 {\n            square <<= 1;\n        }\n        square %= n;\n    }\n    return square;\n}\n\nfn is_prime(n: usize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn find_mersenne_factor(p: usize) -> usize {\n    let mut k = 0;\n    loop {\n        k += 1;\n        let q = 2 * k * p + 1;\n        if q % 8 == 1 || q % 8 == 7 {\n            if mod_pow(p, q) == 1 && is_prime(p) {\n                return q;\n            }\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", find_mersenne_factor(929));\n}",
    "title": "Factors of a Mersenne number",
    "url": "http://rosettacode.org/wiki/Factors_of_a_Mersenne_number"
  },
  {
    "local_code": "fn main() {\n    let target = 78i32;\n    println!(\"Factors of integer {}:\", target);\n    let factors = factor_int(target);\n\n    for f in factors {\n        println!(\"{}\", f);\n    }\n}\n\n/// Compute the factors of an integer\n/// This method uses a simple check on each value between 1 and sqrt(x) to find\n/// pairs of factors\nfn factor_int(x: i32) -> Vec<i32> {\n    let mut factors: Vec<i32> = Vec::new();\n\n    let bound: i32 = f64::from(x).sqrt().floor() as i32;\n\n    for i in 1i32..bound {\n        if x % i == 0 {\n            factors.push(i);\n            factors.push(x / i);\n        }\n    }\n\n    factors\n}\n\n#[test]\nfn test() {\n    let result = factor_int(78i32);\n    assert_eq!(result, vec![1i32, 78, 2, 39, 3, 26, 6, 13]);\n}\n",
    "path": "tasks/factors-of-an-integer",
    "remote_code": "fn main() {\n    assert_eq!(vec![1, 2, 4, 5, 10, 10, 20, 25, 50, 100], factor(100)); // asserts that two expressions are equal to each other\n    assert_eq!(vec![1, 101], factor(101));\n\n}\n\nfn factor(num: i32) -> Vec<i32> {\n    let mut factors: Vec<i32> = Vec::new(); // creates a new vector for the factors of the number\n\n    for i in 1..((num as f32).sqrt() as i32 + 1) { \n        if num % i == 0 {\n            factors.push(i); // pushes smallest factor to factors\n            factors.push(num/i); // pushes largest factor to factors\n        }\n    }\n    factors.sort(); // sorts the factors into numerical order for viewing purposes\n    factors // returns the factors\n}",
    "title": "Factors of an integer",
    "url": "http://rosettacode.org/wiki/Factors_of_an_integer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct Digits {\n    rest: usize,\n    base: usize,\n}\n\nimpl Iterator for Digits {\n    type Item = usize;\n    \n    fn next(&mut self) -> Option<usize> {\n        if self.rest == 0 {\n            return None;\n        }\n        let (digit, rest) = (self.rest % self.base, self.rest / self.base);\n        self.rest = rest;\n        Some(digit)\n    }\n}\n\nfn digits(num: usize, base: usize) -> Digits {\n    Digits { rest: num, base: base }\n}\n\nstruct FairSharing {\n    participants: usize,\n    index: usize,\n}\n\nimpl Iterator for FairSharing {\n    type Item = usize;\n    fn next(&mut self) -> Option<usize> {\n        let digit_sum: usize = digits(self.index, self.participants).sum();\n        let selected = digit_sum % self.participants;\n        self.index += 1;\n        Some(selected)\n    }\n}\n\nfn fair_sharing(participants: usize) -> FairSharing {\n    FairSharing { participants: participants, index: 0 }\n}\n\nfn main() {\n    for i in vec![2, 3, 5, 7] {\n        println!(\"{}: {:?}\", i, fair_sharing(i).take(25).collect::<Vec<usize>>());\n    }\n}",
    "title": "Fairshare between two and more",
    "url": "http://rosettacode.org/wiki/Fairshare_between_two_and_more"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Copy, Clone)]\nstruct Fraction {\n    numerator: u32,\n    denominator: u32,\n}\n\nuse std::fmt;\n\nimpl fmt::Display for Fraction {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}/{}\", self.numerator, self.denominator)\n    }\n}\n\nimpl Fraction {\n    fn new(n: u32, d: u32) -> Fraction {\n        Fraction {\n            numerator: n,\n            denominator: d,\n        }\n    }\n}\n\nfn farey_sequence(n: u32) -> impl std::iter::Iterator<Item = Fraction> {\n    let mut a = 0;\n    let mut b = 1;\n    let mut c = 1;\n    let mut d = n;\n    std::iter::from_fn(move || {\n        if a > n {\n            return None;\n        }\n        let result = Fraction::new(a, b);\n        let k = (n + b) / d;\n        let next_c = k * c - a;\n        let next_d = k * d - b;\n        a = c;\n        b = d;\n        c = next_c;\n        d = next_d;\n        Some(result)\n    })\n}\n\nfn main() {\n    for n in 1..=11 {\n        print!(\"{}:\", n);\n        for f in farey_sequence(n) {\n            print!(\" {}\", f);\n        }\n        println!();\n    }\n    for n in (100..=1000).step_by(100) {\n        println!(\"{}: {}\", n, farey_sequence(n).count());\n    }\n}",
    "title": "Farey sequence",
    "url": "http://rosettacode.org/wiki/Farey_sequence"
  },
  {
    "local_code": "extern crate num;\n\nuse num::complex::Complex;\nuse std::f32::consts::PI;\nuse std::iter::repeat;\n\nfn fft(arr: &[Complex<f32>]) -> Vec<Complex<f32>> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n\n    let mut even = Vec::with_capacity(arr.len() / 2);\n    let mut odd = Vec::with_capacity(arr.len() / 2);\n\n    for (i, val) in arr.iter().enumerate() {\n        if i % 2 == 0 {\n            even.push(*val);\n        } else {\n            odd.push(*val);\n        }\n    }\n\n    let even_fft = fft(&even[..]);\n    let odd_fft = fft(&odd[..]);\n\n    let mut out: Vec<Complex<f32>> = repeat(Complex::new(0f32, 0f32)).take(arr.len()).collect();\n    for i in 0..arr.len() / 2 {\n        let twiddle: Complex<f32> =\n            Complex::from_polar(1f32, -2f32 * PI * (i as f32) / (arr.len() as f32));\n        out[i] = even_fft[i] + twiddle * odd_fft[i];\n        out[i + arr.len() / 2] = even_fft[i] - twiddle * odd_fft[i];\n    }\n\n    out\n}\n\nfn main() {\n    let test = [\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n    ];\n\n    let test_fft = fft(&test[..]);\n    println!(\"{:?}\", test_fft);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::fft;\n    use num::complex::Complex;\n\n    #[test]\n    fn transform() {\n        let test = [\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n        ];\n        let target = [\n            Complex::new(4f32, 0f32),\n            Complex::new(1f32, -2.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, -0.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, 0.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, 2.414f32),\n        ];\n\n        let test_fft = fft(&test[..]);\n        println!(\"{:?}\", target.to_vec());\n        println!(\"{:?}\", test_fft);\n        for (test_item, target_item) in test_fft.iter().zip(target.iter()) {\n            assert!((*test_item - *target_item).norm_sqr() < 1e-6);\n        }\n    }\n}\n",
    "path": "tasks/fast-fourier-transform",
    "remote_code": "extern crate num;\nuse num::complex::Complex;\nuse std::f64::consts::PI;\n\nconst I: Complex<f64> = Complex { re: 0.0, im: 1.0 };\n\npub fn fft(input: &[Complex<f64>]) -> Vec<Complex<f64>> {\n    fn fft_inner(\n        buf_a: &mut [Complex<f64>],\n        buf_b: &mut [Complex<f64>],\n        n: usize,    // total length of the input array\n        step: usize, // precalculated values for t\n    ) {\n        if step >= n {\n            return;\n        }\n\n        fft_inner(buf_b, buf_a, n, step * 2);\n        fft_inner(&mut buf_b[step..], &mut buf_a[step..], n, step * 2);\n        // create a slice for each half of buf_a:\n        let (left, right) = buf_a.split_at_mut(n / 2);\n\n        for i in (0..n).step_by(step * 2) {\n            let t = (-I * PI * (i as f64) / (n as f64)).exp() * buf_b[i + step];\n            left[i / 2] = buf_b[i] + t;\n            right[i / 2] = buf_b[i] - t;\n        }\n    }\n\n    // round n (length) up to a power of 2:\n    let n_orig = input.len();\n    let n = n_orig.next_power_of_two();\n    // copy the input into a buffer:\n    let mut buf_a = input.to_vec();\n    // right pad with zeros to a power of two:\n    buf_a.append(&mut vec![Complex { re: 0.0, im: 0.0 }; n - n_orig]);\n    // alternate between buf_a and buf_b to avoid allocating a new vector each time:\n    let mut buf_b = buf_a.clone();\n    fft_inner(&mut buf_a, &mut buf_b, n, 1);\n    buf_a\n}\n\nfn show(label: &str, buf: &[Complex<f64>]) {\n    println!(\"{}\", label);\n    let string = buf\n        .into_iter()\n        .map(|x| format!(\"{:.4}{:+.4}i\", x.re, x.im))\n        .collect::<Vec<_>>()\n        .join(\", \");\n    println!(\"{}\", string);\n}\n\nfn main() {\n    let input: Vec<_> = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n        .into_iter()\n        .map(|x| Complex::from(x))\n        .collect();\n    show(\"input:\", &input);\n    let output = fft(&input);\n    show(\"output:\", &output);\n}",
    "title": "Fast Fourier transform",
    "url": "http://rosettacode.org/wiki/Fast_Fourier_transform"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Faulhaber's formula",
    "url": "http://rosettacode.org/wiki/Faulhaber's_formula"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Faulhaber's triangle",
    "url": "http://rosettacode.org/wiki/Faulhaber's_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Feigenbaum constant calculation",
    "url": "http://rosettacode.org/wiki/Feigenbaum_constant_calculation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": " struct DivisorGen {\n    curr: u64,\n    last: u64,\n}\n\nimpl Iterator for DivisorGen {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        self.curr += 2u64;\n\n        if self.curr < self.last{\n            None\n        } else {\n            Some(self.curr)\n        }\n    }\n}\n\nfn divisor_gen(num : u64) -> DivisorGen {\n    DivisorGen { curr: 0u64, last: (num / 2u64) + 1u64 }\n}\n\nfn is_prime(num : u64) -> bool{\n    if num == 2 || num == 3 {\n        return true;\n    } else if num % 2 == 0 || num % 3 == 0 || num <= 1{\n        return false;\n    }else{\n        for i in divisor_gen(num){\n            if num % i == 0{\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nfn main() {\n    let fermat_closure = |i : u32| -> u64 {2u64.pow(2u32.pow(i + 1u32))};\n    let mut f_numbers : Vec<u64> = Vec::new();\n    \n    println!(\"First 4 Fermat numbers:\");\n    for i in 0..4 {\n        let f = fermat_closure(i) + 1u64;\n        f_numbers.push(f);\n        println!(\"F{}: {}\", i, f);\n    }\n    \n    println!(\"Factor of the first four numbers:\");\n    for f in f_numbers.iter(){\n        let is_prime : bool = f % 4 == 1 && is_prime(*f);\n        let not_or_not = if is_prime {\" \"} else {\" not \"};\n        println!(\"{} is{}prime\", f, not_or_not);\n    }\n}",
    "title": "Fermat numbers",
    "url": "http://rosettacode.org/wiki/Fermat_numbers"
  },
  {
    "local_code": "/// state for producing generalized Fibonacci sequences\nstruct GenFibonacci {\n    /// current values being summed\n    buf: Vec<u64>,\n\n    /// current sum\n    sum: u64,\n\n    /// index of smallest element\n    idx: usize,\n}\n\n/// note: iterator starts with values *after* the buffer contents\nimpl Iterator for GenFibonacci {\n    type Item = u64;\n    fn next(&mut self) -> Option<u64> {\n        let result = self.sum; // capture current sum\n        self.sum += result - self.buf[self.idx]; // add new elt, subtract old\n        self.buf[self.idx] = result; // write new elt to buffer\n        self.idx = (self.idx + 1) % self.buf.len(); // advance index\n        Some(result) // return result\n    }\n}\n\n/// prints the starting buf and len number of additional elements\nfn print(buf: Vec<u64>, len: usize) {\n    let mut sum = 0;\n    for &elt in &buf {\n        sum += elt;\n        print!(\"\\t{}\", elt);\n    }\n    let iter = GenFibonacci { buf, sum, idx: 0 };\n    for x in iter.take(len) {\n        print!(\"\\t{}\", x);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::GenFibonacci;\n\n    /// test equivalence between tgt and sequence generated from buf\n    fn test(mut buf: Vec<u64>, tgt: Vec<u64>) {\n        let mut sum = 0;\n        for elt in &buf {\n            sum += *elt;\n        }\n        let mut iter = GenFibonacci {\n            buf: buf.clone(),\n            sum,\n            idx: 0,\n        };\n        while buf.len() < tgt.len() {\n            buf.push(iter.next().unwrap());\n        }\n\n        assert_eq!(buf, tgt);\n    }\n\n    #[test]\n    fn test_fib2() {\n        test(vec![1, 1], vec![1, 1, 2, 3, 5, 8, 13, 21, 34, 55]);\n    }\n    #[test]\n    fn test_fib3() {\n        test(vec![1, 1, 2], vec![1, 1, 2, 4, 7, 13, 24, 44, 81, 149]);\n    }\n    #[test]\n    fn test_fib4() {\n        test(vec![1, 1, 2, 4], vec![1, 1, 2, 4, 8, 15, 29, 56, 108, 208]);\n    }\n    #[test]\n    fn test_lucas() {\n        test(vec![2, 1], vec![2, 1, 3, 4, 7, 11, 18, 29, 47, 76]);\n    }\n}\n\n// main() should print:\n// Fib2:\t1\t1\t2\t3\t5\t8\t13\t21\t34\t55\n// Fib3:\t1\t1\t2\t4\t7\t13\t24\t44\t81\t149\n// Fib4:\t1\t1\t2\t4\t8\t15\t29\t56\t108\t208\n// Lucas:\t2\t1\t3\t4\t7\t11\t18\t29\t47\t76\nfn main() {\n    print!(\"Fib2:\");\n    print(vec![1, 1], 10 - 2);\n\n    print!(\"\\nFib3:\");\n    print(vec![1, 1, 2], 10 - 3);\n\n    print!(\"\\nFib4:\");\n    print(vec![1, 1, 2, 4], 10 - 4);\n\n    print!(\"\\nLucas:\");\n    print(vec![2, 1], 10 - 2);\n}\n",
    "path": "tasks/fibonacci-n-step-number-sequences",
    "remote_code": " \nstruct GenFibonacci {\n    buf:    Vec<u64>,\n    sum:    u64,\n    idx:    usize,\n}\n\nimpl Iterator for GenFibonacci {\n    type Item = u64;\n    fn next(&mut self) -> Option<u64> {\n        let result = Some(self.sum);\n        self.sum -= self.buf[self.idx];\n        self.buf[self.idx] += self.sum;\n        self.sum += self.buf[self.idx];\n        self.idx = (self.idx + 1) % self.buf.len();\n        result\n    }\n}\n\nfn print(buf: Vec<u64>, len: usize) {\n    let mut sum = 0;\n    for &elt in buf.iter() { sum += elt; print!(\"\\t{}\", elt); }\n    let iter = GenFibonacci { buf: buf, sum: sum, idx: 0 };\n    for x in iter.take(len) {\n        print!(\"\\t{}\", x);\n    }\n}\n\n\nfn main() {\n    print!(\"Fib2:\");\n    print(vec![1,1], 10 - 2);\n    \n    print!(\"\\nFib3:\");\n    print(vec![1,1,2], 10 - 3);\n    \n    print!(\"\\nFib4:\");\n    print(vec![1,1,2,4], 10 - 4);\n    \n    print!(\"\\nLucas:\");\n    print(vec![2,1], 10 - 2);\n}\n",
    "title": "Fibonacci n-step number sequences",
    "url": "http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences"
  },
  {
    "local_code": "//Iterator \"Successors\"\nfn main() {\n    std::iter::successors(Some((1u128, 0)), |&(a, b)| a.checked_add(b).map(|s| (b, s)))\n        .for_each(|(_, u)| println!(\"{}\", u));\n}\nfn main() {\n    let fns = vec![\n        (fib_recursive as fn(u64) -> u64, \"recursive\"),\n        (fib_tail_recursive as fn(u64) -> u64, \"tail recursive\"),\n        (fib_iterative as fn(u64) -> u64, \"iterative\"),\n    ];\n\n    for (f, desc) in fns {\n        let r = (0u64..10).map(f).collect::<Vec<u64>>();\n        println!(\"{} implementation:\\n{:?}\\n\", desc, r);\n    }\n}\n\n/// Fibonacci \"classic\" recursive version\n/// not tail recursive (it's going to blow the stack for n too high)\nfn fib_recursive(n: u64) -> u64 {\n    match n {\n        0 | 1 => n,\n        n => fib_recursive(n - 1) + fib_recursive(n - 2),\n    }\n}\n\n/// tail recursive version\nfn fib_tail_recursive(n: u64) -> u64 {\n    fn in_fib(n: u64, current: u64, next: u64) -> u64 {\n        match n {\n            0 => current,\n            n => in_fib(n - 1, next, current + next),\n        }\n    }\n\n    in_fib(n, 0, 1)\n}\n\n/// iterative version\nfn fib_iterative(n: u64) -> u64 {\n    let (mut cur, mut next) = (0u64, 1u64);\n\n    for _ in 0u64..n {\n        let tmp = cur + next;\n        cur = next;\n        next = tmp;\n    }\n\n    cur\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{fib_iterative, fib_recursive, fib_tail_recursive};\n\n    /// helper function to test that all versions of the fib function\n    /// return the expected values.\n    fn tester(f: fn(u64) -> u64) {\n        let exp = [0u64, 1, 1, 2, 3, 5, 8, 13, 21, 34];\n        for (i, expected) in (0u64..10).zip(exp.iter()) {\n            assert_eq!(f(i), *expected);\n        }\n    }\n\n    #[test]\n    fn fib_values() {\n        let fns = vec![\n            fib_recursive as fn(u64) -> u64,\n            fib_tail_recursive as fn(u64) -> u64,\n            fib_iterative as fn(u64) -> u64,\n        ];\n        for &f in &fns {\n            tester(f);\n        }\n    }\n}\n",
    "path": "tasks/fibonacci-sequence",
    "remote_code": "fn main() {\n    let mut prev = 0;\n    // Rust needs this type hint for the checked_add method\n    let mut curr = 1usize;\n\n    while let Some(n) = curr.checked_add(prev) {\n        prev = curr;\n        curr = n;\n        println!(\"{}\", n);\n    }\n}",
    "title": "Fibonacci sequence",
    "url": "http://rosettacode.org/wiki/Fibonacci_sequence"
  },
  {
    "local_code": "extern crate entropy;\n\nuse entropy::shannon_entropy;\n\n/// Returns \"amount\" fibonacci words as a vector of tuples\n/// The first value of the tuple is the length of the word\n/// and the second one its entropy\nfn fib_words(amount: usize) -> Vec<(usize, f64)> {\n    let mut data = Vec::with_capacity(amount);\n    let mut previous = String::from(\"1\");\n    let mut next = String::from(\"0\");\n\n    // The first two words (we need to add them manually because\n    // they are the base of the sequence)\n    data.push((previous.len(), shannon_entropy(&previous[..])));\n    data.push((next.len(), shannon_entropy(&next[..])));\n\n    // The rest of the words\n    for _ in 3..(amount + 1) {\n        let temp = next.clone();\n        next.push_str(&previous[..]);\n        previous = temp;\n        data.push((next.len(), shannon_entropy(&next[..])));\n    }\n\n    data\n}\n\n#[allow(clippy::print_literal)]\nfn main() {\n    println!(\"Calculating... This may take a couple of minutes...\\n\");\n\n    let words = fib_words(18);\n    let mut i = 1;\n\n    println!(\"{:>2}:{:>10} {}\", \"N\", \"length\", \"entropy\");\n    for &(length, entropy) in &words {\n        println!(\"{:>2}:{:>10} {:.15}\", i, length, entropy);\n        i += 1;\n    }\n}\n\n#[test]\nfn test_fibonacii_words() {\n    let expected = vec![\n        (1, 0.000000000000000f64),\n        (1, 0.000000000000000),\n        (2, 1.000000000000000),\n        (3, 0.918295834054490),\n        (5, 0.970950594454669),\n        (8, 0.954434002924965),\n        (13, 0.961236604722876),\n        (21, 0.958711882977132),\n        (34, 0.959686893774217),\n        (55, 0.959316032054378),\n        (89, 0.959457915838670),\n        (144, 0.959403754221023),\n        (233, 0.959424446955987),\n        (377, 0.959416543740441),\n        (610, 0.959419562603144),\n        (987, 0.959418409515224),\n        (1597, 0.959418849957810),\n        (2584, 0.959418681724032),\n    ];\n\n    let epsilon = 0.0000000001f64;\n    let output = fib_words(18);\n\n    for ((output_length, output_entropy), (expected_length, expected_entropy)) in\n        output.into_iter().zip(expected.into_iter())\n    {\n        assert!(output_length == expected_length);\n        assert!((output_entropy - expected_entropy).abs() < epsilon);\n    }\n}\n",
    "path": "tasks/fibonacci-word",
    "remote_code": "struct Fib<T> {\n    curr: T,\n    next: T,\n}\n\nimpl<T> Fib<T> {\n    fn new(curr: T, next: T) -> Self {\n        Fib { curr: curr, next: next, }\n    }\n}\n\nimpl Iterator for Fib<String>  {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        let ret = self.curr.clone();\n        self.curr = self.next.clone();\n        self.next = format!(\"{}{}\", ret, self.next);\n        Some(ret)\n    }\n}\n\nfn get_entropy(s: &[u8]) -> f64 {\n    let mut entropy = 0.0;\n    let mut histogram = [0.0; 256];\n \n    for i in 0..s.len() {\n        histogram.get_mut(s[i] as usize).map(|v| *v += 1.0);\n    }\n\n    for i in 0..256 {\n        if histogram[i] > 0.0 {\n            let ratio = histogram[i] / s.len() as f64;\n            entropy -= ratio * ratio.log2();\n        }\n    }\n    entropy\n}\n\nfn main() {\n    let f = Fib::new(\"1\".to_string(), \"0\".to_string());\n        println!(\"{:10} {:10} {:10} {:60}\", \"N\", \"Length\", \"Entropy\", \"Word\");\n    for (i, s) in f.take(37).enumerate() {\n        let word = if s.len() > 60 {\"Too long\"} else {&*s};\n        println!(\"{:10} {:10} {:.10} {:60}\", i + 1, s.len(), get_entropy(&s.bytes().collect::<Vec<_>>()), word);\n    }\n}",
    "title": "Fibonacci word",
    "url": "http://rosettacode.org/wiki/Fibonacci_word"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nuse svg::node::element::path::Data;\nuse svg::node::element::Path;\n\nfn fibonacci_word(n: usize) -> Vec<u8> {\n    let mut f0 = vec![1];\n    let mut f1 = vec![0];\n    if n == 0 {\n        return f0;\n    } else if n == 1 {\n        return f1;\n    }\n    let mut i = 2;\n    loop {\n        let mut f = Vec::with_capacity(f1.len() + f0.len());\n        f.extend(&f1);\n        f.extend(f0);\n        if i == n {\n            return f;\n        }\n        f0 = f1;\n        f1 = f;\n        i += 1;\n    }\n}\n\nstruct FibwordFractal {\n    current_x: f64,\n    current_y: f64,\n    current_angle: i32,\n    line_length: f64,\n    max_x: f64,\n    max_y: f64,\n}\n\nimpl FibwordFractal {\n    fn new(x: f64, y: f64, length: f64, angle: i32) -> FibwordFractal {\n        FibwordFractal {\n            current_x: x,\n            current_y: y,\n            current_angle: angle,\n            line_length: length,\n            max_x: 0.0,\n            max_y: 0.0,\n        }\n    }\n    fn execute(&mut self, n: usize) -> Path {\n        let mut data = Data::new().move_to((self.current_x, self.current_y));\n        for (i, byte) in fibonacci_word(n).iter().enumerate() {\n            data = self.draw_line(data);\n            if *byte == 0u8 {\n                self.turn(if i % 2 == 1 { -90 } else { 90 });\n            }\n        }\n        Path::new()\n            .set(\"fill\", \"none\")\n            .set(\"stroke\", \"black\")\n            .set(\"stroke-width\", \"1\")\n            .set(\"d\", data)\n    }\n    fn draw_line(&mut self, data: Data) -> Data {\n        let theta = (self.current_angle as f64).to_radians();\n        self.current_x += self.line_length * theta.cos();\n        self.current_y += self.line_length * theta.sin();\n        if self.current_x > self.max_x {\n            self.max_x = self.current_x;\n        }\n        if self.current_y > self.max_y {\n            self.max_y = self.current_y;\n        }\n        data.line_to((self.current_x, self.current_y))\n    }\n    fn turn(&mut self, angle: i32) {\n        self.current_angle = (self.current_angle + angle) % 360;\n    }\n    fn save(file: &str, order: usize) -> std::io::Result<()> {\n        use svg::node::element::Rectangle;\n        let x = 5.0;\n        let y = 5.0;\n        let rect = Rectangle::new()\n            .set(\"width\", \"100%\")\n            .set(\"height\", \"100%\")\n            .set(\"fill\", \"white\");\n        let mut ff = FibwordFractal::new(x, y, 1.0, 0);\n        let path = ff.execute(order);\n        let document = svg::Document::new()\n            .set(\"width\", 5 + ff.max_x as usize)\n            .set(\"height\", 5 + ff.max_y as usize)\n            .add(rect)\n            .add(path);\n        svg::save(file, &document)\n    }\n}\n\nfn main() {\n    FibwordFractal::save(\"fibword_fractal.svg\", 22).unwrap();\n}",
    "title": "Fibonacci word/fractal",
    "url": "http://rosettacode.org/wiki/Fibonacci_word/fractal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let exts = [\"zip\", \"rar\", \"7z\", \"gz\", \"archive\", \"A##\", \"tar.bz2\"];\n    let filenames = [\n        \"MyData.a##\",\n        \"MyData.tar.Gz\",\n        \"MyData.gzip\",\n        \"MyData.7z.backup\",\n        \"MyData...\",\n        \"MyData\",\n        \"MyData_v1.0.tar.bz2\",\n        \"MyData_v1.0.bz2\",\n    ];\n\n    println!(\"extenstions: {:?}\\n\", exts);\n\n    for filename in filenames.iter() {\n        let check = exts.iter().any(|ext| {\n            filename\n                .to_lowercase()\n                .ends_with(&format!(\".{}\", ext.to_lowercase()))\n        });\n        println!(\"{:20} {}\", filename, check);\n    }\n}\n",
    "title": "File extension is in extensions list",
    "url": "http://rosettacode.org/wiki/File_extension_is_in_extensions_list"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::{Read, Write};\n\nfn main() {\n    let mut file = File::open(\"input.txt\").unwrap();\n    let mut data = Vec::new();\n    file.read_to_end(&mut data).unwrap();\n    let mut file = File::create(\"output.txt\").unwrap();\n    file.write_all(&data).unwrap();\n}\n",
    "path": "tasks/file-input-output",
    "remote_code": "use std::fs::File;\nuse std::io::{Read, Write};\n\nfn main() {\n    let mut file = File::open(\"input.txt\").unwrap();\n    let mut data = Vec::new();\n    file.read_to_end(&mut data).unwrap();\n    let mut file = File::create(\"output.txt\").unwrap();\n    file.write_all(&data).unwrap();\n}\n",
    "title": "File input/output",
    "url": "http://rosettacode.org/wiki/File_input/output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs;\n\nfn main() -> std::io::Result<()> {\n    let metadata = fs::metadata(\"foo.txt\")?;\n\n    if let Ok(time) = metadata.accessed() {\n        println!(\"{:?}\", time);\n    } else {\n        println!(\"Not supported on this platform\");\n    }\n    Ok(())\n}\n",
    "title": "File modification time",
    "url": "http://rosettacode.org/wiki/File_modification_time"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    if let Ok(attr) = fs::metadata(\"input.txt\") {\n        println!(\"size: {}\", attr.len());\n    }\n    if let Ok(attr_root) = fs::metadata(\"/input.txt\") {\n        println!(\"{}\", attr_root.len());\n    }\n}\n",
    "path": "tasks/file-size",
    "remote_code": "use std::{env, fs, process};\nuse std::io::{self, Write};\nuse std::fmt::Display;\n\nfn main() {\n    let file_name = env::args().nth(1).unwrap_or_else(|| exit_err(\"No file name supplied\", 1));\n    let metadata = fs::metadata(file_name).unwrap_or_else(|e| exit_err(e, 2));\n\n    println!(\"Size of file.txt is {} bytes\", metadata.len());\n}\n\n#[inline]\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    writeln!(&mut io::stderr(), \"Error: {}\", msg).expect(\"Could not write to stdout\");\n    process::exit(code)\n}\n\n}",
    "title": "File size",
    "url": "http://rosettacode.org/wiki/File_size"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::error::Error;\nuse std::marker::PhantomData;\nuse std::path::{Path, PathBuf};\nuse std::{env, fmt, io, time};\nuse walkdir::{DirEntry, WalkDir};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let start = time::Instant::now();\n    let args: Vec<String> = env::args().collect();\n\n    let root = parse_path(&args).expect(\"not a valid path\");\n    let dir = WalkDir::new(&root);\n\n    let (files, dirs): (Vec<PathBuf>, Vec<PathBuf>) = {\n        let pool = pool(dir).expect(\"unable to retrieve entries from WalkDir\");\n        partition_from(pool).expect(\"unable to partition files from directories\")\n    };\n\n    let (fs_count, dr_count) = (files.len(), dirs.len());\n    let (file_counter, total_size) = file_count(files);\n\n    {\n        println!(\"++ File size distribution for : {} ++\\n\", &root.display());\n        println!(\"Files @ 0B            : {:4}\", file_counter[0]);\n        println!(\"Files > 1B  - 1,023B  : {:4}\", file_counter[1]);\n        println!(\"Files > 1KB - 1,023KB : {:4}\", file_counter[2]);\n        println!(\"Files > 1MB - 1,023MB : {:4}\", file_counter[3]);\n        println!(\"Files > 1GB - 1,023GB : {:4}\", file_counter[4]);\n        println!(\"Files > 1TB+          : {:4}\\n\", file_counter[5]);\n\n        println!(\"Files encountered: {}\", fs_count);\n        println!(\"Directories traversed: {}\", dr_count);\n        println!(\n            \"Total size of all files: {}\\n\",\n            Filesize::<Kilobytes>::from(total_size)\n        );\n    }\n\n    let end = time::Instant::now();\n    println!(\"Run time: {:?}\\n\", end.duration_since(start));\n    Ok(())\n}\n\nfn parse_path(args: &[String]) -> Result<&Path, io::Error> {\n    // If there's no `args` entered, the executable will search it's own path.\n    match args.len() {\n        1 => Ok(Path::new(&args[0])),\n        _ => Ok(Path::new(&args[1])),\n    }\n}\n\nfn pool(dir: WalkDir) -> Result<Vec<DirEntry>, Box<dyn Error>> {\n    // Check each item for errors and drop possible invalid `DirEntry`s\n    Ok(dir.into_iter().filter_map(|e| e.ok()).collect())\n}\n\nfn partition_from(pool: Vec<DirEntry>) -> Result<(Vec<PathBuf>, Vec<PathBuf>), Box<dyn Error>> {\n    // Read `Path` from `DirEntry`, checking if `Path` is a file or directory.\n    Ok(pool\n        .into_iter()\n        .map(|e| e.into_path())\n        .partition(|path| path.is_file()))\n}\n\nfn file_count(files: Vec<PathBuf>) -> ([u64; 6], u64) {\n    let mut counter: [u64; 6] = [0; 6];\n    for file in &files {\n        match Filesize::<Bytes>::from(file).bytes {\n            0 => counter[0] += 1,                                 // Empty file\n            1..=1_023 => counter[1] += 1,                         // 1 byte to 0.99KB\n            1_024..=1_048_575 => counter[2] += 1,                 // 1 kilo to 0.99MB\n            1_048_576..=1_073_741_823 => counter[3] += 1,         // 1 mega to 0.99GB\n            1_073_741_824..=1_099_511_627_775 => counter[4] += 1, // 1 giga to 0.99TB\n            1_099_511_627_776..=std::u64::MAX => counter[5] += 1, // 1 terabyte or larger\n        }\n    }\n\n    let total_file_size = files\n        .iter()\n        .fold(0, |acc, file| acc + Filesize::<Bytes>::from(file).bytes);\n    (counter, total_file_size)\n}\n\ntrait SizeUnit: Copy {\n    fn singular_name() -> String;\n    fn num_byte_in_unit() -> u64;\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nstruct Bytes;\nimpl SizeUnit for Bytes {\n    fn singular_name() -> String {\n        \"B\".to_string()\n    }\n    fn num_byte_in_unit() -> u64 {\n        1\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nstruct Kilobytes;\nimpl SizeUnit for Kilobytes {\n    fn singular_name() -> String {\n        \"KB\".to_string()\n    }\n    fn num_byte_in_unit() -> u64 {\n        1_024\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nstruct Filesize<T: SizeUnit> {\n    bytes: u64,\n    unit: PhantomData<T>,\n}\n\nimpl<T> From<u64> for Filesize<T>\nwhere\n    T: SizeUnit,\n{\n    fn from(n: u64) -> Self {\n        Filesize {\n            bytes: n * T::num_byte_in_unit(),\n            unit: PhantomData,\n        }\n    }\n}\n\nimpl<T> From<Filesize<T>> for u64\nwhere\n    T: SizeUnit,\n{\n    fn from(fsz: Filesize<T>) -> u64 {\n        ((fsz.bytes as f64) / (T::num_byte_in_unit() as f64)) as u64\n    }\n}\n\nimpl<T> fmt::Display for Filesize<T>\nwhere\n    T: SizeUnit,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // convert value in associated units to float\n        let size_val = ((self.bytes as f64) / (T::num_byte_in_unit() as f64)) as u64;\n\n        // plural?\n        let name_plural = match size_val {\n            1 => \"\",\n            _ => \"s\",\n        };\n\n        write!(\n            f,\n            \"{} {}{}\",\n            (self.bytes as f64) / (T::num_byte_in_unit() as f64),\n            T::singular_name(),\n            name_plural\n        )\n    }\n}\n\n// Can be expanded for From<File>, or any type that has an alias for Metadata\nimpl<T> From<&PathBuf> for Filesize<T>\nwhere\n    T: SizeUnit,\n{\n    fn from(f: &PathBuf) -> Self {\n        Filesize {\n            bytes: f\n                .metadata()\n                .expect(\"error with metadata from pathbuf into filesize\")\n                .len(),\n            unit: PhantomData,\n        }\n    }\n}\n",
    "title": "File size distribution",
    "url": "http://rosettacode.org/wiki/File_size_distribution"
  },
  {
    "local_code": "fn main() {\n    println!(\"new vec filtered: \");\n    let nums: Vec<i32> = (1..20).collect();\n    let evens: Vec<i32> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();\n    println!(\"{:?}\", evens);\n\n    // Filter an already existing vector\n    println!(\"original vec filtered: \");\n    let mut nums: Vec<i32> = (1..20).collect();\n    nums.retain(|x| x % 2 == 0);\n    println!(\"{:?}\", nums);\n}\n",
    "path": "tasks/filter",
    "remote_code": "fn main() {\n    println!(\"new vec filtered: \");\n    let nums: Vec<i32> = (1..20).collect();\n    let evens: Vec<i32> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();\n    println!(\"{:?}\", evens);\n\n    // Filter an already existing vector\n    println!(\"original vec filtered: \");\n    let mut nums: Vec<i32> = (1..20).collect();\n    nums.retain(|x| x % 2 == 0);\n    println!(\"{:?}\", nums);\n}",
    "title": "Filter",
    "url": "http://rosettacode.org/wiki/Filter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find Chess960 starting position identifier",
    "url": "http://rosettacode.org/wiki/Find_Chess960_starting_position_identifier"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::path::{Path, PathBuf};\n\nfn main() {\n    let paths = [\n        Path::new(\"/home/user1/tmp/coverage/test\"),\n        Path::new(\"/home/user1/tmp/covert/operator\"),\n        Path::new(\"/home/user1/tmp/coven/members\"),\n    ];\n    match common_path(&paths) {\n        Some(p) => println!(\"The common path is: {:#?}\", p),\n        None => println!(\"No common paths found\"),\n    }\n}\n\nfn common_path<I, P>(paths: I) -> Option<PathBuf>\nwhere\n    I: IntoIterator<Item = P>,\n    P: AsRef<Path>,\n{\n    let mut iter = paths.into_iter();\n    let mut ret = iter.next()?.as_ref().to_path_buf();\n    for path in iter {\n        if let Some(r) = common(ret, path.as_ref()) {\n            ret = r;\n        } else {\n            return None;\n        }\n    }\n    Some(ret)\n}\n\nfn common<A: AsRef<Path>, B: AsRef<Path>>(a: A, b: B) -> Option<PathBuf> {\n    let a = a.as_ref().components();\n    let b = b.as_ref().components();\n    let mut ret = PathBuf::new();\n    let mut found = false;\n    for (one, two) in a.zip(b) {\n        if one == two {\n            ret.push(one);\n            found = true;\n        } else {\n            break;\n        }\n    }\n    if found {\n        Some(ret)\n    } else {\n        None\n    }\n}\n",
    "title": "Find common directory path",
    "url": "http://rosettacode.org/wiki/Find_common_directory_path"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    collections::BTreeMap,\n    fs::{read_dir, File},\n    hash::Hasher,\n    io::Read,\n    path::{Path, PathBuf},\n};\n\ntype Duplicates = BTreeMap<(u64, u64), Vec<PathBuf>>;\n\nstruct DuplicateFinder {\n    found: Duplicates,\n    min_size: u64,\n}\n\nimpl DuplicateFinder {\n    fn search(path: impl AsRef<Path>, min_size: u64) -> std::io::Result<Duplicates> {\n        let mut result = Self {\n            found: BTreeMap::new(),\n            min_size,\n        };\n\n        result.walk(path)?;\n        Ok(result.found)\n    }\n\n    fn walk(&mut self, path: impl AsRef<Path>) -> std::io::Result<()> {\n        let listing = read_dir(path.as_ref())?;\n        for entry in listing {\n            let entry = entry?;\n            let path = entry.path();\n            if path.is_dir() {\n                self.walk(path)?;\n            } else {\n                self.compute_digest(&path)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn compute_digest(&mut self, file: &Path) -> std::io::Result<()> {\n        let size = file.metadata()?.len();\n        if size < self.min_size {\n            return Ok(());\n        }\n\n        // This hasher is weak, we could otherwise use an external crate\n        let mut hasher = std::collections::hash_map::DefaultHasher::default();\n        let mut bytes = [0u8; 8182];\n        let mut f = File::open(file)?;\n        loop {\n            let n = f.read(&mut bytes[..])?;\n            hasher.write(&bytes[..n]);\n            if n == 0 {\n                break;\n            }\n        }\n\n        let hash = hasher.finish();\n\n        self.found\n            .entry((size, hash))\n            .or_insert_with(Vec::new)\n            .push(file.to_owned());\n\n        Ok(())\n    }\n}\n\nfn main() -> std::io::Result<()> {\n    let mut args = std::env::args();\n\n    args.next(); // Skip the executable name\n    let dir = args.next().unwrap_or_else(|| \".\".to_owned());\n\n    let min_size = args\n        .next()\n        .and_then(|arg| arg.parse::<u64>().ok())\n        .unwrap_or(0u64);\n\n    DuplicateFinder::search(dir, min_size)?\n        .iter()\n        .rev()\n        .filter(|(_, files)| files.len() > 1)\n        .for_each(|((size, _), files)| {\n            println!(\"Size: {}\", size);\n\n            files\n                .iter()\n                .for_each(|file| println!(\"{}\", file.to_string_lossy()));\n\n            println!();\n        });\n\n    Ok(())\n}",
    "title": "Find duplicate files",
    "url": "http://rosettacode.org/wiki/Find_duplicate_files"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find if a point is within a triangle",
    "url": "http://rosettacode.org/wiki/Find_if_a_point_is_within_a_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find largest left truncatable prime in a given base",
    "url": "http://rosettacode.org/wiki/Find_largest_left_truncatable_prime_in_a_given_base"
  },
  {
    "local_code": "#[allow(unconditional_recursion)]\n\nfn recursion(n: i32) {\n    println!(\"deep: {}\", n);\n    recursion(n + 1);\n}\n\nfn main() {\n    recursion(0);\n}\n",
    "path": "tasks/find-limit-of-recursion",
    "remote_code": "fn recurse(n: i32) {\n    println!(\"depth: {}\", n);\n    recurse(n + 1)\n}\n\nfn main() {\n    recurse(0);\n}",
    "title": "Find limit of recursion",
    "url": "http://rosettacode.org/wiki/Find_limit_of_recursion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find palindromic numbers in both binary and ternary bases",
    "url": "http://rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::ops::{Add, Div, Mul, Sub};\n\n#[derive(Copy, Clone, Debug, PartialEq)]\nstruct V3<T> {\n    x: T,\n    y: T,\n    z: T,\n}\n\nimpl<T> V3<T> {\n    fn new(x: T, y: T, z: T) -> Self {\n        V3 { x, y, z }\n    }\n}\n\nfn zip_with<F, T, U>(f: F, a: V3<T>, b: V3<T>) -> V3<U>\nwhere\n    F: Fn(T, T) -> U,\n{\n    V3 {\n        x: f(a.x, b.x),\n        y: f(a.y, b.y),\n        z: f(a.z, b.z),\n    }\n}\n\nimpl<T> Add for V3<T>\nwhere\n    T: Add<Output = T>,\n{\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        zip_with(<T>::add, self, other)\n    }\n}\n\nimpl<T> Sub for V3<T>\nwhere\n    T: Sub<Output = T>,\n{\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n        zip_with(<T>::sub, self, other)\n    }\n}\n\nimpl<T> Mul for V3<T>\nwhere\n    T: Mul<Output = T>,\n{\n    type Output = Self;\n\n    fn mul(self, other: Self) -> Self {\n        zip_with(<T>::mul, self, other)\n    }\n}\n\nimpl<T> V3<T>\nwhere\n    T: Mul<Output = T> + Add<Output = T>,\n{\n    fn dot(self, other: Self) -> T {\n        let V3 { x, y, z } = self * other;\n        x + y + z\n    }\n}\n\nimpl<T> V3<T>\nwhere\n    T: Mul<Output = T> + Copy,\n{\n    fn scale(self, scalar: T) -> Self {\n        self * V3 {\n            x: scalar,\n            y: scalar,\n            z: scalar,\n        }\n    }\n}\n\nfn intersect<T>(\n    ray_vector: V3<T>,\n    ray_point: V3<T>,\n    plane_normal: V3<T>,\n    plane_point: V3<T>,\n) -> V3<T>\nwhere\n    T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T> + Copy,\n{\n    let diff = ray_point - plane_point;\n    let prod1 = diff.dot(plane_normal);\n    let prod2 = ray_vector.dot(plane_normal);\n    let prod3 = prod1 / prod2;\n    ray_point - ray_vector.scale(prod3)\n}\n\nfn main() {\n    let rv = V3::new(0.0, -1.0, -1.0);\n    let rp = V3::new(0.0, 0.0, 10.0);\n    let pn = V3::new(0.0, 0.0, 1.0);\n    let pp = V3::new(0.0, 0.0, 5.0);\n    println!(\"{:?}\", intersect(rv, rp, pn, pp));\n}\n",
    "title": "Find the intersection of a line with a plane",
    "url": "http://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Copy, Clone, Debug)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n    pub fn new(x: f64, y: f64) -> Self {\n        Point { x, y }\n    }\n}\n\n#[derive(Copy, Clone, Debug)]\nstruct Line(Point, Point);\n\nimpl Line {\n    pub fn intersect(self, other: Self) -> Option<Point> {\n        let a1 = self.1.y - self.0.y;\n        let b1 = self.0.x - self.1.x;\n        let c1 = a1 * self.0.x + b1 * self.0.y;\n\n        let a2 = other.1.y - other.0.y;\n        let b2 = other.0.x - other.1.x;\n        let c2 = a2 * other.0.x + b2 * other.0.y;\n\n        let delta = a1 * b2 - a2 * b1;\n\n        if delta == 0.0 {\n            return None;\n        }\n\n        Some(Point {\n            x: (b2 * c1 - b1 * c2) / delta,\n            y: (a1 * c2 - a2 * c1) / delta,\n        })\n    }\n}\n\nfn main() {\n    let l1 = Line(Point::new(4.0, 0.0), Point::new(6.0, 10.0));\n    let l2 = Line(Point::new(0.0, 3.0), Point::new(10.0, 7.0));\n    println!(\"{:?}\", l1.intersect(l2));\n\n    let l1 = Line(Point::new(0.0, 0.0), Point::new(1.0, 1.0));\n    let l2 = Line(Point::new(1.0, 2.0), Point::new(4.0, 5.0));\n    println!(\"{:?}\", l1.intersect(l2));\n}",
    "title": "Find the intersection of two lines",
    "url": "http://rosettacode.org/wiki/Find_the_intersection_of_two_lines"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env::args;\nuse time::{Date, Duration};\n\nfn main() {\n    let year = args().nth(1).unwrap().parse::<i32>().unwrap();\n    (1..=12)\n        .map(|month| Date::try_from_ymd(year + month / 12, ((month % 12) + 1) as u8, 1))\n        .filter_map(|date| date.ok())\n        .for_each(|date| {\n            let days_back =\n                Duration::days(((date.weekday().number_from_sunday() as i64 + 5) % 7) + 1);\n            println!(\"{}\", date - days_back);\n        });\n}",
    "title": "Find the last Sunday of each month",
    "url": "http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const GIVEN_PERMUTATIONS: [&str; 23] = [\n    \"ABCD\",\n    \"CABD\",\n    \"ACDB\",\n    \"DACB\",\n    \"BCDA\",\n    \"ACBD\",\n    \"ADCB\",\n    \"CDAB\",\n    \"DABC\",\n    \"BCAD\",\n    \"CADB\",\n    \"CDBA\",\n    \"CBAD\",\n    \"ABDC\",\n    \"ADBC\",\n    \"BDCA\",\n    \"DCBA\",\n    \"BACD\",\n    \"BADC\",\n    \"BDAC\",\n    \"CBDA\",\n    \"DBCA\",\n    \"DCAB\"\n];\n\nfn main() {\n\n    const PERMUTATION_LEN: usize = GIVEN_PERMUTATIONS[0].len();\n    let mut bytes_result: [u8; PERMUTATION_LEN] = [0; PERMUTATION_LEN];\n\n    for permutation in &GIVEN_PERMUTATIONS {\n        for (i, val) in permutation.bytes().enumerate() {\n            bytes_result[i] ^= val;\n        }\n    }\n    println!(\"{}\", std::str::from_utf8(&bytes_result).unwrap());\n}\n\n",
    "title": "Find the missing permutation",
    "url": "http://rosettacode.org/wiki/Find_the_missing_permutation"
  },
  {
    "local_code": "// For abstraction, it is desirable to implement the transitions of the state machine through its methods.\n// Here it is done transparently using the method_enum::gen macro.\n\nenum State {\n    Ready,\n    Waiting,\n    Dispense,\n    Refunding,\n    Exit,\n}\n\n#[methods_enum::gen(Act: run)]\nimpl State {\n    pub fn set(&mut self);\n    pub fn input_char(&mut self, ch: char);\n\n    fn run(&mut self, act: Act) {\n        match self {\n            State::Ready => match act {\n                Act::set() => println!(\"Ready: d - deposit / q - quit \"),\n                Act::input_char('d') => self.set_state(State::Waiting),\n                Act::input_char('q') => self.set_state(State::Exit),\n                _ => self.set(),\n            },\n            State::Waiting => match act {\n                Act::set() => println!(\"Waiting: s - select / r - refund \"),\n                Act::input_char('s') => self.set_state(State::Dispense),\n                Act::input_char('r') => self.set_state(State::Refunding),\n                _ => self.set(),\n            },\n            State::Dispense => match act {\n                Act::set() => println!(\"Dispense: r - remove \"),\n                Act::input_char('r') => self.set_state(State::Ready),\n                _ => self.set(),\n            },\n            State::Refunding => match act {\n                Act::set() => {\n                    println!(\"Refunding: refund of the deposit...\");\n                    self.set_state(State::Ready)\n                }\n                _ => (), // never - ignore\n            },\n            State::Exit => match act {\n                Act::set() => println!(\"Exit: goodbye! \"),\n                _ => panic!(\"!! Invalid command for State::Exit: '{act:?}'\"),\n            },\n        }\n    }\n\n    fn set_state(&mut self, new_state: State) {\n        *self = new_state;\n        self.set();\n    }\n}\n\nfn main() {\n    let mut machine = State::Ready;\n    machine.set();\n\n    while !matches!(&machine, State::Exit) {\n        machine.input_char(char_entered());\n    }\n}\n\nfn char_entered() -> char {\n    let mut text = String::new();\n    (std::io::stdin().read_line(&mut text)).unwrap_or(0);\n    text.chars().next().unwrap_or('\\x0d')\n}\n",
    "path": "tasks/finite-state-machine",
    "remote_code": null,
    "title": "Finite state machine",
    "url": "http://rosettacode.org/wiki/Finite_state_machine"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "First class environments",
    "url": "http://rosettacode.org/wiki/First_class_environments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "First perfect square in base n with n unique digits",
    "url": "http://rosettacode.org/wiki/First_perfect_square_in_base_n_with_n_unique_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn power_of_two(l: isize, n: isize) -> isize {\n    let mut test: isize = 0;\n    let log: f64 = 2.0_f64.ln() / 10.0_f64.ln();\n    let mut factor: isize = 1;\n    let mut looop = l;\n    let mut nn = n;\n    while looop > 10 {\n        factor *= 10;\n        looop /= 10;\n    }\n\n    while nn > 0 {\n        test = test + 1;\n        let val: isize = (factor as f64 * 10.0_f64.powf(test as f64 * log % 1.0)) as isize;\n\n        if val == l {\n            nn = nn - 1;\n        }\n    }\n\n    test\n}\n\nfn run_test(l: isize, n: isize) {\n    println!(\"p({}, {}) = {}\", l, n, power_of_two(l, n));\n}\n\nfn main() {\n    run_test(12, 1);\n    run_test(12, 2);\n    run_test(123, 45);\n    run_test(123, 12345);\n    run_test(123, 678910);\n}\n",
    "title": "First power of 2 that has leading decimal digits of 12",
    "url": "http://rosettacode.org/wiki/First_power_of_2_that_has_leading_decimal_digits_of_12"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(conservative_impl_trait)]\nfn main() {\n    let cube      = |x: f64| x.powi(3);\n    let cube_root = |x: f64| x.powf(1.0 / 3.0);\n\n    let flist  : [&Fn(f64) -> f64; 3] = [&cube     , &f64::sin , &f64::cos ];\n    let invlist: [&Fn(f64) -> f64; 3] = [&cube_root, &f64::asin, &f64::acos];\n\n    let result = flist.iter()\n                      .zip(&invlist)\n                      .map(|(f,i)| compose(f,i)(0.5))\n                      .collect::<Vec<_>>();\n\n    println!(\"{:?}\", result);\n\n}\n\nfn compose<'a, F, G, T, U, V>(f: F, g: G) -> impl 'a + Fn(T) -> V\n    where F: 'a + Fn(T) -> U,\n          G: 'a + Fn(U) -> V,\n{\n    move |x| g(f(x))\n\n}",
    "title": "First-class functions",
    "url": "http://rosettacode.org/wiki/First-class_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(conservative_impl_trait)]\nfn main() {\n    let (x, xi) = (2.0, 0.5);\n    let (y, yi) = (4.0, 0.25);\n    let z = x + y;\n    let zi = 1.0/z;\n\n    let numlist = [x,y,z];\n    let invlist = [xi,yi,zi];\n\n    let result = numlist.iter()\n                        .zip(&invlist)\n                        .map(|(x,y)| multiplier(*x,*y)(0.5))\n                        .collect::<Vec<_>>();\n    println!(\"{:?}\", result);\n}\n\nfn multiplier(x: f64, y: f64) -> impl Fn(f64) -> f64 {\n    move |m| x*y*m\n}\n",
    "title": "First-class functions/Use numbers analogously",
    "url": "http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously"
  },
  {
    "local_code": "extern crate chrono;\nuse chrono::prelude::*;\n\n/// Months with 31 days\nconst LONGMONTHS: [u32; 7] = [1, 3, 5, 7, 8, 10, 12];\n\n/// Get all the tuples (year, month) in wich there is five Fridays, five Saturdays and five Sundays\n/// between the years start and end (inclusive).\nfn five_weekends(start: i32, end: i32) -> Vec<(i32, u32)> {\n    let mut out = vec![];\n\n    for year in start..=end {\n        for month in LONGMONTHS.iter() {\n            // Five weekends if a 31-days month starts with a Friday.\n            if Local.ymd(year, *month, 1).weekday() == Weekday::Fri {\n                out.push((year, *month));\n            }\n        }\n    }\n\n    out\n}\n\nfn main() {\n    let out = five_weekends(1900, 2100);\n\n    let len = out.len();\n    println!(\n        \"There are {} months of which the first and last five are:\",\n        len\n    );\n    for (y, m) in &out[..5] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n    println!(\"...\");\n    for (y, m) in &out[(len - 5..)] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n}\n\n#[test]\nfn test() {\n    let out = five_weekends(1900, 2100);\n    assert_eq!(out.len(), 201);\n}\n",
    "path": "tasks/five-weekends",
    "remote_code": "extern crate chrono;\nuse chrono::prelude::*;\n\n/// Months with 31 days\nconst LONGMONTHS: [u32; 7] = [1, 3, 5, 7, 8, 10, 12];\n\n/// Get all the tuples (year, month) in wich there is five Fridays, five Saturdays and five Sundays\n/// between the years start and end (inclusive).\nfn five_weekends(start: i32, end: i32) -> Vec<(i32, u32)> {\n    let mut out = vec![];\n\n    for year in start..=end {\n        for month in LONGMONTHS.iter() {\n            // Five weekends if a 31-days month starts with a Friday.\n            if Local.ymd(year, *month, 1).weekday() == Weekday::Fri {\n                out.push((year, *month));\n            }\n        }\n    }\n\n    out\n}\n\nfn main() {\n    let out = five_weekends(1900, 2100);\n\n    let len = out.len();\n    println!(\n        \"There are {} months of which the first and last five are:\",\n        len\n    );\n    for (y, m) in &out[..5] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n    println!(\"...\");\n    for (y, m) in &out[(len - 5..)] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n}\n\n#[test]\nfn test() {\n    let out = five_weekends(1900, 2100);\n    assert_eq!(out.len(), 201);\n}",
    "title": "Five weekends",
    "url": "http://rosettacode.org/wiki/Five_weekends"
  },
  {
    "local_code": "#[derive(Debug)]\nstruct FiveNum {\n    minimum: f64,\n    lower_quartile: f64,\n    median: f64,\n    upper_quartile: f64,\n    maximum: f64,\n}\n\nfn median(samples: &[f64]) -> f64 {\n    // input is already sorted\n    let n = samples.len();\n    let m = n / 2;\n    if n % 2 == 0 {\n        (samples[m] + samples[m - 1]) / 2.0\n    } else {\n        samples[m]\n    }\n}\n\nfn fivenum(samples: &[f64]) -> FiveNum {\n    let mut xs = samples.to_vec();\n    xs.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\n    let m = xs.len() / 2;\n\n    FiveNum {\n        minimum: xs[0],\n        lower_quartile: median(&xs[0..(m + (xs.len() % 2))]),\n        median: median(&xs),\n        upper_quartile: median(&xs[m..]),\n        maximum: xs[xs.len() - 1],\n    }\n}\nfn main() {\n    let inputs = vec![\n        vec![15., 6., 42., 41., 7., 36., 49., 40., 39., 47., 43.],\n        vec![36., 40., 7., 39., 41., 15.],\n        vec![\n            0.140_828_34,\n            0.097_487_90,\n            1.731_315_07,\n            0.876_360_09,\n            -1.950_595_94,\n            0.734_385_55,\n            -0.030_357_26,\n            1.466_759_70,\n            -0.746_213_49,\n            -0.725_887_72,\n            0.639_051_60,\n            0.615_015_27,\n            -0.989_837_80,\n            -1.004_478_74,\n            -0.627_594_69,\n            0.662_061_63,\n            1.043_120_09,\n            -0.103_053_85,\n            0.757_756_34,\n            0.325_665_78,\n        ],\n    ];\n\n    for input in inputs {\n        let result = fivenum(&input);\n        println!(\"Fivenum\",);\n        println!(\"  Minumum: {}\", result.minimum);\n        println!(\"  Lower quartile: {}\", result.lower_quartile);\n        println!(\"  Median: {}\", result.median);\n        println!(\"  Upper quartile: {}\", result.upper_quartile);\n        println!(\"  Maximum: {}\", result.maximum);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assert_approx_eq::assert_approx_eq;\n\n    #[test]\n    fn test_fivenum() {\n        let input = vec![1., 2.];\n        let result = fivenum(&input);\n\n        assert_approx_eq!(result.minimum, 1.);\n        assert_approx_eq!(result.lower_quartile, 1.);\n        assert_approx_eq!(result.median, 1.5);\n        assert_approx_eq!(result.upper_quartile, 2.);\n        assert_approx_eq!(result.maximum, 2.);\n\n        let input = vec![36., 40., 7., 39., 41., 15.];\n        let result = fivenum(&input);\n\n        assert_approx_eq!(result.minimum, 7.);\n        assert_approx_eq!(result.lower_quartile, 15.);\n        assert_approx_eq!(result.median, 37.5);\n        assert_approx_eq!(result.upper_quartile, 40.);\n        assert_approx_eq!(result.maximum, 41.);\n    }\n}\n",
    "path": "tasks/fivenum",
    "remote_code": "\n#[derive(Debug)]\nstruct FiveNum {\n    minimum: f64,\n    lower_quartile: f64,\n    median: f64,\n    upper_quartile: f64,\n    maximum: f64,\n}\n\nfn median(samples: &[f64]) -> f64 {\n    // input is already sorted\n    let n = samples.len();\n    let m = n / 2;\n    if n % 2 == 0 {\n        (samples[m] + samples[m - 1]) / 2.0\n    } else {\n        samples[m]\n    }\n}\n\nfn fivenum(samples: &[f64]) -> FiveNum {\n    let mut xs = samples.to_vec();\n    xs.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\n    let m = xs.len() / 2;\n\n    FiveNum {\n        minimum: xs[0],\n        lower_quartile: median(&xs[0..(m + (xs.len() % 2))]),\n        median: median(&xs),\n        upper_quartile: median(&xs[m..]),\n        maximum: xs[xs.len() - 1],\n    }\n}\nfn main() {\n    let inputs = vec![\n        vec![15., 6., 42., 41., 7., 36., 49., 40., 39., 47., 43.],\n        vec![36., 40., 7., 39., 41., 15.],\n        vec![\n            0.14082834,\n            0.09748790,\n            1.73131507,\n            0.87636009,\n            -1.95059594,\n            0.73438555,\n            -0.03035726,\n            1.46675970,\n            -0.74621349,\n            -0.72588772,\n            0.63905160,\n            0.61501527,\n            -0.98983780,\n            -1.00447874,\n            -0.62759469,\n            0.66206163,\n            1.04312009,\n            -0.10305385,\n            0.75775634,\n            0.32566578,\n        ],\n    ];\n\n    for input in inputs {\n        let result = fivenum(&input);\n        println!(\"Fivenum\",);\n        println!(\"  Minumum: {}\", result.minimum);\n        println!(\"  Lower quartile: {}\", result.lower_quartile);\n        println!(\"  Median: {}\", result.median);\n        println!(\"  Upper quartile: {}\", result.upper_quartile);\n        println!(\"  Maximum: {}\", result.maximum);\n    }\n}\n",
    "title": "Fivenum",
    "url": "http://rosettacode.org/wiki/Fivenum"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs::File;\nuse std::io::prelude::*;\nuse std::io::{BufReader, BufWriter};\n\nfn reverse_file(\n    input_filename: &str,\n    output_filename: &str,\n    record_len: usize,\n) -> std::io::Result<()> {\n    let mut input = BufReader::new(File::open(input_filename)?);\n    let mut output = BufWriter::new(File::create(output_filename)?);\n    let mut buffer = vec![0; record_len];\n    while input.read(&mut buffer)? == record_len {\n        buffer.reverse();\n        output.write_all(&buffer)?;\n    }\n    output.flush()?;\n    Ok(())\n}\n\nfn main() {\n    match reverse_file(\"infile.dat\", \"outfile.dat\", 80) {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"I/O error: {}\", error),\n    }\n}",
    "title": "Fixed length records",
    "url": "http://rosettacode.org/wiki/Fixed_length_records"
  },
  {
    "local_code": "// Using conditional expressions,\n// checking 15 divisibility avoided so negligibly faster\nfn fb_one() {\n    let mut f: bool;\n    for x in 1..101 {\n        f = false;\n        if x % 3 == 0 {\n            print!(\"Fizz\");\n            f = true;\n        }\n        if x % 5 == 0 {\n            print!(\"Buzz\");\n            f = true;\n        }\n        if f {\n            println!();\n        } else {\n            println!(\"{}\", x)\n        }\n    }\n}\n\n// Rust tuples come in handy, as does matching\nfn fb_two() {\n    for i in 1..101 {\n        match (i % 3 == 0, i % 5 == 0) {\n            (true, true) => println!(\"FizzBuzz\"),\n            (true, false) => println!(\"Fizz\"),\n            (false, true) => println!(\"Buzz\"),\n            (false, false) => println!(\"{}\", i),\n        }\n    }\n}\n\nfn main() {\n    fb_one();\n    fb_two();\n}\n",
    "path": "tasks/fizzbuzz",
    "remote_code": "fn main() {\n    for i in 1..=100 {\n        match (i % 3, i % 5) {\n            (0, 0) => println!(\"fizzbuzz\"),\n            (0, _) => println!(\"fizz\"),\n            (_, 0) => println!(\"buzz\"),\n            (_, _) => println!(\"{}\", i),\n        }\n    }\n}",
    "title": "FizzBuzz",
    "url": "http://rosettacode.org/wiki/FizzBuzz"
  },
  {
    "local_code": "#![feature(box_syntax)]\n\nuse Tree::{Leaf, Node};\n\n#[derive(Debug)]\nenum Tree<T> {\n    Node(Vec<Tree<T>>),\n    Leaf(T),\n}\n\nfn flatten<T>(tree: Tree<T>) -> Vec<T> {\n    match tree {\n        Leaf(val) => vec![val],\n        Node(vec) => vec\n            .into_iter()\n            .flat_map(|t| flatten(t).into_iter())\n            .collect(),\n    }\n}\n\nfn main() {\n    // [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n    let list: Tree<i32> = Node(vec![\n        Node(vec![Leaf(1)]),\n        Leaf(2),\n        Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n        Node(vec![Node(vec![Node(vec![])])]),\n        Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n        Leaf(7),\n        Leaf(8),\n        Node(vec![]),\n    ]);\n\n    println!(\"{:?}\", list);\n\n    let flattened = flatten(list);\n\n    println!(\"{:?}\", flattened);\n}\n\n#[test]\nfn rosetta_flatten_test() {\n    // [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n    let list: Tree<i32> = Node(vec![\n        Node(vec![Leaf(1)]),\n        Leaf(2),\n        Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n        Node(vec![Node(vec![Node(vec![])])]),\n        Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n        Leaf(7),\n        Leaf(8),\n        Node(vec![]),\n    ]);\n\n    println!(\"{:?}\", list);\n\n    let flattened = flatten(list);\n\n    assert!(flattened == vec![1, 2, 3, 4, 5, 6, 7, 8])\n}\n",
    "path": "tasks/flatten-a-list",
    "remote_code": "use std::{vec, mem, iter};\n\nenum List<T> {\n    Node(Vec<List<T>>),\n    Leaf(T),\n}\n\nimpl<T> IntoIterator for List<T> {\n    type Item = List<T>;\n    type IntoIter = ListIter<T>;\n    fn into_iter(self) -> Self::IntoIter {\n        match self {\n            List::Node(vec) => ListIter::NodeIter(vec.into_iter()),\n            leaf @ List::Leaf(_) => ListIter::LeafIter(iter::once(leaf)),\n        }\n    }\n}\n\nenum ListIter<T> {\n    NodeIter(vec::IntoIter<List<T>>),\n    LeafIter(iter::Once<List<T>>),\n}\n\nimpl<T> ListIter<T> {\n    fn flatten(self) -> Flatten<T> {\n        Flatten {\n            stack: Vec::new(),\n            curr: self,\n        }\n    }\n}\n\nimpl<T> Iterator for ListIter<T> {\n    type Item = List<T>;\n    fn next(&mut self) -> Option<Self::Item> {\n        match *self {\n            ListIter::NodeIter(ref mut v_iter) => v_iter.next(),\n            ListIter::LeafIter(ref mut o_iter) => o_iter.next(),\n        }\n    }\n}\n\nstruct Flatten<T> {\n    stack: Vec<ListIter<T>>,\n    curr: ListIter<T>,\n}\n\n// Flatten code is a little messy since we are shoehorning recursion into an Iterator\nimpl<T> Iterator for Flatten<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.curr.next() {\n                Some(list) => {\n                    match list {\n                        node @ List::Node(_) => {\n                            self.stack.push(node.into_iter());\n                            let len = self.stack.len();\n                            mem::swap(&mut self.stack[len - 1], &mut self.curr);\n                        }\n                        List::Leaf(item) => return Some(item),\n                    }\n                }\n                None => {\n                    if let Some(next) = self.stack.pop() {\n                        self.curr = next;\n                    } else {\n                        return None;\n                    }\n                }\n            }\n        }\n    }\n}\n\nuse List::*;\nfn main() {\n    let list = Node(vec![Node(vec![Leaf(1)]),\n                         Leaf(2),\n                         Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n                         Node(vec![Node(vec![Node(vec![])])]),\n                         Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n                         Leaf(7),\n                         Leaf(8),\n                         Node(vec![])]);\n\n    for elem in list.into_iter().flatten() {\n        print!(\"{} \", elem);\n    }\n    println!();\n\n}",
    "title": "Flatten a list",
    "url": "http://rosettacode.org/wiki/Flatten_a_list"
  },
  {
    "local_code": "// For random generation\nextern crate rand;\n\n// For fmt::Display\nuse std::fmt;\n// For I/O (stdin, stdout, etc)\nuse std::io::prelude::*;\n\nuse rand::Rng;\n\n/// A simple struct for a board\nstruct Board {\n    /// The cells of the board\n    cells: Vec<bool>,\n    /// The size of the board\n    size: usize,\n}\n\n// Functions for the Board struct\nimpl Board {\n    /// Generate a new, empty board, of size >= 1\n    ///\n    /// Returns a Board in the \"off\" state, where all cells are 0.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    /// A mutable board is required for using Board::fliprow and Board::flipcol functions.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// ```\n    fn new(size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size > 0 {\n            Board {\n                cells: vec![false; size * size],\n                size,\n            }\n        } else {\n            Board::new(1)\n        }\n    }\n\n    /// Flip the specified row\n    ///\n    /// Returns true if the row is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.fliprow(1);\n    /// ```\n    fn fliprow(&mut self, row: usize) -> bool {\n        // Check constraints\n        if row > self.size {\n            return false;\n        }\n        // Starting position in the vector\n        let start = row * self.size;\n        // Loop through the vector row\n        for i in start..start + self.size {\n            self.cells[i] = !self.cells[i];\n        }\n        true\n    }\n\n    /// Flip the specified column\n    ///\n    /// Returns true if the column is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.flipcol(0);\n    /// ```\n    fn flipcol(&mut self, col: usize) -> bool {\n        // Check constraints\n        if col > self.size {\n            return false;\n        }\n        // Loop through the vector column\n        for i in 0..self.size {\n            self.cells[col + i * self.size] = !self.cells[col + i * self.size];\n        }\n        true\n    }\n\n    /// Generate a random board\n    ///\n    /// Returns a Board in a random state.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    ///\n    /// ```\n    /// let target: Board = Board::random(3);\n    /// ```\n    fn random<R: Rng>(rng: &mut R, size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size == 0 {\n            return Board::random(rng, 1);\n        }\n\n        // Make a vector of the board size with random bits\n        let cells = (0..size * size)\n            .map(|_| rng.gen::<bool>())\n            .collect::<Vec<_>>();\n        // Return the random board\n        Board { cells, size }\n    }\n}\n\nimpl PartialEq for Board {\n    fn eq(&self, rhs: &Board) -> bool {\n        self.cells == rhs.cells\n    }\n}\n\n// Implement the Display format, used with `print!(\"{}\", &board);`\nimpl fmt::Display for Board {\n    // Example output:\n    //   0 1 2\n    // 0 0 1 0\n    // 1 1 0 0\n    // 2 0 1 1\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Get the string width of the size of the board\n        let width = (self.size - 1).to_string().len();\n        // Write the initial spaces (upper left)\n        write!(f, \"{space: >0$}\", width, space = \" \")?;\n        // Write the column numbers\n        for i in 0..self.size {\n            write!(f, \" {offset:>0$}\", width, offset = i)?;\n        }\n        // Newline for rows\n        writeln!(f)?;\n        // Loop through the rows\n        for row in 0..self.size {\n            // Write the row number\n            write!(f, \"{row:>0$}\", width, row = row)?;\n            // Loop through the columns\n            for col in 0..self.size {\n                // Get the value of the cell as 1 or 0\n                let p = self.cells[row * self.size + col] as usize;\n                // Write the column value\n                write!(f, \" {col:>0$}\", width, col = p)?;\n            }\n            // Newline for next row\n            writeln!(f)?;\n        }\n        // Return Formatter result\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    // The board size\n    let size: usize = 3;\n    // The target board\n    let target: Board = Board::random(&mut rng, size);\n    // The user board\n    let mut board: Board = Board::new(size);\n    // How many moves taken\n    let mut moves: u32 = 0;\n    // Loop until win or quit\n    'mainloop: loop {\n        // User input\n        let mut input: String;\n        // Write the boards\n        println!(\"Target:\\n{}\\nBoard:\\n{}\", &target, &board);\n        // User input loop\n        'userinput: loop {\n            // Prompt\n            print!(\"\\nFlip? [q|[r|c]#] \");\n            // Flush stdout to write the previous print, if we can't then exit\n            match std::io::stdout().flush() {\n                Ok(_) => {}\n                Err(e) => {\n                    println!(\"Error: cannot flush stdout: {}\", e);\n                    break 'mainloop;\n                }\n            };\n            // Reset input for each loop\n            input = String::new();\n            // Read user input\n            match std::io::stdin().read_line(&mut input) {\n                Ok(_) => {\n                    input = input.trim().to_string();\n                    // Get the first character\n                    let rc: char = match input.chars().next() {\n                        Some(c) => c,\n                        None => {\n                            println!(\"Error: No input\");\n                            continue 'userinput;\n                        }\n                    };\n                    // Make sure input is r, c, or q\n                    if rc != 'r' && rc != 'c' && rc != 'q' {\n                        println!(\"Error: '{}': Must use 'r'ow or 'c'olumn or 'q'uit\", rc);\n                        continue 'userinput;\n                    }\n                    // If input is q, exit game\n                    if rc == 'q' {\n                        println!(\"Thanks for playing!\");\n                        break 'mainloop;\n                    }\n                    // If input is r or c, get the number after\n                    let n: usize = match input[1..].to_string().parse() {\n                        Ok(x) => {\n                            // If we're within bounds, return the parsed number\n                            if x < size {\n                                x\n                            } else {\n                                println!(\n                                    \"Error: Must specify a row or column within size({})\",\n                                    size\n                                );\n                                continue 'userinput;\n                            }\n                        }\n                        Err(_) => {\n                            println!(\n                                \"Error: '{}': Unable to parse row or column number\",\n                                &input[1..]\n                            );\n                            continue 'userinput;\n                        }\n                    };\n                    // Flip the row or column specified\n                    match rc {\n                        'r' => board.fliprow(n),\n                        'c' => board.flipcol(n),\n                        _ => {\n                            // We want to panic here because should NEVER\n                            // have anything other than 'r' or 'c' here\n                            panic!(\"How did you end up here?\");\n                        }\n                    };\n                    // Increment moves\n                    moves += 1;\n                    println!(\"Moves taken: {}\", moves);\n                    break 'userinput;\n                }\n                Err(e) => {\n                    println!(\"Error reading input: {}\", e);\n                    break 'mainloop;\n                }\n            }\n        } // 'userinput\n        if board == target {\n            println!(\"You win!\");\n            break;\n        }\n    } // 'mainloop\n}\n",
    "path": "tasks/flipping-bits-game",
    "remote_code": "\n// For random generation\nextern crate rand;\n\n// For fmt::Display\nuse std::fmt;\n// For I/O (stdin, stdout, etc)\nuse std::io::prelude::*;\n\nuse rand::Rng;\n\n/// A simple struct for a board\nstruct Board {\n    /// The cells of the board\n    cells: Vec<bool>,\n    /// The size of the board\n    size: usize,\n}\n\n// Functions for the Board struct\nimpl Board {\n    /// Generate a new, empty board, of size >= 1\n    ///\n    /// Returns a Board in the \"off\" state, where all cells are 0.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    /// A mutable board is required for using Board::fliprow and Board::flipcol functions.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// ```\n    fn new(size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size > 0 {\n            Board {\n                cells: vec![false; size * size],\n                size,\n            }\n        } else {\n            Board::new(1)\n        }\n    }\n\n    /// Flip the specified row\n    ///\n    /// Returns true if the row is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.fliprow(1);\n    /// ```\n    fn fliprow(&mut self, row: usize) -> bool {\n        // Check constraints\n        if row > self.size {\n            return false;\n        }\n        // Starting position in the vector\n        let start = row * self.size;\n        // Loop through the vector row\n        for i in start..start + self.size {\n            self.cells[i] = !self.cells[i];\n        }\n        true\n    }\n\n    /// Flip the specified column\n    ///\n    /// Returns true if the column is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.flipcol(0);\n    /// ```\n    fn flipcol(&mut self, col: usize) -> bool {\n        // Check constraints\n        if col > self.size {\n            return false;\n        }\n        // Loop through the vector column\n        for i in 0..self.size {\n            self.cells[col + i * self.size] = !self.cells[col + i * self.size];\n        }\n        true\n    }\n\n    /// Generate a random board\n    ///\n    /// Returns a Board in a random state.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    ///\n    /// ```\n    /// let target: Board = Board::random(3);\n    /// ```\n    fn random<R: Rng>(rng: &mut R, size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size == 0 {\n            return Board::random(rng, 1);\n        }\n\n        // Make a vector of the board size with random bits\n        let cells = (0..size * size)\n            .map(|_| rng.gen::<bool>())\n            .collect::<Vec<_>>();\n        // Return the random board\n        Board { cells, size }\n    }\n}\n\nimpl PartialEq for Board {\n    fn eq(&self, rhs: &Board) -> bool {\n        self.cells == rhs.cells\n    }\n}\n\n// Implement the Display format, used with `print!(\"{}\", &board);`\nimpl fmt::Display for Board {\n    // Example output:\n    //   0 1 2\n    // 0 0 1 0\n    // 1 1 0 0\n    // 2 0 1 1\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Get the string width of the size of the board\n        let width = (self.size - 1).to_string().len();\n        // Write the initial spaces (upper left)\n        write!(f, \"{space: >0$}\", width, space = \" \")?;\n        // Write the column numbers\n        for i in 0..self.size {\n            write!(f, \" {offset:>0$}\", width, offset = i)?;\n        }\n        // Newline for rows\n        writeln!(f)?;\n        // Loop through the rows\n        for row in 0..self.size {\n            // Write the row number\n            write!(f, \"{row:>0$}\", width, row = row)?;\n            // Loop through the columns\n            for col in 0..self.size {\n                // Get the value of the cell as 1 or 0\n                let p = self.cells[row * self.size + col] as usize;\n                // Write the column value\n                write!(f, \" {col:>0$}\", width, col = p)?;\n            }\n            // Newline for next row\n            writeln!(f)?;\n        }\n        // Return Formatter result\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    // The board size\n    let size: usize = 3;\n    // The target board\n    let target: Board = Board::random(&mut rng, size);\n    // The user board\n    let mut board: Board = Board::new(size);\n    // How many moves taken\n    let mut moves: u32 = 0;\n    // Loop until win or quit\n    'mainloop: loop {\n        // User input\n        let mut input: String;\n        // Write the boards\n        println!(\"Target:\\n{}\\nBoard:\\n{}\", &target, &board);\n        // User input loop\n        'userinput: loop {\n            // Prompt\n            print!(\"\\nFlip? [q|[r|c]#] \");\n            // Flush stdout to write the previous print, if we can't then exit\n            match std::io::stdout().flush() {\n                Ok(_) => {}\n                Err(e) => {\n                    println!(\"Error: cannot flush stdout: {}\", e);\n                    break 'mainloop;\n                }\n            };\n            // Reset input for each loop\n            input = String::new();\n            // Read user input\n            match std::io::stdin().read_line(&mut input) {\n                Ok(_) => {\n                    input = input.trim().to_string();\n                    // Get the first character\n                    let rc: char = match input.chars().next() {\n                        Some(c) => c,\n                        None => {\n                            println!(\"Error: No input\");\n                            continue 'userinput;\n                        }\n                    };\n                    // Make sure input is r, c, or q\n                    if rc != 'r' && rc != 'c' && rc != 'q' {\n                        println!(\"Error: '{}': Must use 'r'ow or 'c'olumn or 'q'uit\", rc);\n                        continue 'userinput;\n                    }\n                    // If input is q, exit game\n                    if rc == 'q' {\n                        println!(\"Thanks for playing!\");\n                        break 'mainloop;\n                    }\n                    // If input is r or c, get the number after\n                    let n: usize = match input[1..].to_string().parse() {\n                        Ok(x) => {\n                            // If we're within bounds, return the parsed number\n                            if x < size {\n                                x\n                            } else {\n                                println!(\n                                    \"Error: Must specify a row or column within size({})\",\n                                    size\n                                );\n                                continue 'userinput;\n                            }\n                        }\n                        Err(_) => {\n                            println!(\n                                \"Error: '{}': Unable to parse row or column number\",\n                                input[1..].to_string()\n                            );\n                            continue 'userinput;\n                        }\n                    };\n                    // Flip the row or column specified\n                    match rc {\n                        'r' => board.fliprow(n),\n                        'c' => board.flipcol(n),\n                        _ => {\n                            // We want to panic here because should NEVER\n                            // have anything other than 'r' or 'c' here\n                            panic!(\"How did you end up here?\");\n                        }\n                    };\n                    // Increment moves\n                    moves += 1;\n                    println!(\"Moves taken: {}\", moves);\n                    break 'userinput;\n                }\n                Err(e) => {\n                    println!(\"Error reading input: {}\", e);\n                    break 'mainloop;\n                }\n            }\n        } // 'userinput\n        if board == target {\n            println!(\"You win!\");\n            break;\n        }\n    } // 'mainloop\n}\n",
    "title": "Flipping bits game",
    "url": "http://rosettacode.org/wiki/Flipping_bits_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Flow-control structures",
    "url": "http://rosettacode.org/wiki/Flow-control_structures"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    floyds_triangle(5);\n    floyds_triangle(14);\n}\n\nfn floyds_triangle(n: u32) {\n    let mut triangle: Vec<Vec<String>> = Vec::new();\n    let mut current = 0;\n    for i in 1..=n {\n        let mut v = Vec::new();\n        for _ in 0..i {\n            current += 1;\n            v.push(current);\n        }\n        let row = v.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n        triangle.push(row);\n    }\n\n    for row in &triangle {\n        let arranged_row: Vec<_> = row\n            .iter()\n            .enumerate()\n            .map(|(i, number)| {\n                let space_len = triangle.last().unwrap()[i].len() - number.len() + 1;\n                let spaces = \" \".repeat(space_len);\n                let mut padded_number = spaces;\n                padded_number.push_str(&number);\n                padded_number\n            })\n            .collect();\n        println!(\"{}\", arranged_row.join(\"\"))\n    }\n}\n\n",
    "title": "Floyd's triangle",
    "url": "http://rosettacode.org/wiki/Floyd's_triangle"
  },
  {
    "local_code": "use std::cmp;\nuse std::collections::BTreeMap;\nuse std::i32;\nuse std::ops::{Index, IndexMut};\n\n/// A 2-D array for storing data per-vertex pair. 1-indexed.\n#[derive(Debug, Default)]\nstruct VertexArray<T> {\n    dimension: usize,\n    data: Vec<T>,\n}\n\nimpl<T> VertexArray<T>\nwhere\n    T: Default + Copy + Clone,\n{\n    fn new(dimension: usize) -> Self {\n        Self {\n            dimension,\n            data: vec![T::default(); dimension * dimension],\n        }\n    }\n}\n\nimpl<T> Index<(usize, usize)> for VertexArray<T> {\n    type Output = T;\n\n    fn index(&self, (i, j): (usize, usize)) -> &Self::Output {\n        let (i, j) = (i - 1, j - 1);\n        &self.data[self.dimension * i + j]\n    }\n}\n\nimpl<T> IndexMut<(usize, usize)> for VertexArray<T> {\n    fn index_mut(&mut self, (i, j): (usize, usize)) -> &mut Self::Output {\n        let (i, j) = (i - 1, j - 1);\n        &mut self.data[self.dimension * i + j]\n    }\n}\n\n/// Returns a `BTreeMap` mapping pairs of vertices to a pair consisting of the weight of the\n/// shortest path between them, and a `Vec` containing the path itself.\nfn floyd_warshall(graph: &[((usize, usize), i32)]) -> BTreeMap<(usize, usize), (i32, Vec<usize>)> {\n    let num_vertices = graph\n        .iter()\n        .map(|&((u, v), _)| cmp::max(u, v))\n        .max()\n        .unwrap();\n\n    let mut dist = VertexArray::<Option<i32>>::new(num_vertices);\n    let mut next = VertexArray::<Option<usize>>::new(num_vertices);\n\n    for &((u, v), w) in graph {\n        dist[(u, v)] = Some(w);\n        next[(u, v)] = Some(v);\n    }\n\n    for k in 1..=num_vertices {\n        dist[(k, k)] = Some(0);\n    }\n\n    for k in 1..=num_vertices {\n        for i in 1..=num_vertices {\n            for j in 1..=num_vertices {\n                if let (Some(w1), Some(w2)) = (dist[(i, k)], dist[(k, j)]) {\n                    if dist[(i, j)].is_none() || dist[(i, j)].unwrap() > w1 + w2 {\n                        dist[(i, j)] = Some(w1 + w2);\n                        next[(i, j)] = next[(i, k)];\n                    }\n                }\n            }\n        }\n    }\n\n    let mut pairs = BTreeMap::new();\n\n    for i in 1..=num_vertices {\n        for j in 1..=num_vertices {\n            if i == j {\n                continue;\n            }\n\n            let distance = dist[(i, j)].unwrap();\n            let path = path(&next, (i, j));\n            pairs.insert((i, j), (distance, path));\n        }\n    }\n\n    pairs\n}\n\nfn path(next: &VertexArray<Option<usize>>, (mut u, v): (usize, usize)) -> Vec<usize> {\n    let mut path = vec![u];\n\n    while u != v && next[(u, v)].is_some() {\n        u = next[(u, v)].unwrap();\n        path.push(u);\n    }\n\n    path\n}\n\n#[allow(clippy::print_literal)]\nfn main() {\n    let weights = vec![\n        ((1, 3), -2),\n        ((2, 1), 4),\n        ((2, 3), 3),\n        ((3, 4), 2),\n        ((4, 2), -1),\n    ];\n\n    println!(\"{:<7} {:<7} {}\", \"pair\", \"dist\", \"path\");\n    let pairs = floyd_warshall(&weights);\n    for (pair, &(distance, ref path)) in &pairs {\n        println!(\n            \"{:<7} {:<7} {:?}\",\n            format!(\"{} -> {}\", pair.0, pair.1),\n            format!(\"{:>4}\", distance),\n            path\n        );\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::BTreeMap;\n\n    #[test]\n    fn floyd_warshall() {\n        let weights = vec![\n            ((1, 3), -2),\n            ((2, 1), 4),\n            ((2, 3), 3),\n            ((3, 4), 2),\n            ((4, 2), -1),\n        ];\n\n        let mut expected = BTreeMap::new();\n        expected.insert((1, 2), (-1, vec![1, 3, 4, 2]));\n        expected.insert((1, 3), (-2, vec![1, 3]));\n        expected.insert((1, 4), (0, vec![1, 3, 4]));\n        expected.insert((2, 1), (4, vec![2, 1]));\n        expected.insert((2, 3), (2, vec![2, 1, 3]));\n        expected.insert((2, 4), (4, vec![2, 1, 3, 4]));\n        expected.insert((3, 1), (5, vec![3, 4, 2, 1]));\n        expected.insert((3, 2), (1, vec![3, 4, 2]));\n        expected.insert((3, 4), (2, vec![3, 4]));\n        expected.insert((4, 1), (3, vec![4, 2, 1]));\n        expected.insert((4, 2), (-1, vec![4, 2]));\n        expected.insert((4, 3), (1, vec![4, 2, 1, 3]));\n\n        assert_eq!(expected, super::floyd_warshall(&weights));\n    }\n}\n",
    "path": "tasks/floyd-warshall-algorithm",
    "remote_code": "pub type Edge = (usize, usize);\n\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\npub struct Graph<T> {\n    size: usize,\n    edges: Vec<Option<T>>,\n}\n\nimpl<T> Graph<T> {\n    pub fn new(size: usize) -> Self {\n        Self {\n            size,\n            edges: std::iter::repeat_with(|| None).take(size * size).collect(),\n        }\n    }\n\n    pub fn new_with(size: usize, f: impl FnMut(Edge) -> Option<T>) -> Self {\n        let edges = (0..size)\n            .flat_map(|i| (0..size).map(move |j| (i, j)))\n            .map(f)\n            .collect();\n\n        Self { size, edges }\n    }\n\n    pub fn with_diagonal(mut self, mut f: impl FnMut(usize) -> Option<T>) -> Self {\n        self.edges\n            .iter_mut()\n            .step_by(self.size + 1)\n            .enumerate()\n            .for_each(move |(vertex, edge)| *edge = f(vertex));\n\n        self\n    }\n\n    pub fn size(&self) -> usize {\n        self.size\n    }\n\n    pub fn edge(&self, edge: Edge) -> &Option<T> {\n        let index = self.edge_index(edge);\n        &self.edges[index]\n    }\n\n    pub fn edge_mut(&mut self, edge: Edge) -> &mut Option<T> {\n        let index = self.edge_index(edge);\n        &mut self.edges[index]\n    }\n\n    fn edge_index(&self, (row, col): Edge) -> usize {\n        assert!(row < self.size && col < self.size);\n        row * self.size() + col\n    }\n}\n\nimpl<T> std::ops::Index<Edge> for Graph<T> {\n    type Output = Option<T>;\n\n    fn index(&self, index: Edge) -> &Self::Output {\n        self.edge(index)\n    }\n}\n\nimpl<T> std::ops::IndexMut<Edge> for Graph<T> {\n    fn index_mut(&mut self, index: Edge) -> &mut Self::Output {\n        self.edge_mut(index)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Paths(Graph<usize>);\n\nimpl Paths {\n    pub fn new<T>(graph: &Graph<T>) -> Self {\n        Self(Graph::new_with(graph.size(), |(i, j)| {\n            graph[(i, j)].as_ref().map(|_| j)\n        }))\n    }\n\n    pub fn vertices(&self, from: usize, to: usize) -> Path<'_> {\n        assert!(from < self.0.size() && to < self.0.size());\n\n        Path {\n            graph: &self.0,\n            from: Some(from),\n            to,\n        }\n    }\n\n    fn update(&mut self, from: usize, to: usize, via: usize) {\n        self.0[(from, to)] = self.0[(from, via)];\n    }\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct Path<'a> {\n    graph: &'a Graph<usize>,\n    from: Option<usize>,\n    to: usize,\n}\n\nimpl<'a> Iterator for Path<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.from.map(|from| {\n            let result = from;\n\n            self.from = if result != self.to {\n                self.graph[(result, self.to)]\n            } else {\n                None\n            };\n\n            result\n        })\n    }\n}\n\npub fn floyd_warshall<W>(mut result: Graph<W>) -> (Graph<W>, Option<Paths>)\nwhere\n    W: Copy + std::ops::Add<W, Output = W> + std::cmp::Ord + Default,\n{\n    let mut without_negative_cycles = true;\n    let mut paths = Paths::new(&result);\n    let n = result.size();\n\n    for k in 0..n {\n        for i in 0..n {\n            for j in 0..n {\n                // Negative cycle detection with T::default as the negative boundary\n                if i == j && result[(i, j)].filter(|&it| it < W::default()).is_some() {\n                    without_negative_cycles = false;\n                    continue;\n                }\n\n                if let (Some(ik_weight), Some(kj_weight)) = (result[(i, k)], result[(k, j)]) {\n                    let ij_edge = result.edge_mut((i, j));\n                    let ij_weight = ik_weight + kj_weight;\n\n                    if ij_edge.is_none() {\n                        *ij_edge = Some(ij_weight);\n                        paths.update(i, j, k);\n                    } else {\n                        ij_edge\n                            .as_mut()\n                            .filter(|it| ij_weight < **it)\n                            .map_or((), |it| {\n                                *it = ij_weight;\n                                paths.update(i, j, k);\n                            });\n                    }\n                }\n            }\n        }\n    }\n\n    (result, Some(paths).filter(|_| without_negative_cycles)) // No paths for negative cycles\n}\n\nfn format_path<T: ToString>(path: impl Iterator<Item = T>) -> String {\n    path.fold(String::new(), |mut acc, x| {\n        if !acc.is_empty() {\n            acc.push_str(\" -> \");\n        }\n\n        acc.push_str(&x.to_string());\n        acc\n    })\n}\n\nfn print_results<W, V>(weights: &Graph<W>, paths: Option<&Paths>, vertex: impl Fn(usize) -> V)\nwhere\n    W: std::fmt::Display + Default + Eq,\n    V: std::fmt::Display,\n{\n    let n = weights.size();\n\n    for from in 0..n {\n        for to in 0..n {\n            if let Some(weight) = &weights[(from, to)] {\n                // Skip trivial information (i.e., default weight on the diagonal)\n                if from == to && *weight == W::default() {\n                    continue;\n                }\n\n                println!(\n                    \"{} -> {}: {} \\t{}\",\n                    vertex(from),\n                    vertex(to),\n                    weight,\n                    format_path(paths.iter().flat_map(|p| p.vertices(from, to)).map(&vertex))\n                );\n            }\n        }\n    }\n}\n\nfn main() {\n    let graph = {\n        let mut g = Graph::new(4).with_diagonal(|_| Some(0));\n        g[(0, 2)] = Some(-2);\n        g[(1, 0)] = Some(4);\n        g[(1, 2)] = Some(3);\n        g[(2, 3)] = Some(2);\n        g[(3, 1)] = Some(-1);\n        g\n    };\n\n    let (weights, paths) = floyd_warshall(graph);\n    // Fixup the vertex name (as we use zero-based indices)\n    print_results(&weights, paths.as_ref(), |index| index + 1);\n}\n",
    "title": "Floyd-Warshall algorithm",
    "url": "http://rosettacode.org/wiki/Floyd-Warshall_algorithm"
  },
  {
    "local_code": "extern crate ansi_term;\nextern crate rand;\n\n#[derive(Copy, Clone, PartialEq)]\nenum Tile {\n    Empty,\n    Tree,\n    Burning,\n    Heating,\n}\n\nimpl fmt::Display for Tile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let output = match *self {\n            Empty => Black.paint(\" \"),\n            Tree => Green.bold().paint(\"T\"),\n            Burning => Red.bold().paint(\"B\"),\n            Heating => Yellow.bold().paint(\"T\"),\n        };\n        write!(f, \"{}\", output)\n    }\n}\n\nconst NEW_TREE_PROB: f64 = 0.01;\nconst INITIAL_TREE_PROB: f64 = 0.5;\nconst FIRE_PROB: f64 = 0.001;\n\nconst FOREST_WIDTH: usize = 60;\nconst FOREST_HEIGHT: usize = 30;\n\nconst SLEEP_MILLIS: u64 = 25;\n\nuse std::fmt;\nuse std::io::prelude::*;\nuse std::io::{stdout, BufWriter, StdoutLock};\nuse std::process::Command;\nuse std::time::Duration;\n\nuse ansi_term::Colour::*;\nuse rand::{thread_rng, Rng};\n\nuse Tile::{Burning, Empty, Heating, Tree};\n\nfn main() {\n    let sleep_duration = Duration::from_millis(SLEEP_MILLIS);\n    let mut forest = [[Tile::Empty; FOREST_WIDTH]; FOREST_HEIGHT];\n\n    prepopulate_forest(&mut forest);\n    print_forest(forest, 0);\n\n    std::thread::sleep(sleep_duration);\n\n    for generation in 1.. {\n        for row in &mut forest {\n            for tile in row.iter_mut() {\n                update_tile(tile);\n            }\n        }\n\n        for y in 0..FOREST_HEIGHT {\n            for x in 0..FOREST_WIDTH {\n                if forest[y][x] == Burning {\n                    heat_neighbors(&mut forest, y, x);\n                }\n            }\n        }\n\n        print_forest(forest, generation);\n\n        std::thread::sleep(sleep_duration);\n    }\n}\n\nfn prepopulate_forest(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT]) {\n    let mut rng = thread_rng();\n\n    for row in forest.iter_mut() {\n        for tile in row.iter_mut() {\n            *tile = if rng.gen_bool(INITIAL_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            };\n        }\n    }\n}\n\nfn update_tile(tile: &mut Tile) {\n    let mut rng = thread_rng();\n    *tile = match *tile {\n        Empty => {\n            if rng.gen_bool(NEW_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            }\n        }\n        Tree => {\n            if rng.gen_bool(FIRE_PROB) {\n                Burning\n            } else {\n                Tree\n            }\n        }\n        Burning => Empty,\n        Heating => Burning,\n    }\n}\n\nfn heat_neighbors(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], y: usize, x: usize) {\n    let neighbors = [\n        (-1, -1),\n        (-1, 0),\n        (-1, 1),\n        (0, -1),\n        (0, 1),\n        (1, -1),\n        (1, 0),\n        (1, 1),\n    ];\n\n    for (nx, ny) in neighbors\n        .iter()\n        .map(|&(x_off, y_off)| (x as i8 + x_off, (y as i8 + y_off)))\n        .filter(|&(nx, ny)| nx > 0 && ny > 0)\n        .map(|(nx, ny)| (nx as usize, (ny as usize)))\n    {\n        if let Some(tile) = forest.get_mut(ny).and_then(|r| r.get_mut(nx)) {\n            if *tile == Tree {\n                *tile = Heating;\n            }\n        }\n    }\n}\n\nfn print_forest(forest: [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], generation: usize) {\n    let stdout = stdout();\n    let mut writer = BufWriter::new(stdout.lock());\n    clear_screen(&mut writer);\n    writeln!(writer, \"Generation: {}\", generation + 1).unwrap();\n    for row in &forest {\n        for tree in row.iter() {\n            write!(writer, \"{}\", tree).unwrap();\n        }\n        writeln!(writer).unwrap();\n    }\n}\n\nfn clear_screen(writer: &mut BufWriter<StdoutLock>) {\n    let output = Command::new(\"clear\").output().unwrap();\n    write!(writer, \"{}\", String::from_utf8_lossy(&output.stdout)).unwrap();\n}\n",
    "path": "tasks/forest-fire",
    "remote_code": "extern crate rand;\nextern crate ansi_term;\n\n#[derive(Copy, Clone, PartialEq)]\nenum Tile {\n    Empty,\n    Tree,\n    Burning,\n    Heating,\n}\n\nimpl fmt::Display for Tile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let output = match *self {\n            Empty => Black.paint(\" \"),\n            Tree => Green.bold().paint(\"T\"),\n            Burning => Red.bold().paint(\"B\"),\n            Heating => Yellow.bold().paint(\"T\"),\n        };\n        write!(f, \"{}\", output)\n    }\n}\n\n// This has been added to the nightly rust build as of March 24, 2016\n// Remove when in stable branch!\ntrait Contains<T> {\n    fn contains(&self, T) -> bool;\n}\n\nimpl<T: PartialOrd> Contains<T> for std::ops::Range<T> {\n    fn contains(&self, elt: T) -> bool {\n        self.start <= elt && elt < self.end\n    }\n}\n\nconst NEW_TREE_PROB: f32 = 0.01;\nconst INITIAL_TREE_PROB: f32 = 0.5;\nconst FIRE_PROB: f32 = 0.001;\n\nconst FOREST_WIDTH: usize = 60;\nconst FOREST_HEIGHT: usize = 30;\n\nconst SLEEP_MILLIS: u64 = 25;\n\nuse std::fmt;\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufWriter;\nuse std::io::Stdout;\nuse std::process::Command;\nuse std::time::Duration;\nuse rand::Rng;\nuse ansi_term::Colour::*;\n\nuse Tile::{Empty, Tree, Burning, Heating};\n\nfn main() {\n    let sleep_duration = Duration::from_millis(SLEEP_MILLIS);\n    let mut forest = [[Tile::Empty; FOREST_WIDTH]; FOREST_HEIGHT];\n\n    prepopulate_forest(&mut forest);\n    print_forest(forest, 0);\n\n    std::thread::sleep(sleep_duration);\n\n    for generation in 1.. {\n\n        for row in forest.iter_mut() {\n            for tile in row.iter_mut() {\n                update_tile(tile);\n            }\n        }\n\n        for y in 0..FOREST_HEIGHT {\n            for x in 0..FOREST_WIDTH {\n                if forest[y][x] == Burning {\n                    heat_neighbors(&mut forest, y, x);\n                }\n            }\n        }\n\n        print_forest(forest, generation);\n\n        std::thread::sleep(sleep_duration);\n    }\n}\n\nfn prepopulate_forest(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT]) {\n    for row in forest.iter_mut() {\n        for tile in row.iter_mut() {\n            *tile = if prob_check(INITIAL_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            };\n        }\n    }\n}\n\nfn update_tile(tile: &mut Tile) {\n    *tile = match *tile {\n        Empty => {\n            if prob_check(NEW_TREE_PROB) == true {\n                Tree\n            } else {\n                Empty\n            }\n        }\n        Tree => {\n            if prob_check(FIRE_PROB) == true {\n                Burning\n            } else {\n                Tree\n            }\n        }\n        Burning => Empty,\n        Heating => Burning,\n    }\n}\n\nfn heat_neighbors(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], y: usize, x: usize) {\n    let neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)];\n\n    for &(xoff, yoff) in neighbors.iter() {\n        let nx: i32 = (x as i32) + xoff;\n        let ny: i32 = (y as i32) + yoff;\n        if (0..FOREST_WIDTH as i32).contains(nx) && (0..FOREST_HEIGHT as i32).contains(ny) &&\n           forest[ny as usize][nx as usize] == Tree {\n            forest[ny as usize][nx as usize] = Heating\n        }\n    }\n}\n\nfn prob_check(chance: f32) -> bool {\n    let roll = rand::thread_rng().gen::<f32>();\n    if chance - roll > 0.0 {\n        true\n    } else {\n        false\n    }\n}\n\nfn print_forest(forest: [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], generation: u32) {\n    let mut writer = BufWriter::new(io::stdout());\n    clear_screen(&mut writer);\n    writeln!(writer, \"Generation: {}\", generation + 1).unwrap();\n    for row in forest.iter() {\n        for tree in row.iter() {\n            write!(writer, \"{}\", tree).unwrap();\n        }\n        writer.write(b\"\\n\").unwrap();\n    }\n}\n\nfn clear_screen(writer: &mut BufWriter<Stdout>) {\n    let output = Command::new(\"clear\").output().unwrap();\n    write!(writer, \"{}\", String::from_utf8_lossy(&output.stdout)).unwrap();\n}\n",
    "title": "Forest fire",
    "url": "http://rosettacode.org/wiki/Forest_fire"
  },
  {
    "local_code": "use std::process::Command;\n\nfn main() {\n    println!(\"parent\");\n\n    let _ = Command::new(\"echo\").arg(\"child\").spawn().unwrap();\n}\n",
    "path": "tasks/fork",
    "remote_code": "use nix::unistd::{fork, ForkResult};\nuse std::process::id;\n\nfn main() {\n    match fork() {\n        Ok(ForkResult::Parent { child, .. }) => {\n            println!(\n                \"This is the original process(pid: {}). New child has pid: {}\",\n                id(),\n                child\n            );\n        }\n        Ok(ForkResult::Child) => println!(\"This is the new process(pid: {}).\", id()),\n        Err(_) => println!(\"Something went wrong.\"),\n    }\n}\n",
    "title": "Fork",
    "url": "http://rosettacode.org/wiki/Fork"
  },
  {
    "local_code": "use std::fmt;\nuse std::fmt::Write;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\nuse std::sync::{Arc, Mutex};\n\nuse lazy_static::lazy_static;\nuse num::rational::BigRational;\nuse num::{BigInt, One, Signed, Zero};\n\nconst MAX_DISPLAYED_TERMS: usize = 24;\n\nlazy_static! {\n    static ref ZERO: FormalPowerSeries =\n        FormalPowerSeries::new(Arc::new(FormalPowerSeries::zero_func));\n    static ref ONE: FormalPowerSeries =\n        FormalPowerSeries::new(Arc::new(FormalPowerSeries::one_func));\n}\n\ntype Coef = Arc<dyn Fn(usize) -> BigRational + Send + Sync>;\ntype Cache = Arc<Mutex<Vec<BigRational>>>;\n\n#[derive(Clone)]\npub struct FormalPowerSeries {\n    // nobody else seems to be using bigints for the term index parameter, so usize it is\n    coef: Coef,\n}\n\nimpl FormalPowerSeries {\n    /// Helper for creating the global zero\n    fn zero_func(_: usize) -> BigRational {\n        BigRational::zero()\n    }\n\n    /// Helper for creating the global one\n    fn one_func(n: usize) -> BigRational {\n        if n == 0 {\n            BigRational::one()\n        } else {\n            BigRational::zero()\n        }\n    }\n\n    /// Returns the global additive identity\n    pub fn zero() -> &'static Self {\n        &*ZERO\n    }\n\n    /// Returns the global multiplicative identity\n    pub fn one() -> &'static Self {\n        &*ONE\n    }\n\n    /// Construct a new formal power series\n    pub fn new(coef: Coef) -> Self {\n        FormalPowerSeries { coef }\n    }\n\n    /// Returns a string of Unicode superscript characters corresponding to the base-10\n    /// representation of exp. Example: `12` becomes `¹²`.\n    fn exp_string(mut exp: usize) -> String {\n        const EXPS: [char; 10] = [\n            '\\u{2070}', '\\u{00B9}', '\\u{00B2}', '\\u{00B3}', '\\u{2074}', '\\u{2075}', '\\u{2076}',\n            '\\u{2077}', '\\u{2078}', '\\u{2079}',\n        ];\n        if exp == 1 {\n            return String::new();\n        } else if exp == 0 {\n            return String::from('\\u{2070}');\n        }\n        let mut digits = Vec::new();\n        let num_digits = (exp.log10() + 1) as usize; // obviously safe\n        digits.resize(num_digits, '\\0');\n        for i in 0..num_digits {\n            let digit = (exp % 10) as usize; // obviously safe\n            digits[num_digits - (i + 1)] = EXPS[digit];\n            exp /= 10;\n        }\n        digits.into_iter().collect()\n    }\n\n    /// Returns the xⁿ term of the series\n    pub fn nth(&self, n: usize) -> BigRational {\n        (self.coef)(n)\n    }\n\n    /// Helper function for computing the inverse\n    fn inv_coef(&self, n: usize, cache: Cache) -> BigRational {\n        if n == 0 {\n            BigRational::one() / self.nth(0)\n        } else {\n            let cache_vec = cache.lock().unwrap();\n            let len = cache_vec.len();\n            if len > n {\n                cache_vec[n].clone()\n            } else {\n                drop(cache_vec); // since we need to pass the cache to the recursive calls\n                let mut prod_others = BigRational::zero();\n                for i in 0..n {\n                    prod_others -= self.nth(n - i) * self.inv_coef(i, cache.clone())\n                }\n                let result = prod_others / self.nth(0);\n                let mut cache_vec = cache.lock().unwrap();\n                cache_vec.resize(n + 1, BigRational::zero());\n                cache_vec[n] = result;\n                cache_vec[n].clone()\n            }\n        }\n    }\n\n    /// Returns the inverse, which is the series _s_ such that _self_ * _s_ = 1. Only valid for\n    /// series with nonzero constant term.\n    pub fn inverse(&self) -> Self {\n        if self.nth(0) == BigRational::zero() {\n            panic!(\"cannot take the inverse of a series with constant term zero\");\n        }\n        let copy = self.clone();\n        let inv_coef = Arc::new(move |n| {\n            let cache = Arc::new(Mutex::new(Vec::with_capacity(MAX_DISPLAYED_TERMS)));\n            copy.inv_coef(n, cache)\n        });\n        FormalPowerSeries::new(inv_coef)\n    }\n\n    /// Returns the first derivative of the series with respect to x\n    pub fn derivative(&self) -> Self {\n        let copy = self.clone();\n        let deriv_coef =\n            Arc::new(move |n| copy.nth(n + 1) * BigRational::from(BigInt::from(n + 1)));\n        FormalPowerSeries::new(deriv_coef)\n    }\n\n    /// Returns the definite integral of the series with lower limit 0 and upper limit x\n    pub fn integral(&self) -> Self {\n        let copy = self.clone();\n        let int_coef = Arc::new(move |n| {\n            if n > 0 {\n                copy.nth(n - 1) * BigRational::new(BigInt::one(), BigInt::from(n))\n            } else {\n                BigRational::zero()\n            }\n        });\n        FormalPowerSeries::new(int_coef)\n    }\n\n    pub fn iter(&self) -> Iter {\n        Iter {\n            series: self,\n            cur_term: 0,\n        }\n    }\n\n    pub fn iter_nonzero(&self) -> IterNonzero {\n        IterNonzero {\n            series: self,\n            cur_term: 0,\n        }\n    }\n}\n\n// Here and in the other ops the closures are shared since FormalPowerSeries is a persistent type\nimpl Add for FormalPowerSeries {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        let sum_coef = Arc::new(move |index| self.nth(index) + rhs.nth(index));\n        FormalPowerSeries::new(sum_coef)\n    }\n}\n\nimpl Sub for FormalPowerSeries {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        let diff_coef = Arc::new(move |index| self.nth(index) - rhs.nth(index));\n        FormalPowerSeries::new(diff_coef)\n    }\n}\n\nimpl Mul for FormalPowerSeries {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        let prod_coef = Arc::new(move |index| {\n            let mut prod = BigRational::zero();\n            for i in 0..=index {\n                prod += self.nth(i) * rhs.nth(index - i);\n            }\n            prod\n        });\n        FormalPowerSeries::new(prod_coef)\n    }\n}\n\nimpl Div for FormalPowerSeries {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inverse()\n    }\n}\n\nimpl Neg for FormalPowerSeries {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        FormalPowerSeries::new(Arc::new(move |n| -self.nth(n)))\n    }\n}\n\nimpl Add for &FormalPowerSeries {\n    type Output = FormalPowerSeries;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        let lcpy = self.clone();\n        let rcpy = rhs.clone();\n        let sum_coef = Arc::new(move |n| lcpy.nth(n) + rcpy.nth(n));\n        FormalPowerSeries::new(sum_coef)\n    }\n}\n\nimpl Sub for &FormalPowerSeries {\n    type Output = FormalPowerSeries;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        let lcpy = self.clone();\n        let rcpy = rhs.clone();\n        let diff_coef = Arc::new(move |n| lcpy.nth(n) - rcpy.nth(n));\n        FormalPowerSeries::new(diff_coef)\n    }\n}\n\nimpl Mul for &FormalPowerSeries {\n    type Output = FormalPowerSeries;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n        let lcpy = self.clone();\n        let rcpy = rhs.clone();\n        let prod_coef = Arc::new(move |n| {\n            let mut prod = BigRational::zero();\n            for i in 0..=n {\n                prod += lcpy.nth(i) * rcpy.nth(n - i);\n            }\n            prod\n        });\n        FormalPowerSeries::new(prod_coef)\n    }\n}\n\nimpl Div for &FormalPowerSeries {\n    type Output = FormalPowerSeries;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * &rhs.inverse()\n    }\n}\n\nimpl Neg for &FormalPowerSeries {\n    type Output = FormalPowerSeries;\n\n    fn neg(self) -> Self::Output {\n        let copy = self.clone();\n        FormalPowerSeries::new(Arc::new(move |n| -copy.nth(n)))\n    }\n}\n\nimpl fmt::Display for FormalPowerSeries {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut s = String::new();\n        for term in self.iter().take(MAX_DISPLAYED_TERMS) {\n            if term.coef == BigRational::zero() {\n                continue;\n            }\n            let exp_string = FormalPowerSeries::exp_string(term.exp);\n            const EXP_ZERO: &str = \"\\u{2070}\";\n            if exp_string == EXP_ZERO {\n                write!(s, \"{}\", term.coef)?;\n            } else if s.is_empty() {\n                if term.coef == BigRational::one() {\n                    write!(s, \"x{}\", exp_string)?;\n                } else if term.coef.abs() == BigRational::one() {\n                    write!(s, \"-x{}\", exp_string)?;\n                } else {\n                    write!(s, \"{} x{}\", term.coef, exp_string)?;\n                }\n            } else {\n                let sign = if term.coef > BigRational::zero() {\n                    '+'\n                } else {\n                    '-'\n                };\n                let coef = term.coef.abs();\n                if coef == BigRational::one() {\n                    write!(s, \" {} x{}\", sign, exp_string)?;\n                } else {\n                    write!(s, \" {} {} x{}\", sign, term.coef.abs(), exp_string)?;\n                }\n            }\n        }\n        if s.is_empty() {\n            write!(f, \"0\")?;\n        } else {\n            write!(f, \"{}\", s)?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Term {\n    pub exp: usize,\n    pub coef: BigRational,\n}\n\npub struct Iter<'a> {\n    series: &'a FormalPowerSeries,\n    cur_term: usize,\n}\n\nimpl<'a> Iterator for Iter<'a> {\n    type Item = Term;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.cur_term == usize::MAX {\n            None\n        } else {\n            let coef = self.series.nth(self.cur_term);\n            let exp = self.cur_term;\n            self.cur_term += 1;\n            Some(Term { exp, coef })\n        }\n    }\n}\n\npub struct IterNonzero<'a> {\n    series: &'a FormalPowerSeries,\n    cur_term: usize,\n}\n\nimpl<'a> Iterator for IterNonzero<'a> {\n    type Item = Term;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        for exp in (self.cur_term + 1).. {\n            let coef = self.series.nth(exp);\n            if coef != BigRational::zero() {\n                self.cur_term = exp;\n                return Some(Term { exp, coef });\n            }\n        }\n        unreachable!()\n    }\n}\n#![feature(int_log)]\n#![feature(once_cell)]\n\nmod fps;\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use lazy_static::lazy_static;\n    use num::{BigInt, BigRational, One, Zero};\n\n    use super::fps::*;\n\n    lazy_static! {\n        static ref N_PLUS_ONE: FormalPowerSeries =\n            FormalPowerSeries::new(Arc::new(|n| { BigRational::from(BigInt::from(n + 1)) }));\n        static ref TWO_TIMES_N: FormalPowerSeries =\n            FormalPowerSeries::new(Arc::new(|n| { BigRational::from(BigInt::from(2 * n)) }));\n        static ref ONE_MINUS_X_SQ: FormalPowerSeries = FormalPowerSeries::new(Arc::new(|n| {\n            if n == 0 {\n                BigRational::one()\n            } else if n == 1 {\n                BigRational::from(BigInt::from(-2))\n            } else if n == 2 {\n                BigRational::one()\n            } else {\n                BigRational::zero()\n            }\n        }));\n        static ref SIN: FormalPowerSeries = FormalPowerSeries::new(Arc::new(move |n| {\n            if n == 0 {\n                BigRational::zero()\n            } else {\n                COS.integral().nth(n)\n            }\n        }));\n        static ref COS: FormalPowerSeries = FormalPowerSeries::new(Arc::new(move |n| {\n            if n == 0 {\n                BigRational::one()\n            } else {\n                (FormalPowerSeries::one() - &SIN.integral()).nth(n)\n            }\n        }));\n    }\n\n    #[test]\n    #[cfg(feature = \"five_terms\")]\n    fn create_and_print() {\n        let fps = &*N_PLUS_ONE;\n        assert_eq!(\n            fps.to_string(),\n            \"1 + 2 x + 3 x\\u{00B2} + 4 x\\u{00B3} + 5 x\\u{2074}\"\n        )\n    }\n\n    #[test]\n    fn zero_one() {\n        let zero = FormalPowerSeries::zero();\n        let one = FormalPowerSeries::one();\n        assert_eq!(zero.to_string(), \"0\");\n        assert_eq!(one.to_string(), \"1\");\n    }\n\n    #[test]\n    #[cfg(feature = \"five_terms\")]\n    fn arithmetic() {\n        let fps1 = &*N_PLUS_ONE;\n        let fps2 = &*TWO_TIMES_N;\n        let poly = &*ONE_MINUS_X_SQ;\n        assert_eq!(\n            (fps1 + fps2).to_string(),\n            \"1 + 4 x + 7 x\\u{00B2} + 10 x\\u{00B3} + 13 x\\u{2074}\"\n        );\n        assert_eq!(\n            (fps1 - fps2).to_string(),\n            \"1 - x\\u{00B2} - 2 x\\u{00B3} - 3 x\\u{2074}\"\n        );\n        assert_eq!(\n            (fps1 * fps2).to_string(),\n            \"2 x + 8 x\\u{00B2} + 20 x\\u{00B3} + 40 x\\u{2074}\"\n        );\n        assert_eq!(\n            (poly / fps1).to_string(),\n            \"1 - 4 x + 6 x\\u{00B2} - 4 x\\u{00B3} + x\\u{2074}\"\n        );\n    }\n\n    #[test]\n    fn inverse() {\n        let fps1 = &*N_PLUS_ONE;\n        let fps2 = &*TWO_TIMES_N;\n        let poly = &*ONE_MINUS_X_SQ;\n        assert_eq!(fps1.inverse().to_string(), poly.to_string());\n        assert_eq!(\n            (fps1 * poly).to_string(),\n            FormalPowerSeries::one().to_string()\n        );\n        assert_eq!((fps2 / fps1).to_string(), \"2 x\")\n    }\n\n    #[test]\n    #[should_panic]\n    fn invert_zero_constant_term() {\n        let zct = &*TWO_TIMES_N;\n        zct.inverse();\n    }\n\n    #[test]\n    fn calculus() {\n        let fps1 = FormalPowerSeries::one() + &(*N_PLUS_ONE).integral();\n        let fps2 = FormalPowerSeries::new(Arc::new(move |_| BigRational::one()));\n        assert_eq!(fps1.to_string(), fps2.to_string());\n        assert_eq!(fps2.derivative().to_string(), *N_PLUS_ONE.to_string());\n    }\n\n    #[test]\n    fn sin_cos() {\n        let sin_series = &*SIN;\n        let cos_series = &*COS;\n\n        println!(\"sin(x) = {}\", sin_series);\n        println!(\"cos(x) = {}\", cos_series);\n\n        // Definitions\n        assert_eq!(sin_series.to_string(), cos_series.integral().to_string());\n        assert_eq!(\n            cos_series.to_string(),\n            (FormalPowerSeries::one() - &sin_series.integral()).to_string()\n        );\n\n        // Pythagorean identity\n        assert_eq!(\n            (sin_series * sin_series + cos_series * cos_series).to_string(),\n            FormalPowerSeries::one().to_string()\n        );\n    }\n\n    #[test]\n    #[cfg(feature = \"five_terms\")]\n    fn sin_cos_explicit() {\n        let sin_series = &*SIN;\n        let cos_series = &*COS;\n        assert_eq!(sin_series.to_string(), \"x - 1/6 x\\u{00B3}\");\n        assert_eq!(cos_series.to_string(), \"1 - 1/2 x\\u{00B2} + 1/24 x\\u{2074}\");\n    }\n}\n",
    "path": "tasks/formal-power-series",
    "remote_code": null,
    "title": "Formal power series",
    "url": "http://rosettacode.org/wiki/Formal_power_series"
  },
  {
    "local_code": "fn main() {\n    let x = 7.125;\n\n    println!(\"{:9}\", x);\n    println!(\"{:09}\", x);\n    println!(\"{:9}\", -x);\n    println!(\"{:09}\", -x);\n}\n",
    "path": "tasks/formatted-numeric-output",
    "remote_code": "\nfn main() {\n    let x = 7.125;\n\n    println!(\"{:9}\", x);\n    println!(\"{:09}\", x);\n    println!(\"{:9}\", -x);\n    println!(\"{:09}\", -x);\n}\n",
    "title": "Formatted numeric output",
    "url": "http://rosettacode.org/wiki/Formatted_numeric_output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fortunate numbers",
    "url": "http://rosettacode.org/wiki/Fortunate_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Forward difference",
    "url": "http://rosettacode.org/wiki/Forward_difference"
  },
  {
    "local_code": "use std::fmt;\nuse std::ops::Deref;\n\n// primitive gates\nfn not(a: bool) -> bool {\n    !a\n}\nfn or(a: bool, b: bool) -> bool {\n    a || b\n}\nfn and(a: bool, b: bool) -> bool {\n    a && b\n}\n\n/// xor gate [2x not, 2x and, 1x or]\n/// (A & !B) | (B & !A)\nfn xor(a: bool, b: bool) -> bool {\n    or(and(a, not(b)), and(b, not(a)))\n}\n\n/// half adder [1x xor, 1x and]\n/// S = A ^ B, C = A & B\nfn half_adder(a: bool, b: bool) -> (bool, bool) {\n    (xor(a, b), and(a, b))\n}\n\n/// full adder [2x half adder, 1x or]\n/// t = (C0 + A), t2 = t.S + B\n/// S = t2.S, C = t.C | t2.C\nfn full_adder(a: bool, b: bool, carry: bool) -> (bool, bool) {\n    let (s0, c0) = half_adder(carry, a);\n    let (s1, c1) = half_adder(s0, b);\n\n    (s1, or(c0, c1))\n}\n\n#[derive(Copy, Clone)]\nstruct Nibble([bool; 4]);\nimpl Nibble {\n    fn new(arr: [u8; 4]) -> Nibble {\n        Nibble([arr[0] != 0, arr[1] != 0, arr[2] != 0, arr[3] != 0])\n    }\n\n    fn from_u8(n: u8) -> Nibble {\n        Nibble::new([n & 8, n & 4, n & 2, n & 1])\n    }\n\n    fn to_u8(self, carry: bool) -> u8 {\n        match u8::from_str_radix(&(format!(\"{}\", self))[..], 2) {\n            Ok(n) if carry => n + 16,\n            Ok(n) => n,\n            Err(_) => unreachable!(),\n        }\n    }\n}\n\nimpl fmt::Display for Nibble {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(\n            f,\n            \"{}\",\n            self.iter()\n                .map(|&b| if b { '1' } else { '0' })\n                .collect::<String>()\n        )\n    }\n}\n\n/// We implement `Deref` so we can index the Nibble easily\nimpl<'a> Deref for Nibble {\n    type Target = [bool; 4];\n\n    fn deref(&self) -> &[bool; 4] {\n        let Nibble(ref inner) = *self;\n        inner\n    }\n}\n\n/// 4bit adder [4x full adder]\n/// calculate each bit of the sum, propagate the carry\nfn four_bit_adder(a: Nibble, b: Nibble, carry: bool) -> (Nibble, bool) {\n    let (s0, carry) = full_adder(a[3], b[3], carry);\n    let (s1, carry) = full_adder(a[2], b[2], carry);\n    let (s2, carry) = full_adder(a[1], b[1], carry);\n    let (s3, carry) = full_adder(a[0], b[0], carry);\n\n    (Nibble([s3, s2, s1, s0]), carry)\n}\n\nfn main() {\n    let nib_a = Nibble::new([1u8, 0, 1, 1]);\n    let a = nib_a.to_u8(false);\n    let b = 6;\n    let nib_b = Nibble::from_u8(b);\n    let (result, carry) = four_bit_adder(nib_a, nib_b, false);\n    println!(\n        \"{} + {} = {} | {} + {} = {} | overflow: {}\",\n        a,\n        b,\n        result.to_u8(carry),\n        nib_a,\n        nib_b,\n        result,\n        carry\n    )\n}\n\n#[test]\nfn test_not() {\n    assert_eq!(true, not(false));\n    assert_eq!(false, not(true));\n}\n\n#[test]\nfn test_or() {\n    assert_eq!(false, or(false, false));\n    assert_eq!(true, or(true, false));\n    assert_eq!(true, or(false, true));\n    assert_eq!(true, or(true, true));\n}\n\n#[test]\nfn test_and() {\n    assert_eq!(false, and(false, false));\n    assert_eq!(false, and(false, true));\n    assert_eq!(false, and(true, false));\n    assert_eq!(true, and(true, true));\n}\n\n#[test]\nfn test_xor() {\n    assert_eq!(false, xor(false, false));\n    assert_eq!(true, xor(false, true));\n    assert_eq!(true, xor(true, false));\n    assert_eq!(false, xor(true, true));\n}\n\n#[test]\nfn test_full_add() {\n    assert_eq!((false, false), full_adder(false, false, false));\n    assert_eq!((true, false), full_adder(false, false, true));\n    assert_eq!((true, false), full_adder(false, true, false));\n    assert_eq!((true, false), full_adder(true, false, false));\n    assert_eq!((false, true), full_adder(false, true, true));\n    assert_eq!((false, true), full_adder(true, false, true));\n    assert_eq!((false, true), full_adder(true, true, false));\n    assert_eq!((true, true), full_adder(true, true, true));\n}\n\n#[test]\nfn test_four_bit_adder() {\n    for (a, b) in (0..std::u8::MAX).map(|n| (n >> 4, n & 15)) {\n        let nib_a = Nibble::from_u8(a);\n        let nib_b = Nibble::from_u8(b);\n\n        let (result, carry) = four_bit_adder(nib_a, nib_b, false);\n        assert_eq!(a + b, result.to_u8(carry));\n        let (result, carry) = four_bit_adder(nib_a, nib_b, true);\n        assert_eq!(a + b + 1, result.to_u8(carry));\n    }\n}\n",
    "path": "tasks/four-bit-adder",
    "remote_code": "\n// half adder with XOR and AND\n// SUM = A XOR B\n// CARRY = A.B\nfn half_adder(a: usize, b: usize) -> (usize, usize) {\n    return (a ^ b, a & b);\n}\n\n// full adder as a combination of half adders\n// SUM = A XOR B XOR C\n// CARRY = A.B + B.C + C.A\nfn full_adder(a: usize, b: usize, c_in: usize) -> (usize, usize) {\n    let (s0, c0) = half_adder(a, b);\n    let (s1, c1) = half_adder(s0, c_in);\n    return (s1, c0 | c1);\n}\n\n// A = (A3, A2, A1, A0)\n// B = (B3, B2, B1, B0)\n// S = (S3, S2, S1, S0)\nfn four_bit_adder (\n    a: (usize, usize, usize, usize),\n    b: (usize, usize, usize, usize)\n)\n    ->\n    // 4 bit output, carry is ignored\n    (usize, usize, usize, usize)\n{\n    // lets have a.0 refer to the rightmost element\n    let a = a.reverse();\n    let b = b.reverse();\n\n    // i would prefer a loop but that would abstract\n    // the \"connections of the constructive blocks\"\n    let (sum, carry) = half_adder(a.0, b.0);\n    let out0 = sum;\n    let (sum, carry) = full_adder(a.1, b.1, carry);\n    let out1 = sum;\n    let (sum, carry) = full_adder(a.2, b.2, carry);\n    let out2 = sum;\n    let (sum, _) = full_adder(a.3, b.3, carry);\n    let out3 = sum;\n    return (out3, out2, out1, out0);\n}\n\nfn main() {\n    let a: (usize, usize, usize, usize) = (0, 1, 1, 0);\n    let b: (usize, usize, usize, usize) = (0, 1, 1, 0);\n    assert_eq!(four_bit_adder(a, b), (1, 1, 0, 0));\n    // 0110 + 0110 = 1100\n    // 6 + 6 = 12\n}\n\n// misc. traits to make our life easier\ntrait Reverse<A, B, C, D> {\n    fn reverse(self) -> (D, C, B, A);\n}\n\n// reverse a generic tuple of arity 4\nimpl<A, B, C, D> Reverse<A, B, C, D> for (A, B, C, D) {\n    fn reverse(self) -> (D, C, B, A){\n        return (self.3, self.2, self.1, self.0)\n    }\n}\n\n",
    "title": "Four bit adder",
    "url": "http://rosettacode.org/wiki/Four_bit_adder"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    magic(4);\n    magic(2_340);\n    magic(765_000);\n    magic(27_000_001);\n    magic(999_123_090);\n    magic(239_579_832_723_441);\n    magic(std::u64::MAX);\n}\n\nfn magic(num: u64) {\n    if num == 4 {\n        println!(\"four is magic!\");\n        println!();\n        return;\n    }\n    let name = number_name(num);\n    let len = name.len() as u64;\n    print!(\"{} is {}, \", name, number_name(len));\n    magic(len);\n}\n\n\nconst LOW: &'static [&'static str] = &[\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n    \"six\", \"seven\", \"eight\",\"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n    \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n];\nconst MED: &'static [&'static str] = &[\n    \"twenty\", \"thirty\", \"forty\", \"fifty\",\n    \"sixy\", \"seventy\", \"eighty\", \"ninety\"\n];\nconst HIGH: &'static [&'static str] = &[\n    \"thousand\", \"million\", \"billion\",\n    \"trillion\", \"quadrillion\", \"quintillion\"\n];\n\nfn number_name(num: u64) -> String {\n    if num < 20 {\n        return LOW[num as usize].to_string();\n    }\n    if num < 100 {\n        let index = ((num / 10) - 2) as usize;\n        let tens = MED[index].to_string();\n        let remainder = num % 10;\n        if remainder > 0 {\n            return format!(\"{}-{}\", tens, number_name(remainder));\n        }\n        return tens;\n    }\n    if num < 1000 {\n        let hundreds = LOW[(num / 100) as usize];\n        let remainder = num % 100;\n        if remainder > 0 {\n            return format!(\"{} hundred {}\", hundreds, number_name(remainder));\n        }\n        return format!(\"{} hundred\", hundreds);\n    }\n\n    let mut remainder = num % 1000;\n    let mut cur = if remainder > 0 { number_name(remainder) } else { \"\".to_string() };\n    let mut n = num / 1000;\n\n    for noun in HIGH.iter() {\n        if n > 0 {\n            remainder = n % 1000;\n            if remainder > 0 {\n                // this condition resolves double space issues\n                cur =\n                    if cur.len() > 0 { format!(\"{} {} {}\", number_name(remainder), noun, cur ) }\n                    else { format!(\"{} {}\", number_name(remainder), noun) }\n            }\n            n /= 1000;\n        }\n    }\n    return cur;\n}",
    "title": "Four is magic",
    "url": "http://rosettacode.org/wiki/Four_is_magic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct NumberNames {\n    cardinal: &'static str,\n    ordinal: &'static str,\n}\n\nimpl NumberNames {\n    fn get_name(&self, ordinal: bool) -> &'static str {\n        if ordinal {\n            return self.ordinal;\n        }\n        self.cardinal\n    }\n}\n\nconst SMALL_NAMES: [NumberNames; 20] = [\n    NumberNames {\n        cardinal: \"zero\",\n        ordinal: \"zeroth\",\n    },\n    NumberNames {\n        cardinal: \"one\",\n        ordinal: \"first\",\n    },\n    NumberNames {\n        cardinal: \"two\",\n        ordinal: \"second\",\n    },\n    NumberNames {\n        cardinal: \"three\",\n        ordinal: \"third\",\n    },\n    NumberNames {\n        cardinal: \"four\",\n        ordinal: \"fourth\",\n    },\n    NumberNames {\n        cardinal: \"five\",\n        ordinal: \"fifth\",\n    },\n    NumberNames {\n        cardinal: \"six\",\n        ordinal: \"sixth\",\n    },\n    NumberNames {\n        cardinal: \"seven\",\n        ordinal: \"seventh\",\n    },\n    NumberNames {\n        cardinal: \"eight\",\n        ordinal: \"eighth\",\n    },\n    NumberNames {\n        cardinal: \"nine\",\n        ordinal: \"ninth\",\n    },\n    NumberNames {\n        cardinal: \"ten\",\n        ordinal: \"tenth\",\n    },\n    NumberNames {\n        cardinal: \"eleven\",\n        ordinal: \"eleventh\",\n    },\n    NumberNames {\n        cardinal: \"twelve\",\n        ordinal: \"twelfth\",\n    },\n    NumberNames {\n        cardinal: \"thirteen\",\n        ordinal: \"thirteenth\",\n    },\n    NumberNames {\n        cardinal: \"fourteen\",\n        ordinal: \"fourteenth\",\n    },\n    NumberNames {\n        cardinal: \"fifteen\",\n        ordinal: \"fifteenth\",\n    },\n    NumberNames {\n        cardinal: \"sixteen\",\n        ordinal: \"sixteenth\",\n    },\n    NumberNames {\n        cardinal: \"seventeen\",\n        ordinal: \"seventeenth\",\n    },\n    NumberNames {\n        cardinal: \"eighteen\",\n        ordinal: \"eighteenth\",\n    },\n    NumberNames {\n        cardinal: \"nineteen\",\n        ordinal: \"nineteenth\",\n    },\n];\n\nconst TENS: [NumberNames; 8] = [\n    NumberNames {\n        cardinal: \"twenty\",\n        ordinal: \"twentieth\",\n    },\n    NumberNames {\n        cardinal: \"thirty\",\n        ordinal: \"thirtieth\",\n    },\n    NumberNames {\n        cardinal: \"forty\",\n        ordinal: \"fortieth\",\n    },\n    NumberNames {\n        cardinal: \"fifty\",\n        ordinal: \"fiftieth\",\n    },\n    NumberNames {\n        cardinal: \"sixty\",\n        ordinal: \"sixtieth\",\n    },\n    NumberNames {\n        cardinal: \"seventy\",\n        ordinal: \"seventieth\",\n    },\n    NumberNames {\n        cardinal: \"eighty\",\n        ordinal: \"eightieth\",\n    },\n    NumberNames {\n        cardinal: \"ninety\",\n        ordinal: \"ninetieth\",\n    },\n];\n\nstruct NamedNumber {\n    cardinal: &'static str,\n    ordinal: &'static str,\n    number: usize,\n}\n\nimpl NamedNumber {\n    fn get_name(&self, ordinal: bool) -> &'static str {\n        if ordinal {\n            return self.ordinal;\n        }\n        self.cardinal\n    }\n}\n\nconst N: usize = 7;\nconst NAMED_NUMBERS: [NamedNumber; N] = [\n    NamedNumber {\n        cardinal: \"hundred\",\n        ordinal: \"hundredth\",\n        number: 100,\n    },\n    NamedNumber {\n        cardinal: \"thousand\",\n        ordinal: \"thousandth\",\n        number: 1000,\n    },\n    NamedNumber {\n        cardinal: \"million\",\n        ordinal: \"millionth\",\n        number: 1000000,\n    },\n    NamedNumber {\n        cardinal: \"billion\",\n        ordinal: \"billionth\",\n        number: 1000000000,\n    },\n    NamedNumber {\n        cardinal: \"trillion\",\n        ordinal: \"trillionth\",\n        number: 1000000000000,\n    },\n    NamedNumber {\n        cardinal: \"quadrillion\",\n        ordinal: \"quadrillionth\",\n        number: 1000000000000000,\n    },\n    NamedNumber {\n        cardinal: \"quintillion\",\n        ordinal: \"quintillionth\",\n        number: 1000000000000000000,\n    },\n];\n\nfn big_name(n: usize) -> &'static NamedNumber {\n    for i in 1..N {\n        if n < NAMED_NUMBERS[i].number {\n            return &NAMED_NUMBERS[i - 1];\n        }\n    }\n    &NAMED_NUMBERS[N - 1]\n}\n\nfn count_letters(s: &str) -> usize {\n    let mut count = 0;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n            count += 1;\n        }\n    }\n    count\n}\n\nstruct WordList {\n    words: Vec<(usize, usize)>,\n    string: String,\n}\n\nimpl WordList {\n    fn new() -> WordList {\n        WordList {\n            words: Vec::new(),\n            string: String::new(),\n        }\n    }\n    fn append(&mut self, s: &str) {\n        let offset = self.string.len();\n        self.string.push_str(s);\n        self.words.push((offset, offset + s.len()));\n    }\n    fn extend(&mut self, s: &str) {\n        let len = self.words.len();\n        let mut w = &mut self.words[len - 1];\n        w.1 += s.len();\n        self.string.push_str(s);\n    }\n    fn len(&self) -> usize {\n        self.words.len()\n    }\n    fn sentence_length(&self) -> usize {\n        let n = self.words.len();\n        if n == 0 {\n            return 0;\n        }\n        self.string.len() + n - 1\n    }\n    fn get_word(&self, index: usize) -> &str {\n        let w = &self.words[index];\n        &self.string[w.0..w.1]\n    }\n}\n\nfn append_number_name(words: &mut WordList, n: usize, ordinal: bool) -> usize {\n    let mut count = 0;\n    if n < 20 {\n        words.append(SMALL_NAMES[n].get_name(ordinal));\n        count += 1;\n    } else if n < 100 {\n        if n % 10 == 0 {\n            words.append(TENS[n / 10 - 2].get_name(ordinal));\n        } else {\n            words.append(TENS[n / 10 - 2].get_name(false));\n            words.extend(\"-\");\n            words.extend(SMALL_NAMES[n % 10].get_name(ordinal));\n        }\n        count += 1;\n    } else {\n        let big = big_name(n);\n        count += append_number_name(words, n / big.number, false);\n        if n % big.number == 0 {\n            words.append(big.get_name(ordinal));\n            count += 1;\n        } else {\n            words.append(big.get_name(false));\n            count += 1;\n            count += append_number_name(words, n % big.number, ordinal);\n        }\n    }\n    count\n}\n\nfn sentence(count: usize) -> WordList {\n    let mut result = WordList::new();\n    const WORDS: &'static [&'static str] = &[\n        \"Four\",\n        \"is\",\n        \"the\",\n        \"number\",\n        \"of\",\n        \"letters\",\n        \"in\",\n        \"the\",\n        \"first\",\n        \"word\",\n        \"of\",\n        \"this\",\n        \"sentence,\",\n    ];\n    for s in WORDS {\n        result.append(s);\n    }\n    let mut n = result.len();\n    let mut i = 1;\n    while count > n {\n        let count = count_letters(result.get_word(i));\n        n += append_number_name(&mut result, count, false);\n        result.append(\"in\");\n        result.append(\"the\");\n        n += 2;\n        n += append_number_name(&mut result, i + 1, true);\n        result.extend(\",\");\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let mut n = 201;\n    let s = sentence(n);\n    println!(\"Number of letters in first {} words in the sequence:\", n);\n    for i in 0..n {\n        if i != 0 {\n            if i % 25 == 0 {\n                println!();\n            } else {\n                print!(\" \");\n            }\n        }\n        print!(\"{:2}\", count_letters(s.get_word(i)));\n    }\n    println!();\n    println!(\"Sentence length: {}\", s.sentence_length());\n    n = 1000;\n    while n <= 10000000 {\n        let s = sentence(n);\n        let word = s.get_word(n - 1);\n        print!(\n            \"The {}th word is '{}' and has {} letters. \",\n            n,\n            word,\n            count_letters(word)\n        );\n        println!(\"Sentence length: {}\", s.sentence_length());\n        n *= 10;\n    }\n}",
    "title": "Four is the number of letters in the ...",
    "url": "http://rosettacode.org/wiki/Four_is_the_number_of_letters_in_the_..."
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//Cargo deps :\n//  piston = \"0.35.0\"\n//  piston2d-graphics = \"0.23.0\"\n//  piston2d-opengl_graphics = \"0.49.0\"\n//  pistoncore-glutin_window = \"0.42.0\"\n\nextern crate piston;\nextern crate graphics;\nextern crate opengl_graphics;\nextern crate glutin_window;\n\nuse piston::window::WindowSettings;\nuse piston::event_loop::{Events, EventSettings};\nuse piston::input::RenderEvent;\nuse glutin_window::GlutinWindow as Window;\nuse opengl_graphics::{GlGraphics, OpenGL};\nuse graphics::{clear, line, Context};\n\nconst ANG: f64 = 20.0;\nconst COLOR: [f32; 4] = [1.0, 0.0, 0.5, 1.0];\nconst LINE_THICKNESS: f64 = 5.0;\nconst DEPTH: u32 = 11;\n\nfn main() {\n    let mut window: Window = WindowSettings::new(\"Fractal Tree\", [1024, 768])\n        .opengl(OpenGL::V3_2)\n        .exit_on_esc(true)\n        .build()\n        .unwrap();\n    let mut gl = GlGraphics::new(OpenGL::V3_2);\n\n    let mut events = Events::new(EventSettings::new());\n    while let Some(e) = events.next(&mut window) {\n        if let Some(args) = e.render_args() {\n            gl.draw(args.viewport(), |c, g| {\n                clear([1.0, 1.0, 1.0, 1.0], g);\n                draw_fractal_tree(512.0, 700.0, 0.0, DEPTH, c, g);\n            });\n        }\n    }\n}\n\nfn draw_fractal_tree(x1: f64, y1: f64, angle: f64, depth: u32, c: Context, g: &mut GlGraphics) {\n    let x2 = x1 + angle.to_radians().sin() * depth as f64 * 10.0;\n    let y2 = y1 - angle.to_radians().cos() * depth as f64 * 10.0;\n    line(\n        COLOR,\n        LINE_THICKNESS * depth as f64 * 0.2,\n        [x1, y1, x2, y2],\n        c.transform,\n        g,\n    );\n    if depth > 0 {\n        draw_fractal_tree(x2, y2, angle - ANG, depth - 1, c, g);\n        draw_fractal_tree(x2, y2, angle + ANG, depth - 1, c, g);\n    }\n}\n",
    "title": "Fractal tree",
    "url": "http://rosettacode.org/wiki/Fractal_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fraction reduction",
    "url": "http://rosettacode.org/wiki/Fraction_reduction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fractran",
    "url": "http://rosettacode.org/wiki/Fractran"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "French Republican calendar",
    "url": "http://rosettacode.org/wiki/French_Republican_calendar"
  },
  {
    "local_code": "fn main() {\n    use std::f32::consts;\n\n    // the two functions we will compose:\n    let f = |x: u32| x.to_string();\n    let g = |x: f32| x as u32;\n\n    // their composition\n    let comp = compose(f, g);\n\n    println!(\"{:?}\", (*comp)(consts::PI));\n}\n\nfn compose<'a, F, G, A, B, C>(f: F, g: G) -> Box<dyn Fn(A) -> C + 'a>\nwhere\n    G: Fn(A) -> B + 'a,\n    F: Fn(B) -> C + 'a,\n{\n    Box::new(move |a: A| f(g(a)))\n}\n\n#[test]\nfn test_compose() {\n    fn inc(x: usize) -> usize {\n        x + 1\n    }\n    fn mul(x: usize) -> usize {\n        x * 3\n    }\n\n    let comp = compose(inc, mul);\n    assert_eq!((*comp)(3), 10);\n}\n",
    "path": "tasks/function-composition",
    "remote_code": "fn compose<'a,F,G,T,U,V>(f: F, g: G) -> Box<Fn(T) -> V + 'a>\n    where F: Fn(U) -> V + 'a,\n          G: Fn(T) -> U + 'a,\n{\n   Box::new(move |x| f(g(x)))\n}",
    "title": "Function composition",
    "url": "http://rosettacode.org/wiki/Function_composition"
  },
  {
    "local_code": "use std::ops::Mul;\n\n/// Function taking 2 ints, multply them and return the value\nfn multiply(x: i32, y: i32) -> i32 {\n    // In Rust a statement is a expression. An expression at the end of a\n    // function without semicolon is a return expression\n    x * y //equivalent \"return x * y;\"\n}\n\n/// generic version of multiply\nfn multiply_gen<T: Mul<Output = T>>(x: T, y: T) -> T {\n    x * y\n}\n\n#[test]\nfn test_multiply_gen() {\n    assert_eq!(multiply_gen(2i32, 2), 4);\n}\n\n#[test]\nfn test_multiply() {\n    assert_eq!(multiply(2i32, 2), 4);\n}\n\nfn main() {\n    println!(\"2 multiply 4 = {}\", multiply(2i32, 4));\n    println!(\"2.0 multiply 4.0 = {}\", multiply_gen(2.0f32, 4.0));\n    println!(\"5.0 multiply 7.0 is {}\", multiply_gen(5.0_f32, 7.0_f32));\n}\n",
    "path": "tasks/function-definition",
    "remote_code": "fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}",
    "title": "Function definition",
    "url": "http://rosettacode.org/wiki/Function_definition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Function frequency",
    "url": "http://rosettacode.org/wiki/Function_frequency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Function prototype",
    "url": "http://rosettacode.org/wiki/Function_prototype"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Functional coverage tree",
    "url": "http://rosettacode.org/wiki/Functional_coverage_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn fusc_sequence() -> impl std::iter::Iterator<Item = u32> {\n    let mut sequence = vec![0, 1];\n    let mut n = 0;\n    std::iter::from_fn(move || {\n        if n > 1 {\n            sequence.push(match n % 2 {\n                0 => sequence[n / 2],\n                _ => sequence[(n - 1) / 2] + sequence[(n + 1) / 2],\n            });\n        }\n        let result = sequence[n];\n        n += 1;\n        Some(result)\n    })\n}\n\nfn main() {\n    println!(\"First 61 fusc numbers:\");\n    for n in fusc_sequence().take(61) {\n        print!(\"{} \", n)\n    }\n    println!();\n\n    let limit = 1000000000;\n    println!(\n        \"Fusc numbers up to {} that are longer than any previous one:\",\n        limit\n    );\n    let mut max = 0;\n    for (index, n) in fusc_sequence().take(limit).enumerate() {\n        if n >= max {\n            max = std::cmp::max(10, max * 10);\n            println!(\"index = {}, fusc number = {}\", index, n);\n        }\n    }\n}",
    "title": "Fusc sequence",
    "url": "http://rosettacode.org/wiki/Fusc_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI component interaction",
    "url": "http://rosettacode.org/wiki/GUI_component_interaction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI enabling/disabling of controls",
    "url": "http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI/Maximum window dimensions",
    "url": "http://rosettacode.org/wiki/GUI/Maximum_window_dimensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Galton box animation",
    "url": "http://rosettacode.org/wiki/Galton_box_animation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Gamma function",
    "url": "http://rosettacode.org/wiki/Gamma_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Gapful numbers",
    "url": "http://rosettacode.org/wiki/Gapful_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\n    let mut a: Vec<Vec<f64>> = vec![vec![1.0, 2.0, 3.0],\n                                vec![4.0, 1.0, 6.0],\n                                vec![7.0, 8.0, 9.0]\n                                ];\n    let mut b: Vec<Vec<f64>> = vec![vec![2.0, -1.0, 0.0],\n                                vec![-1.0, 2.0, -1.0],\n                                vec![0.0, -1.0, 2.0]\n                                ];\n\n    let mut ref_a = &mut a;\n    let rref_a = &mut ref_a;\n    let mut ref_b = &mut b;\n    let rref_b = &mut ref_b;\n\n    println!(\"Matrix A:\\n\");\n    print_matrix(rref_a);\n    println!(\"\\nInverse of Matrix A:\\n\");\n    print_matrix(&mut matrix_inverse(rref_a));\n    println!(\"\\n\\nMatrix B:\\n\");\n    print_matrix(rref_b);\n    println!(\"\\nInverse of Matrix B:\\n\");\n    print_matrix(&mut matrix_inverse(rref_b));\n}\n\n//Begin Matrix Inversion\nfn matrix_inverse(matrix: &mut Vec<Vec<f64>>) -> Vec<Vec<f64>>{\n    let len = matrix.len();\n    let mut aug = zero_matrix(len, len * 2);\n    for i in 0..len {\n        for j in 0.. len {\n            aug[i][j] = matrix[i][j];\n        }\n        aug[i][i + len] = 1.0;\n    }\n\n    gauss_jordan_general(&mut aug);\n    \n    \n    let mut unaug = zero_matrix(len, len);\n    for i in 0..len {\n        for j in 0..len {\n            unaug[i][j] = aug[i][j+len];\n        }\n    }\n    unaug\n}\n//End Matrix Inversion\n\n//Begin Generalised Reduced Row Echelon Form\nfn gauss_jordan_general(matrix: &mut Vec<Vec<f64>>) {\n    let mut lead = 0;\n    let row_count = matrix.len();\n    let col_count = matrix[0].len();\n\n    for r in 0..row_count {\n        if col_count <= lead {\n            break;\n        }\n        let mut i = r;\n        while matrix[i][lead] == 0.0 {\n            i = i + 1;\n            if row_count == i {\n                i = r;\n                lead = lead + 1;\n                if col_count == lead {\n                    break;\n                }\n            }\n        }\n\n        let temp = matrix[i].to_owned();\n        matrix[i] = matrix[r].to_owned();\n        matrix[r] = temp.to_owned();\n\n        if matrix[r][lead] != 0.0 {\n            let div = matrix[r][lead];\n            for j in 0..col_count {\n                matrix[r][j] = matrix[r][j] / div;\n            }\n        }\n\n        for k in 0..row_count {\n            if k != r {\n                let mult = matrix[k][lead];\n                for j in 0..col_count {\n                    matrix[k][j] = matrix[k][j] - matrix[r][j] * mult;\n                }\n            }\n        }\n        lead = lead + 1;\n\n    }\n    //matrix.to_owned()\n}\n\nfn zero_matrix(rows: usize, cols: usize) -> Vec<Vec<f64>> {\n    let mut matrix = Vec::with_capacity(cols);\n    for _ in 0..rows {\n        let mut col: Vec<f64> = Vec::with_capacity(rows);\n        for _ in 0..cols {\n            col.push(0.0);\n        }\n        matrix.push(col);\n    }\n    matrix\n}\n\nfn print_matrix(mat: &mut Vec<Vec<f64>>) {\n    for row in 0..mat.len(){\n        println!(\"{:?}\", mat[row]);\n    }\n}\n",
    "title": "Gauss-Jordan matrix inversion",
    "url": "http://rosettacode.org/wiki/Gauss-Jordan_matrix_inversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n// using a Vec<f32> might be a better idea\n// for now, let us create a fixed size array\n// of size:\nconst SIZE: usize = 6;\n\npub fn eliminate(mut system: [[f32; SIZE+1]; SIZE]) -> Option<Vec<f32>> {\n    // produce the row reduced echelon form\n    //\n    // for every row...\n    for i in 0..SIZE-1 {\n        // for every column in that row...\n        for j in i..SIZE-1 {\n            if system[i][i] == 0f32 {\n                continue;\n            } else {\n                // reduce every element under that element to 0\n                let factor = system[j + 1][i] as f32 / system[i][i] as f32;\n                for k in i..SIZE+1 {\n                    // potential optimization: set every element to zero, instead of subtracting\n                    // i think subtraction helps showcase the process better\n                    system[j + 1][k] -= factor * system[i][k] as f32;\n                }\n            }\n        }\n    }\n\n    // produce gaussian eliminated array\n    //\n    // the process follows a similar pattern\n    // but this one reduces the upper triangular \n    // elements\n    for i in (1..SIZE).rev() {\n        if system[i][i] == 0f32 {\n            continue;\n        } else {\n            for j in (1..i+1).rev() {\n                let factor = system[j - 1][i] as f32 / system[i][i] as f32;\n                for k in (0..SIZE+1).rev() {\n                    system[j - 1][k] -= factor * system[i][k] as f32;\n                }\n            }\n        }\n    }\n\n    // produce solutions through back substitution\n    let mut solutions: Vec<f32> = vec![];\n    for i in 0..SIZE {\n        if system[i][i] == 0f32 {\n            return None;\n        }\n        else {\n            system[i][SIZE] /= system[i][i] as f32;\n            system[i][i] = 1f32;\n            println!(\"X{} = {}\", i + 1, system[i][SIZE]);\n            solutions.push(system[i][SIZE])\n        }\n    }\n    return Some(solutions);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    // sample run of the program\n    #[test]\n    fn eliminate_seven_by_six() {\n        let system: [[f32; SIZE +1]; SIZE] = [\n            [1.00 , 0.00 , 0.00 , 0.00  , 0.00  , 0.00   , -0.01 ] ,\n            [1.00 , 0.63 , 0.39 , 0.25  , 0.16  , 0.10   , 0.61  ] ,\n            [1.00 , 1.26 , 1.58 , 1.98  , 2.49  , 3.13   , 0.91  ] ,\n            [1.00 , 1.88 , 3.55 , 6.70  , 12.62 , 23.80  , 0.99  ] ,\n            [1.00 , 2.51 , 6.32 , 15.88 , 39.90 , 100.28 , 0.60  ] ,\n            [1.00 , 3.14 , 9.87 , 31.01 , 97.41 , 306.02 , 0.02  ]\n        ] ;\n        let solutions = eliminate(system).unwrap();\n        assert_eq!(6, solutions.len());\n        let assert_solns = vec![-0.01, 1.60278, -1.61320, 1.24549, -0.49098, 0.06576];\n        for (ans, key) in solutions.iter().zip(assert_solns.iter()) {\n            if (ans - key).abs() > 1E-4 { panic!(\"Test Failed!\") }\n        }\n    }\n}\n",
    "title": "Gaussian elimination",
    "url": "http://rosettacode.org/wiki/Gaussian_elimination"
  },
  {
    "local_code": "use std::io;\nuse std::io::BufRead;\n\nfn parse_entry(l: &str) -> (i32, String) {\n    let params: Vec<&str> = l.split(' ').collect();\n\n    let divisor = params[0].parse::<i32>().unwrap();\n    let word = params[1].to_string();\n    (divisor, word)\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|l| l.unwrap());\n\n    let l = lines.next().unwrap();\n    let high = l.parse::<i32>().unwrap();\n\n    let mut entries = Vec::new();\n    for l in lines {\n        if l.is_empty() {\n            break;\n        }\n        let entry = parse_entry(&l);\n        entries.push(entry);\n    }\n\n    for i in 1..(high + 1) {\n        let mut line = String::new();\n        for &(divisor, ref word) in &entries {\n            if i % divisor == 0 {\n                line = line + word;\n            }\n        }\n        if line.is_empty() {\n            println!(\"{}\", i);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n}\n",
    "path": "tasks/general-fizzbuzz",
    "remote_code": "use std::io;\nuse std::io::BufRead;\n\nfn parse_entry(l: &str) -> (i32, String) {\n    let params: Vec<&str> = l.split(' ').collect();\n\n    let divisor = params[0].parse::<i32>().unwrap();\n    let word = params[1].to_string();\n    (divisor, word)\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|l| l.unwrap());\n\n    let l = lines.next().unwrap();\n    let high = l.parse::<i32>().unwrap();\n\n    let mut entries = Vec::new();\n    for l in lines {\n        if &l == \"\" { break }\n        let entry = parse_entry(&l);\n        entries.push(entry);\n    }\n\n    for i in 1..(high + 1) {\n        let mut line = String::new();\n        for &(divisor, ref word) in &entries {\n            if i % divisor == 0 {\n                line = line + &word;\n            }\n        }\n        if line == \"\" {\n            println!(\"{}\", i);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n}",
    "title": "General FizzBuzz",
    "url": "http://rosettacode.org/wiki/General_FizzBuzz"
  },
  {
    "local_code": "use std::collections::BTreeSet;\n\nstruct Chess960(BTreeSet<String>);\n\nimpl Chess960 {\n    fn invoke(&mut self, b: &str, e: &str) {\n        if e.len() <= 1 {\n            let s = b.to_string() + e;\n            if Chess960::is_valid(&s) {\n                self.0.insert(s);\n            }\n        } else {\n            for (i, c) in e.char_indices() {\n                let mut b = b.to_string();\n                b.push(c);\n                let mut e = e.to_string();\n                e.remove(i);\n                self.invoke(&b, &e);\n            }\n        }\n    }\n\n    fn is_valid(s: &str) -> bool {\n        let k = s.find('K').unwrap();\n        k > s.find('R').unwrap()\n            && k < s.rfind('R').unwrap()\n            && s.find('B').unwrap() % 2 != s.rfind('B').unwrap() % 2\n    }\n}\n\n// Program entry point.\nfn main() {\n    let mut chess960 = Chess960(BTreeSet::new());\n    chess960.invoke(\"\", \"KQRRNNBB\");\n\n    for (i, p) in chess960.0.iter().enumerate() {\n        println!(\"{}: {}\", i, p);\n    }\n}\n",
    "path": "tasks/generate-chess960-starting-position",
    "remote_code": "use std::collections::BTreeSet;\n\nstruct Chess960 ( BTreeSet<String> );\n\nimpl Chess960 {\n    fn invoke(&mut self, b: &str, e: &str) {\n        if e.len() <= 1 {\n            let s = b.to_string() + e;\n            if Chess960::is_valid(&s) { self.0.insert(s); }\n        } else {\n            for (i, c) in e.char_indices() {\n                let mut b = b.to_string();\n                b.push(c);\n                let mut e = e.to_string();\n                e.remove(i);\n                self.invoke(&b, &e);\n            }\n        }\n    }\n\n    fn is_valid(s: &str) -> bool {\n        let k = s.find('K').unwrap();\n        k > s.find('R').unwrap() && k < s.rfind('R').unwrap() && s.find('B').unwrap() % 2 != s.rfind('B').unwrap() % 2\n    }\n}\n\n// Program entry point.\nfn main() {\n    let mut chess960 = Chess960(BTreeSet::new());\n    chess960.invoke(\"\", \"KQRRNNBB\");\n\n    for (i, p) in chess960.0.iter().enumerate() {\n        println!(\"{}: {}\", i, p);\n    }\n}",
    "title": "Generate Chess960 starting position",
    "url": "http://rosettacode.org/wiki/Generate_Chess960_starting_position"
  },
  {
    "local_code": "fn lower_case_alphabet() -> Box<dyn Iterator<Item = char>> {\n    let ascii_iter = (0..26).map(|x| (x + b'a') as char);\n    Box::new(ascii_iter)\n}\n\nfn main() {\n    println!(\"{:?}\", lower_case_alphabet().collect::<Vec<_>>());\n}\n\n#[test]\nfn test_alphabet() {\n    let expected = vec![\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    ];\n    assert_eq!(expected, lower_case_alphabet().collect::<Vec<_>>());\n}\n",
    "path": "tasks/generate-lower-case-ascii-alphabet",
    "remote_code": "fn main() {\n    // An iterator over the lowercase alpha's\n    let ascii_iter = (0..26)\n        .map(|x| (x + b'a') as char);\n \n    println!(\"{:?}\", ascii_iter.collect::<Vec<char>>());\n}",
    "title": "Generate lower case ASCII alphabet",
    "url": "http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt::Write;\n\nuse rand::{Rng, distributions::{Distribution, Standard}};\n\nconst EMPTY: u8 = b'.';\n\n#[derive(Clone, Debug)]\nstruct Board {\n    grid: [[u8; 8]; 8],\n}\n\nimpl Distribution<Board> for Standard {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Board {\n        let mut board = Board::empty();\n        board.place_kings(rng);\n        board.place_pieces(rng, b\"PPPPPPPP\", true);\n        board.place_pieces(rng, b\"pppppppp\", true);\n        board.place_pieces(rng, b\"RNBQBNR\", false);\n        board.place_pieces(rng, b\"rnbqbnr\", false);\n        board\n    }\n}\n\nimpl Board {\n    fn empty() -> Self {\n        Board { grid: [[EMPTY; 8]; 8] }\n    }\n    \n    fn fen(&self) -> String {\n        let mut fen = String::new();\n        let mut count_empty = 0;\n        for row in &self.grid {\n            for &ch in row {\n                print!(\"{} \", ch as char);\n                if ch == EMPTY {\n                    count_empty += 1;\n                } else {\n                    if count_empty > 0 {\n                        write!(fen, \"{}\", count_empty).unwrap();\n                        count_empty = 0;\n                    }\n                    fen.push(ch as char);\n                }\n            }\n            if count_empty > 0 {\n                write!(fen, \"{}\", count_empty).unwrap();\n                count_empty = 0;\n            }\n            fen.push('/');\n            println!();\n        }\n        fen.push_str(\" w - - 0 1\");\n        fen\n    }\n\n    fn place_kings<R: Rng + ?Sized>(&mut self, rng: &mut R) {\n        loop {\n            let r1: i8 = rng.gen_range(0, 8);\n            let c1: i8 = rng.gen_range(0, 8);\n            let r2: i8 = rng.gen_range(0, 8);\n            let c2: i8 = rng.gen_range(0, 8);\n            if r1 != r2 && (r1 - r2).abs() > 1 && (c1 - c2).abs() > 1 {\n                self.grid[r1 as usize][c1 as usize] = b'K';\n                self.grid[r2 as usize][c2 as usize] = b'k';\n                return;\n            }\n        }\n    }\n\n    fn place_pieces<R: Rng + ?Sized>(&mut self, rng: &mut R, pieces: &[u8], is_pawn: bool) {\n        let num_to_place = rng.gen_range(0, pieces.len());\n        for &piece in pieces.iter().take(num_to_place) {\n            let mut r = rng.gen_range(0, 8);\n            let mut c = rng.gen_range(0, 8);\n            while self.grid[r][c] != EMPTY || (is_pawn && (r == 7 || r == 0)) {\n                r = rng.gen_range(0, 8);\n                c = rng.gen_range(0, 8);\n            }\n            self.grid[r][c] = piece;\n        }\n    }\n}\n\nfn main() {\n    let b: Board = rand::random();\n    println!(\"{}\", b.fen());\n}",
    "title": "Generate random chess position",
    "url": "http://rosettacode.org/wiki/Generate_random_chess_position"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp::Ordering;\nuse std::iter::Peekable;\n\nfn powers(m: u32) -> impl Iterator<Item = u64> {\n    (0u64..).map(move |x| x.pow(m))\n}\n\nfn noncubic_squares() -> impl Iterator<Item = u64> {\n    NoncubicSquares {\n        squares: powers(2).peekable(),\n        cubes: powers(3).peekable(),\n    }\n}\n\nstruct NoncubicSquares<T: Iterator<Item = u64>, U: Iterator<Item = u64>> {\n    squares: Peekable<T>,\n    cubes: Peekable<U>,\n}\n\nimpl<T: Iterator<Item = u64>, U: Iterator<Item = u64>> Iterator for NoncubicSquares<T, U> {\n    type Item = u64;\n    fn next(&mut self) -> Option<u64> {\n        loop {\n            match self.squares.peek()?.cmp(self.cubes.peek()?) {\n                Ordering::Equal => self.squares.next(),\n                Ordering::Greater => self.cubes.next(),\n                Ordering::Less => return self.squares.next(),\n            };\n        }\n    }\n}\n\nfn main() {\n    noncubic_squares()\n        .skip(20)\n        .take(10)\n        .for_each(|x| print!(\"{} \", x));\n    println!();\n}",
    "title": "Generator/Exponential",
    "url": "http://rosettacode.org/wiki/Generator/Exponential"
  },
  {
    "local_code": "use std::mem::swap;\n\nfn main() {\n    println!(\"Same type:\");\n    let mut thing_one = \"The First String\";\n    let mut thing_two = \"The Second String\";\n    println!(\"Thing 1: {}, Thing 2: {}\", thing_one, thing_two);\n    swap(&mut thing_one, &mut thing_two);\n    println!(\"Thing 1: {}, Thing 2: {}\", thing_one, thing_two);\n}\n",
    "path": "tasks/generic-swap",
    "remote_code": "\nfn generic_swap<'a, T>(var1: &'a mut T, var2: &'a mut T) {\n    std::mem::swap(var1, var2)\n}\n",
    "title": "Generic swap",
    "url": "http://rosettacode.org/wiki/Generic_swap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::process::Command;\nuse std::io::{Write, self};\n\nfn main() {\n    let output = Command::new(\"/bin/cat\")\n                            .arg(\"/etc/fstab\")\n                            .output()\n                            .expect(\"failed to execute process\");\n\n    io::stdout().write(&output.stdout);\n}",
    "title": "Get system command output",
    "url": "http://rosettacode.org/wiki/Get_system_command_output"
  },
  {
    "local_code": "//! Author: Rahul Sharma\n//! Github: <https://github.com/creativcoder>\n\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Write;\n\nfn main() {\n    // opens file for writing replaced lines\n    let out_fd = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .open(\"resources/output.txt\");\n\n    // defining a closure write_line\n    let write_line = |line: &str| match out_fd {\n        Ok(ref v) => {\n            let mut writer = BufWriter::new(v);\n            writer.write_all(line.as_bytes()).unwrap();\n        }\n        Err(ref e) => {\n            println!(\"Error:{}\", e);\n        }\n    };\n    // read input file\n    match File::open(\"resources/paragraph.txt\") {\n        Ok(handle) => {\n            let mut reader = BufReader::new(handle);\n            let mut line = String::new();\n            // read the first line\n            reader.read_line(&mut line).unwrap();\n            // loop until line end\n            while line.trim() != \"\" {\n                let mut replaced_line = line.trim().replace(\"Goodbye London!\", \"Hello New York!\");\n                replaced_line += \"\\n\";\n                write_line(&replaced_line[..]);\n                line.clear();\n                reader.read_line(&mut line).unwrap();\n            }\n        }\n        Err(e) => println!(\"Error:{}\", e),\n    }\n}\n",
    "path": "tasks/globally-replace-text-in-several-files",
    "remote_code": "\n//! Author: Rahul Sharma\n//! Github: <https://github.com/creativcoder>\n\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Write;\n\nfn main() {\n    // opens file for writing replaced lines\n    let out_fd = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .open(\"resources/output.txt\");\n\n    // defining a closure write_line\n    let write_line = |line: &str| match out_fd {\n        Ok(ref v) => {\n            let mut writer = BufWriter::new(v);\n            writer.write_all(line.as_bytes()).unwrap();\n        }\n        Err(ref e) => {\n            println!(\"Error:{}\", e);\n        }\n    };\n    // read input file\n    match File::open(\"resources/paragraph.txt\") {\n        Ok(handle) => {\n            let mut reader = BufReader::new(handle);\n            let mut line = String::new();\n            // read the first line\n            reader.read_line(&mut line).unwrap();\n            // loop until line end\n            while line.trim() != \"\" {\n                let mut replaced_line = line.trim().replace(\"Goodbye London!\", \"Hello New York!\");\n                replaced_line += \"\\n\";\n                write_line(&replaced_line[..]);\n                line.clear();\n                reader.read_line(&mut line).unwrap();\n            }\n        }\n        Err(e) => println!(\"Error:{}\", e),\n    }\n}\n",
    "title": "Globally replace text in several files",
    "url": "http://rosettacode.org/wiki/Globally_replace_text_in_several_files"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Go Fish",
    "url": "http://rosettacode.org/wiki/Go_Fish"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// plotters = \"0.3.2\"\n\nuse plotters::prelude::*;\n\nfn goldbach(n: u64) -> u64 {\n    let mut p = 2;\n    let mut count = 0;\n    loop {\n        let q = n - p;\n        if q < p {\n            break;\n        }\n        if primal::is_prime(p) && primal::is_prime(q) {\n            count += 1;\n        }\n        if p == 2 {\n            p += 1;\n        } else {\n            p += 2;\n        }\n    }\n    count\n}\n\nfn goldbach_plot(filename: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let gvalues : Vec<u64> = (1..=2000).map(|x| goldbach(2 * x + 2)).collect();\n    let mut gmax = *gvalues.iter().max().unwrap();\n    gmax = 10 * ((gmax + 9) / 10);\n\n    let root = SVGBackend::new(filename, (1000, 500)).into_drawing_area();\n    root.fill(&WHITE)?;\n\n    let mut chart = ChartBuilder::on(&root)\n        .x_label_area_size(20)\n        .y_label_area_size(20)\n        .margin(10)\n        .caption(\"Goldbach's Comet\", (\"sans-serif\", 24).into_font())\n        .build_cartesian_2d(0usize..2000usize, 0u64..gmax)?;\n\n    chart\n        .configure_mesh()\n        .disable_x_mesh()\n        .disable_y_mesh()\n        .draw()?;\n\n    chart.draw_series(\n        gvalues\n            .iter()\n            .cloned()\n            .enumerate()\n            .map(|p| Circle::new(p, 2, BLUE.filled())),\n    )?;\n\n    Ok(())\n}\n\nfn main() {\n    println!(\"First 100 G numbers:\");\n    for i in 1..=100 {\n        print!(\n            \"{:2}{}\",\n            goldbach(2 * i + 2),\n            if i % 10 == 0 { \"\\n\" } else { \" \" }\n        );\n    }\n\n    println!(\"\\nG(1000000) = {}\", goldbach(1000000));\n\n    match goldbach_plot(\"goldbach.svg\") {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"Error: {}\", error),\n    }\n}",
    "title": "Goldbach's comet",
    "url": "http://rosettacode.org/wiki/Goldbach's_comet"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Graph colouring",
    "url": "http://rosettacode.org/wiki/Graph_colouring"
  },
  {
    "local_code": "/// Encode an usize\nfn gray_encode(integer: usize) -> usize {\n    (integer >> 1) ^ integer\n}\n\n/// Decode an usize\nfn gray_decode(integer: usize) -> usize {\n    match integer {\n        0 => 0,\n        _ => integer ^ gray_decode(integer >> 1),\n    }\n}\n\nfn main() {\n    for i in 0..32 {\n        println!(\n            \"{:2} {:0>5} {:0>5} {:2}\",\n            i,\n            i,\n            gray_encode(i),\n            gray_decode(i)\n        );\n    }\n}\n\n#[test]\nfn test_coherence() {\n    assert!((0..1000).all(|x| gray_decode(gray_encode(x)) == x));\n}\n",
    "path": "tasks/gray-code",
    "remote_code": "fn gray_encode(integer: u64) -> u64 {\n    (integer >> 1) ^ integer\n}\n\nfn gray_decode(integer: u64) -> u64 {\n    match integer {\n        0 => 0,\n        _ => integer ^ gray_decode(integer >> 1)\n    }\n}\n\nfn main() {\n    for i in 0..32 {\n        println!(\"{:2} {:0>5b} {:0>5b} {:2}\", i, i, gray_encode(i),\n            gray_decode(i));\n    }\n\n}",
    "title": "Gray code",
    "url": "http://rosettacode.org/wiki/Gray_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Grayscale image",
    "url": "http://rosettacode.org/wiki/Grayscale_image"
  },
  {
    "local_code": "//! This task demonstrates three possible implementation strategies.\n\nextern crate num;\n\nuse num::integer::gcd;\n\n/// Iterative Euclid algorithm\nfn iterative_euclid_gcd(mut m: i32, mut n: i32) -> i32 {\n    while m != 0 {\n        let old_m = m;\n        m = n % m;\n        n = old_m;\n    }\n    n.abs()\n}\n\n/// Recursive Euclid algorithm\nfn recursive_euclid_gcd(m: i32, n: i32) -> i32 {\n    if m == 0 {\n        n.abs()\n    } else {\n        recursive_euclid_gcd(n % m, m)\n    }\n}\n\nfn main() {\n    println!(\"gcd(399, -3999) = {}\", gcd(399, -3999));\n    println!(\"gcd(0, 3999) = {}\", iterative_euclid_gcd(0, 3999));\n    println!(\n        \"gcd(13 * 13, 13 * 29) = {}\",\n        recursive_euclid_gcd(13 * 13, 13 * 29)\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{iterative_euclid_gcd, recursive_euclid_gcd};\n\n    #[test]\n    fn iterative() {\n        assert_eq!(3, iterative_euclid_gcd(399, -3999));\n        assert_eq!(3999, iterative_euclid_gcd(0, 3999));\n        assert_eq!(13, iterative_euclid_gcd(13 * 13, 13 * 29));\n    }\n\n    #[test]\n    fn recursive() {\n        assert_eq!(3, recursive_euclid_gcd(399, -3999));\n        assert_eq!(3999, recursive_euclid_gcd(0, 3999));\n        assert_eq!(13, recursive_euclid_gcd(13 * 13, 13 * 29));\n    }\n}\n",
    "path": "tasks/greatest-common-divisor",
    "remote_code": "extern crate num;\nuse num::integer::gcd;",
    "title": "Greatest common divisor",
    "url": "http://rosettacode.org/wiki/Greatest_common_divisor"
  },
  {
    "local_code": "use std::fmt::Display;\n\nfn main() {\n    find_max(\"first\", &[1i32, 2, 3, 4, 5, 6, 7, 8, 9]);\n    find_max(\n        \"second\",\n        &[\n            123i32, 3543, 23, 432, 5, 2, 34, 234, 234, 2, 4, 234, 23, 4, 24, 25, 7, 658, 68,\n        ],\n    );\n    find_max(\"third\", &['a', 'b', 'c', 'd', 'e']);\n    find_max(\n        \"fourth\",\n        &[\"Bonjour\", \"Hola\", \"Hello\", \"Hallo\", \"Buongiorno\"],\n    );\n}\n\nfn find_max<T: Display + Ord>(count: &str, list: &[T]) {\n    let max = list.iter().max().unwrap();\n    println!(\"Max of the {} list: {}\", count, max);\n}\n",
    "path": "tasks/greatest-element-of-a-list",
    "remote_code": "fn main() {\n    let nums = [1,2,39,34,20];\n    println!(\"{:?}\", nums.iter().max());\n    println!(\"{}\", nums.iter().max().unwrap());\n}",
    "title": "Greatest element of a list",
    "url": "http://rosettacode.org/wiki/Greatest_element_of_a_list"
  },
  {
    "local_code": "use std::ops::Range;\n\nfn greatest_subsequential_sum(nums: &[i32]) -> (i32, Range<usize>) {\n    let mut max = 0;\n    let mut boundaries = 0..0;\n\n    for length in 0..nums.len() {\n        for start in 0..nums.len() - length {\n            let sum = (&nums[start..start + length]).iter().sum();\n            if sum > max {\n                max = sum;\n                boundaries = start..start + length;\n            }\n        }\n    }\n\n    (max, boundaries)\n}\n\nfn main() {\n    let nums = [1, 2, 39, 34, 20, -20, -16, 35, 0];\n\n    let (max, boundaries) = greatest_subsequential_sum(&nums);\n\n    println!(\"Max subsequence sum: {} for {:?}\", max, &nums[boundaries]);\n}\n\n#[test]\nfn subsequential_sum() {\n    let nums = [1, 2, 39, 34, 20, -20, -16, 35, 0];\n\n    let (max, boundaries) = greatest_subsequential_sum(&nums);\n\n    assert_eq!(max, 96);\n    assert_eq!(&nums[boundaries], &[1, 2, 39, 34, 20]);\n}\n",
    "path": "tasks/greatest-subsequential-sum",
    "remote_code": "fn main() {\n    let nums = [1,2,39,34,20, -20, -16, 35, 0];\n\n    let mut max = 0;\n    let mut boundaries = 0..0;\n\n    for length in 0..nums.len() {\n        for start in 0..nums.len()-length {\n            let sum = (&nums[start..start+length]).iter()\n                .fold(0, |sum, elem| sum+elem);\n            if sum > max {\n                max = sum;\n                boundaries = start..start+length;\n            }\n        }\n    }\n\n    println!(\"Max subsequence sum: {} for {:?}\", max, &nums[boundaries]);;\n}",
    "title": "Greatest subsequential sum",
    "url": "http://rosettacode.org/wiki/Greatest_subsequential_sum"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Greyscale bars/Display",
    "url": "http://rosettacode.org/wiki/Greyscale_bars/Display"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io::stdin;\n\nuse rand::{thread_rng, Rng};\n\nfn main() {\n    let mystery_number = thread_rng().gen_range(0u8, 10) + 1;\n    println!(\"Guess my number between 1 and 10\");\n\n    let input = stdin();\n    loop {\n        let mut line = String::new();\n        let _ = input.read_line(&mut line).unwrap();\n        match line.trim().parse::<u8>() {\n            Ok(guess) if guess == mystery_number => break,\n            Ok(_) => println!(\"Wrong! Try again!\"),\n            Err(_) => println!(\"Please enter an integer\"),\n        }\n    }\n\n    // The loop ends only if the player wins\n    println!(\"Well guessed!\");\n}\nuse std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            let input = stdin()\n                .read_line(&mut line)\n                .ok()\n                .and_then(|_| line.trim_start().chars().next())\n                .and_then(|c| c.to_uppercase().next());\n            match input {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                }\n                Some('L') => {\n                    min = guess + 1;\n                    num_guesses += 1;\n                }\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\n                            \"\\n*** I knew it! Got it in only {} guesses! ***\\n\",\n                            num_guesses\n                        );\n                    }\n                    break;\n                }\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\"),\n            }\n        }\n    }\n}\nextern crate rand;\n\nuse rand::{thread_rng, Rng};\nuse std::io::stdin;\n\nconst LOWEST: isize = 1;\nconst HIGHEST: isize = 100;\n\nfn main() {\n    let mut rng = thread_rng();\n\n    loop {\n        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);\n        let mut num_guesses = 0;\n\n        println!(\n            \"I have chosen my number between {} and {}. You know what to do\",\n            LOWEST, HIGHEST\n        );\n\n        loop {\n            num_guesses += 1;\n\n            let mut line = String::new();\n            let res = stdin().read_line(&mut line);\n            let input: Option<isize> = res.ok().and_then(|_| line.trim().parse().ok());\n\n            match input {\n                None => println!(\"numbers only, please\"),\n                Some(n) if n == number => {\n                    println!(\"you got it in {} tries!\", num_guesses);\n                    break;\n                }\n                Some(n) if n < number => println!(\"too low!\"),\n                Some(n) if n > number => println!(\"too high!\"),\n                Some(_) => println!(\"something went wrong\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number",
    "remote_code": "extern crate rand;\n\nfn main() {\n    println!(\"Type in an integer between 1 and 10 and press enter.\");\n\n    let n = rand::random::<u32>() % 10 + 1;\n    loop {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        let option: Result<u32,_> = line.trim().parse();\n        match option {\n            Ok(guess) => {\n                if guess < 1 || guess > 10 {\n                    println!(\"Guess is out of bounds; try again.\");\n                } else if guess == n {\n                    println!(\"Well guessed!\");\n                    break;\n                } else {\n                    println!(\"Wrong! Try again.\");\n                }\n            },\n            Err(_) => println!(\"Invalid input; try again.\")\n        }\n    }\n}",
    "title": "Guess the number",
    "url": "http://rosettacode.org/wiki/Guess_the_number"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\nuse std::io::stdin;\n\nconst LOWEST: isize = 1;\nconst HIGHEST: isize = 100;\n\nfn main() {\n    let mut rng = thread_rng();\n\n    loop {\n        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);\n        let mut num_guesses = 0;\n\n        println!(\n            \"I have chosen my number between {} and {}. You know what to do\",\n            LOWEST, HIGHEST\n        );\n\n        loop {\n            num_guesses += 1;\n\n            let mut line = String::new();\n            let res = stdin().read_line(&mut line);\n            let input: Option<isize> = res.ok().and_then(|_| line.trim().parse().ok());\n\n            match input {\n                None => println!(\"numbers only, please\"),\n                Some(n) if n == number => {\n                    println!(\"you got it in {} tries!\", num_guesses);\n                    break;\n                }\n                Some(n) if n < number => println!(\"too low!\"),\n                Some(n) if n > number => println!(\"too high!\"),\n                Some(_) => println!(\"something went wrong\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number/with-feedback",
    "remote_code": "use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nconst LOWEST: u32 = 1;\nconst HIGHEST: u32 = 100;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n\n    println!(\"I have chosen my number between {} and {}. Guess the number!\", LOWEST, HIGHEST);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}",
    "title": "Guess the number/With feedback",
    "url": "http://rosettacode.org/wiki/Guess_the_number/With_feedback"
  },
  {
    "local_code": "use std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            let input = stdin()\n                .read_line(&mut line)\n                .ok()\n                .and_then(|_| line.trim_start().chars().next())\n                .and_then(|c| c.to_uppercase().next());\n            match input {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                }\n                Some('L') => {\n                    min = guess + 1;\n                    num_guesses += 1;\n                }\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\n                            \"\\n*** I knew it! Got it in only {} guesses! ***\\n\",\n                            num_guesses\n                        );\n                    }\n                    break;\n                }\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number/with-feedback-player",
    "remote_code": "use std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            stdin().read_line(&mut line).unwrap();\n            match Some(line.chars().next().unwrap().to_uppercase().next().unwrap()) {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                },\n                Some('L')=> {\n                    min = guess + 1;\n                    num_guesses += 1;\n                },\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\"\\n*** I knew it! Got it in only {} guesses! ***\\n\", num_guesses);\n                    }\n                    break;\n                },\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\")\n            }\n        }\n    }\n}",
    "title": "Guess the number/With feedback (player)",
    "url": "http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player)"
  },
  {
    "local_code": "extern crate reqwest;\n\nuse std::io::prelude::*;\n\nfn main() {\n    let mut response = reqwest::blocking::get(\"http://rosettacode.org\").unwrap();\n    let mut response_text = String::new();\n    response.read_to_string(&mut response_text).unwrap();\n\n    println!(\"{}\", response_text);\n}\n",
    "path": "tasks/http",
    "remote_code": "\n//cargo-deps: hyper=\"0.6\"\n// The above line can be used with cargo-script which makes cargo's dependency handling more convenient for small programs\nextern crate hyper;\n\nuse std::io::Read;\nuse hyper::client::Client;\n\nfn main() {\n    let client = Client::new();\n    let mut resp = client.get(\"http://rosettacode.org\").send().unwrap();\n    let mut body = String::new();\n    resp.read_to_string(&mut body).unwrap();\n    println!(\"{}\", body);\n}\n",
    "title": "HTTP",
    "url": "http://rosettacode.org/wiki/HTTP"
  },
  {
    "local_code": "extern crate reqwest;\n\nfn main() {\n    let response = match reqwest::blocking::get(\"https://sourceforge.net\") {\n        Ok(response) => response,\n        Err(e) => panic!(\"error encountered while making request: {:?}\", e),\n    };\n\n    println!(\"{}\", response.text().unwrap());\n}\nextern crate reqwest;\n\nuse reqwest::blocking::Client;\nuse reqwest::header::CONNECTION;\n\nfn main() {\n    let client = Client::new();\n\n    // reqwest uses strongly-typed structs for creating headers\n    let res = client\n        .get(\"https://www.example.com\")\n        .basic_auth(\"user\", Some(\"password\"))\n        .header(CONNECTION, \"close\")\n        .send()\n        .unwrap();\n\n    let body = res.text().unwrap();\n\n    println!(\"{}\", body);\n}\n",
    "path": "tasks/https",
    "remote_code": "\nextern crate reqwest;\n\nfn main() {\n    let response = match reqwest::blocking::get(\"https://sourceforge.net\") {\n        Ok(response) => response,\n        Err(e) => panic!(\"error encountered while making request: {:?}\", e),\n    };\n\n    println!(\"{}\", response.text().unwrap());\n}\n",
    "title": "HTTPS",
    "url": "http://rosettacode.org/wiki/HTTPS"
  },
  {
    "local_code": "extern crate reqwest;\n\nuse reqwest::blocking::Client;\nuse reqwest::header::CONNECTION;\n\nfn main() {\n    let client = Client::new();\n\n    // reqwest uses strongly-typed structs for creating headers\n    let res = client\n        .get(\"https://www.example.com\")\n        .basic_auth(\"user\", Some(\"password\"))\n        .header(CONNECTION, \"close\")\n        .send()\n        .unwrap();\n\n    let body = res.text().unwrap();\n\n    println!(\"{}\", body);\n}\n",
    "path": "tasks/https/authenticated",
    "remote_code": "\nextern crate reqwest;\n\nuse reqwest::blocking::Client;\nuse reqwest::header::CONNECTION;\n\nfn main() {\n    let client = Client::new();\n\n    // reqwest uses strongly-typed structs for creating headers\n    let res = client\n        .get(\"https://www.example.com\")\n        .basic_auth(\"user\", Some(\"password\"))\n        .header(CONNECTION, \"close\")\n        .send()\n        .unwrap();\n\n    let body = res.text().unwrap();\n\n    println!(\"{}\", body);\n}\n",
    "title": "HTTPS/Authenticated",
    "url": "http://rosettacode.org/wiki/HTTPS/Authenticated"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs::File;\nuse std::io::Read;\n\nuse reqwest::blocking::Client;\nuse reqwest::Identity;\n\nfn main() -> std::io::Result<()> {\n    let identity = {\n        let mut buf = Vec::new();\n\n        // Downloaded from https://badssl.com/certs/badssl.com-client.p12\n        File::open(\"badssl.com-client.p12\")?.read_to_end(&mut buf)?;\n\n        // Password is badssl.com\n        Identity::from_pkcs12_der(&buf, \"badssl.com\").unwrap()\n    };\n\n    let client = Client::builder().identity(identity).build().unwrap();\n    let response = client.get(\"https://client.badssl.com/\").send().unwrap();\n\n    if !response.status().is_success() {\n        eprintln!(\"HTTP error requesting URL: {}\", response.status());\n    }\n\n    println!(\"Got response from server: {}\", response.text().unwrap());\n\n    Ok(())\n}",
    "title": "HTTPS/Client-authenticated",
    "url": "http://rosettacode.org/wiki/HTTPS/Client-authenticated"
  },
  {
    "local_code": "/// Define a struct which stores the state for the iterator.\nstruct Hailstone {\n    next: usize,\n    pub start: usize,\n}\n\nimpl Hailstone {\n    /// Define a constructor for the struct.\n    fn new(n: usize) -> Hailstone {\n        Hailstone { next: n, start: n }\n    }\n}\n\n/// Implement the hailstone iteration sequence.\nimpl Iterator for Hailstone {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        // We need to cache the current value.\n        let current = self.next;\n        // And then calculate the 'next'\n        self.next = match current {\n            0 => {\n                // Resets the iterator.\n                self.next = self.start;\n                return None;\n            }\n            // At the end, yield 1 and roll over next time called.\n            1 => 0,\n            // Got an even.\n            x if x % 2 == 0 => x / 2,\n            // All remaining numbers are odd.\n            x => (3 * x) + 1,\n        };\n\n        Some(current)\n    }\n}\n\n/// Returns the start number and length of the longest hailstone sequence up to `limit`\nfn biggest_hailstone(limit: usize) -> (usize, usize) {\n    (0..limit)\n        .map(|n| (n, Hailstone::new(n).count()))\n        .max_by_key(|&(_, count)| count)\n        .unwrap()\n}\n\nfn main() {\n    // Find the hailstone for 27.\n    let two_seven = Hailstone::new(27).collect::<Vec<usize>>();\n    let ts_len = two_seven.len();\n    println!(\n        \"Testing: {}, Length: {}, Values: {:?}...{:?}\",\n        two_seven[0],\n        ts_len,\n        &two_seven[0..4],\n        &two_seven[ts_len - 4..]\n    );\n\n    // Find the longest.\n    let (biggest, length) = biggest_hailstone(100_000);\n    println!(\"Largest: {}, Size: {}\", biggest, length);\n}\n\n#[test]\nfn test_27() {\n    let seq = Hailstone::new(27).collect::<Vec<usize>>();\n\n    assert_eq!(&seq[0..4], [27, 82, 41, 124]);\n    assert_eq!(&seq[seq.len() - 4..], [8, 4, 2, 1]);\n}\n\n#[test]\nfn test_biggest() {\n    let (biggest, length) = biggest_hailstone(100_000);\n    assert_eq!(biggest, 77031);\n    assert_eq!(length, 351);\n}\n",
    "path": "tasks/hailstone-sequence",
    "remote_code": "fn hailstone(start : u32) -> Vec<u32> {\n    let mut res = Vec::new();\n    let mut next = start;\n\n    res.push(start);\n\n    while next != 1  {\n        next = if next % 2 == 0 { next/2 } else { 3*next+1 };\n        res.push(next);\n    }\n    res\n}\n\n \nfn main() {\n    let test_num = 27;\n    let test_hailseq = hailstone(test_num);\n\n    println!(\"For {} number of elements is {} \", test_num, test_hailseq.len());\n\n    let fst_slice = test_hailseq[0..4].iter()\n                        .fold(\"\".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + \", \" });\n    let last_slice = test_hailseq[test_hailseq.len()-4..].iter()\n                        .fold(\"\".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + \", \" });\n    \n    println!(\"  hailstone starting with {} ending with {} \", fst_slice, last_slice);\n\n    let max_range = 100000;\n    let mut max_len = 0;\n    let mut max_seed = 0;\n    for i_seed in 1..max_range {\n        let i_len = hailstone(i_seed).len();\n\n        if i_len > max_len {\n            max_len = i_len;\n            max_seed = i_seed;\n        }\n    }\n    println!(\"Longest sequence is {} element long for seed {}\", max_len, max_seed);\n}",
    "title": "Hailstone sequence",
    "url": "http://rosettacode.org/wiki/Hailstone_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main(){panic!(\"\");}\n",
    "title": "Halt and catch fire",
    "url": "http://rosettacode.org/wiki/Halt_and_catch_fire"
  },
  {
    "local_code": "extern crate num;\n\nuse std::cmp::min;\nuse std::collections::VecDeque;\nuse std::ops::Mul;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::one;\nuse num::traits::One;\n\n/// representing a Hamming number as a `BigUint`\nimpl HammingNumber for BigUint {\n    // returns the multipliers 2, 3 and 5 in the representation for the HammingNumber\n    fn multipliers() -> (BigUint, BigUint, BigUint) {\n        (\n            2u8.to_biguint().unwrap(),\n            3u8.to_biguint().unwrap(),\n            5u8.to_biguint().unwrap(),\n        )\n    }\n}\n\n/// representation of a Hamming number\n/// allows to abstract on how the hamming number is stored\n/// i.e. as `BigUint` directly or just as the powers of 2, 3 and 5 used to build it\npub trait HammingNumber: Eq + Ord + ToBigUint + Mul<Output = Self> + One + Clone {\n    fn multipliers() -> (Self, Self, Self);\n}\n\n/// Hamming numbers are multiples of 2, 3 or 5.\n///\n/// We keep them on three queues and extract the lowest (leftmost) value from\n/// the three queues at each iteration.\npub struct Hamming<T> {\n    // Using a VecDeque as a queue, push to the back, pop from the front\n    q2: VecDeque<T>,\n    q3: VecDeque<T>,\n    q5: VecDeque<T>,\n}\n\nimpl<T: HammingNumber> Hamming<T> {\n    /// Static constructor method\n    /// `n` initializes the capacity of the queues\n    pub fn new(n: usize) -> Hamming<T> {\n        let mut h = Hamming {\n            q2: VecDeque::with_capacity(n),\n            q3: VecDeque::with_capacity(n),\n            q5: VecDeque::with_capacity(n),\n        };\n\n        h.q2.push_back(one());\n        h.q3.push_back(one());\n        h.q5.push_back(one());\n\n        h\n    }\n\n    /// Pushes the next multiple of `n` (x2, x3, x5) to the queues\n    pub fn enqueue(&mut self, n: &T) {\n        let (two, three, five): (T, T, T) = HammingNumber::multipliers();\n        self.q2.push_back(two * n.clone());\n        self.q3.push_back(three * n.clone());\n        self.q5.push_back(five * n.clone());\n    }\n}\n\n/// Implements the `Iterator` trait, so we can generate Hamming numbers lazily\nimpl<T: HammingNumber> Iterator for Hamming<T> {\n    type Item = T;\n\n    /// The core of the work is done in the `next` method.\n    /// We check which of the 3 queues has the lowest candidate and extract it\n    /// as the next Hamming number.\n    fn next(&mut self) -> Option<T> {\n        // Return `pop_targets` so the borrow from `front()` will be finished\n        let (two, three, five) = match (self.q2.front(), self.q3.front(), self.q5.front()) {\n            (Some(head2), Some(head3), Some(head5)) => {\n                let n = min(head2, min(head3, head5));\n                (head2 == n, head3 == n, head5 == n)\n            }\n            _ => unreachable!(),\n        };\n\n        let h2 = if two { self.q2.pop_front() } else { None };\n        let h3 = if three { self.q3.pop_front() } else { None };\n        let h5 = if five { self.q5.pop_front() } else { None };\n\n        match h2.or(h3).or(h5) {\n            Some(n) => {\n                self.enqueue(&n);\n                Some(n)\n            }\n            None => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn create() {\n    let mut h = Hamming::<BigUint>::new(5);\n    h.q2.push_back(one::<BigUint>());\n    h.q2.push_back(one::<BigUint>() * 3.to_biguint().unwrap());\n\n    assert_eq!(h.q2.pop_front().unwrap(), one::<BigUint>());\n}\n\n#[test]\nfn try_enqueue() {\n    let mut h = Hamming::<BigUint>::new(5);\n    let (two, three, five): (BigUint, BigUint, BigUint) = HammingNumber::multipliers();\n    h.enqueue(&one::<BigUint>());\n    h.enqueue(&(one::<BigUint>() * two.clone()));\n\n    assert!(h.q2.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q3.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q5.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q2.pop_front().unwrap() == one::<BigUint>() * two);\n    assert!(h.q3.pop_front().unwrap() == one::<BigUint>() * three);\n    assert!(h.q5.pop_front().unwrap() == one::<BigUint>() * five);\n}\n\n#[test]\nfn hamming_iter() {\n    let mut hamming = Hamming::<BigUint>::new(20);\n    assert!(hamming.nth(19).unwrap().to_biguint() == 36.to_biguint());\n}\n\n#[ignore]\n#[test]\nfn hamming_iter_1million() {\n    let mut hamming = Hamming::<BigUint>::new(128);\n    // one-million-th hamming number has index 999_999 because indexes are zero-based\n    let millionth_hamming_number = \"51931278044838873608958984375000000000000000000000000000000000\\\n                                    0000000000000000000000\";\n    assert_eq!(\n        hamming.nth(999_999).unwrap().to_biguint(),\n        millionth_hamming_number.parse::<BigUint>().ok()\n    );\n}\n#![allow(clippy::excessive_precision)]\n\n//! Alternate version: uses a more efficient representation of Hamming numbers:\n//! instead of storing them as `BigUint` directly, it stores the three exponents\n//! i, j and k for 2^i * 3^j * 5 ^k and the logarithm of the number for comparisons\n\nextern crate num;\n\nextern crate hamming_numbers;\n\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::ops::Mul;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::pow;\nuse num::traits::One;\n\nuse hamming_numbers::{Hamming, HammingNumber};\n\nfn main() {\n    // capacity of the queue currently needs to be a power of 2 because of a bug with VecDeque\n    let hamming: Hamming<HammingTriple> = Hamming::new(128);\n\n    for (idx, h) in hamming.enumerate().take(1_000_000) {\n        match idx + 1 {\n            1..=20 => print!(\"{} \", h.to_biguint().unwrap()),\n            i @ 1691 | i @ 1_000_000 => println!(\"\\n{}th number: {}\", i, h.to_biguint().unwrap()),\n            _ => continue,\n        }\n    }\n}\n\n// we store these to calculate the ln of a hamming number\npub const LN_2: f64 =\n    0.693_147_180_559_945_309_417_232_121_458_176_568_075_500_134_360_255_254_120_680;\npub const LN_3: f64 =\n    1.098_612_288_668_109_691_395_245_236_922_525_704_647_490_557_822_749_451_734_694;\npub const LN_5: f64 =\n    1.609_437_912_434_100_374_600_759_333_226_187_639_525_601_354_268_517_721_912_647;\n\n/// more space-efficient representation of a Hamming number.\n/// A Hamming number is 2^i * 3^j * 5^k;\n/// instead of storing it directly as a `BigUint`\n/// we store the powers i, j and k and calculate the\n/// result as a `BigUint` only when we need it.\n/// we also store the logarithm for quicker comparisons, using this property\n/// of logarithms: ln(2^i * 3^j * 5^k) = i*ln2 + j*ln3 + k*ln5\n#[derive(Debug, Copy, Clone)]\npub struct HammingTriple {\n    pow_2: usize,\n    pow_3: usize,\n    pow_5: usize,\n    ln: f64,\n}\n\nimpl Mul for HammingTriple {\n    type Output = HammingTriple;\n    fn mul(self, other: HammingTriple) -> HammingTriple {\n        HammingTriple {\n            pow_2: self.pow_2 + other.pow_2,\n            pow_3: self.pow_3 + other.pow_3,\n            pow_5: self.pow_5 + other.pow_5,\n            ln: self.ln + other.ln,\n        }\n    }\n}\n\nimpl One for HammingTriple {\n    /// 1 as an HammingNumber is 2^0 * 3^0 * 5^0\n    /// ln(1) = 0\n    fn one() -> HammingTriple {\n        HammingTriple::new(0, 0, 0)\n    }\n}\n\nimpl HammingNumber for HammingTriple {\n    fn multipliers() -> (HammingTriple, HammingTriple, HammingTriple) {\n        (\n            HammingTriple {\n                pow_2: 1,\n                pow_3: 0,\n                pow_5: 0,\n                ln: LN_2,\n            },\n            HammingTriple {\n                pow_2: 0,\n                pow_3: 1,\n                pow_5: 0,\n                ln: LN_3,\n            },\n            HammingTriple {\n                pow_2: 0,\n                pow_3: 0,\n                pow_5: 1,\n                ln: LN_5,\n            },\n        )\n    }\n}\n\nimpl ToBigUint for HammingTriple {\n    /// calculate the value as a `BigUint`\n    fn to_biguint(&self) -> Option<BigUint> {\n        Some(\n            pow(2u8.to_biguint().unwrap(), self.pow_2)\n                * pow(3u8.to_biguint().unwrap(), self.pow_3)\n                * pow(5u8.to_biguint().unwrap(), self.pow_5),\n        )\n    }\n}\n\nimpl HammingTriple {\n    fn new(pow_2: usize, pow_3: usize, pow_5: usize) -> HammingTriple {\n        HammingTriple {\n            pow_2,\n            pow_3,\n            pow_5,\n            ln: (pow_2 as f64) * LN_2 + (pow_3 as f64) * LN_3 + (pow_5 as f64) * LN_5,\n        }\n    }\n}\n\nimpl PartialEq for HammingTriple {\n    fn eq(&self, other: &HammingTriple) -> bool {\n        self.pow_2 == other.pow_2 && self.pow_3 == other.pow_3 && self.pow_5 == other.pow_5\n    }\n}\n\nimpl Eq for HammingTriple {}\n\nimpl PartialOrd for HammingTriple {\n    fn partial_cmp(&self, other: &HammingTriple) -> Option<Ordering> {\n        if self == other {\n            Some(Equal)\n        } else if ((self.pow_2 >= other.pow_2)\n            && (self.pow_3 >= other.pow_3)\n            && (self.pow_5 >= other.pow_5))\n            || (self.ln > other.ln)\n        {\n            Some(Greater)\n        } else if ((self.pow_2 <= other.pow_2)\n            && (self.pow_3 <= other.pow_3)\n            && (self.pow_5 <= other.pow_5))\n            || (self.ln < other.ln)\n        {\n            Some(Less)\n        } else {\n            None\n        }\n    }\n}\n\nimpl Ord for HammingTriple {\n    fn cmp(&self, other: &HammingTriple) -> Ordering {\n        // as a last resort we need to calculate the BigUint values and compare them.\n        // This should be rare. The reason is that for very big values floating point precision\n        // could make hamming_1.ln == hamming_2.ln even if the two numbers are actually different\n        self.partial_cmp(other)\n            .unwrap_or_else(|| self.to_biguint().unwrap().cmp(&other.to_biguint().unwrap()))\n    }\n}\n\n#[test]\nfn hamming_iter() {\n    let mut hamming = Hamming::<HammingTriple>::new(20);\n    assert!(hamming.nth(19).unwrap().to_biguint() == 36u8.to_biguint());\n}\n\n#[test]\nfn hamming_iter_1million() {\n    let mut hamming = Hamming::<HammingTriple>::new(128);\n    let millionth_hamming_number = \"51931278044838873608958984375000000000000000000000000000000000\\\n                                    0000000000000000000000\";\n\n    // one-million-th hamming number has index 999_999 because indexes are zero-based\n    assert_eq!(\n        hamming.nth(999_999).unwrap().to_biguint(),\n        millionth_hamming_number.parse::<BigUint>().ok()\n    );\n}\nextern crate num;\n\nextern crate hamming_numbers;\n\nuse num::bigint::ToBigUint;\nuse num::BigUint;\n\nuse hamming_numbers::Hamming;\n\nfn main() {\n    // capacity of the queue currently needs to be a power of 2 because of a bug with VecDeque\n    let hamming: Hamming<BigUint> = Hamming::new(128);\n\n    for (idx, h) in hamming.enumerate().take(1_000_000) {\n        match idx + 1 {\n            1..=20 => print!(\"{} \", h.to_biguint().unwrap()),\n            i @ 1691 | i @ 1_000_000 => println!(\"\\n{}th number: {}\", i, h.to_biguint().unwrap()),\n            _ => continue,\n        }\n    }\n}\n",
    "path": "tasks/hamming-numbers",
    "remote_code": "extern crate num;\nnum::bigint::BigUint;\n\nuse std::time::Instant;\n\nfn basic_hamming(n: usize) -> BigUint {\n    let two = BigUint::from(2u8);\n    let three = BigUint::from(3u8);\n    let five = BigUint::from(5u8);\n    let mut h = vec![BigUint::from(0u8); n];\n    h[0] = BigUint::from(1u8);\n    let mut x2 = BigUint::from(2u8);\n    let mut x3 = BigUint::from(3u8);\n    let mut x5 = BigUint::from(5u8);\n    let mut i = 0usize; let mut j = 0usize; let mut k = 0usize;\n\n    // BigUint comparisons are expensive, so do it only as necessary...\n    fn min3(x: &BigUint, y: &BigUint, z: &BigUint) -> (usize, BigUint) {\n        let (cs, r1) = if y == z { (0x6, y) } \n                        else if y < z { (2, y) } else { (4, z) };\n        if x == r1 { (cs | 1, x.clone()) }\n        else if x < r1 { (1, x.clone()) } else { (cs, r1.clone()) }\n    }\n\n    let mut c = 1;\n    while c < n { // satisfy borrow checker with extra blocks: {  }\n        let (cs, e1) = { min3(&x2, &x3, &x5) };\n        h[c] = e1; // vector now owns the generated value\n        if (cs & 1) != 0 { i += 1; x2 = &two * &h[i] }\n        if (cs & 2) != 0 { j += 1; x3 = &three * &h[j] }\t\n        if (cs & 4) != 0 { k += 1; x5 = &five * &h[k] }\n        c += 1;\n    }\n\n    match h.pop() {\n        Some(v) => v,\n        _ => panic!(\"basic_hamming: arg is zero; no elements\")\n    }\n}\n\nfn main() {\n    print!(\"[\");\n    for (i, h) in (1..21).map(basic_hamming).enumerate() {\n        if i != 0 { print!(\",\") }\n        print!(\" {}\", h)\n    }\n    println!(\" ]\");\n    println!(\"{}\", basic_hamming(1691));\n\n    let strt = Instant::now();\n\n    let rslt = basic_hamming(1000000);\n\n    let elpsd = strt.elapsed();\n    let secs = elpsd.as_secs();\n    let millis = (elpsd.subsec_nanos() / 1000000)as u64;\n    let dur = secs * 1000 + millis;\n\n    let rs = rslt.to_str_radix(10);\n    let mut s = rs.as_str();\n    println!(\"{} digits:\", s.len());\n        while s.len() > 100 {\n            let (f, r) = s.split_at(100);\n            s = r;\n            println!(\"{}\", f);\n        }\n        println!(\"{}\", s);\n\n    println!(\"This last took {} milliseconds\", dur);\n}",
    "title": "Hamming numbers",
    "url": "http://rosettacode.org/wiki/Hamming_numbers"
  },
  {
    "local_code": "#[cfg(unix)]\nfn main() {\n    use std::sync::atomic::{AtomicBool, Ordering};\n    use std::thread;\n    use std::time::{Duration, Instant};\n\n    use libc::{sighandler_t, SIGINT};\n\n    // The time between ticks of our counter.\n    let duration = Duration::from_secs(1) / 2;\n\n    // \"SIGINT received\" global variable.\n    static mut GOT_SIGINT: AtomicBool = AtomicBool::new(false);\n\n    unsafe {\n        // Initially, \"SIGINT received\" is false.\n        GOT_SIGINT.store(false, Ordering::Release);\n        // Interrupt handler that handles the SIGINT signal\n        unsafe fn handle_sigint() {\n            // It is dangerous to perform any system calls in interrupts, so just set the atomic\n            // \"SIGINT received\" global to true when it arrives.\n            GOT_SIGINT.store(true, Ordering::Release);\n        }\n        // Make handle_sigint the signal handler for SIGINT.\n        libc::signal(SIGINT, handle_sigint as sighandler_t);\n    }\n\n    // Get the start time...\n    let start = Instant::now();\n\n    // Integer counter\n    let mut i = 0u32;\n\n    // Every `duration`...\n    loop {\n        thread::sleep(duration);\n\n        // Break if SIGINT was handled\n        if unsafe { GOT_SIGINT.load(Ordering::Acquire) } {\n            break;\n        }\n\n        // Otherwise, increment and display the integer and continue the loop.\n        i += 1;\n        println!(\"{}\", i);\n    }\n\n    // Get the elapsed time.\n    let elapsed = start.elapsed();\n\n    // Print the difference and exit\n    println!(\"Program has run for {} seconds\", elapsed.as_secs());\n}\n\n#[cfg(not(unix))]\nfn main() {\n    println!(\"Not supported on this platform\");\n}\n",
    "path": "tasks/handle-a-signal",
    "remote_code": "\n#[cfg(unix)]\nfn main() {\n    use std::sync::atomic::{AtomicBool, Ordering};\n    use std::thread;\n    use std::time::{Duration, Instant};\n\n    use libc::{sighandler_t, SIGINT};\n\n    // The time between ticks of our counter.\n    let duration = Duration::from_secs(1) / 2;\n\n    // \"SIGINT received\" global variable.\n    static mut GOT_SIGINT: AtomicBool = AtomicBool::new(false);\n\n    unsafe {\n        // Initially, \"SIGINT received\" is false.\n        GOT_SIGINT.store(false, Ordering::Release);\n        // Interrupt handler that handles the SIGINT signal\n        unsafe fn handle_sigint() {\n            // It is dangerous to perform any system calls in interrupts, so just set the atomic\n            // \"SIGINT received\" global to true when it arrives.\n            GOT_SIGINT.store(true, Ordering::Release);\n        }\n        // Make handle_sigint the signal handler for SIGINT.\n        libc::signal(SIGINT, handle_sigint as sighandler_t);\n    }\n\n    // Get the start time...\n    let start = Instant::now();\n\n    // Integer counter\n    let mut i = 0u32;\n\n    // Every `duration`...\n    loop {\n        thread::sleep(duration);\n\n        // Break if SIGINT was handled\n        if unsafe { GOT_SIGINT.load(Ordering::Acquire) } {\n            break;\n        }\n\n        // Otherwise, increment and display the integer and continue the loop.\n        i += 1;\n        println!(\"{}\", i);\n    }\n\n    // Get the elapsed time.\n    let elapsed = start.elapsed();\n\n    // Print the difference and exit\n    println!(\"Program has run for {} seconds\", elapsed.as_secs());\n}\n\n#[cfg(not(unix))]\nfn main() {\n    println!(\"Not supported on this platform\");\n}\n\n",
    "title": "Handle a signal",
    "url": "http://rosettacode.org/wiki/Handle_a_signal"
  },
  {
    "local_code": "fn digits(mut n: usize) -> Vec<usize> {\n    let mut ds = vec![];\n    if n == 0 {\n        return vec![0];\n    }\n    while n > 0 {\n        ds.push(n % 10);\n        n /= 10;\n    }\n    ds.reverse();\n    ds\n}\n\nfn is_happy(mut x: usize) -> bool {\n    let mut past = Vec::new();\n    while x != 1 {\n        // Take the sum of the squares of the digits of x\n        x = digits(x).iter().fold(0, |a, &b| a + b * b);\n\n        // The number is not happy if there is an endless loop\n        if past.contains(&x) {\n            return false;\n        }\n\n        // past.insert(x);\n        past.push(x);\n    }\n    true\n}\n\nfn main() {\n    // Print the first 8 happy numbers\n    let v: Vec<usize> = (1..).filter(|x| is_happy(*x)).take(8).collect();\n    println!(\"{:?}\", v)\n}\n\n#[test]\nfn test_digits() {\n    assert_eq!(digits(0), vec![0]);\n    assert_eq!(digits(1), vec![1]);\n    assert_eq!(digits(2), vec![2]);\n    assert_eq!(digits(10), vec![1, 0]);\n    assert_eq!(digits(11), vec![1, 1]);\n    assert_eq!(digits(101), vec![1, 0, 1]);\n    assert_eq!(digits(1000), vec![1, 0, 0, 0]);\n}\n\n#[test]\nfn test_is_happy() {\n    let happys = [1, 7, 10, 13, 19, 23, 28, 31, 1607, 1663];\n    let unhappys = [0, 2, 3, 4, 5, 6, 8, 9, 29, 1662];\n\n    assert!(happys.iter().all(|&n| is_happy(n)));\n    assert!(unhappys.iter().all(|&n| !is_happy(n)));\n}\n",
    "path": "tasks/happy-numbers",
    "remote_code": "#![feature(core)]\n\nfn sumsqd(mut n: i32) -> i32 {\n    let mut sq = 0;\n    while n > 0 {\n        let d = n % 10;\n        sq += d*d;\n        n /= 10\n    }\n    sq\n}\n\nuse std::num::Int;\nfn cycle<T: Int>(a: T, f: fn(T) -> T) -> T {\n    let mut t = a;\n    let mut h = f(a);\n\n    while t != h {\n        t = f(t);\n        h = f(f(h))\n    }\n    t\n}\n\nfn ishappy(n: i32) -> bool {\n    cycle(n, sumsqd) == 1\n}\n\nfn main() {\n    let happy = std::iter::count(1, 1)\n                    .filter(|&n| ishappy(n))\n                    .take(8)\n                    .collect::<Vec<i32>>();\n\n    println!(\"{:?}\", happy)\n}",
    "title": "Happy numbers",
    "url": "http://rosettacode.org/wiki/Happy_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse num::rational::Ratio;\nuse num::{BigInt, FromPrimitive};\n\nfn main() {\n    for n in 1..=20 {\n        println!(\"Harmonic number {} = {}\", n, harmonic_number(n.into()));\n    }\n\n    println!(\"Harmonic number 100 = {}\", harmonic_number(100.into()));\n\n    let max = 5;\n    let mut target = 1;\n    let mut i = 1;\n    while target <= max {\n        if harmonic_number(i.into()) > Ratio::from_integer(FromPrimitive::from_u64(target).unwrap())\n        {\n            println!(\"Position of first term > {} is {}\", target, i);\n            target += 1;\n        }\n        i += 1;\n    }\n}\n\nfn harmonic_number(n: BigInt) -> Ratio<BigInt> {\n    let mut result: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u8(0).unwrap());\n    let mut i: BigInt = FromPrimitive::from_u8(1).unwrap();\n    let one: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u8(1).unwrap());\n\n    while i <= n {\n        result = &result + &one / &i;\n        i += 1;\n    }\n\n    result\n}\n",
    "title": "Harmonic series",
    "url": "http://rosettacode.org/wiki/Harmonic_series"
  },
  {
    "local_code": "use std::u32;\n\nfn main() {\n    let digit_sum = |i: u32| {\n        i.to_string()\n            .chars()\n            .fold(0u32, |d, c| d + c.to_digit(10).unwrap())\n    };\n    let mut harshads = (1u32..u32::MAX).filter(|&n| n % digit_sum(n) == 0);\n\n    for _ in 0u32..20 {\n        print!(\"{} \", harshads.next().unwrap())\n    }\n    println!(\"\\n{}\", harshads.find(|&h| h > 1000).unwrap());\n}\n",
    "path": "tasks/harshad-or-niven-series",
    "remote_code": "\nfn is_harshad (n : u32) -> bool {\n    let sum_digits = n.to_string()\n                      .chars()\n                      .map(|c| c.to_digit(10).unwrap())\n                      .fold(0, |a, b| a+b);\n    n % sum_digits == 0\n}\n\nfn main() {\n    for i in (1u32..).filter(|num| is_harshad(*num)).take(20) {\n        println!(\"Harshad : {}\", i);\n    }\n    for i in (1_001u32..).filter(|num| is_harshad(*num)).take(1) {\n        println!(\"First Harshad bigger than 1_000 : {}\", i);\n    }\n}\n",
    "title": "Harshad or Niven series",
    "url": "http://rosettacode.org/wiki/Harshad_or_Niven_series"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let keys = [\"a\", \"b\", \"c\"];\n    let values = [1, 2, 3];\n\n    let hash = keys.iter().zip(values.iter()).collect::<HashMap<_, _>>();\n    println!(\"{:?}\", hash);\n}\n",
    "path": "tasks/hash-from-two-arrays",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let keys = [\"a\", \"b\", \"c\"];\n    let values = [1, 2, 3];\n\n    let hash = keys.iter().zip(values.iter()).collect::<HashMap<_, _>>();\n    println!(\"{:?}\", hash);\n}",
    "title": "Hash from two arrays",
    "url": "http://rosettacode.org/wiki/Hash_from_two_arrays"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n// If you know one of the tables is smaller, it is best to make it the second parameter.\nfn hash_join<A, B, K>(first: &[(K, A)], second: &[(K, B)]) -> Vec<(A, K, B)>\nwhere\n    K: Hash + Eq + Copy,\n    A: Copy,\n    B: Copy,\n{\n    let mut hash_map = HashMap::new();\n\n    // hash phase\n    for &(key, val_a) in second {\n        // collect all values by their keys, appending new ones to each existing entry\n        hash_map.entry(key).or_insert_with(Vec::new).push(val_a);\n    }\n\n    let mut result = Vec::new();\n    // join phase\n    for &(key, val_b) in first {\n        if let Some(vals) = hash_map.get(&key) {\n            let tuples = vals.iter().map(|&val_a| (val_b, key, val_a));\n            result.extend(tuples);\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let table1 = [\n        (\"Jonah\", 27),\n        (\"Alan\", 18),\n        (\"Glory\", 28),\n        (\"Popeye\", 18),\n        (\"Alan\", 28),\n    ];\n    let table2 = [\n        (\"Jonah\", \"Whales\"),\n        (\"Jonah\", \"Spiders\"),\n        (\"Alan\", \"Ghosts\"),\n        (\"Alan\", \"Zombies\"),\n        (\"Glory\", \"Buffy\"),\n    ];\n    let result = hash_join(&table1, &table2);\n    println!(\"Age | Character Name | Nemesis\");\n    println!(\"----|----------------|--------\");\n    for (age, name, nemesis) in result {\n        println!(\"{:<3} | {:^14} | {}\", age, name, nemesis);\n    }\n}\n\n#[test]\nfn test() {\n    let t1 = [(\"hello\", 0), (\"world\", 1)];\n    let t2 = [(\"hello\", \"rust\"), (\"hello\", \"cargo\")];\n    let r = hash_join(&t1, &t2);\n    let expected = [(0, \"hello\", \"rust\"), (0, \"hello\", \"cargo\")];\n    assert_eq!(r, expected);\n}\n",
    "path": "tasks/hash-join",
    "remote_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n// If you know one of the tables is smaller, it is best to make it the second parameter.\nfn hash_join<A, B, K>(first: &[(K, A)], second: &[(K, B)]) -> Vec<(A, K, B)>\nwhere\n    K: Hash + Eq + Copy,\n    A: Copy,\n    B: Copy,\n{\n    let mut hash_map = HashMap::new();\n\n    // hash phase\n    for &(key, val_a) in second {\n        // collect all values by their keys, appending new ones to each existing entry\n        hash_map.entry(key).or_insert_with(Vec::new).push(val_a);\n    }\n\n    let mut result = Vec::new();\n    // join phase\n    for &(key, val_b) in first {\n        if let Some(vals) = hash_map.get(&key) {\n            let tuples = vals.iter().map(|&val_a| (val_b, key, val_a));\n            result.extend(tuples);\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let table1 = [(\"Jonah\", 27), (\"Alan\", 18), (\"Glory\", 28), (\"Popeye\", 18), (\"Alan\", 28)];\n    let table2 = [\n        (\"Jonah\", \"Whales\"), (\"Jonah\", \"Spiders\"), (\"Alan\", \"Ghosts\"),\n        (\"Alan\", \"Zombies\"), (\"Glory\", \"Buffy\")\n    ];\n    let result = hash_join(&table1, &table2);\n    println!(\"Age | Character Name | Nemesis\");\n    println!(\"----|----------------|--------\");\n    for (age, name, nemesis) in result {\n        println!(\"{:<3} | {:^14} | {}\", age, name, nemesis);\n    }\n}",
    "title": "Hash join",
    "url": "http://rosettacode.org/wiki/Hash_join"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::f64;\n\nstatic R: f64 = 6372.8;\n\nstruct Point {\n    lat: f64,\n    lon: f64,\n}\n\nfn haversine(mut origin: Point, mut destination: Point) -> f64 {\n    origin.lon -= destination.lon;\n    origin.lon = origin.lon.to_radians();\n    origin.lat = origin.lat.to_radians();\n    destination.lat = destination.lat.to_radians();\n    let dz: f64 = origin.lat.sin() - destination.lat.sin();\n    let dx: f64 = origin.lon.cos() * origin.lat.cos() - destination.lat.cos();\n    let dy: f64 = origin.lon.sin() * origin.lat.cos();\n    ((dx * dx + dy * dy + dz * dz).sqrt() / 2.0).asin() * 2.0 * R\n}\n\nfn main() {\n    let origin: Point = Point {\n        lat: 36.12,\n        lon:-86.67\n    };\n    let destination: Point = Point {\n        lat: 33.94,\n        lon:-118.4\n    };\n    let d: f64 = haversine(origin, destination);\n    println!(\"Distance: {} km ({} mi)\", d, d / 1.609344);\n}\n\n",
    "title": "Haversine formula",
    "url": "http://rosettacode.org/wiki/Haversine_formula"
  },
  {
    "local_code": "use iced::{executor, Application, Command, Element, Settings, Text};\n\nstruct Goodbye;\n\nimpl Application for Goodbye {\n    type Executor = executor::Default;\n    type Message = ();\n    type Flags = ();\n\n    fn new(_flags: ()) -> (Goodbye, Command<Self::Message>) {\n        (Goodbye, Command::none())\n    }\n\n    fn title(&self) -> String {\n        String::from(\"Hello, World!\")\n    }\n\n    fn update(&mut self, _message: Self::Message) -> Command<Self::Message> {\n        Command::none()\n    }\n\n    fn view(&mut self) -> Element<Self::Message> {\n        Text::new(\"Goodbye, World!\").into()\n    }\n}\n\nfn main() -> iced::Result {\n    Goodbye::run(Settings::default())\n}\n",
    "path": "tasks/hello-world/graphical",
    "remote_code": "// cargo-deps:  gtk\nextern crate gtk;\nuse gtk::traits::*;\nuse gtk::{Window, WindowType, WindowPosition};\nuse gtk::signal::Inhibit;\n\nfn main() {\n    gtk::init().unwrap();\n    let window = Window::new(WindowType::Toplevel).unwrap();\n\n    window.set_title(\"Goodbye, World!\");\n    window.set_border_width(10);\n    window.set_window_position(WindowPosition::Center);\n    window.set_default_size(350, 70);\n    window.connect_delete_event(|_,_| {\n        gtk::main_quit();\n        Inhibit(false)\n    });\n\n    window.show_all();\n    gtk::main();\n}",
    "title": "Hello world/Graphical",
    "url": "http://rosettacode.org/wiki/Hello_world/Graphical"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Write;\n\nfn main() {\n    let mut file = File::open(\"/dev/lp0\").unwrap();\n    write!(file, \"Hello World!\").unwrap();\n}\n",
    "path": "tasks/hello-world/line-printer",
    "remote_code": "use std::fs::OpenOptions;\nuse std::io::Write;\n\nfn main() {\n    let file = OpenOptions::new().write(true).open(\"/dev/lp0\").unwrap();\n    file.write(b\"Hello, World!\").unwrap();\n}",
    "title": "Hello world/Line printer",
    "url": "http://rosettacode.org/wiki/Hello_world/Line_printer"
  },
  {
    "local_code": "//! A complete description of how to install the language can be found on the [Install page] of the\n//! [Rust web site]. However, for the purposes of trying out code examples, use the [online REPL]\n//! which allows you to enter code, compile it and run it within a single browser window.\n//!\n//! [Install page]: http://www.rust-lang.org/install.html\n//! [Rust web site]: http://www.rust-lang.org/\n//! [online REPL]: http://play.rust-lang.org/\n\nfn main() {\n    println!(\"Hello world!\");\n}\n",
    "path": "tasks/hello-world/newbie",
    "remote_code": "fn main() {\n    println!(\"Hello world!\");\n}",
    "title": "Hello world/Newbie",
    "url": "http://rosettacode.org/wiki/Hello_world/Newbie"
  },
  {
    "local_code": "fn main() {\n    print!(\"Goodbye, World!\");\n}\n",
    "path": "tasks/hello-world/newline-omission",
    "remote_code": "fn main () {\n    print!(\"Goodbye, World!\");\n}",
    "title": "Hello world/Newline omission",
    "url": "http://rosettacode.org/wiki/Hello_world/Newline_omission"
  },
  {
    "local_code": "use std::io::{self, Write};\n\nfn main() {\n    let mut stderr = io::stderr();\n    let _ = stderr.write_all(b\"Goodbye, World!\\n\");\n}\n",
    "path": "tasks/hello-world/standard-error",
    "remote_code": "fn main() {\n    eprintln!(\"Hello, {}!\", \"world\");\n}",
    "title": "Hello world/Standard error",
    "url": "http://rosettacode.org/wiki/Hello_world/Standard_error"
  },
  {
    "local_code": "fn main() {\n    println!(\"Hello world!\");\n}\n",
    "path": "tasks/hello-world/text",
    "remote_code": "\nfn main() {\n   print!(\"Hello world!\");\n}\n",
    "title": "Hello world/Text",
    "url": "http://rosettacode.org/wiki/Hello_world/Text"
  },
  {
    "local_code": "use std::env;\nuse std::io::{Result, Write};\nuse std::net::{Shutdown, TcpListener, TcpStream};\n\nfn handle_client(mut stream: TcpStream) -> Result<()> {\n    let response = b\"HTTP/1.1 200 OK\nContent-Type: text/html;\ncharset=UTF-8\n\n<!doctype html>\n<html>\n    <head>\n        <title>Bye-bye baby bye-bye</title>\n        <style>\n            body { background-color: #111 }\n            h1 { font-size:4cm; text-align: center; color: black; text-shadow: 0 0 2mm red}\n        </style>\n    </head>\n    <body>\n        <h1>Goodbye, world!</h1>\n    </body>\n</html>\";\n\n    stream.write_all(response)?;\n    stream.shutdown(Shutdown::Write)\n}\n\nfn handle_server(ip: &str, port: u16) -> Result<TcpListener> {\n    use std::thread::spawn;\n    let listener = TcpListener::bind((ip, port))?;\n    println!(\"Listening for connections on port {}\", port);\n\n    let handle = listener.try_clone()?;\n    for stream in handle.incoming() {\n        match stream {\n            Ok(s) => {\n                spawn(move || match handle_client(s) {\n                    Ok(_) => println!(\"Response sent!\"),\n                    Err(e) => println!(\"Failed sending response: {}!\", e),\n                });\n            }\n            Err(e) => {\n                println!(\"No longer accepting new requests: {}\", e);\n                break;\n            }\n        }\n    }\n    drop(listener);\n    Ok(handle)\n}\n\nfn main() {\n    let mut args = env::args();\n    let app_name = args.next().unwrap();\n    let host = \"127.0.0.1\";\n    let port = if let Some(os_port) = args.next() {\n        os_port\n            .parse::<u16>()\n            .expect(&*format!(\"Usage: {:?} <port>\", app_name))\n    } else {\n        8080\n    };\n\n    handle_server(host, port).unwrap();\n}\n",
    "path": "tasks/hello-world/web-server",
    "remote_code": "use std::net::{Shutdown, TcpListener};\nuse std::thread;\nuse std::io::Write;\n\nconst RESPONSE: &'static [u8] = b\"HTTP/1.1 200 OK\\r\nContent-Type: text/html; charset=UTF-8\\r\\n\\r\n<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title>\n<style>body { background-color: #111 }\nh1 { font-size:4cm; text-align: center; color: black;\ntext-shadow: 0 0 2mm red}</style></head>\n<body><h1>Goodbye, world!</h1></body></html>\\r\";\n\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n\n    for stream in listener.incoming() {\n        thread::spawn(move || {\n            let mut stream = stream.unwrap();\n            match stream.write(RESPONSE) {\n                Ok(_) => println!(\"Response sent!\"),\n                Err(e) => println!(\"Failed sending response: {}!\", e),\n            }\n            stream.shutdown(Shutdown::Write).unwrap();\n        });\n    }\n}\n",
    "title": "Hello world/Web server",
    "url": "http://rosettacode.org/wiki/Hello_world/Web_server"
  },
  {
    "local_code": "fn main() {\n    // Similar to C++, Rust offers raw strings:\n    let x = r#\"\n        This is a \"raw string literal,\" roughly equivalent to a heredoc.\n    \"#;\n\n    println!(\"{}\", x);\n}\n",
    "path": "tasks/here-document",
    "remote_code": "let x = r#\"\n    This is a \"raw string literal,\" roughly equivalent to a heredoc.   \n\"#;\n\nlet y = r##\"\n  This string contains a #.\n\"##;\n",
    "title": "Here document",
    "url": "http://rosettacode.org/wiki/Here_document"
  },
  {
    "local_code": "use num_integer::Integer;\nuse std::{f64, usize};\n\nconst MAXSIZE: usize = 200;\n\n#[derive(Debug)]\nstruct HerionanTriangle {\n    a: usize,\n    b: usize,\n    c: usize,\n    area: usize,\n    perimeter: usize,\n}\n\nfn get_area(a: f64, b: f64, c: f64) -> f64 {\n    let s = (a + b + c) / 2.;\n    (s * (s - a) * (s - b) * (s - c)).sqrt()\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn is_heronian(a: usize, b: usize, c: usize) -> bool {\n    let area = get_area(a as f64, b as f64, c as f64);\n    // Heronian if the area is an integer number\n    area != 0. && area.fract() == 0.\n}\n\n#[allow(clippy::cast_precision_loss)]\n#[allow(clippy::cast_possible_truncation)]\n#[allow(clippy::cast_sign_loss)]\nfn main() {\n    let mut heronians: Vec<HerionanTriangle> = vec![];\n\n    (1..=MAXSIZE).into_iter().for_each(|a| {\n        (a..=MAXSIZE).into_iter().for_each(|b| {\n            (b..=MAXSIZE).into_iter().for_each(|c| {\n                if a + b > c && a.gcd(&b).gcd(&c) == 1 && is_heronian(a, b, c) {\n                    heronians.push(HerionanTriangle {\n                        a,\n                        b,\n                        c,\n                        perimeter: a + b + c,\n                        area: get_area(a as f64, b as f64, c as f64) as usize,\n                    })\n                }\n            })\n        })\n    });\n\n    // sort by area then by perimeter, then by maximum side\n    heronians.sort_unstable_by(|x, y| {\n        x.area\n            .cmp(&y.area)\n            .then(x.perimeter.cmp(&y.perimeter))\n            .then((x.a.max(x.b).max(x.c)).cmp(&y.a.max(y.b).max(y.c)))\n    });\n\n    println!(\n        \"Primitive Heronian triangles with sides up to 200: {}\",\n        heronians.len()\n    );\n\n    println!(\"\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\");\n    heronians.iter().take(10).for_each(|h| println!(\"{:?}\", h));\n\n    println!(\"\\nAll with area 210 subject to the previous ordering:\");\n    heronians\n        .iter()\n        .filter(|h| h.area == 210)\n        .for_each(|h| println!(\"{:?}\", h));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_heronian;\n\n    #[test]\n    fn test_heronian() {\n        assert_eq!(is_heronian(3, 4, 5), true);\n        assert_eq!(is_heronian(5, 5, 6), true);\n        assert_eq!(is_heronian(1, 2, 3), false);\n    }\n}\n",
    "path": "tasks/heronian-triangles",
    "remote_code": "\nuse num_integer::Integer;\nuse std::{f64, usize};\n\nconst MAXSIZE: usize = 200;\n\n#[derive(Debug)]\nstruct HerionanTriangle {\n    a: usize,\n    b: usize,\n    c: usize,\n    area: usize,\n    perimeter: usize,\n}\n\nfn get_area(a: &usize, b: &usize, c: &usize) -> f64 {\n    let s = (a + b + c) as f64 / 2.;\n    (s * (s - *a as f64) * (s - *b as f64) * (s - *c as f64)).sqrt()\n}\n\nfn is_heronian(a: &usize, b: &usize, c: &usize) -> bool {\n    let area = get_area(a, b, c);\n    // Heronian if the area is an integer number\n    area != 0. && area.fract() == 0.\n}\n\nfn main() {\n    let mut heronians: Vec<HerionanTriangle> = vec![];\n\n    (1..=MAXSIZE).into_iter().for_each(|a| {\n        (a..=MAXSIZE).into_iter().for_each(|b| {\n            (b..=MAXSIZE).into_iter().for_each(|c| {\n                if a + b > c && a.gcd(&b).gcd(&c) == 1 && is_heronian(&a, &b, &c) {\n                    heronians.push(HerionanTriangle {\n                        a,\n                        b,\n                        c,\n                        perimeter: a + b + c,\n                        area: get_area(&a, &b, &c) as usize,\n                    })\n                }\n            })\n        })\n    });\n\n    // sort by area then by perimeter, then by maximum side\n    heronians.sort_unstable_by(|x, y| {\n        x.area\n            .cmp(&y.area)\n            .then(x.perimeter.cmp(&y.perimeter))\n            .then((x.a.max(x.b).max(x.c)).cmp(&y.a.max(y.b).max(y.c)))\n    });\n\n    println!(\n        \"Primitive Heronian triangles with sides up to 200: {}\",\n        heronians.len()\n    );\n\n    println!(\"\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\");\n    heronians.iter().take(10).for_each(|h| println!(\"{:?}\", h));\n\n    println!(\"\\nAll with area 210 subject to the previous ordering:\");\n    heronians\n        .iter()\n        .filter(|h| h.area == 210)\n        .for_each(|h| println!(\"{:?}\", h));\n}\n\n",
    "title": "Heronian triangles",
    "url": "http://rosettacode.org/wiki/Heronian_triangles"
  },
  {
    "local_code": "use decimal::d128;\nuse factorial::Factorial;\n\nfn hickerson(n: u64) -> d128 {\n    d128::from(n.factorial()) / (d128!(2) * (d128!(2).ln().pow(d128::from(n + 1))))\n}\n\n// Some details on floating-points numbers can be found at https://cheats.rs/#basic-types\nfn main() {\n    for i in 1..18 {\n        let h = hickerson(i);\n        let string = h.to_string();\n        let dec_part = string.split('.').nth(1).unwrap();\n        if dec_part.starts_with('0') || dec_part.starts_with('9') {\n            println!(\"{} is an almost integer.\", h);\n        } else {\n            println!(\"{} is not an almost integer.\", h);\n        }\n    }\n}\n",
    "path": "tasks/hickerson-series-of-almost-integers",
    "remote_code": "\nuse decimal::d128;\nuse factorial::Factorial;\n\nfn hickerson(n: u64) -> d128 {\n    d128::from(n.factorial()) / (d128!(2) * (d128!(2).ln().pow(d128::from(n + 1))))\n}\n\n// Some details on floating-points numbers can be found at https://cheats.rs/#basic-types\nfn main() {\n    for i in 1..18 {\n        let h = hickerson(i);\n        let string = h.to_string();\n        let dec_part = string.split('.').nth(1).unwrap();\n        if dec_part.starts_with('0') || dec_part.starts_with('9') {\n            println!(\"{} is an almost integer.\", h);\n        } else {\n            println!(\"{} is not an almost integer.\", h);\n        }\n    }\n}\n",
    "title": "Hickerson series of almost integers",
    "url": "http://rosettacode.org/wiki/Hickerson_series_of_almost_integers"
  },
  {
    "local_code": "fn plain_function() {\n    println!(\"regular function\");\n}\n\nfn higher_order<F>(cb: F)\nwhere\n    F: Fn(),\n{\n    cb();\n}\n\nfn main() {\n    higher_order(plain_function);\n    higher_order(|| println!(\"a closure\"));\n}\n",
    "path": "tasks/higher-order-functions",
    "remote_code": "fn execute_with_10<F: Fn(u64) -> u64> (f: F) -> u64 {\n\tf(10)\n}\n\nfn square(n: u64) -> u64 {\n\tn*n\n}\n\nfn main() {\n\tprintln!(\"{}\", execute_with_10(|n| n*n )); // closure\n\tprintln!(\"{}\", execute_with_10(square));   // function\n}",
    "title": "Higher-order functions",
    "url": "http://rosettacode.org/wiki/Higher-order_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nuse svg::node::element::path::Data;\nuse svg::node::element::Path;\n\nstruct HilbertCurve {\n    current_x: f64,\n    current_y: f64,\n    current_angle: i32,\n    line_length: f64,\n}\n\nimpl HilbertCurve {\n    fn new(x: f64, y: f64, length: f64, angle: i32) -> HilbertCurve {\n        HilbertCurve {\n            current_x: x,\n            current_y: y,\n            current_angle: angle,\n            line_length: length,\n        }\n    }\n    fn rewrite(order: usize) -> String {\n        let mut str = String::from(\"A\");\n        for _ in 0..order {\n            let mut tmp = String::new();\n            for ch in str.chars() {\n                match ch {\n                    'A' => tmp.push_str(\"-BF+AFA+FB-\"),\n                    'B' => tmp.push_str(\"+AF-BFB-FA+\"),\n                    _ => tmp.push(ch),\n                }\n            }\n            str = tmp;\n        }\n        str\n    }\n    fn execute(&mut self, order: usize) -> Path {\n        let mut data = Data::new().move_to((self.current_x, self.current_y));\n        for ch in HilbertCurve::rewrite(order).chars() {\n            match ch {\n                'F' => data = self.draw_line(data),\n                '+' => self.turn(90),\n                '-' => self.turn(-90),\n                _ => {}\n            }\n        }\n        Path::new()\n            .set(\"fill\", \"none\")\n            .set(\"stroke\", \"black\")\n            .set(\"stroke-width\", \"1\")\n            .set(\"d\", data)\n    }\n    fn draw_line(&mut self, data: Data) -> Data {\n        let theta = (self.current_angle as f64).to_radians();\n        self.current_x += self.line_length * theta.cos();\n        self.current_y -= self.line_length * theta.sin();\n        data.line_to((self.current_x, self.current_y))\n    }\n    fn turn(&mut self, angle: i32) {\n        self.current_angle = (self.current_angle + angle) % 360;\n    }\n    fn save(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n        use svg::node::element::Rectangle;\n        let x = 10.0;\n        let y = 10.0;\n        let rect = Rectangle::new()\n            .set(\"width\", \"100%\")\n            .set(\"height\", \"100%\")\n            .set(\"fill\", \"white\");\n        let mut hilbert = HilbertCurve::new(x, y, 10.0, 0);\n        let document = svg::Document::new()\n            .set(\"width\", size)\n            .set(\"height\", size)\n            .add(rect)\n            .add(hilbert.execute(order));\n        svg::save(file, &document)\n    }\n}\n\nfn main() {\n    HilbertCurve::save(\"hilbert_curve.svg\", 650, 6).unwrap();\n}",
    "title": "Hilbert curve",
    "url": "http://rosettacode.org/wiki/Hilbert_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Clone, Debug)]\nstruct HVar<T> {\n    history: Vec<T>,\n    current: T,\n}\n\nimpl<T> HVar<T> {\n    fn new(val: T) -> Self {\n        HVar {\n            history: Vec::new(),\n            current: val,\n        }\n    }\n\n    fn get(&self) -> &T {\n        &self.current\n    }\n\n    fn set(&mut self, val: T) {\n        self.history.push(std::mem::replace(&mut self.current, val));\n    }\n\n    fn history(&self) -> (&[T], &T) {\n        (&self.history, &self.current)\n    }\n\n    fn revert(&mut self) -> Option<T> {\n        self.history\n            .pop()\n            .map(|val| std::mem::replace(&mut self.current, val))\n    }\n}\n\nfn main() {\n    let mut var = HVar::new(0);\n    var.set(1);\n    var.set(2);\n    println!(\"{:?}\", var.history());\n    println!(\"{:?}\", var.revert());\n    println!(\"{:?}\", var.revert());\n    println!(\"{:?}\", var.revert());\n    println!(\"{:?}\", var.get());\n}",
    "title": "History variables",
    "url": "http://rosettacode.org/wiki/History_variables"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nstruct Hffs {\n    sequence_r: HashMap<usize, usize>,\n    sequence_s: HashMap<usize, usize>,\n}\n\nimpl Hffs {\n    fn new() -> Hffs {\n        Hffs {\n            sequence_r: HashMap::new(),\n            sequence_s: HashMap::new(),\n        }\n    }\n    fn ffr(&mut self, n: usize) -> usize {\n        // first try the cache\n        let new_r = if let Some(result) = self.sequence_r.get(&n) {\n            *result\n        } else if n == 0 {\n            1\n        } else {\n            // call recursively\n            self.ffr(n - 1) + self.ffs(n - 1)\n        };\n\n        // insert into the cache and return value\n        *self.sequence_r.entry(n).or_insert(new_r)\n    }\n\n    fn ffs(&mut self, n: usize) -> usize {\n        // first try the cache\n        let new_s = if let Some(result) = self.sequence_s.get(&n) {\n            *result\n        } else if n == 0 {\n            2\n        } else {\n            let lower = self.ffs(n - 1) + 1_usize;\n            let upper = self.ffr(n) + 1_usize;\n            let mut min_s: usize = 0;\n            // find next available S\n            for i in lower..=upper {\n                if !self.sequence_r.values().any(|&val| val == i) {\n                    min_s = i;\n                    break;\n                }\n            }\n            min_s\n        };\n\n        // insert into the cache and return value\n        *self.sequence_s.entry(n).or_insert(new_s)\n    }\n}\n\nimpl Default for Hffs {\n    fn default() -> Self {\n        Self::new()\n    }\n}\nfn main() {\n    let mut hof = Hffs::new();\n\n    for i in 0..10 {\n        println!(\"H:{} -> R: {}, S: {}\", i, hof.ffr(i), hof.ffs(i));\n    }\n\n    let r40 = (0..40).map(|i| hof.ffr(i)).collect::<Vec<_>>();\n    let mut s960 = (0..960).map(|i| hof.ffs(i)).collect::<Vec<_>>();\n\n    s960.extend(&r40);\n    s960.sort_unstable();\n    let f1000 = (1_usize..=1000).collect::<Vec<_>>();\n\n    assert_eq!(f1000, s960, \"Does NOT match\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hof() {\n        let mut hof = Hffs::new();\n\n        let f10 = (0..10).map(|i| hof.ffr(i)).collect::<Vec<_>>();\n        assert_eq!(f10, vec![1, 3, 7, 12, 18, 26, 35, 45, 56, 69]);\n    }\n}\n",
    "path": "tasks/hofstadter-figure-figure-sequences",
    "remote_code": "\nuse std::collections::HashMap;\n\nstruct Hffs {\n    sequence_r: HashMap<usize, usize>,\n    sequence_s: HashMap<usize, usize>,\n}\n\nimpl Hffs {\n    fn new() -> Hffs {\n        Hffs {\n            sequence_r: HashMap::new(),\n            sequence_s: HashMap::new(),\n        }\n    }\n    fn ffr(&mut self, n: usize) -> usize {\n        // first try the cache\n        let new_r = if let Some(result) = self.sequence_r.get(&n) {\n            *result\n        } else if n == 0 {\n            1\n        } else {\n            // call recursively\n            self.ffr(n - 1) + self.ffs(n - 1)\n        };\n\n        // insert into the cache and return value\n        *self.sequence_r.entry(n).or_insert(new_r)\n    }\n\n    fn ffs(&mut self, n: usize) -> usize {\n        // first try the cache\n        let new_s = if let Some(result) = self.sequence_s.get(&n) {\n            *result\n        } else if n == 0 {\n            2\n        } else {\n            let lower = self.ffs(n - 1) + 1_usize;\n            let upper = self.ffr(n) + 1_usize;\n            let mut min_s: usize = 0;\n            // find next available S\n            for i in lower..=upper {\n                if !self.sequence_r.values().any(|&val| val == i) {\n                    min_s = i;\n                    break;\n                }\n            }\n            min_s\n        };\n\n        // insert into the cache and return value\n        *self.sequence_s.entry(n).or_insert(new_s)\n    }\n}\n\nimpl Default for Hffs {\n    fn default() -> Self {\n        Self::new()\n    }\n}\nfn main() {\n    let mut hof = Hffs::new();\n\n    for i in 0..10 {\n        println!(\"H:{} -> R: {}, S: {}\", i, hof.ffr(i), hof.ffs(i));\n    }\n\n    let r40 = (0..40).map(|i| hof.ffr(i)).collect::<Vec<_>>();\n    let mut s960 = (0..960).map(|i| hof.ffs(i)).collect::<Vec<_>>();\n\n    s960.extend(&r40);\n    s960.sort_unstable();\n    let f1000 = (1_usize..=1000).collect::<Vec<_>>();\n\n    assert_eq!(f1000, s960, \"Does NOT match\");\n}\n",
    "title": "Hofstadter Figure-Figure sequences",
    "url": "http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences"
  },
  {
    "local_code": "//! An iterable version.\n\n/// Define a struct which stores the state for the iterator.\nstruct HofstadterQ {\n    next: usize,\n    memoize_vec: Vec<usize>,\n}\n\nimpl HofstadterQ {\n    /// Define a constructor for the struct.\n    fn new() -> HofstadterQ {\n        HofstadterQ {\n            next: 1,\n            memoize_vec: vec![1],\n        }\n    }\n}\n\nimpl Default for HofstadterQ {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Implement the hofstadter q iteration sequence.\nimpl Iterator for HofstadterQ {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        // Cache the current value.\n        self.memoize_vec.push(self.next);\n        // And then calculate the 'next'.\n        // First, make the four recursive calls.\n        let current: usize = self.memoize_vec.len();\n        let rec_call_1: usize = self.memoize_vec[current - 1];\n        let rec_call_2: usize = self.memoize_vec[current - 2];\n        let rec_call_3: usize = self.memoize_vec[current - rec_call_1];\n        let rec_call_4: usize = self.memoize_vec[current - rec_call_2];\n        // Then update self.next and return it.\n        self.next = rec_call_3 + rec_call_4;\n        Some(self.next)\n    }\n}\n\nfn main() {\n    // Set up the iterable.\n    let hof: HofstadterQ = HofstadterQ::new();\n    // The number of terms we want from the iterator.\n    let upto: usize = 1000;\n    // Create the iterator.\n    let mut it = hof.take(upto - 2);\n    // Print the base values.\n    println!(\"H(1) = 1\");\n    println!(\"H(2) = 1\");\n    // Print the rest of the sequence.\n    for i in 3..1 + upto {\n        println!(\"H({}) = {}\", i, it.next().unwrap());\n    }\n}\n\n#[test]\nfn test_first_ten() {\n    let hofstadter_q = HofstadterQ::new().take(10).collect::<Vec<_>>();\n    // Test that the first ten values are as expected\n    // The first two values are hardcoded, so no need to test those.\n    let hofstadter_q_expected = vec![2, 3, 3, 4, 5, 5, 6, 6, 6, 8];\n    assert_eq!(hofstadter_q_expected, hofstadter_q);\n}\n\n#[test]\nfn test_thousandth() {\n    // Set up the iterable.\n    let hof: HofstadterQ = HofstadterQ::new();\n    // The number of terms we want from the iterator.\n    let upto: usize = 1000;\n    // Create the iterator.\n    let mut it = hof.take(upto - 2);\n    let expected: usize = 502;\n    // Test that the upto-th term is as expected.\n    for _ in 3..upto {\n        it.next();\n    }\n    assert_eq!(expected, it.next().unwrap());\n}\n",
    "path": "tasks/hofstadter-q-sequence",
    "remote_code": "fn hofq(q: &mut Vec<u32>, x : u32) -> u32 {\n    let cur_len=q.len()-1;\n    let i=x as usize;\n    if i>cur_len {\n        // extend storage\n        q.reserve(i+1);\n        for j in (cur_len+1)..(i+1) {\n            let qj=(q[j-q[j-1] as usize]+q[j-q[j-2] as usize]) as u32;\n            q.push(qj);\n        }\n    }\n    q[i]\n}\n\nfn main() {\n    let mut q_memo: Vec<u32>=vec![0,1,1];\n    let mut q=|i| {hofq(&mut q_memo, i)};\n    for i in 1..11 {\n        println!(\"Q({})={}\", i, q(i));\n    }\n    println!(\"Q(1000)={}\", q(1000));\n    let q100001=q(100_000); // precompute all\n    println!(\"Q(100000)={}\", q100000);\n    let nless=(1..100_000).fold(0,|s,i|{if q(i+1)<q(i) {s+1} else {s}});\n    println!(\"Term is less than preceding term {} times\", nless);\n}\n",
    "title": "Hofstadter Q sequence",
    "url": "http://rosettacode.org/wiki/Hofstadter_Q_sequence"
  },
  {
    "local_code": "struct HofstadterConway {\n    current: usize,\n    sequence: Vec<usize>,\n}\n\nimpl HofstadterConway {\n    /// Define a constructor for the struct.\n    fn new() -> HofstadterConway {\n        HofstadterConway {\n            current: 0,\n            sequence: vec![1, 1],\n        }\n    }\n}\n\nimpl Default for HofstadterConway {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Implement the hofstadter q iteration sequence.\nimpl Iterator for HofstadterConway {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        let max_index = self.sequence.len() - 1;\n        let last_value = self.sequence[max_index];\n\n        if self.current > max_index {\n            let new_x = self.sequence[last_value - 1] + self.sequence[max_index - last_value + 1];\n            self.sequence.push(new_x);\n        }\n        self.current += 1;\n        Some(self.sequence[self.current - 1])\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn main() {\n    let mut hof = HofstadterConway::new();\n    let mut winning_num = 0_usize;\n\n    for p in 0..20 {\n        let max_hof = (2_usize.pow(p)..2_usize.pow(p + 1))\n            .map(|n| (n, hof.next().unwrap() as f64 / n as f64))\n            .fold(f64::NAN, |a, (n, b)| {\n                if b >= 0.55 {\n                    winning_num = n;\n                }\n                a.max(b)\n            });\n\n        println!(\"2^{:>2}-2^{:>2}, {:>.8}\", p, p + 1, max_hof);\n    }\n\n    println!(\"Winning number: {}\", winning_num);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hofsadter_conway() {\n        let hofstadter_sequence = HofstadterConway::new().take(10).collect::<Vec<_>>();\n        assert_eq!(hofstadter_sequence, vec![1, 1, 2, 2, 3, 4, 4, 4, 5, 6]);\n    }\n}\n",
    "path": "tasks/hofstadter-conway",
    "remote_code": "\nstruct HofstadterConway {\n    current: usize,\n    sequence: Vec<usize>,\n}\n\nimpl HofstadterConway {\n    /// Define a constructor for the struct.\n    fn new() -> HofstadterConway {\n        HofstadterConway {\n            current: 0,\n            sequence: vec![1, 1],\n        }\n    }\n}\n\nimpl Default for HofstadterConway {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Implement the hofstadter q iteration sequence.\nimpl Iterator for HofstadterConway {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        let max_index = self.sequence.len() - 1;\n        let last_value = self.sequence[max_index];\n\n        if self.current > max_index {\n            let new_x = self.sequence[last_value - 1] + self.sequence[max_index - last_value + 1];\n            self.sequence.push(new_x);\n        }\n        self.current += 1;\n        Some(self.sequence[self.current - 1])\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn main() {\n    let mut hof = HofstadterConway::new();\n    let mut winning_num = 0_usize;\n\n    for p in 0..20 {\n        let max_hof = (2_usize.pow(p)..2_usize.pow(p + 1))\n            .map(|n| (n, hof.next().unwrap() as f64 / n as f64))\n            .fold(f64::NAN, |a, (n, b)| {\n                if b >= 0.55 {\n                    winning_num = n;\n                }\n                a.max(b)\n            });\n\n        println!(\"2^{:>2}-2^{:>2}, {:>.8}\", p, p + 1, max_hof);\n    }\n\n    println!(\"Winning number: {}\", winning_num);\n}\n",
    "title": "Hofstadter-Conway $10,000 sequence",
    "url": "http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence"
  },
  {
    "local_code": "use std::ops::Add;\n\nuse chrono::{prelude::*, Duration};\n\n#[allow(clippy::cast_possible_truncation)]\n#[allow(clippy::cast_sign_loss)]\n#[allow(clippy::cast_possible_wrap)]\nfn get_easter_day(year: u32) -> chrono::NaiveDate {\n    let k = (f64::from(year) / 100.).floor();\n    let d = (19 * (year % 19)\n        + ((15 - ((13. + 8. * k) / 25.).floor() as u32 + k as u32 - (k / 4.).floor() as u32) % 30))\n        % 30;\n    let e =\n        (2 * (year % 4) + 4 * (year % 7) + 6 * d + ((4 + k as u32 - (k / 4.).floor() as u32) % 7))\n            % 7;\n\n    let (month, day) = match d {\n        29 if e == 6 => (4, 19),\n        28 if e == 6 => (4, 18),\n        _ if d + e < 10 => (3, 22 + d + e),\n        _ => (4, d + e - 9),\n    };\n\n    NaiveDate::from_ymd(year as i32, month, day)\n}\nfn main() {\n    let holidays = vec![\n        (\"Easter\", Duration::days(0)),\n        (\"Ascension\", Duration::days(39)),\n        (\"Pentecost\", Duration::days(49)),\n        (\"Trinity\", Duration::days(56)),\n        (\"Corpus Christi\", Duration::days(60)),\n    ];\n    for year in (400..=2100).step_by(100).chain(2010..=2020) {\n        print!(\"{}: \", year);\n        for (name, offset) in &holidays {\n            print!(\n                \"{}: {}, \",\n                name,\n                get_easter_day(year).add(*offset).format(\"%a %d %h\")\n            );\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_easter_day() {\n        assert_eq!(NaiveDate::from_ymd(1777, 3, 30), get_easter_day(1777));\n        assert_eq!(NaiveDate::from_ymd(2021, 4, 4), get_easter_day(2021));\n    }\n}\n",
    "path": "tasks/holidays-related-to-easter",
    "remote_code": "\nuse std::ops::Add;\n\nuse chrono::{prelude::*, Duration};\n\n#[allow(clippy::cast_possible_truncation)]\n#[allow(clippy::cast_sign_loss)]\n#[allow(clippy::cast_possible_wrap)]\nfn get_easter_day(year: u32) -> chrono::NaiveDate {\n    let k = (f64::from(year) / 100.).floor();\n    let d = (19 * (year % 19)\n        + ((15 - ((13. + 8. * k) / 25.).floor() as u32 + k as u32 - (k / 4.).floor() as u32) % 30))\n        % 30;\n    let e =\n        (2 * (year % 4) + 4 * (year % 7) + 6 * d + ((4 + k as u32 - (k / 4.).floor() as u32) % 7))\n            % 7;\n\n    let (month, day) = match d {\n        29 if e == 6 => (4, 19),\n        28 if e == 6 => (4, 18),\n        _ if d + e < 10 => (3, 22 + d + e),\n        _ => (4, d + e - 9),\n    };\n\n    NaiveDate::from_ymd(year as i32, month, day)\n}\nfn main() {\n    let holidays = vec![\n        (\"Easter\", Duration::days(0)),\n        (\"Ascension\", Duration::days(39)),\n        (\"Pentecost\", Duration::days(49)),\n        (\"Trinity\", Duration::days(56)),\n        (\"Corpus Christi\", Duration::days(60)),\n    ];\n    for year in (400..=2100).step_by(100).chain(2010..=2020) {\n        print!(\"{}: \", year);\n        for (name, offset) in &holidays {\n            print!(\n                \"{}: {}, \",\n                name,\n                get_easter_day(year).add(*offset).format(\"%a %d %h\")\n            );\n        }\n        println!();\n    }\n}\n",
    "title": "Holidays related to Easter",
    "url": "http://rosettacode.org/wiki/Holidays_related_to_Easter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Home primes",
    "url": "http://rosettacode.org/wiki/Home_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Honeycombs",
    "url": "http://rosettacode.org/wiki/Honeycombs"
  },
  {
    "local_code": "use std::io;\nstruct SundialCalculation {\n    hour_angle: f64,\n    hour_line_angle: f64,\n}\n\nfn get_input(prompt: &str) -> Result<f64, Box<dyn std::error::Error>> {\n    println!(\"{}\", prompt);\n    let mut input = String::new();\n    let stdin = io::stdin();\n    stdin.read_line(&mut input)?;\n    Ok(input.trim().parse::<f64>()?)\n}\n\nfn calculate_sundial(hour: i8, lat: f64, lng: f64, meridian: f64) -> SundialCalculation {\n    let diff = lng - meridian;\n    let hour_angle = f64::from(hour) * 15. - diff;\n    let hour_line_angle = (hour_angle.to_radians().tan() * lat.to_radians().sin())\n        .atan()\n        .to_degrees();\n\n    SundialCalculation {\n        hour_angle,\n        hour_line_angle,\n    }\n}\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let lat = get_input(\"Enter latitude       => \")?;\n    let lng = get_input(\"Enter longitude      => \")?;\n    let meridian = get_input(\"Enter legal meridian => \")?;\n    let diff = lng - meridian;\n\n    let sine_lat = lat.to_radians().sin();\n    println!(\"Sine of latitude: {:.5}\", sine_lat);\n    println!(\"Diff longitude: {}\", diff);\n\n    println!(\"  Hrs Angle   Hour Line Angle\");\n    (-6..=6).for_each(|hour| {\n        let sd = calculate_sundial(hour, lat, lng, meridian);\n        println!(\n            \"{:>3}{} {:>5}   {:>+15.5}\",\n            if hour == 0 { 12 } else { (hour + 12) % 12 },\n            if hour <= 6 { \"pm\" } else { \"am\" },\n            sd.hour_angle,\n            sd.hour_line_angle\n        );\n    });\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assert_approx_eq::assert_approx_eq;\n\n    #[test]\n    fn test_calculate_sundial() {\n        let result = calculate_sundial(-6, -4.95, -150.5, -150.);\n        assert_approx_eq!(result.hour_angle, -89.5);\n        assert_approx_eq!(result.hour_line_angle, 84.224832601);\n    }\n}\n",
    "path": "tasks/horizontal-sundial-calculations",
    "remote_code": "\nuse std::io;\nstruct SundialCalculation {\n    hour_angle: f64,\n    hour_line_angle: f64,\n}\n\nfn get_input(prompt: &str) -> Result<f64, Box<dyn std::error::Error>> {\n    println!(\"{}\", prompt);\n    let mut input = String::new();\n    let stdin = io::stdin();\n    stdin.read_line(&mut input)?;\n    Ok(input.trim().parse::<f64>()?)\n}\n\nfn calculate_sundial(hour: i8, lat: f64, lng: f64, meridian: f64) -> SundialCalculation {\n    let diff = lng - meridian;\n    let hour_angle = f64::from(hour) * 15. - diff;\n    let hour_line_angle = (hour_angle.to_radians().tan() * lat.to_radians().sin())\n        .atan()\n        .to_degrees();\n\n    SundialCalculation {\n        hour_angle,\n        hour_line_angle,\n    }\n}\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let lat = get_input(\"Enter latitude       => \")?;\n    let lng = get_input(\"Enter longitude      => \")?;\n    let meridian = get_input(\"Enter legal meridian => \")?;\n    let diff = lng - meridian;\n\n    let sine_lat = lat.to_radians().sin();\n    println!(\"Sine of latitude: {:.5}\", sine_lat);\n    println!(\"Diff longitude: {}\", diff);\n\n    println!(\"  Hrs Angle   Hour Line Angle\");\n    (-6..=6).for_each(|hour| {\n        let sd = calculate_sundial(hour, lat, lng, meridian);\n        println!(\n            \"{:>3}{} {:>5}   {:>+15.5}\",\n            if hour == 0 { 12 } else { (hour + 12) % 12 },\n            if hour <= 6 { \"pm\" } else { \"am\" },\n            sd.hour_angle,\n            sd.hour_line_angle\n        );\n    });\n    Ok(())\n}\n\n",
    "title": "Horizontal sundial calculations",
    "url": "http://rosettacode.org/wiki/Horizontal_sundial_calculations"
  },
  {
    "local_code": "extern crate num;\n\nuse num::traits::{PrimInt, Zero};\n\nfn horner<T: PrimInt + Zero>(cs: &[T], x: T) -> T {\n    cs.iter()\n        .rev()\n        .fold(Zero::zero(), |acc: T, c| (acc * x) + (*c))\n}\n\nfn main() {\n    println!(\"{}\", horner(&[-19i32, 7, -4, 6], 3i32)); // 128\n}\n\n#[cfg(test)]\nmod tests {\n    use super::horner;\n\n    #[test]\n    fn test() {\n        assert_eq!(horner(&[-19i32, 7, -4, 6], 3i32), 128);\n        assert_eq!(horner(&[-1i32, 7, -4, 6], 0i32), -1);\n        assert_eq!(horner(&[-0i32, 3], 100i32), 300);\n        assert_eq!(horner(&[-20i32, 7, 1], 10i32), 150);\n        assert_eq!(horner(&[-19i32, 7, -4, 0], 5i32), -84);\n    }\n}\n",
    "path": "tasks/horners-rule-for-polynomial-evaluation",
    "remote_code": "fn horner(v: &[f64], x: f64) -> f64 {\n    v.iter().rev().fold(0.0, |acc, coeff| acc*x + coeff)\n}\n\nfn main() {\n    let v = [-19., 7., -4., 6.];\n    println!(\"result: {}\", horner(&v, 3.0));\n}",
    "title": "Horner's rule for polynomial evaluation",
    "url": "http://rosettacode.org/wiki/Horner's_rule_for_polynomial_evaluation"
  },
  {
    "local_code": "fn main() {\n    println!(\"word size: {} bits\", 8 * std::mem::size_of::<usize>());\n\n    if cfg!(target_endian = \"big\") {\n        println!(\"big endian\");\n    } else {\n        println!(\"little endian\");\n    }\n}\n",
    "path": "tasks/host-introspection",
    "remote_code": "#[derive(Copy, Clone, Debug)]\nenum Endianness {\n    Big, Little,\n}\n\nimpl Endianness {\n    fn target() -> Self {\n        #[cfg(target_endian = \"big\")]\n        {\n            Endianness::Big\n        }\n        #[cfg(not(target_endian = \"big\"))]\n        {\n            Endianness::Little\n        }\n    }\n}\n\nfn main() {\n    println!(\"Word size: {} bytes\", std::mem::size_of::<usize>());\n    println!(\"Endianness: {:?}\", Endianness::target());\n}",
    "title": "Host introspection",
    "url": "http://rosettacode.org/wiki/Host_introspection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    match hostname::get_hostname() {\n        Some(host) => println!(\"hostname: {}\", host),\n        None => eprintln!(\"Could not get hostname!\"),\n    }\n}",
    "title": "Hostname",
    "url": "http://rosettacode.org/wiki/Hostname"
  },
  {
    "local_code": "//! Contributed by Gavin Baker <gavinb@antonym.org>\n//! Adapted from the Go version\n\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\nuse std::iter::repeat;\n\n/// Simple 8-bit grayscale image\nstruct ImageGray8 {\n    width: usize,\n    height: usize,\n    data: Vec<u8>,\n}\n\nfn load_pgm(filename: &str) -> io::Result<ImageGray8> {\n    // Open file\n    let mut file = BufReader::new(File::open(filename)?);\n\n    // Read header\n    let mut magic_in = String::new();\n    let _ = file.read_line(&mut magic_in)?;\n    let mut width_in = String::new();\n    let _ = file.read_line(&mut width_in)?;\n    let mut height_in = String::new();\n    let _ = file.read_line(&mut height_in)?;\n    let mut maxval_in = String::new();\n    let _ = file.read_line(&mut maxval_in)?;\n\n    assert_eq!(magic_in, \"P5\\n\");\n    assert_eq!(maxval_in, \"255\\n\");\n\n    // Parse header\n    let width = width_in\n        .trim()\n        .parse::<usize>()\n        .map_err(|_| io::ErrorKind::InvalidData)?;\n    let height: usize = height_in\n        .trim()\n        .parse::<usize>()\n        .map_err(|_| io::ErrorKind::InvalidData)?;\n\n    println!(\"Reading pgm file {}: {} x {}\", filename, width, height);\n\n    // Create image and allocate buffer\n    let mut img = ImageGray8 {\n        width,\n        height,\n        data: vec![],\n    };\n\n    // Read image data\n    let expected_bytes = width * height;\n    let bytes_read = file.read_to_end(&mut img.data)?;\n    if bytes_read != expected_bytes {\n        let kind = if bytes_read < expected_bytes {\n            io::ErrorKind::UnexpectedEof\n        } else {\n            io::ErrorKind::InvalidData\n        };\n        let msg = format!(\"expected {} bytes\", expected_bytes);\n        return Err(io::Error::new(kind, msg));\n    }\n\n    Ok(img)\n}\n\nfn save_pgm(img: &ImageGray8, filename: &str) {\n    // Open file\n    let mut file = BufWriter::new(File::create(filename).unwrap());\n\n    // Write header\n    if let Err(e) = writeln!(&mut file, \"P5\\n{}\\n{}\\n255\", img.width, img.height) {\n        println!(\"Failed to write header: {}\", e);\n    }\n\n    println!(\n        \"Writing pgm file {}: {} x {}\",\n        filename, img.width, img.height\n    );\n\n    // Write binary image data\n    if let Err(e) = file.write_all(&(img.data[..])) {\n        println!(\"Failed to image data: {}\", e);\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\n#[allow(clippy::cast_possible_truncation)]\nfn hough(image: &ImageGray8, out_width: usize, out_height: usize) -> ImageGray8 {\n    let in_width = image.width;\n    let in_height = image.height;\n\n    // Allocate accumulation buffer\n    let out_height = ((out_height / 2) * 2) as usize;\n    let mut accum = ImageGray8 {\n        width: out_width,\n        height: out_height,\n        data: repeat(255).take(out_width * out_height).collect(),\n    };\n\n    // Transform extents\n    let rmax = (in_width as f64).hypot(in_height as f64);\n    let dr = rmax / (out_height / 2) as f64;\n    let dth = std::f64::consts::PI / out_width as f64;\n\n    // Process input image in raster order\n    for y in 0..in_height {\n        for x in 0..in_width {\n            let in_idx = y * in_width + x;\n            let col = image.data[in_idx];\n            if col == 255 {\n                continue;\n            }\n\n            // Project into rho,theta space\n            for jtx in 0..out_width {\n                let th = dth * (jtx as f64);\n                let r = (x as f64) * (th.cos()) + (y as f64) * (th.sin());\n\n                let iry = out_height as i64 / 2 - (r / (dr as f64) + 0.5).floor() as i64;\n                #[allow(clippy::cast_sign_loss)]\n                let out_idx = (jtx as i64 + iry * out_width as i64) as usize;\n                let col = accum.data[out_idx];\n                if col > 0 {\n                    accum.data[out_idx] = col - 1;\n                }\n            }\n        }\n    }\n    accum\n}\n\nfn main() -> io::Result<()> {\n    let image = load_pgm(\"resources/Pentagon.pgm\")?;\n    let accum = hough(&image, 460, 360);\n    save_pgm(&accum, \"hough.pgm\");\n    Ok(())\n}\n",
    "path": "tasks/hough-transform",
    "remote_code": "\n//! Contributed by Gavin Baker <gavinb@antonym.org>\n//! Adapted from the Go version\n\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\nuse std::iter::repeat;\n\n/// Simple 8-bit grayscale image\nstruct ImageGray8 {\n    width: usize,\n    height: usize,\n    data: Vec<u8>,\n}\n\nfn load_pgm(filename: &str) -> io::Result<ImageGray8> {\n    // Open file\n    let mut file = BufReader::new(File::open(filename)?);\n\n    // Read header\n    let mut magic_in = String::new();\n    let _ = file.read_line(&mut magic_in)?;\n    let mut width_in = String::new();\n    let _ = file.read_line(&mut width_in)?;\n    let mut height_in = String::new();\n    let _ = file.read_line(&mut height_in)?;\n    let mut maxval_in = String::new();\n    let _ = file.read_line(&mut maxval_in)?;\n\n    assert_eq!(magic_in, \"P5\\n\");\n    assert_eq!(maxval_in, \"255\\n\");\n\n    // Parse header\n    let width = width_in\n        .trim()\n        .parse::<usize>()\n        .map_err(|_| io::ErrorKind::InvalidData)?;\n    let height: usize = height_in\n        .trim()\n        .parse::<usize>()\n        .map_err(|_| io::ErrorKind::InvalidData)?;\n\n    println!(\"Reading pgm file {}: {} x {}\", filename, width, height);\n\n    // Create image and allocate buffer\n    let mut img = ImageGray8 {\n        width,\n        height,\n        data: vec![],\n    };\n\n    // Read image data\n    let expected_bytes = width * height;\n    let bytes_read = file.read_to_end(&mut img.data)?;\n    if bytes_read != expected_bytes {\n        let kind = if bytes_read < expected_bytes {\n            io::ErrorKind::UnexpectedEof\n        } else {\n            io::ErrorKind::InvalidData\n        };\n        let msg = format!(\"expected {} bytes\", expected_bytes);\n        return Err(io::Error::new(kind, msg));\n    }\n\n    Ok(img)\n}\n\nfn save_pgm(img: &ImageGray8, filename: &str) {\n    // Open file\n    let mut file = BufWriter::new(File::create(filename).unwrap());\n\n    // Write header\n    if let Err(e) = writeln!(&mut file, \"P5\\n{}\\n{}\\n255\", img.width, img.height) {\n        println!(\"Failed to write header: {}\", e);\n    }\n\n    println!(\n        \"Writing pgm file {}: {} x {}\",\n        filename, img.width, img.height\n    );\n\n    // Write binary image data\n    if let Err(e) = file.write_all(&(img.data[..])) {\n        println!(\"Failed to image data: {}\", e);\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\n#[allow(clippy::clippy::cast_possible_truncation)]\nfn hough(image: &ImageGray8, out_width: usize, out_height: usize) -> ImageGray8 {\n    let in_width = image.width;\n    let in_height = image.height;\n\n    // Allocate accumulation buffer\n    let out_height = ((out_height / 2) * 2) as usize;\n    let mut accum = ImageGray8 {\n        width: out_width,\n        height: out_height,\n        data: repeat(255).take(out_width * out_height).collect(),\n    };\n\n    // Transform extents\n    let rmax = (in_width as f64).hypot(in_height as f64);\n    let dr = rmax / (out_height / 2) as f64;\n    let dth = std::f64::consts::PI / out_width as f64;\n\n    // Process input image in raster order\n    for y in 0..in_height {\n        for x in 0..in_width {\n            let in_idx = y * in_width + x;\n            let col = image.data[in_idx];\n            if col == 255 {\n                continue;\n            }\n\n            // Project into rho,theta space\n            for jtx in 0..out_width {\n                let th = dth * (jtx as f64);\n                let r = (x as f64) * (th.cos()) + (y as f64) * (th.sin());\n\n                let iry = out_height as i64 / 2 - (r / (dr as f64) + 0.5).floor() as i64;\n                #[allow(clippy::clippy::cast_sign_loss)]\n                let out_idx = (jtx as i64 + iry * out_width as i64) as usize;\n                let col = accum.data[out_idx];\n                if col > 0 {\n                    accum.data[out_idx] = col - 1;\n                }\n            }\n        }\n    }\n    accum\n}\n\nfn main() -> io::Result<()> {\n    let image = load_pgm(\"resources/Pentagon.pgm\")?;\n    let accum = hough(&image, 460, 360);\n    save_pgm(&accum, \"hough.pgm\");\n    Ok(())\n}\n\n",
    "title": "Hough transform",
    "url": "http://rosettacode.org/wiki/Hough_transform"
  },
  {
    "local_code": "// Implement data structures for a Huffman encoding tree:\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\n\n/// Each `HNode` has a weight, representing the sum of the frequencies for all its\n/// children. It is either a leaf (containing a character), or an `HTree` (containing two children)\nstruct HNode {\n    weight: usize,\n    item: HItem,\n}\n\nenum HItem {\n    Tree(HTreeData),\n    Leaf(char),\n}\n\nstruct HTreeData {\n    left: Box<HNode>,\n    right: Box<HNode>,\n}\n\n/// Implementing comparison traits (`Ord` and all its dependencies) such that the `HNode` with the\n/// greatest weight is the smallest in a comparison. Basically reversing all the comparison\n/// operators.\nimpl Ord for HNode {\n    fn cmp(&self, other: &HNode) -> Ordering {\n        match self.weight.cmp(&other.weight) {\n            Less => Greater,\n            Equal => Equal,\n            Greater => Less,\n        }\n    }\n}\n\nimpl PartialOrd for HNode {\n    fn partial_cmp(&self, other: &HNode) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Eq for HNode {}\nimpl PartialEq for HNode {\n    fn eq(&self, other: &HNode) -> bool {\n        self.weight == other.weight\n    }\n}\n\n/// Takes a non-empty string (function will fail if string is empty) and computes the Huffman\n/// encoding tree for that string.\nfn huffman_tree(input: &str) -> HNode {\n    // 1. Loop through all the characters in that string, adding them to a HashMap\n    //    of character to frequency.\n    let mut freq = HashMap::new();\n    for ch in input.chars() {\n        match freq.entry(ch) {\n            Vacant(entry) => {\n                entry.insert(1);\n            }\n            Occupied(mut entry) => {\n                *entry.get_mut() += 1;\n            }\n        };\n    }\n\n    // 2. For each (character, frequency) pair in the HashMap, add a Leaf to a\n    //    PriorityQueue\n    let mut queue = BinaryHeap::<HNode>::new();\n    for (ch, freq) in &freq {\n        let new_node = HNode {\n            weight: *freq,\n            item: HItem::Leaf(*ch),\n        };\n        queue.push(new_node);\n    }\n\n    // 3. Pop two items with the least weight from the queue, combine them into\n    //    a tree as children. The parent node's weight is the sum of the\n    //    children's weight. Continue until one item is left on the queue, and\n    //    return that item.\n    while queue.len() > 1 {\n        let item1 = queue.pop().unwrap();\n        let item2 = queue.pop().unwrap();\n        let new_node = HNode {\n            weight: item1.weight + item2.weight,\n            item: HItem::Tree(HTreeData {\n                left: Box::new(item1),\n                right: Box::new(item2),\n            }),\n        };\n        queue.push(new_node);\n    }\n    queue.pop().unwrap()\n}\n\n/// Takes a Huffman Tree, traverse it and build a table with each character and\n/// its encoding string.\nfn build_encoding_table(tree: &HNode, table: &mut HashMap<char, String>, start_str: &str) {\n    match tree.item {\n        HItem::Tree(ref data) => {\n            build_encoding_table(&data.left, table, &format!(\"{}0\", start_str)[..]);\n            build_encoding_table(&data.right, table, &format!(\"{}1\", start_str)[..]);\n        }\n        HItem::Leaf(ch) => {\n            table.insert(ch, start_str.to_string());\n        }\n    };\n}\n\n/// Attempts to construct a tree, and test that the construction is successful\n///\n/// ```\n///     7\n///    ----\n///   /    \\\n///  4:'4'  3\n///       -----\n///      /     \\\n///     2:'2'  1:'1'\n/// ```\n#[test]\nfn test_tree_construction() {\n    let to_encode = \"4444221\";\n    let tree = huffman_tree(to_encode);\n    assert!(tree.weight == 7);\n    let children = match tree.item {\n        HItem::Tree(data) => data,\n        HItem::Leaf(_) => panic!(\"Tree Missing Children!\"),\n    };\n    let left = &children.left;\n    let right = &children.right;\n    assert!(right.weight == 4);\n    assert!(left.weight == 3);\n    let right_char = match right.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    assert!(right_char == '4');\n    let children = match left.item {\n        HItem::Tree(ref data) => data,\n        HItem::Leaf(_) => panic!(\"Tree Missing Children!\"),\n    };\n    let left = &children.left;\n    let right = &children.right;\n    let left_char = match left.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    let right_char = match right.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    match (left.weight, right.weight) {\n        (1, 2) => {\n            assert!(left_char == '1');\n            assert!(right_char == '2');\n        }\n        (2, 1) => {\n            assert!(left_char == '2');\n            assert!(right_char == '1');\n        }\n        (_, _) => {\n            panic!(\"Incorrect Leaf Nodes\");\n        }\n    };\n}\n\n/// Constructs a table:\n///\n/// ```\n///  '4': 1\n///  '2': 01 OR 00\n///  '1': 00    01\n///  ```\n///\n/// And tests that the table was correctly constructed\n#[test]\nfn test_table_construction() {\n    let to_encode = \"4444221\";\n    let tree = huffman_tree(to_encode);\n    let mut table = HashMap::<char, String>::new();\n    build_encoding_table(&tree, &mut table, \"\");\n    let one = &*table[&'1'];\n    let two = &*table[&'2'];\n    let four = &*table[&'4'];\n    assert!(four == \"1\");\n    assert!((one == \"01\" && two == \"00\") || (one == \"00\" && two == \"01\"));\n}\n\nfn main() {\n    let to_encode = \"this is an example for huffman encoding\";\n    let tree = huffman_tree(to_encode);\n    let mut table = HashMap::<char, String>::new();\n    build_encoding_table(&tree, &mut table, \"\");\n\n    for (ch, encoding) in &table {\n        println!(\"{}: {}\", *ch, encoding);\n    }\n}\n",
    "path": "tasks/huffman-coding",
    "remote_code": "\nuse std::collections::BTreeMap;\nuse std::collections::binary_heap::BinaryHeap;\n\n#[derive(Debug, Eq, PartialEq)]\nenum NodeKind {\n    Internal(Box<Node>, Box<Node>),\n    Leaf(char),\n}\n\n#[derive(Debug, Eq, PartialEq)]\nstruct Node {\n    frequency: usize,\n    kind: NodeKind,\n}\n\nimpl Ord for Node {\n    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n        rhs.frequency.cmp(&self.frequency)\n    }\n}\n\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(&rhs))\n    }\n}\n\ntype HuffmanCodeMap = BTreeMap<char, Vec<u8>>;\n\nfn main() {\n    let text = \"this is an example for huffman encoding\";\n\n    let mut frequencies = BTreeMap::new();\n    for ch in text.chars() {\n        *frequencies.entry(ch).or_insert(0) += 1;\n    }\n\n    let mut prioritized_frequencies = BinaryHeap::new();\n    for counted_char in frequencies {\n        prioritized_frequencies.push(Node {\n            frequency: counted_char.1,\n            kind: NodeKind::Leaf(counted_char.0),\n        });\n    }\n\n    while prioritized_frequencies.len() > 1 {\n        let left_child = prioritized_frequencies.pop().unwrap();\n        let right_child = prioritized_frequencies.pop().unwrap();\n        prioritized_frequencies.push(Node {\n            frequency: right_child.frequency + left_child.frequency,\n            kind: NodeKind::Internal(Box::new(left_child), Box::new(right_child)),\n        });\n    }\n\n    let mut codes = HuffmanCodeMap::new();\n    generate_codes(\n        prioritized_frequencies.peek().unwrap(),\n        vec![0u8; 0],\n        &mut codes,\n    );\n\n    for item in codes {\n        print!(\"{}: \", item.0);\n        for bit in item.1 {\n            print!(\"{}\", bit);\n        }\n        println!();\n    }\n}\n\nfn generate_codes(node: &Node, prefix: Vec<u8>, out_codes: &mut HuffmanCodeMap) {\n    match node.kind {\n        NodeKind::Internal(ref left_child, ref right_child) => {\n            let mut left_prefix = prefix.clone();\n            left_prefix.push(0);\n            generate_codes(&left_child, left_prefix, out_codes);\n\n            let mut right_prefix = prefix;\n            right_prefix.push(1);\n            generate_codes(&right_child, right_prefix, out_codes);\n        }\n        NodeKind::Leaf(ch) => {\n            out_codes.insert(ch, prefix);\n        }\n    }\n}\n",
    "title": "Huffman coding",
    "url": "http://rosettacode.org/wiki/Huffman_coding"
  },
  {
    "local_code": "use itertools::Itertools;\n\nstruct HumbleNumbers {\n    seq: Vec<u64>,\n    current_h: u64,\n    index: usize,\n    next2: u64,\n    next3: u64,\n    next5: u64,\n    next7: u64,\n    last2: usize,\n    last3: usize,\n    last5: usize,\n    last7: usize,\n}\n\nimpl HumbleNumbers {\n    fn new() -> HumbleNumbers {\n        HumbleNumbers {\n            seq: vec![0; 50],\n            current_h: 1,\n            index: 0,\n            next2: 2,\n            next3: 3,\n            next5: 5,\n            next7: 7,\n            last2: 0,\n            last3: 0,\n            last5: 0,\n            last7: 0,\n        }\n    }\n}\n\nimpl Iterator for HumbleNumbers {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        // Direct generation, with u64 it's good up to ~19 digits, ~81000 humble numbers\n\n        // if reached the max # of numbers, increase the vector\n        if self.index >= self.seq.len() {\n            self.seq.resize(self.seq.len() * 2, 0);\n        }\n\n        // this wil be returned\n        self.seq[self.index] = self.current_h;\n        self.index += 1;\n\n        if self.current_h == self.next2 {\n            self.last2 += 1;\n            // check for overflow\n            self.next2 = match self.seq[self.last2].checked_mul(2) {\n                Some(n) => n,\n                _ => return None,\n            };\n        }\n\n        if self.current_h == self.next3 {\n            self.last3 += 1;\n            self.next3 = self.seq[self.last3] * 3;\n        }\n\n        if self.current_h == self.next5 {\n            self.last5 += 1;\n            self.next5 = self.seq[self.last5] * 5;\n        }\n\n        if self.current_h == self.next7 {\n            self.last7 += 1;\n            self.next7 = self.seq[self.last7] * 7;\n        }\n\n        // store next number\n        self.current_h = *vec![self.next2, self.next3, self.next5, self.next7]\n            .iter()\n            .min()\n            .unwrap();\n\n        // return latest number\n        Some(self.seq[self.index - 1])\n    }\n}\n\nfn main() {\n    let seq_iter = HumbleNumbers::new().take(50);\n    println!(\"First 50 Humble number\");\n    for (i, x) in seq_iter.enumerate() {\n        if i % 10 == 9 {\n            println!(\"{:>3}\", x);\n        } else {\n            print!(\"{:>3}, \", x);\n        }\n    }\n\n    let seq_iter = HumbleNumbers::new();\n    println!(\"\\nOf the first ~81.000 humble numbers\");\n    for (key, group) in &seq_iter.into_iter().group_by(|e| (*e).to_string().len()) {\n        if key < 20 {\n            println!(\"{:>5} have  {:>3} digits\", group.count(), key);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_humble() {\n        let seq_iter = HumbleNumbers::new();\n        let result = seq_iter.skip(10).take(10).collect::<Vec<_>>();\n        assert_eq!(result, vec![12, 14, 15, 16, 18, 20, 21, 24, 25, 27])\n    }\n}\n",
    "path": "tasks/humble-numbers",
    "remote_code": null,
    "title": "Humble numbers",
    "url": "http://rosettacode.org/wiki/Humble_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hunt the Wumpus",
    "url": "http://rosettacode.org/wiki/Hunt_the_Wumpus"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nenum MatchState {\n    /// Nothing of interest seen so far\n    Nothing,\n\n    /// Last seen a 'c'\n    C,\n\n    /// Last seen a 'c' followed by an 'e'\n    Ce,\n\n    /// Last seen a 'c' followed by an 'i'\n    Ci,\n\n    /// Last seen an 'e' not preceded by a 'c'\n    E,\n\n    /// Last seen an 'i' not preceded by a 'c'\n    I,\n}\n\nstruct Occurrences {\n    cie: u32,\n    cei: u32,\n    ie: u32,\n    ei: u32,\n}\n#[allow(clippy::similar_names)]\nfn count_occurrences(data: &str) -> Occurrences {\n    // The counting process is implemented by a state machine. The state variable\n    // tracks what pattern prefix was recognized so far (details at MatchState).\n    // Each time a full pattern is matched the corresponding saw_* variable is set\n    // to true to record its presence for the current word (They are not added\n    // directly to result to ensure that words having multiple occurrences of one\n    // pattern are only counted once.).\n    // At each word boundary add to result what was recorded and clear all state\n    // for next word.\n    let mut result = Occurrences {\n        cie: 0,\n        cei: 0,\n        ie: 0,\n        ei: 0,\n    };\n    let mut saw_cie = false;\n    let mut saw_cei = false;\n    let mut saw_ie = false;\n    let mut saw_ei = false;\n    let mut state = MatchState::Nothing;\n    for c in data.chars() {\n        state = match (state, c.to_lowercase().next().unwrap()) {\n            (_, '\\n') | (_, '\\r') => {\n                if saw_cie {\n                    result.cie += 1;\n                    saw_cie = false;\n                }\n                if saw_cei {\n                    result.cei += 1;\n                    saw_cei = false;\n                }\n                if saw_ie {\n                    result.ie += 1;\n                    saw_ie = false;\n                }\n                if saw_ei {\n                    result.ei += 1;\n                    saw_ei = false;\n                }\n                MatchState::Nothing\n            }\n            (_, 'c') => MatchState::C,\n            (MatchState::C, 'i') => MatchState::Ci,\n            (MatchState::Ce, 'i') => {\n                saw_cei = true;\n                MatchState::Nothing\n            }\n            (MatchState::E, 'i') => {\n                saw_ei = true;\n                MatchState::Nothing\n            }\n            (_, 'i') => MatchState::I,\n            (MatchState::C, 'e') => MatchState::Ce,\n            (MatchState::Ci, 'e') => {\n                saw_cie = true;\n                MatchState::Nothing\n            }\n            (MatchState::I, 'e') => {\n                saw_ie = true;\n                MatchState::Nothing\n            }\n            (_, 'e') => MatchState::E,\n            _ => MatchState::Nothing,\n        };\n    }\n    result\n}\n\nfn main() {\n    let path = Path::new(\"resources/unixdict.txt\");\n    let mut file = File::open(&path).unwrap();\n    let mut data = String::new();\n    file.read_to_string(&mut data).unwrap();\n    let occ = count_occurrences(&data);\n    println!(\n        \"I before E when not preceded by C is {} (ie: {}, cie: {})\",\n        if occ.ie > 2 * occ.cie {\n            \"plausible\"\n        } else {\n            \"implausible\"\n        },\n        occ.ie,\n        occ.cie\n    );\n    println!(\n        \"E before I when preceded by C is {} (cei: {}, ei: {})\",\n        if occ.cei > 2 * occ.ei {\n            \"plausible\"\n        } else {\n            \"implausible\"\n        },\n        occ.cei,\n        occ.ei\n    );\n}\n\n#[test]\nfn basic_test() {\n    let occ1 = count_occurrences(\"ceiling\\nclient\\nleisure\\n\");\n    assert_eq!(occ1.cie, 0);\n    assert_eq!(occ1.cei, 1);\n    assert_eq!(occ1.ie, 1);\n    assert_eq!(occ1.ei, 1);\n}\n",
    "path": "tasks/i-before-e-except-after-c",
    "remote_code": "use std::default::Default;\nuse std::ops::AddAssign;\n\nuse itertools::Itertools;\nuse reqwest::get;\n\n#[derive(Default, Debug)]\nstruct Feature<T> {\n    pub cie: T,\n    pub xie: T,\n    pub cei: T,\n    pub xei: T,\n}\n\nimpl AddAssign<Feature<bool>> for Feature<u64> {\n    fn add_assign(&mut self, rhs: Feature<bool>) {\n        self.cei += rhs.cei as u64;\n        self.xei += rhs.xei as u64;\n        self.cie += rhs.cie as u64;\n        self.xie += rhs.xie as u64;\n    }\n}\n\nfn check_feature(word: &str) -> Feature<bool> {\n    let mut feature: Feature<bool> = Default::default();\n\n    for window in word.chars().tuple_windows::<(char, char, char)>() {\n        match window {\n            ('c', 'e', 'i') => { feature.cei = true }\n            ('c', 'i', 'e') => { feature.cie = true }\n            (not_c, 'e', 'i') if not_c != 'c' => (feature.xei = true),\n            (not_c, 'i', 'e') if not_c != 'c' => (feature.xie = true),\n            _ => {}\n        }\n    }\n\n    feature\n}\n\n\nfn maybe_is_feature_plausible(feature_count: u64, opposing_count: u64) -> Option<bool> {\n    if feature_count > 2 * opposing_count { Some(true) } else if opposing_count > 2 * feature_count { Some(false) } else { None }\n}\n\nfn print_feature_plausibility(feature_plausibility: Option<bool>, feature_name: &str) {\n    let plausible_msg =\n        match feature_plausibility {\n            None => \" is implausible\",\n            Some(true) => \"is plausible\",\n            Some(false) => \"is definitely implausible\",\n        };\n\n    println!(\"{} {}\", feature_name, plausible_msg)\n}\n\nfn main() {\n    let mut res = get(\" http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\").unwrap();\n    let texts = res.text().unwrap();\n\n    let mut feature_count: Feature<u64> = Default::default();\n    for word in texts.lines() {\n        let feature = check_feature(word);\n        feature_count += feature;\n    }\n\n    println!(\"Counting {:#?}\", feature_count);\n\n    let xie_plausibility =\n        maybe_is_feature_plausible(feature_count.xie, feature_count.cie);\n    let cei_plausibility =\n        maybe_is_feature_plausible(feature_count.cei, feature_count.xei);\n\n    print_feature_plausibility(xie_plausibility, \"I before E when not preceded by C\");\n    print_feature_plausibility(cei_plausibility, \"E before I when preceded by C\");\n    println!(\"The rule in general is {}\",\n             if xie_plausibility.unwrap_or(false) && cei_plausibility.unwrap_or(false)\n             { \"Plausible\" } else { \"Implausible\" }\n    );\n}\n",
    "title": "I before E except after C",
    "url": "http://rosettacode.org/wiki/I_before_E_except_after_C"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\n\nfn main() {\n    if is_valid(\"GB82 WEST 1234 5698 7654 32\") {\n        println!(\"IBAN correctly validated!\");\n    } else {\n        println!(\"Invalid IBAN!\");\n    }\n}\n\n/// Returns true if the IBAN is valid\n/// See [Validating the IBAN][iban].\n///\n/// [iban]: http://en.wikipedia.org/wiki/International_Bank_Account_Number#Validating_the_IBAN\nfn is_valid(iban: &str) -> bool {\n    // Discard whitespace\n    let mut iban_chars: Vec<char> = iban.chars().filter(|c| !c.is_whitespace()).collect();\n\n    if iban_chars.len() < 2 {\n        return false;\n    }\n\n    // Check length of the IBAN\n    match country_length(&iban[..2]) {\n        Some(l) if l == iban_chars.len() => {}\n        _ => return false,\n    };\n\n    // Rearrange (first four characters go to the back)\n    for _ in 0..4 {\n        let front = iban_chars.remove(0);\n        iban_chars.push(front);\n    }\n\n    // Expand letters to digits\n    let iban_int = parse_digits(&iban_chars);\n\n    // Check if the remainder is one\n    match iban_int {\n        Some(x) => x % 97.to_bigint().unwrap() == 1.to_bigint().unwrap(),\n        None => false,\n    }\n}\n\n/// Returns a `BigInt` made from the digits and letters of the IBAN\nfn parse_digits(chars: &[char]) -> Option<BigInt> {\n    let mut vec: Vec<u8> = Vec::with_capacity(chars.len() + 10);\n\n    // Copy the digits to the vector and expand the letters to digits\n    for &c in chars {\n        match c.to_digit(36) {\n            Some(d) => vec.extend(d.to_string().bytes()),\n            None => return None,\n        }\n    }\n    // Since it was built from digits we know the vec is valid utf8, so we can just unwrap().\n    let as_str = String::from_utf8(vec).unwrap();\n    as_str.parse::<BigInt>().ok()\n}\n\nfn country_length(country_code: &str) -> Option<usize> {\n    let countries = [\n        (\"AL\", 28),\n        (\"AD\", 24),\n        (\"AT\", 20),\n        (\"AZ\", 28),\n        (\"BE\", 16),\n        (\"BH\", 22),\n        (\"BA\", 20),\n        (\"BR\", 29),\n        (\"BG\", 22),\n        (\"CR\", 21),\n        (\"HR\", 21),\n        (\"CY\", 28),\n        (\"CZ\", 24),\n        (\"DK\", 18),\n        (\"DO\", 28),\n        (\"EE\", 20),\n        (\"FO\", 18),\n        (\"FI\", 18),\n        (\"FR\", 27),\n        (\"GE\", 22),\n        (\"DE\", 22),\n        (\"GI\", 23),\n        (\"GR\", 27),\n        (\"GL\", 18),\n        (\"GT\", 28),\n        (\"HU\", 28),\n        (\"IS\", 26),\n        (\"IE\", 22),\n        (\"IL\", 23),\n        (\"IT\", 27),\n        (\"KZ\", 20),\n        (\"KW\", 30),\n        (\"LV\", 21),\n        (\"LB\", 28),\n        (\"LI\", 21),\n        (\"LT\", 20),\n        (\"LU\", 20),\n        (\"MK\", 19),\n        (\"MT\", 31),\n        (\"MR\", 27),\n        (\"MU\", 30),\n        (\"MC\", 27),\n        (\"MD\", 24),\n        (\"ME\", 22),\n        (\"NL\", 18),\n        (\"NO\", 15),\n        (\"PK\", 24),\n        (\"PS\", 29),\n        (\"PL\", 28),\n        (\"PT\", 25),\n        (\"RO\", 24),\n        (\"SM\", 27),\n        (\"SA\", 24),\n        (\"RS\", 22),\n        (\"SK\", 24),\n        (\"SI\", 19),\n        (\"ES\", 24),\n        (\"SE\", 24),\n        (\"CH\", 21),\n        (\"TN\", 24),\n        (\"TR\", 26),\n        (\"AE\", 23),\n        (\"GB\", 22),\n        (\"VG\", 24),\n    ];\n\n    countries\n        .iter()\n        .find(|&&(country, _)| country == country_code)\n        .map(|&(_, length)| length)\n}\n\n#[test]\nfn test_valid() {\n    assert!(is_valid(\"GB82 WEST 1234 5698 7654 32\"));\n    assert!(is_valid(\"BE18 0016 5492 3565\"));\n}\n\n#[test]\nfn test_wrong() {\n    assert!(!is_valid(\"ASDA FJAS DMAF BKDB AKGS DH\"));\n    assert!(!is_valid(\"XX82 WEST 1234 5698 7654 32\"));\n    assert!(!is_valid(\"BE18 0016 5492 3566\"));\n    assert!(!is_valid(\"BE18 0016 5492 3565 6\"));\n    assert!(!is_valid(\"BE18 0016 5492 356\"));\n    assert!(!is_valid(\"\"));\n}\n",
    "path": "tasks/iban",
    "remote_code": "\nfn main() {\n    for iban in [\n        \"\",\n        \"x\",\n        \"QQ82\",\n        \"QQ82W\",\n        \"GB82 TEST 1234 5698 7654 322\",\n        \"gb82 WEST 1234 5698 7654 32\",\n        \"GB82 WEST 1234 5698 7654 32\",\n        \"GB82 TEST 1234 5698 7654 32\",\n        \"GB81 WEST 1234 5698 7654 32\",\n        \"SA03 8000 0000 6080 1016 7519\",\n        \"CH93 0076 2011 6238 5295 7\",\n    ].iter()\n    {\n        println!(\n            \"'{}' is {}valid\",\n            iban,\n            if validate_iban(iban) { \"\" } else { \"NOT \" }\n        );\n    }\n}\n\nfn validate_iban(iban: &str) -> bool {\n    let iso_len = [\n        (\"AL\", 28), (\"AD\", 24), (\"AT\", 20), (\"AZ\", 28), (\"BE\", 16), (\"BH\", 22),\n        (\"BA\", 20), (\"BR\", 29), (\"BG\", 22), (\"HR\", 21), (\"CY\", 28), (\"CZ\", 24),\n        (\"DK\", 18), (\"DO\", 28), (\"EE\", 20), (\"FO\", 18), (\"FI\", 18), (\"FR\", 27),\n        (\"GE\", 22), (\"DE\", 22), (\"GI\", 23), (\"GL\", 18), (\"GT\", 28), (\"HU\", 28),\n        (\"IS\", 26), (\"IE\", 22), (\"IL\", 23), (\"IT\", 27), (\"KZ\", 20), (\"KW\", 30),\n        (\"LV\", 21), (\"LB\", 28), (\"LI\", 21), (\"LT\", 20), (\"LU\", 20), (\"MK\", 19),\n        (\"MT\", 31), (\"MR\", 27), (\"MU\", 30), (\"MC\", 27), (\"MD\", 24), (\"ME\", 22),\n        (\"NL\", 18), (\"NO\", 15), (\"PK\", 24), (\"PS\", 29), (\"PL\", 28), (\"PT\", 25),\n        (\"RO\", 24), (\"SM\", 27), (\"SA\", 24), (\"RS\", 22), (\"SK\", 24), (\"SI\", 19),\n        (\"ES\", 24), (\"SE\", 24), (\"CH\", 21), (\"TN\", 24), (\"TR\", 26), (\"AE\", 23),\n        (\"GB\", 22), (\"VG\", 24), (\"GR\", 27), (\"CR\", 21),\n    ];\n    let trimmed_iban = iban.chars()\n        .filter(|&ch| ch != ' ')\n        .collect::<String>()\n        .to_uppercase();\n    if trimmed_iban.len() < 4 {\n        return false;\n    }\n    let prefix = &trimmed_iban[0..2];\n    if let Some(pair) = iso_len.iter().find(|&&(code, _)| code == prefix) {\n        if pair.1 != trimmed_iban.len() {\n            return false;\n        }\n    } else {\n        return false;\n    }\n    let reversed_iban = format!(\"{}{}\", &trimmed_iban[4..], &trimmed_iban[0..4]);\n    let mut expanded_iban = String::new();\n    for ch in reversed_iban.chars() {\n        expanded_iban.push_str(&if ch.is_numeric() {\n            format!(\"{}\", ch)\n        } else {\n            format!(\"{}\", ch as u8 - 'A' as u8 + 10u8)\n        });\n    }\n    expanded_iban.bytes().fold(0, |acc, ch| {\n        (acc * 10 + ch as u32 - '0' as u32) % 97\n    }) == 1\n}\n",
    "title": "IBAN",
    "url": "http://rosettacode.org/wiki/IBAN"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let isbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"];\n    isbns.iter().for_each(|isbn| println!(\"{}: {}\", isbn, check_isbn(isbn)));\n}\n\nfn check_isbn(isbn: &str) -> bool {\n    if isbn.chars().filter(|c| c.is_digit(10)).count() != 13 {\n            return false;\n    } \n    let checksum = isbn.chars().filter_map(|c| c.to_digit(10))\n        .zip([1, 3].iter().cycle())\n        .fold(0, |acc, (val, fac)| acc + val * fac);\n    checksum % 10 == 0\n}\n",
    "title": "ISBN13 check digit",
    "url": "http://rosettacode.org/wiki/ISBN13_check_digit"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate num;\nstruct Matrix<T> {\n    data: Vec<T>,\n    size: usize,\n}\n\nimpl<T> Matrix<T>\nwhere\n    T: num::Num + Clone + Copy,\n{\n    fn new(size: usize) -> Self {\n        Self {\n            data: vec![T::zero(); size * size],\n            size: size,\n        }\n    }\n    fn get(&mut self, x: usize, y: usize) -> T {\n        self.data[x + self.size * y]\n    }\n    fn identity(&mut self) {\n        for (i, item) in self.data.iter_mut().enumerate() {\n            *item = if i % (self.size + 1) == 0 {\n                T::one()\n            } else {\n                T::zero()\n            }\n        }\n    }\n}\n\nfn main() {\n    let size = std::env::args().nth(1).unwrap().parse().unwrap();\n    let mut matrix = Matrix::<i32>::new(size);\n    matrix.identity();\n    for y in 0..size {\n        for x in 0..size {\n            print!(\"{} \", matrix.get(x, y));\n        }\n        println!();\n    }\n}\n",
    "title": "Identity matrix",
    "url": "http://rosettacode.org/wiki/Identity_matrix"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Idiomatically determine all the characters that can be used for symbols",
    "url": "http://rosettacode.org/wiki/Idiomatically_determine_all_the_characters_that_can_be_used_for_symbols"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\n        \"Lowercase letters: {}\",\n        (b'a'..=b'z').map(|c| c as char).collect::<String>()\n    );\n    println!(\n        \"Uppercase letters: {}\",\n        (b'A'..=b'Z').map(|c| c as char).collect::<String>()\n    );\n}\n",
    "title": "Idiomatically determine all the lowercase and uppercase letters",
    "url": "http://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Image convolution",
    "url": "http://rosettacode.org/wiki/Image_convolution"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Image noise",
    "url": "http://rosettacode.org/wiki/Image_noise"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Imaginary base numbers",
    "url": "http://rosettacode.org/wiki/Imaginary_base_numbers"
  },
  {
    "local_code": "println!(\"Hello from included file!\")\npub fn hello_world() {\n    println!(\"Hello world!\");\n}\n// The compiler will import either `hello_world.rs` or `hello_world/mod.rs` (if the first one\n// doesn't exist).\nmod hello_world;\n\n// You can import public functions, structs, etc. from a module with the `use` statement.\nuse hello_world::hello_world;\n\n// Additionally, third-party libraries (called `crates` in Rust) can be declared thusly:\nextern crate url;\n\nuse url::Url;\n\nfn main() {\n    // Call an imported function.\n    hello_world();\n\n    // Use a struct included from an external crate.\n    println!(\"{:?}\", Url::parse(\"http://rosettacode.org\").unwrap());\n\n    // Though uncommon, it is also possible to include source directly from files with the\n    // `include!` macro.\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/resources/include.rs\"));\n}\n",
    "path": "tasks/include-a-file",
    "remote_code": "mod test;\n\nfn main() {\n    test::some_function();\n}",
    "title": "Include a file",
    "url": "http://rosettacode.org/wiki/Include_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// num-format = \"0.4\"\n\n// Returns the sum of the digits of n given the\n// sum of the digits of n - 1\nfn digit_sum(mut n: u64, mut sum: u64) -> u64 {\n    sum += 1;\n    while n > 0 && n % 10 == 0 {\n        sum -= 9;\n        n /= 10;\n    }\n    sum\n}\n\nfn divisible(n: u64, d: u64) -> bool {\n    if (d & 1) == 0 && (n & 1) == 1 {\n        return false;\n    }\n    n % d == 0\n}\n\nfn main() {\n    use num_format::{Locale, ToFormattedString};\n    let mut previous = 1;\n    let mut gap = 0;\n    let mut sum = 0;\n    let mut niven_index = 0;\n    let mut gap_index = 1;\n    let mut niven = 1;\n    println!(\"Gap index  Gap    Niven index    Niven number\");\n    while gap_index <= 32 {\n        sum = digit_sum(niven, sum);\n        if divisible(niven, sum) {\n            if niven > previous + gap {\n                gap = niven - previous;\n                println!(\n                    \"{:9} {:4} {:>14} {:>15}\",\n                    gap_index,\n                    gap,\n                    niven_index.to_formatted_string(&Locale::en),\n                    previous.to_formatted_string(&Locale::en)\n                );\n                gap_index += 1;\n            }\n            previous = niven;\n            niven_index += 1;\n        }\n        niven += 1;\n    }\n}",
    "title": "Increasing gaps between consecutive Niven numbers",
    "url": "http://rosettacode.org/wiki/Increasing_gaps_between_consecutive_Niven_numbers"
  },
  {
    "local_code": "use std::num::ParseIntError;\n\nfn increment(input: &str) -> Result<String, ParseIntError> {\n    input.parse::<i64>().map(|num| (num + 1).to_string())\n}\n\nfn main() {\n    let s = \"-1\";\n    let s2 = increment(s).unwrap();\n    println!(\"{:?}\", s2);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::increment;\n\n    #[test]\n    fn numeric() {\n        assert_eq!(increment(\"47\").unwrap(), \"48\".to_owned());\n    }\n\n    #[test]\n    fn not_numeric() {\n        assert!(increment(\"abc\").is_err());\n    }\n}\n",
    "path": "tasks/increment-a-numerical-string",
    "remote_code": "fn next_string(input: &str) -> String {\n    (input.parse::<i64>().unwrap() + 1).to_string()\n}\n\nfn main() {\n    let s = \"-1\";\n    let s2 = next_string(s);\n    println!(\"{:?}\", s2);\n}",
    "title": "Increment a numerical string",
    "url": "http://rosettacode.org/wiki/Increment_a_numerical_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Index finite lists of positive integers",
    "url": "http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers"
  },
  {
    "local_code": "fn main() {\n    let inf = ::std::f32::INFINITY;\n    println!(\"{}\", inf);\n}\n",
    "path": "tasks/infinity",
    "remote_code": "fn main() {\n    let inf = f32::INFINITY;\n    println!(\"{}\", inf);\n}",
    "title": "Infinity",
    "url": "http://rosettacode.org/wiki/Infinity"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "trait Camera {}\ntrait MobilePhone {}\ntrait CameraPhone: Camera + MobilePhone {}",
    "title": "Inheritance/Multiple",
    "url": "http://rosettacode.org/wiki/Inheritance/Multiple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "trait Animal {}\ntrait Cat: Animal {}\ntrait Dog: Animal {}\ntrait Lab: Dog {}\ntrait Collie: Dog {}",
    "title": "Inheritance/Single",
    "url": "http://rosettacode.org/wiki/Inheritance/Single"
  },
  {
    "local_code": "use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    for line in stdin.lock().lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n",
    "path": "tasks/input-loop",
    "remote_code": " use std::io::{self, BufReader, Read, BufRead};\nuse std::fs::File;\n\nfn main() {\n    print_by_line(io::stdin())\n        .expect(\"Could not read from stdin\");\n\n    File::open(\"/etc/fstab\")\n        .and_then(print_by_line)\n        .expect(\"Could not read from file\");\n}\n\nfn print_by_line<T: Read>(reader: T) -> io::Result<()> {\n    let buffer = BufReader::new(reader);\n    for line in buffer.lines() {\n        println!(\"{}\", line?)\n    }\n    Ok(())\n}",
    "title": "Input loop",
    "url": "http://rosettacode.org/wiki/Input_loop"
  },
  {
    "local_code": "#![allow(clippy::comparison_chain)]\n\nuse std::io::{self, BufRead};\n\nfn main() {\n    let reader = io::stdin();\n    let lines = reader.lock().lines().take(2);\n    let nums = lines\n        .map(|string| string.unwrap().trim().parse().unwrap())\n        .collect::<Vec<i32>>();\n    let a = nums[0];\n    let b = nums[1];\n    if a < b {\n        println!(\"{} is less than {}\", a, b)\n    } else if a == b {\n        println!(\"{} equals {}\", a, b)\n    } else if a > b {\n        println!(\"{} is greater than {}\", a, b)\n    };\n}\n",
    "path": "tasks/integer-comparison",
    "remote_code": "use std::io::{self, BufRead};\n\nfn main() {\n    let mut reader = io::stdin();\n    let mut buffer = String::new();\n    let mut lines = reader.lock().lines().take(2);\n    let nums: Vec<i32>= lines.map(|string|\n        string.unwrap().trim().parse().unwrap()\n        ).collect();\n    let a: i32 = nums[0];\n    let b: i32 = nums[1];\n    if a < b {\n        println!(\"{} is less than {}\" , a , b)\n    } else if a == b {\n        println!(\"{} equals {}\" , a , b)\n    } else if a > b {\n        println!(\"{} is greater than {}\" , a , b)\n    };\n}",
    "title": "Integer comparison",
    "url": "http://rosettacode.org/wiki/Integer_comparison"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n    // The following will panic!\n    let i32_1 : i32 = -(-2_147_483_647 - 1);\n    let i32_2 : i32 = 2_000_000_000 + 2_000_000_000;\n    let i32_3 : i32 = -2_147_483_647 - 2_147_483_647;\n    let i32_4 : i32 = 46341 * 46341;\n    let i32_5 : i32 = (-2_147_483_647 - 1) / -1;\n\n    // These will panic! also\n    let i64_1 : i64 = -(-9_223_372_036_854_775_807 - 1);\n    let i64_2 : i64 = 5_000_000_000_000_000_000 + 5_000_000_000_000_000_000;\n    let i64_3 : i64 = -9_223_372_036_854_775_807 - 9_223_372_036_854_775_807;\n    let i64_4 : i64 = 3_037_000_500 * 3_037_000_500;\n    let i64_5 : i64 = (-9_223_372_036_854_775_807 - 1) / -1;\n",
    "title": "Integer overflow",
    "url": "http://rosettacode.org/wiki/Integer_overflow"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigUint, One};\n\nfn main() {\n    let one: BigUint = One::one();\n    let mut i: BigUint = One::one();\n\n    loop {\n        println!(\"{}\", i);\n        i = &i + &one;\n    }\n}\n",
    "path": "tasks/integer-sequence",
    "remote_code": "fn main() {\n    for i in 0.. {\n        println!(\"{}\", i);\n    }\n}",
    "title": "Integer sequence",
    "url": "http://rosettacode.org/wiki/Integer_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#[macro_use]\nextern crate clap;\nuse clap::App;\nfn main() {\n    let yaml = load_yaml!(\"cli.yaml\");\n    let matches = App::from(yaml).get_matches();\n\n    let str1 = matches.value_of(\"STRING1\").unwrap();\n    let str2 = matches.value_of(\"STRING2\").unwrap();\n    let str3 = matches.value_of(\"SEPARATOR\").unwrap();\n\n    println!(\"{:?}\", f(&str1, &str2, &str3));\n}\n\nfn f<'a>(s1: &'a str, s2: &'a str, sep :&'a str) -> String{\n    [s1,sep,sep,s2].iter().map(|x| *x).collect()\n}",
    "title": "Interactive programming (repl)",
    "url": "http://rosettacode.org/wiki/Interactive_programming_(repl)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Intersecting number wheels",
    "url": "http://rosettacode.org/wiki/Intersecting_number_wheels"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Introspection",
    "url": "http://rosettacode.org/wiki/Introspection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Part 1: Inverted index structure\n\nuse std::{\n    borrow::Borrow,\n    collections::{BTreeMap, BTreeSet},\n};\n\n#[derive(Debug, Default)]\npub struct InvertedIndex<T> {\n    indexed: BTreeMap<String, BTreeSet<usize>>,\n    sources: Vec<T>,\n}\n\nimpl<T> InvertedIndex<T> {\n    pub fn add<I, V>(&mut self, source: T, tokens: I)\n    where\n        I: IntoIterator<Item = V>,\n        V: Into<String>,\n    {\n        let source_id = self.sources.len();\n        self.sources.push(source);\n        for token in tokens {\n            self.indexed\n                .entry(token.into())\n                .or_insert_with(BTreeSet::new)\n                .insert(source_id);\n        }\n    }\n\n    pub fn search<'a, I, K>(&self, tokens: I) -> impl Iterator<Item = &T>\n    where\n        String: Borrow<K>,\n        K: Ord + ?Sized + 'a,\n        I: IntoIterator<Item = &'a K>,\n    {\n        let mut tokens = tokens.into_iter();\n\n        tokens\n            .next()\n            .and_then(|token| self.indexed.get(token).cloned())\n            .and_then(|first| {\n                tokens.try_fold(first, |found, token| {\n                    self.indexed\n                        .get(token)\n                        .map(|sources| {\n                            found\n                                .intersection(sources)\n                                .cloned()\n                                .collect::<BTreeSet<_>>()\n                        })\n                        .filter(|update| !update.is_empty())\n                })\n            })\n            .unwrap_or_else(BTreeSet::new)\n            .into_iter()\n            .map(move |source| &self.sources[source])\n    }\n\n    pub fn tokens(&self) -> impl Iterator<Item = &str> {\n        self.indexed.keys().map(|it| it.as_str())\n    }\n\n    pub fn sources(&self) -> &[T] {\n        &self.sources\n    }\n}\n\n// Part 2: File walking and processing\n\nuse std::{\n    ffi::OsString,\n    fmt::{Debug, Display},\n    fs::{read_dir, DirEntry, File, ReadDir},\n    io::{self, stdin, Read},\n    path::{Path, PathBuf},\n};\n\n#[derive(Debug)]\npub struct Files {\n    dirs: Vec<ReadDir>,\n}\n\nimpl Files {\n    pub fn walk<P: AsRef<Path>>(path: P) -> io::Result<Self> {\n        Ok(Files {\n            dirs: vec![read_dir(path)?],\n        })\n    }\n}\n\nimpl Iterator for Files {\n    type Item = DirEntry;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'outer: while let Some(mut current) = self.dirs.pop() {\n            while let Some(entry) = current.next() {\n                if let Ok(entry) = entry {\n                    let path = entry.path();\n                    if !path.is_dir() {\n                        self.dirs.push(current);\n                        return Some(entry);\n                    } else if let Ok(dir) = read_dir(path) {\n                        self.dirs.push(current);\n                        self.dirs.push(dir);\n                        continue 'outer;\n                    }\n                }\n            }\n        }\n\n        None // No directory left\n    }\n}\n\nfn tokenize<'a>(input: &'a str) -> impl Iterator<Item = String> + 'a {\n    input\n        .split(|c: char| !c.is_alphanumeric())\n        .filter(|token| !token.is_empty())\n        .map(|token| token.to_lowercase())\n}\n\nfn tokenize_file<P: AsRef<Path>>(path: P) -> io::Result<BTreeSet<String>> {\n    let mut buffer = Vec::new();\n    File::open(path)?.read_to_end(&mut buffer)?;\n    let text = String::from_utf8_lossy(&buffer);\n    Ok(tokenize(&text).collect::<BTreeSet<_>>())\n}\n\nfn tokenize_query(input: &str) -> Vec<String> {\n    let result = tokenize(input).collect::<BTreeSet<_>>();\n    // Make a vector sorted by length, so that longer tokens are processed first.\n    // This heuristics should narrow the resulting set faster.\n    let mut result = result.into_iter().collect::<Vec<_>>();\n    result.sort_by_key(|item| usize::MAX - item.len());\n    result\n}\n\n// Part 3: Interactive application\n\nfn args() -> io::Result<(OsString, BTreeSet<OsString>)> {\n    let mut args = std::env::args_os().skip(1); // Skip the executable's name\n\n    let path = args\n        .next()\n        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"missing path\"))?;\n\n    let extensions = args.collect::<BTreeSet<_>>();\n\n    Ok((path, extensions))\n}\n\nfn print_hits<'a, T>(hits: impl Iterator<Item = T>)\nwhere\n    T: Display,\n{\n    let mut found_none = true;\n    for (number, hit) in hits.enumerate() {\n        println!(\"    [{}] {}\", number + 1, hit);\n        found_none = false;\n    }\n\n    if found_none {\n        println!(\"(none)\")\n    }\n}\n\nfn main() -> io::Result<()> {\n    let (path, extensions) = args()?;\n    let mut files = InvertedIndex::<PathBuf>::default();\n    let mut content = InvertedIndex::<PathBuf>::default();\n\n    println!(\n        \"Indexing {:?} files in '{}'\",\n        extensions,\n        path.to_string_lossy()\n    );\n\n    for path in Files::walk(path)?.map(|file| file.path()).filter(|path| {\n        path.extension()\n            .filter(|&ext| extensions.is_empty() || extensions.contains(ext))\n            .is_some()\n    }) {\n        files.add(path.clone(), tokenize(&path.to_string_lossy()));\n\n        match tokenize_file(&path) {\n            Ok(tokens) => content.add(path, tokens),\n            Err(e) => eprintln!(\"Skipping a file {}: {}\", path.display(), e),\n        }\n    }\n\n    println!(\n        \"Indexed {} tokens in {} files.\",\n        content.tokens().count(),\n        content.sources.len()\n    );\n\n    // Run the query UI loop\n    let mut query = String::new();\n\n    loop {\n        query.clear();\n        println!(\"Enter search query:\");\n        if stdin().read_line(&mut query).is_err() || query.trim().is_empty() {\n            break;\n        }\n\n        match query.trim() {\n            \"/exit\" | \"/quit\" | \"\" => break,\n\n            \"/tokens\" => {\n                println!(\"Tokens:\");\n                for token in content.tokens() {\n                    println!(\"{}\", token);\n                }\n\n                println!();\n            }\n\n            \"/files\" => {\n                println!(\"Sources:\");\n                for source in content.sources() {\n                    println!(\"{}\", source.display());\n                }\n\n                println!();\n            }\n\n            _ => {\n                let query = tokenize_query(&query);\n                println!();\n                println!(\"Found hits:\");\n                print_hits(content.search(query.iter()).map(|it| it.display()));\n                println!(\"Found file names:\");\n                print_hits(files.search(query.iter()).map(|it| it.display()));\n                println!();\n            }\n        }\n    }\n\n    Ok(())\n}",
    "title": "Inverted index",
    "url": "http://rosettacode.org/wiki/Inverted_index"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Inverted syntax",
    "url": "http://rosettacode.org/wiki/Inverted_syntax"
  },
  {
    "local_code": "use num::BigUint;\nuse num::CheckedSub;\nuse num_traits::{One, Zero};\n\nfn isqrt(number: &BigUint) -> BigUint {\n    let mut q: BigUint = One::one();\n    while q <= *number {\n        q <<= &2;\n    }\n\n    let mut z = number.clone();\n    let mut result: BigUint = Zero::zero();\n\n    while q > One::one() {\n        q >>= &2;\n        let t = z.checked_sub(&result).and_then(|diff| diff.checked_sub(&q));\n        result >>= &1;\n\n        if let Some(t) = t {\n            z = t;\n            result += &q;\n        }\n    }\n\n    result\n}\n\nfn with_thousand_separator(s: &str) -> String {\n    let digits: Vec<_> = s.chars().rev().collect();\n    let chunks: Vec<_> = digits\n        .chunks(3)\n        .map(|chunk| chunk.iter().collect::<String>())\n        .collect();\n\n    chunks.join(\",\").chars().rev().collect::<String>()\n}\n\nfn main() {\n    println!(\"The integer square roots of integers from 0 to 65 are:\");\n    (0_u32..=65).for_each(|n| print!(\"{} \", isqrt(&n.into())));\n\n    println!(\"\\nThe integer square roots of odd powers of 7 from 7^1 up to 7^74 are:\");\n    (1_u32..75).step_by(2).for_each(|exp| {\n        println!(\n            \"7^{:>2}={:>83} ISQRT: {:>42} \",\n            exp,\n            with_thousand_separator(&BigUint::from(7_u8).pow(exp).to_string()),\n            with_thousand_separator(&isqrt(&BigUint::from(7_u8).pow(exp)).to_string())\n        )\n    });\n}\n\n#[cfg(test)]\nmod tests {\n    use num::Num;\n\n    use super::*;\n\n    #[test]\n    fn test_isqrt() {\n        assert_eq!(isqrt(&0_u32.into()), BigUint::from(0_u32));\n        assert_eq!(isqrt(&1_u32.into()), BigUint::from(1_u32));\n        assert_eq!(isqrt(&2_u32.into()), BigUint::from(1_u32));\n        assert_eq!(isqrt(&4_u32.into()), BigUint::from(2_u32));\n        assert_eq!(\n            isqrt(&BigUint::from_str_radix(\"11398895185373143\", 10).unwrap()),\n            BigUint::from_str_radix(\"106765608\", 10).unwrap()\n        );\n    }\n}\n",
    "path": "tasks/integer-square-root",
    "remote_code": "\nuse num::BigUint;\nuse num::CheckedSub;\nuse num_traits::{One, Zero};\n\nfn isqrt(number: &BigUint) -> BigUint {\n    let mut q: BigUint = One::one();\n    while q <= *number {\n        q <<= &2;\n    }\n\n    let mut z = number.clone();\n    let mut result: BigUint = Zero::zero();\n\n    while q > One::one() {\n        q >>= &2;\n        let t = z.checked_sub(&result).and_then(|diff| diff.checked_sub(&q));\n        result >>= &1;\n\n        if let Some(t) = t {\n            z = t;\n            result += &q;\n        }\n    }\n\n    result\n}\n\nfn with_thousand_separator(s: &str) -> String {\n    let digits: Vec<_> = s.chars().rev().collect();\n    let chunks: Vec<_> = digits\n        .chunks(3)\n        .map(|chunk| chunk.iter().collect::<String>())\n        .collect();\n\n    chunks.join(\",\").chars().rev().collect::<String>()\n}\n\nfn main() {\n    println!(\"The integer square roots of integers from 0 to 65 are:\");\n    (0_u32..=65).for_each(|n| print!(\"{} \", isqrt(&n.into())));\n\n    println!(\"\\nThe integer square roots of odd powers of 7 from 7^1 up to 7^74 are:\");\n    (1_u32..75).step_by(2).for_each(|exp| {\n        println!(\n            \"7^{:>2}={:>83} ISQRT: {:>42} \",\n            exp,\n            with_thousand_separator(&BigUint::from(7_u8).pow(exp).to_string()),\n            with_thousand_separator(&isqrt(&BigUint::from(7_u8).pow(exp)).to_string())\n        )\n    });\n}\n",
    "title": "Isqrt (integer square root) of X",
    "url": "http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X"
  },
  {
    "local_code": "//! These are two naive solutions, one with lots of redundant calculations (memoizationless\n//! recursion) and one with a few precomputed values. All digit square sums are no greater than 648\n//! for numbers < 100,000,000.\n//!\n//! Both are slow algorithms, however, Rust is among faster languages, so this doesn't take minutes\n//! or hours.\n\nfn digit_square_sum(mut num: usize) -> usize {\n    let mut sum = 0;\n    while num != 0 {\n        sum += (num % 10).pow(2);\n        num /= 10;\n    }\n    sum\n}\n\nfn last_in_chain(num: usize) -> usize {\n    match num {\n        0 => 0,\n        1 | 89 => num,\n        _ => last_in_chain(digit_square_sum(num)),\n    }\n}\n\nfn main() {\n    let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n    println!(\"{}\", count);\n\n    let precomputed = (0..649).map(last_in_chain).collect::<Vec<_>>();\n    let count = (1..100_000_000)\n        .filter(|&n| precomputed[digit_square_sum(n)] == 89)\n        .count();\n    println!(\"{}\", count);\n}\n\n/// Ignore these tests because they're pretty expensive on a non-release build.\n#[cfg(test)]\nmod tests {\n    use super::{digit_square_sum, last_in_chain};\n\n    #[test]\n    #[ignore]\n    fn naive() {\n        let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n        assert_eq!(count, 85744333);\n    }\n\n    #[test]\n    #[ignore]\n    fn precomputation() {\n        let precomputed = (0..649).map(last_in_chain).collect::<Vec<_>>();\n        let count = (1..100_000_000)\n            .filter(|&n| precomputed[digit_square_sum(n)] == 89)\n            .count();\n        assert_eq!(count, 85744333);\n    }\n}\n",
    "path": "tasks/iterated-digits-squaring",
    "remote_code": "fn digit_square_sum(mut num: usize) -> usize {\n    let mut sum = 0;\n    while num != 0 {\n        sum += (num % 10).pow(2);\n        num /= 10;\n    }\n    sum\n}\n\nfn last_in_chain(num: usize) -> usize {\n    match num {\n        1 | 89 => num,\n        _ => last_in_chain(digit_square_sum(num)),\n    }\n}\n\nfn main() {\n    let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n    println!(\"{}\", count);\n}",
    "title": "Iterated digits squaring",
    "url": "http://rosettacode.org/wiki/Iterated_digits_squaring"
  },
  {
    "local_code": "#[macro_use]\nextern crate serde_derive;\n\nextern crate serde;\nextern crate serde_json;\n\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct Contact {\n    name: String,\n    city: String,\n}\n\nfn main() {\n    // Encode contact to json\n    let c = Contact {\n        name: \"John\".to_string(),\n        city: \"Paris\".to_string(),\n    };\n    let json = serde_json::to_string(&c).unwrap();\n    println!(\"Encoded: {:?}\", json);\n\n    // Decode json to contact\n    let json_str = r#\"{ \"name\": \"Alan\", \"city\": \"Tokyo\" }\"#;\n    let contact: Contact = serde_json::from_str(json_str).unwrap();\n    println!(\"Decoded: {:?}\", contact);\n}\n\n#[test]\nfn test_coherence() {\n    let c = Contact {\n        name: \"John\".to_string(),\n        city: \"Paris\".to_string(),\n    };\n    assert_eq!(\n        serde_json::from_str::<Contact>(&serde_json::to_string(&c).unwrap()).unwrap(),\n        c\n    );\n}\n\n#[test]\nfn test_decode() {\n    let json_str = r#\"{ \"name\": \"Alan\", \"city\": \"Tokyo\" }\"#;\n    let contact: Contact = serde_json::from_str(json_str).unwrap();\n    assert_eq!(\n        contact,\n        Contact {\n            name: \"Alan\".to_string(),\n            city: \"Tokyo\".to_string(),\n        }\n    );\n}\n",
    "path": "tasks/json",
    "remote_code": "use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}",
    "title": "JSON",
    "url": "http://rosettacode.org/wiki/JSON"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn jacobi(mut n: i32, mut k: i32) -> i32 {\n    assert!(k > 0 && k % 2 == 1);\n    n %= k;\n    let mut t = 1;\n    while n != 0 {\n        while n % 2 == 0 {\n            n /= 2;\n            let r = k % 8;\n            if r == 3 || r == 5 {\n                t = -t;\n            }\n        }\n        std::mem::swap(&mut n, &mut k);\n        if n % 4 == 3 && k % 4 == 3 {\n            t = -t;\n        }\n        n %= k;\n    }\n    if k == 1 {\n        t\n    } else {\n        0\n    }\n}\n\nfn print_table(kmax: i32, nmax: i32) {\n    print!(\"n\\\\k|\");\n    for k in 0..=kmax {\n        print!(\" {:2}\", k);\n    }\n    print!(\"\\n----\");\n    for _ in 0..=kmax {\n        print!(\"---\");\n    }\n    println!();\n    for n in (1..=nmax).step_by(2) {\n        print!(\"{:2} |\", n);\n        for k in 0..=kmax {\n            print!(\" {:2}\", jacobi(k, n));\n        }\n        println!();\n    }\n}\n\nfn main() {\n    print_table(20, 21);\n}",
    "title": "Jacobi symbol",
    "url": "http://rosettacode.org/wiki/Jacobi_symbol"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"0.3\"\n\nuse rug::integer::IsPrime;\nuse rug::Integer;\n\nfn jacobsthal_numbers() -> impl std::iter::Iterator<Item = Integer> {\n    (0..).map(|x| ((Integer::from(1) << x) - if x % 2 == 0 { 1 } else { -1 }) / 3)\n}\n\nfn jacobsthal_lucas_numbers() -> impl std::iter::Iterator<Item = Integer> {\n    (0..).map(|x| (Integer::from(1) << x) + if x % 2 == 0 { 1 } else { -1 })\n}\n\nfn jacobsthal_oblong_numbers() -> impl std::iter::Iterator<Item = Integer> {\n    let mut jn = jacobsthal_numbers();\n    let mut n0 = jn.next().unwrap();\n    std::iter::from_fn(move || {\n        let n1 = jn.next().unwrap();\n        let result = Integer::from(&n0 * &n1);\n        n0 = n1;\n        Some(result)\n    })\n}\n\nfn jacobsthal_primes() -> impl std::iter::Iterator<Item = Integer> {\n    jacobsthal_numbers().filter(|x| x.is_probably_prime(30) != IsPrime::No)\n}\n\nfn main() {\n    println!(\"First 30 Jacobsthal Numbers:\");\n    for (i, n) in jacobsthal_numbers().take(30).enumerate() {\n        print!(\"{:9}{}\", n, if (i + 1) % 5 == 0 { \"\\n\" } else { \" \" });\n    }\n    println!(\"\\nFirst 30 Jacobsthal-Lucas Numbers:\");\n    for (i, n) in jacobsthal_lucas_numbers().take(30).enumerate() {\n        print!(\"{:9}{}\", n, if (i + 1) % 5 == 0 { \"\\n\" } else { \" \" });\n    }\n    println!(\"\\nFirst 20 Jacobsthal oblong Numbers:\");\n    for (i, n) in jacobsthal_oblong_numbers().take(20).enumerate() {\n        print!(\"{:11}{}\", n, if (i + 1) % 5 == 0 { \"\\n\" } else { \" \" });\n    }\n    println!(\"\\nFirst 20 Jacobsthal primes:\");\n    for n in jacobsthal_primes().take(20) {\n        println!(\"{}\", n);\n    }\n}",
    "title": "Jacobsthal numbers",
    "url": "http://rosettacode.org/wiki/Jacobsthal_numbers"
  },
  {
    "local_code": "use std::cmp;\n\nfn jaro(str1: &str, str2: &str) -> f64 {\n    // lengths of both strings\n    let str1_len: usize = str1.len();\n    let str2_len: usize = str2.len();\n\n    // if both strings are empty return 1\n    // if only one of the strings is empty return 0\n    if str1_len == 0 {\n        if str2_len == 0 {\n            return 1.0;\n        } else {\n            return 0.0;\n        }\n    }\n\n    // max distance between two chars to be considered matching\n    let match_distance: isize = cmp::max(str1_len, str2_len) as isize / 2 - 1;\n\n    // mutable vectors of bools that signify if that char in the matching string has a match\n    let mut str1_matches: Vec<bool> = vec![false; str1_len];\n    let mut str2_matches: Vec<bool> = vec![false; str2_len];\n\n    // number of matches and transpositions\n    let mut matches: f64 = 0.0;\n    let mut transpositions: f64 = 0.0;\n\n    // find the matches\n    for (i, str1_match) in str1_matches.iter_mut().enumerate() {\n        // cast new variable i_isize for clarity\n        let i_isize = i as isize;\n        // start and end take into account the match distance\n        let start: usize = cmp::max(0, i_isize - match_distance) as usize;\n        let end: usize = cmp::min(i_isize + match_distance + 1, str2_len as isize) as usize;\n\n        for (k, str2_match) in str2_matches.iter_mut().enumerate().take(end).skip(start) {\n            // if str2 already has a match continue\n            if *str2_match {\n                continue;\n            }\n            // if str1 at i and str2 at k are not equal\n            if str1.chars().nth(i).unwrap() != str2.chars().nth(k).unwrap() {\n                continue;\n            }\n            // otherwise assume there is a match\n            *str1_match = true;\n            *str2_match = true;\n            matches += 1.0;\n            break;\n        }\n    }\n\n    // if there are no matches return 0\n    if matches == 0.0 {\n        return 0.0;\n    }\n\n    // count transpositions\n    let mut k = 0;\n    for (i, str1_match) in str1_matches.iter().enumerate() {\n        // if there are no matches in str1 continue\n        if !str1_match {\n            continue;\n        }\n        // while there is no match in str2 increment k\n        while !str2_matches[k] {\n            k += 1;\n        }\n        // increment transpositions\n        if str1.chars().nth(i).unwrap() != str2.chars().nth(k).unwrap() {\n            transpositions += 1.0;\n        }\n        k += 1;\n    }\n\n    // divide the number of transpositions by two as per the algorithm specs\n    transpositions /= 2.0;\n\n    // return the Jaro distance\n    ((matches / str1_len as f64)\n        + (matches / str2_len as f64)\n        + ((matches - transpositions) / matches))\n        / 3.0\n}\n\nfn main() {\n    println!(\"{}\", jaro(\"MARTHA\", \"MARHTA\"));\n    println!(\"{}\", jaro(\"DIXON\", \"DICKSONX\"));\n    println!(\"{}\", jaro(\"JELLYFISH\", \"SMELLYFISH\"));\n}\n\n#[test]\nfn test_jaro() {\n    use std::f64;\n\n    assert!((jaro(\"MARTHA\", \"MARHTA\") - 0.9444444444444445).abs() < f64::EPSILON);\n    assert!((jaro(\"DIXON\", \"DICKSONX\") - 0.7666666666666666).abs() < f64::EPSILON);\n    assert!((jaro(\"JELLYFISH\", \"SMELLYFISH\") - 0.8962962962962964).abs() < f64::EPSILON);\n}\n",
    "path": "tasks/jaro-distance",
    "remote_code": null,
    "title": "Jaro distance",
    "url": "http://rosettacode.org/wiki/Jaro_distance"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp;\n\npub fn jaro(s1: &str, s2: &str) -> f64 {\n    let s1_len = s1.len();\n    let s2_len = s2.len();\n    if s1_len == 0 && s2_len == 0 { return 1.0; }\n    let match_distance = cmp::max(s1_len, s2_len) / 2 - 1;\n    let mut s1_matches = vec![false; s1_len];\n    let mut s2_matches = vec![false; s2_len];\n    let mut m: isize = 0;\n    for i in 0..s1_len {\n        let start = cmp::max(0, i as isize - match_distance as isize) as usize;\n        let end = cmp::min(i + match_distance + 1, s2_len);\n        for j in start..end {\n            if !s2_matches[j] && s1.as_bytes()[i] == s2.as_bytes()[j] {\n                s1_matches[i] = true;\n                s2_matches[j] = true;\n                m += 1;\n                break;\n            }\n        }\n    }\n    if m == 0 { return 0.0; }\n    let mut t = 0.0;\n    let mut k = 0;\n    for i in 0..s1_len {\n        if s1_matches[i] {\n            while !s2_matches[k] { k += 1; }\n            if s1.as_bytes()[i] != s2.as_bytes()[k] { t += 0.5; }\n            k += 1;\n        }\n    }\n\n    let m = m as f64;\n    (m / s1_len as f64 + m / s2_len as f64 + (m  - t) / m) / 3.0\n}\n\nfn main() {\n    let pairs = [(\"MARTHA\", \"MARHTA\"), (\"DIXON\", \"DICKSONX\"), (\"JELLYFISH\", \"SMELLYFISH\")];\n    for p in pairs.iter() { println!(\"{}/{} = {}\", p.0, p.1, jaro(p.0, p.1)); }\n}",
    "title": "Jaro similarity",
    "url": "http://rosettacode.org/wiki/Jaro_similarity"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs::File;\nuse std::io::{self, BufRead};\n\nfn load_dictionary(filename: &str) -> std::io::Result<Vec<String>> {\n    let file = File::open(filename)?;\n    let mut dict = Vec::new();\n    for line in io::BufReader::new(file).lines() {\n        dict.push(line?);\n    }\n    Ok(dict)\n}\n\nfn jaro_winkler_distance(string1: &str, string2: &str) -> f64 {\n    let mut st1 = string1;\n    let mut st2 = string2;\n    let mut len1 = st1.chars().count();\n    let mut len2 = st2.chars().count();\n    if len1 < len2 {\n        std::mem::swap(&mut st1, &mut st2);\n        std::mem::swap(&mut len1, &mut len2);\n    }\n    if len2 == 0 {\n        return if len1 == 0 { 0.0 } else { 1.0 };\n    }\n    let delta = std::cmp::max(1, len1 / 2) - 1;\n    let mut flag = vec![false; len2];\n    let mut ch1_match = vec![];\n    for (idx1, ch1) in st1.chars().enumerate() {\n        for (idx2, ch2) in st2.chars().enumerate() {\n            if idx2 <= idx1 + delta && idx2 + delta >= idx1 && ch1 == ch2 && !flag[idx2] {\n                flag[idx2] = true;\n                ch1_match.push(ch1);\n                break;\n            }\n        }\n    }\n    let matches = ch1_match.len();\n    if matches == 0 {\n        return 1.0;\n    }\n    let mut transpositions = 0;\n    let mut idx1 = 0;\n    for (idx2, ch2) in st2.chars().enumerate() {\n        if flag[idx2] {\n            transpositions += (ch2 != ch1_match[idx1]) as i32;\n            idx1 += 1;\n        }\n    }\n    let m = matches as f64;\n    let jaro =\n        (m / (len1 as f64) + m / (len2 as f64) + (m - (transpositions as f64) / 2.0) / m) / 3.0;\n    let mut commonprefix = 0;\n    for (c1, c2) in st1.chars().zip(st2.chars()).take(std::cmp::min(4, len2)) {\n        commonprefix += (c1 == c2) as i32;\n    }\n    1.0 - (jaro + commonprefix as f64 * 0.1 * (1.0 - jaro))\n}\n\nfn within_distance<'a>(\n    dict: &'a Vec<String>,\n    max_distance: f64,\n    stri: &str,\n    max_to_return: usize,\n) -> Vec<(&'a String, f64)> {\n    let mut arr: Vec<(&String, f64)> = dict\n        .iter()\n        .map(|w| (w, jaro_winkler_distance(stri, w)))\n        .filter(|x| x.1 <= max_distance)\n        .collect();\n    // The trait std::cmp::Ord is not implemented for f64, otherwise\n    // we could just do this:\n    // arr.sort_by_key(|x| x.1);\n    let compare_distance = |d1, d2| {\n        use std::cmp::Ordering;\n        if d1 < d2 {\n            Ordering::Less\n        } else if d1 > d2 {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    };\n    arr.sort_by(|x, y| compare_distance(x.1, y.1));\n    arr[0..std::cmp::min(max_to_return, arr.len())].to_vec()\n}\n\nfn main() {\n    match load_dictionary(\"linuxwords.txt\") {\n        Ok(dict) => {\n            for word in &[\n                \"accomodate\",\n                \"definately\",\n                \"goverment\",\n                \"occured\",\n                \"publically\",\n                \"recieve\",\n                \"seperate\",\n                \"untill\",\n                \"wich\",\n            ] {\n                println!(\"Close dictionary words (distance < 0.15 using Jaro-Winkler distance) to '{}' are:\", word);\n                println!(\"        Word   |  Distance\");\n                for (w, dist) in within_distance(&dict, 0.15, word, 5) {\n                    println!(\"{:>14} | {:6.4}\", w, dist)\n                }\n                println!();\n            }\n        }\n        Err(error) => eprintln!(\"{}\", error),\n    }\n}",
    "title": "Jaro-Winkler distance",
    "url": "http://rosettacode.org/wiki/Jaro-Winkler_distance"
  },
  {
    "local_code": "use std::f32;\n\nfn harmonic_sum<F>(lo: usize, hi: usize, term: F) -> f32\nwhere\n    F: Fn(f32) -> f32,\n{\n    (lo..hi + 1).fold(0.0, |acc, item| acc + term(item as f32))\n}\n\nfn main() {\n    println!(\"{}\", harmonic_sum(1, 100, |i| 1.0 / i));\n}\n\n#[test]\nfn test_harm_sum() {\n    let term = |i| 1.0 / i;\n    assert!((harmonic_sum(1, 100, &term).abs() - 5.187378) < f32::EPSILON);\n    assert!((harmonic_sum(1, 50, &term).abs() - 4.4992056) < f32::EPSILON);\n    assert!((harmonic_sum(1, 1000, &term).abs() - 7.4854784) < f32::EPSILON);\n    assert!((harmonic_sum(1, 2, &term).abs() - 1.5) < f32::EPSILON);\n}\n",
    "path": "tasks/jensens-device",
    "remote_code": "\nuse std::f32;\n\nfn harmonic_sum<F>(lo: usize, hi: usize, term: F) -> f32\nwhere\n    F: Fn(f32) -> f32,\n{\n    (lo..hi + 1).fold(0.0, |acc, item| acc + term(item as f32))\n}\n\nfn main() {\n    println!(\"{}\", harmonic_sum(1, 100, |i| 1.0 / i));\n}\n\n",
    "title": "Jensen's Device",
    "url": "http://rosettacode.org/wiki/Jensen's_Device"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn count_jewels(stones: &str, jewels: &str) -> u8 {\n    let mut count: u8 = 0;\n    for cur_char in stones.chars() {\n        if jewels.contains(cur_char) {\n            count += 1;\n        }\n    }\n    count\n}\nfn main() {\n    println!(\"{}\", count_jewels(\"aAAbbbb\", \"aA\"));\n    println!(\"{}\", count_jewels(\"ZZ\", \"z\"));\n}\n",
    "title": "Jewels and stones",
    "url": "http://rosettacode.org/wiki/Jewels_and_stones"
  },
  {
    "local_code": "use std::cmp::{Eq, Ord};\n\nfn jortsort<T: Ord + Eq + Clone>(array: &[T]) -> bool {\n    // sort the array\n    let mut sorted_array = array.to_vec();\n    sorted_array.sort();\n\n    // compare to see if it was originally sorted\n    for i in 0..array.len() {\n        if array[i] != sorted_array[i] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let unsorted = [1, 3, 2];\n    if jortsort(&unsorted) {\n        println!(\"{:?} is sorted.\", unsorted);\n    } else {\n        println!(\"{:?} is unsorted.\", unsorted);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::jortsort;\n\n    #[test]\n    fn sorted() {\n        let sorted = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        assert!(jortsort(&sorted))\n    }\n\n    #[test]\n    fn unsorted() {\n        let unsorted = [1, 3, 2];\n        assert!(!jortsort(&unsorted))\n    }\n}\n",
    "path": "tasks/jortsort",
    "remote_code": "use std::cmp::{Ord, Eq};\n\nfn jort_sort<T: Ord + Eq + Clone>(array: Vec<T>) -> bool {\n    // sort the array\n    let mut sorted_array = array.to_vec();\n    sorted_array.sort();\n    \n    // compare to see if it was originally sorted\n    for i in 0..array.len() {\n        if array[i] != sorted_array[i] {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "title": "JortSort",
    "url": "http://rosettacode.org/wiki/JortSort"
  },
  {
    "local_code": "/// implementation based on observation:\n/// `josephus(n, k) == if n < 2 { 0 } else { (josephus(n - 1, k) + k) % n }`\nfn josephus(n: u32, k: u32) -> u32 {\n    let mut result = 0u32;\n    for i in 2..(n + 1) {\n        result = (result + k) % i;\n    }\n    result\n}\n\nfn main() {\n    let n = 5;\n    let k = 2;\n    println!(\"n: {} k: {} survivor: {}\", n, k, josephus(n, k));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::josephus;\n\n    #[test]\n    fn test() {\n        assert!(josephus(5, 2) == 2);\n        assert!(josephus(41, 3) == 30);\n    }\n}\n",
    "path": "tasks/josephus-problem",
    "remote_code": "const N: usize = 41;\nconst K: usize = 3;\nconst M: usize = 3;\nconst POSITION: usize = 5;\n\nfn main() {\n    let mut prisoners: Vec<usize> = Vec::new();\n    let mut executed: Vec<usize> = Vec::new();\n    for pos in 0..N {\n        prisoners.push(pos);\n    }\n\n    let mut to_kill: usize = 0;\n    let mut len: usize = prisoners.len();\n\n    while len > M {\n        to_kill = (to_kill + K - 1) % len;\n        executed.push(prisoners.remove(to_kill));\n        len -= 1;\n    }\n\n    println!(\"JOSEPHUS n={}, k={}, m={}\", N, K, M);\n    println!(\"Executed: {:?}\", executed);\n    println!(\"Executed position number {}: {}\", POSITION, executed[POSITION - 1]);\n    println!(\"Survivors: {:?}\", prisoners);\n}",
    "title": "Josephus problem",
    "url": "http://rosettacode.org/wiki/Josephus_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Joystick position",
    "url": "http://rosettacode.org/wiki/Joystick_position"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Juggler sequence",
    "url": "http://rosettacode.org/wiki/Juggler_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{ImageBuffer, Pixel, Rgb};\n\nfn main() {\n    // 4 : 3 ratio is nice\n    let width = 8000;\n    let height = 6000;\n\n    let mut img = ImageBuffer::new(width as u32, height as u32);\n\n    // constants to tweak for appearance\n    let cx = -0.9;\n    let cy = 0.27015;\n    let iterations = 110;\n\n    for x in 0..width {\n        for y in 0..height {\n            let inner_height = height as f32;\n            let inner_width = width as f32;\n            let inner_y = y as f32;\n            let inner_x = x as f32;\n\n            let mut zx = 3.0 * (inner_x - 0.5 * inner_width) / (inner_width);\n            let mut zy = 2.0 * (inner_y - 0.5 * inner_height) / (inner_height);\n\n            let mut i = iterations;\n\n            while zx * zx + zy * zy < 4.0 && i > 1 {\n                let tmp = zx * zx - zy * zy + cx;\n                zy = 2.0 * zx * zy + cy;\n                zx = tmp;\n                i -= 1;\n            }\n\n            // guesswork to make the rgb color values look okay\n            let r = (i << 3) as u8;\n            let g = (i << 5) as u8;\n            let b = (i << 4) as u8;\n            let pixel = Rgb::from_channels(r, g, b, 0);\n            img.put_pixel(x as u32, y as u32, pixel);\n        }\n    }\n\n    let _ = img.save(\"output.png\");\n\n}",
    "title": "Julia set",
    "url": "http://rosettacode.org/wiki/Julia_set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Jump anywhere",
    "url": "http://rosettacode.org/wiki/Jump_anywhere"
  },
  {
    "local_code": "use std::cmp::Ordering;\nuse std::cmp::Ordering::Less;\nuse std::ops::Sub;\nuse std::time::Instant;\n\nuse rand::prelude::*;\n\n#[derive(Clone, PartialEq, Debug)]\nstruct Point {\n    pub coords: Vec<f32>,\n}\n\nimpl<'a, 'b> Sub<&'b Point> for &'a Point {\n    type Output = Point;\n\n    fn sub(self, rhs: &Point) -> Point {\n        assert_eq!(self.coords.len(), rhs.coords.len());\n        Point {\n            coords: self\n                .coords\n                .iter()\n                .zip(rhs.coords.iter())\n                .map(|(&x, &y)| x - y)\n                .collect(),\n        }\n    }\n}\n\nimpl Point {\n    fn norm_sq(&self) -> f32 {\n        self.coords.iter().map(|n| n * n).sum()\n    }\n}\n\n#[allow(clippy::upper_case_acronyms)]\nstruct KDTreeNode {\n    point: Point,\n    dim: usize,\n    // Construction could become faster if we use an arena allocator,\n    // but this is easier to use.\n    left: Option<Box<KDTreeNode>>,\n    right: Option<Box<KDTreeNode>>,\n}\n\nimpl KDTreeNode {\n    /// Create a new `KDTreeNode` around the `dim`th dimension.\n    /// Alternatively, we could dynamically determine the dimension to\n    /// split on by using the longest dimension.\n    pub fn new(points: &mut [Point], dim: usize) -> KDTreeNode {\n        let points_len = points.len();\n        if points_len == 1 {\n            return KDTreeNode {\n                point: points[0].clone(),\n                dim,\n                left: None,\n                right: None,\n            };\n        }\n\n        // Split around the median\n        let pivot = quickselect_by(points, points_len / 2, &|a, b| {\n            a.coords[dim].partial_cmp(&b.coords[dim]).unwrap()\n        });\n\n        let left = Some(Box::new(KDTreeNode::new(\n            &mut points[0..points_len / 2],\n            (dim + 1) % pivot.coords.len(),\n        )));\n        let right = if points.len() >= 3 {\n            Some(Box::new(KDTreeNode::new(\n                &mut points[points_len / 2 + 1..points_len],\n                (dim + 1) % pivot.coords.len(),\n            )))\n        } else {\n            None\n        };\n\n        KDTreeNode {\n            point: pivot,\n            dim,\n            left,\n            right,\n        }\n    }\n\n    pub fn find_nearest_neighbor<'a>(&'a self, point: &Point) -> (&'a Point, usize) {\n        self.find_nearest_neighbor_helper(point, &self.point, (point - &self.point).norm_sq(), 1)\n    }\n\n    fn find_nearest_neighbor_helper<'a>(\n        &'a self,\n        point: &Point,\n        best: &'a Point,\n        best_dist_sq: f32,\n        n_visited: usize,\n    ) -> (&'a Point, usize) {\n        let mut my_best = best;\n        let mut my_best_dist_sq = best_dist_sq;\n        let mut my_n_visited = n_visited;\n\n        // We should always examine the near side\n        if self.point.coords[self.dim] < point.coords[self.dim] && self.right.is_some() {\n            let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        } else if self.left.is_some() {\n            let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        }\n\n        // distance along this node's axis\n        let axis_dist_sq = (self.point.coords[self.dim] - point.coords[self.dim]).powi(2);\n        if axis_dist_sq <= my_best_dist_sq {\n            // self can only be nearer than best if axis_dist_sq is less than\n            // best_dist_sq because axis_dist_sq is a lower bound for\n            // self_dist_sq\n            let self_dist_sq = (point - &self.point).norm_sq();\n            if self_dist_sq < my_best_dist_sq {\n                my_best = &self.point;\n                my_best_dist_sq = self_dist_sq;\n            }\n\n            // bookkeeping\n            my_n_visited += 1;\n\n            // same reasoning applies for the far side of the split\n            if self.point.coords[self.dim] < point.coords[self.dim] && self.left.is_some() {\n                let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            } else if self.right.is_some() {\n                let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            }\n        }\n\n        (my_best, my_n_visited)\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\npub fn main() {\n    let mut rng = thread_rng();\n\n    // wordpress\n    let mut wp_points: Vec<Point> = [\n        [2.0, 3.0],\n        [5.0, 4.0],\n        [9.0, 6.0],\n        [4.0, 7.0],\n        [8.0, 1.0],\n        [7.0, 2.0],\n    ]\n    .iter()\n    .map(|x| Point { coords: x.to_vec() })\n    .collect();\n    let wp_tree = KDTreeNode::new(&mut wp_points, 0);\n\n    let wp_target = Point {\n        coords: vec![9.0, 2.0],\n    };\n    {\n        let (point, n_visited) = wp_tree.find_nearest_neighbor(&wp_target);\n        println!(\"Wikipedia example data:\");\n        println!(\"Point: [9, 2]\");\n        println!(\"Nearest neighbor: {:?}\", point);\n        println!(\"Distance: {}\", (point - &wp_target).norm_sq().sqrt());\n        println!(\"Nodes visited: {}\", n_visited);\n    }\n    // randomly generated 3D\n    let n_random = 1000;\n    let mut make_random_point = || Point {\n        coords: (0..3).map(|_| (rng.gen::<f32>() - 0.5) * 1000.0).collect(),\n    };\n    let mut random_points: Vec<Point> = (0..n_random).map(|_| make_random_point()).collect();\n\n    let start_cons_time = Instant::now();\n    let random_tree = KDTreeNode::new(&mut random_points, 0);\n    let cons_time = start_cons_time.elapsed();\n    println!(\n        \"1,000 3d points (Construction time: {}ms)\",\n        cons_time.as_millis(),\n    );\n\n    let random_target = make_random_point();\n\n    {\n        let (point, n_visited) = random_tree.find_nearest_neighbor(&random_target);\n        println!(\"Point: {:?}\", random_target);\n        println!(\"Nearest neighbor: {:?}\", point);\n        println!(\"Distance: {}\", (point - &random_target).norm_sq().sqrt());\n        println!(\"Nodes visited: {}\", n_visited);\n    }\n    // benchmark search time\n    let n_searches = 1000;\n    let random_targets: Vec<Point> = (0..n_searches).map(|_| make_random_point()).collect();\n\n    let start_search_time = Instant::now();\n    let mut total_n_visited = 0;\n    for target in &random_targets {\n        let (_, n_visited) = random_tree.find_nearest_neighbor(target);\n        total_n_visited += n_visited;\n    }\n    let search_time = start_search_time.elapsed();\n    println!(\n        \"Visited an average of {} nodes on {} searches in {} ms\",\n        total_n_visited as f32 / n_searches as f32,\n        n_searches,\n        search_time.as_millis(),\n    );\n}\n\nfn quickselect_by<T>(arr: &mut [T], position: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> T\nwhere\n    T: Clone,\n{\n    // We use `thread_rng` here because it was already initialized in `main`.\n    let mut pivot_index = thread_rng().gen_range(0, arr.len());\n    // Need to wrap in another closure or we get ownership complaints.\n    // Tried using an unboxed closure to get around this but couldn't get it to work.\n    pivot_index = partition_by(arr, pivot_index, &|a: &T, b: &T| cmp(a, b));\n    let array_len = arr.len();\n    match position.cmp(&pivot_index) {\n        Ordering::Equal => arr[position].clone(),\n        Ordering::Less => quickselect_by(&mut arr[0..pivot_index], position, cmp),\n        Ordering::Greater => quickselect_by(\n            &mut arr[pivot_index + 1..array_len],\n            position - pivot_index - 1,\n            cmp,\n        ),\n    }\n}\n\nfn partition_by<T>(arr: &mut [T], pivot_index: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> usize {\n    let array_len = arr.len();\n    arr.swap(pivot_index, array_len - 1);\n    let mut store_index = 0;\n    for i in 0..array_len - 1 {\n        if cmp(&arr[i], &arr[array_len - 1]) == Less {\n            arr.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n    arr.swap(array_len - 1, store_index);\n    store_index\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{KDTreeNode, Point};\n\n    #[test]\n    fn wp() {\n        let mut wp_points: Vec<Point> = [\n            [2.0, 3.0],\n            [5.0, 4.0],\n            [9.0, 6.0],\n            [4.0, 7.0],\n            [8.0, 1.0],\n            [7.0, 2.0],\n        ]\n        .iter()\n        .map(|x| Point { coords: x.to_vec() })\n        .collect();\n        let wp_tree = KDTreeNode::new(&mut wp_points, 0);\n\n        let wp_target = Point {\n            coords: vec![9.0, 2.0],\n        };\n        let (point, _) = wp_tree.find_nearest_neighbor(&wp_target);\n        assert_eq!(\n            *point,\n            Point {\n                coords: vec![8.0, 1.0],\n            }\n        );\n    }\n}\n",
    "path": "tasks/k-d-tree",
    "remote_code": "\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::Less;\nuse std::ops::Sub;\nuse std::time::Instant;\n\nuse rand::prelude::*;\n\n#[derive(Clone, PartialEq, Debug)]\nstruct Point {\n    pub coords: Vec<f32>,\n}\n\nimpl<'a, 'b> Sub<&'b Point> for &'a Point {\n    type Output = Point;\n\n    fn sub(self, rhs: &Point) -> Point {\n        assert_eq!(self.coords.len(), rhs.coords.len());\n        Point {\n            coords: self\n                .coords\n                .iter()\n                .zip(rhs.coords.iter())\n                .map(|(&x, &y)| x - y)\n                .collect(),\n        }\n    }\n}\n\nimpl Point {\n    fn norm_sq(&self) -> f32 {\n        self.coords.iter().map(|n| n * n).sum()\n    }\n}\n\nstruct KDTreeNode {\n    point: Point,\n    dim: usize,\n    // Construction could become faster if we use an arena allocator,\n    // but this is easier to use.\n    left: Option<Box<KDTreeNode>>,\n    right: Option<Box<KDTreeNode>>,\n}\n\nimpl KDTreeNode {\n    /// Create a new KDTreeNode around the `dim`th dimension.\n    /// Alternatively, we could dynamically determine the dimension to\n    /// split on by using the longest dimension.\n    pub fn new(points: &mut [Point], dim: usize) -> KDTreeNode {\n        let points_len = points.len();\n        if points_len == 1 {\n            return KDTreeNode {\n                point: points[0].clone(),\n                dim,\n                left: None,\n                right: None,\n            };\n        }\n\n        // Split around the median\n        let pivot = quickselect_by(points, points_len / 2, &|a, b| {\n            a.coords[dim].partial_cmp(&b.coords[dim]).unwrap()\n        });\n\n        let left = Some(Box::new(KDTreeNode::new(\n            &mut points[0..points_len / 2],\n            (dim + 1) % pivot.coords.len(),\n        )));\n        let right = if points.len() >= 3 {\n            Some(Box::new(KDTreeNode::new(\n                &mut points[points_len / 2 + 1..points_len],\n                (dim + 1) % pivot.coords.len(),\n            )))\n        } else {\n            None\n        };\n\n        KDTreeNode {\n            point: pivot,\n            dim,\n            left,\n            right,\n        }\n    }\n\n    pub fn find_nearest_neighbor<'a>(&'a self, point: &Point) -> (&'a Point, usize) {\n        self.find_nearest_neighbor_helper(point, &self.point, (point - &self.point).norm_sq(), 1)\n    }\n\n    fn find_nearest_neighbor_helper<'a>(\n        &'a self,\n        point: &Point,\n        best: &'a Point,\n        best_dist_sq: f32,\n        n_visited: usize,\n    ) -> (&'a Point, usize) {\n        let mut my_best = best;\n        let mut my_best_dist_sq = best_dist_sq;\n        let mut my_n_visited = n_visited;\n\n        // We should always examine the near side\n        if self.point.coords[self.dim] < point.coords[self.dim] && self.right.is_some() {\n            let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        } else if self.left.is_some() {\n            let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        }\n\n        // distance along this node's axis\n        let axis_dist_sq = (self.point.coords[self.dim] - point.coords[self.dim]).powi(2);\n        if axis_dist_sq <= my_best_dist_sq {\n            // self can only be nearer than best if axis_dist_sq is less than\n            // best_dist_sq because axis_dist_sq is a lower bound for\n            // self_dist_sq\n            let self_dist_sq = (point - &self.point).norm_sq();\n            if self_dist_sq < my_best_dist_sq {\n                my_best = &self.point;\n                my_best_dist_sq = self_dist_sq;\n            }\n\n            // bookkeeping\n            my_n_visited += 1;\n\n            // same reasoning applies for the far side of the split\n            if self.point.coords[self.dim] < point.coords[self.dim] && self.left.is_some() {\n                let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            } else if self.right.is_some() {\n                let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            }\n        }\n\n        (my_best, my_n_visited)\n    }\n}\n\npub fn main() {\n    let mut rng = thread_rng();\n\n    // wordpress\n    let mut wp_points: Vec<Point> = [\n        [2.0, 3.0],\n        [5.0, 4.0],\n        [9.0, 6.0],\n        [4.0, 7.0],\n        [8.0, 1.0],\n        [7.0, 2.0],\n    ]\n    .iter()\n    .map(|x| Point { coords: x.to_vec() })\n    .collect();\n    let wp_tree = KDTreeNode::new(&mut wp_points, 0);\n\n    let wp_target = Point {\n        coords: vec![9.0, 2.0],\n    };\n    let (point, n_visited) = wp_tree.find_nearest_neighbor(&wp_target);\n    println!(\"Wikipedia example data:\");\n    println!(\"Point: [9, 2]\");\n    println!(\"Nearest neighbor: {:?}\", point);\n    println!(\"Distance: {}\", (point - &wp_target).norm_sq().sqrt());\n    println!(\"Nodes visited: {}\", n_visited);\n\n    // randomly generated 3D\n    let n_random = 1000;\n    let mut make_random_point = || Point {\n        coords: (0..3).map(|_| (rng.gen::<f32>() - 0.5) * 1000.0).collect(),\n    };\n    let mut random_points: Vec<Point> = (0..n_random).map(|_| make_random_point()).collect();\n\n    let start_cons_time = Instant::now();\n    let random_tree = KDTreeNode::new(&mut random_points, 0);\n    let cons_time = start_cons_time.elapsed();\n    println!(\n        \"1,000 3d points (Construction time: {}ms)\",\n        cons_time.as_millis(),\n    );\n\n    let random_target = make_random_point();\n\n    let (point, n_visited) = random_tree.find_nearest_neighbor(&random_target);\n    println!(\"Point: {:?}\", random_target);\n    println!(\"Nearest neighbor: {:?}\", point);\n    println!(\"Distance: {}\", (point - &random_target).norm_sq().sqrt());\n    println!(\"Nodes visited: {}\", n_visited);\n\n    // benchmark search time\n    let n_searches = 1000;\n    let random_targets: Vec<Point> = (0..n_searches).map(|_| make_random_point()).collect();\n\n    let start_search_time = Instant::now();\n    let mut total_n_visited = 0;\n    for target in &random_targets {\n        let (_, n_visited) = random_tree.find_nearest_neighbor(target);\n        total_n_visited += n_visited;\n    }\n    let search_time = start_search_time.elapsed();\n    println!(\n        \"Visited an average of {} nodes on {} searches in {} ms\",\n        total_n_visited as f32 / n_searches as f32,\n        n_searches,\n        search_time.as_millis(),\n    );\n}\n\nfn quickselect_by<T>(arr: &mut [T], position: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> T\nwhere\n    T: Clone,\n{\n    // We use `thread_rng` here because it was already initialized in `main`.\n    let mut pivot_index = thread_rng().gen_range(0, arr.len());\n    // Need to wrap in another closure or we get ownership complaints.\n    // Tried using an unboxed closure to get around this but couldn't get it to work.\n    pivot_index = partition_by(arr, pivot_index, &|a: &T, b: &T| cmp(a, b));\n    let array_len = arr.len();\n    match position.cmp(&pivot_index) {\n        Ordering::Equal => arr[position].clone(),\n        Ordering::Less => quickselect_by(&mut arr[0..pivot_index], position, cmp),\n        Ordering::Greater => quickselect_by(\n            &mut arr[pivot_index + 1..array_len],\n            position - pivot_index - 1,\n            cmp,\n        ),\n    }\n}\n\nfn partition_by<T>(arr: &mut [T], pivot_index: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> usize {\n    let array_len = arr.len();\n    arr.swap(pivot_index, array_len - 1);\n    let mut store_index = 0;\n    for i in 0..array_len - 1 {\n        if cmp(&arr[i], &arr[array_len - 1]) == Less {\n            arr.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n    arr.swap(array_len - 1, store_index);\n    store_index\n}\n",
    "title": "K-d tree",
    "url": "http://rosettacode.org/wiki/K-d_tree"
  },
  {
    "local_code": "extern crate csv;\nextern crate gnuplot;\nextern crate nalgebra;\nextern crate rand;\nextern crate structopt;\n\nuse std::f64::consts::PI;\nuse std::fs::File;\nuse std::path::PathBuf;\n\nuse gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};\nuse nalgebra::DVector;\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\nuse structopt::StructOpt;\n\ntype Point = DVector<f64>;\n\nstruct Cluster<'a> {\n    members: Vec<&'a Point>,\n    center: Point,\n}\n\nstruct Stats {\n    centroids: Vec<Point>,\n    mean_d_from_centroid: DVector<f64>,\n}\n\n/// `DVector` doesn't implement `BaseFloat`, so a custom distance function is required.\nfn sqdist(p1: &Point, p2: &Point) -> f64 {\n    (p1.clone() - p2.clone()).iter().map(|x| x * x).sum()\n}\n\n/// Returns (distance^2, index) tuple of winning point.\nfn nearest(p: &Point, candidates: &[Point]) -> (f64, usize) {\n    let (dsquared, the_index) =\n        candidates\n            .iter()\n            .enumerate()\n            .fold((sqdist(p, &candidates[0]), 0), |(d, index), next| {\n                let dprime = sqdist(p, &candidates[next.0]);\n                if dprime < d {\n                    (dprime, next.0)\n                } else {\n                    (d, index)\n                }\n            });\n    (dsquared, the_index)\n}\n\n/// Computes starting centroids and makes initial assignments.\nfn kpp(points: &[Point], k: usize, rng: &mut impl Rng) -> Stats {\n    // Random point for first centroid guess:\n    let mut centroids: Vec<Point> = vec![points.choose(rng).unwrap().clone()];\n    let mut dists: Vec<f64> = vec![0f64; points.len()];\n\n    for _ in 1..k {\n        let mut sum = 0.0;\n        for (j, p) in points.iter().enumerate() {\n            let (dsquared, _) = nearest(p, &centroids);\n            dists[j] = dsquared;\n            sum += dsquared;\n        }\n\n        // This part chooses the next cluster center with a probability proportional to d^2\n        sum *= rng.gen::<f64>();\n        for (j, d) in dists.iter().enumerate() {\n            sum -= *d;\n            if sum <= 0f64 {\n                centroids.push(points[j].clone());\n                break;\n            }\n        }\n    }\n\n    let clusters = assign_clusters(points, &centroids);\n    compute_stats(&clusters)\n}\n\nfn assign_clusters<'a>(points: &'a [Point], centroids: &[Point]) -> Vec<Cluster<'a>> {\n    let mut clusters: Vec<Cluster> = Vec::new();\n\n    for _ in 0..centroids.len() {\n        clusters.push(Cluster {\n            members: Vec::new(),\n            center: DVector::zeros(points[0].len()),\n        });\n    }\n\n    for p in points.iter() {\n        let (_, nearest_index) = nearest(p, centroids);\n        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();\n        clusters[nearest_index].members.push(p);\n    }\n\n    for cluster in &mut clusters {\n        cluster.center = cluster.center.clone() / cluster.members.len() as f64;\n    }\n\n    clusters\n}\n\n/// Computes centroids and mean-distance-from-centroid for each cluster.\nfn compute_stats(clusters: &[Cluster]) -> Stats {\n    let mut centroids = Vec::new();\n    let mut means_vec = Vec::new();\n\n    for c in clusters.iter() {\n        let pts = &c.members;\n        let seed: DVector<f64> = DVector::zeros(pts[0].len());\n        let centroid = pts.iter().fold(seed, |a, &b| a + b.clone()) / pts.len() as f64;\n        means_vec.push(\n            pts.iter()\n                .fold(0f64, |acc, pt| acc + sqdist(pt, &centroid).sqrt())\n                / pts.len() as f64,\n        );\n        centroids.push(centroid);\n    }\n\n    Stats {\n        centroids,\n        mean_d_from_centroid: DVector::from_row_slice(&means_vec),\n    }\n}\n\nfn lloyd<'a>(\n    points: &'a [Point],\n    k: usize,\n    stoppage_delta: f64,\n    max_iter: u32,\n    rng: &mut impl Rng,\n) -> (Vec<Cluster<'a>>, Stats) {\n    let mut clusters = Vec::new();\n    // Choose starting centroids and make initial assignments\n    let mut stats = kpp(points, k, rng);\n\n    for i in 1..max_iter {\n        let last_means: DVector<f64> = stats.mean_d_from_centroid.clone();\n        clusters = assign_clusters(points, &stats.centroids);\n        stats = compute_stats(&clusters);\n        let err = sqdist(&stats.mean_d_from_centroid, &last_means).sqrt();\n        if err < stoppage_delta {\n            println!(\"Stoppage condition reached on iteration {}\", i);\n            return (clusters, stats);\n        }\n        // Console output\n        print!(\"Iter {}: \", i);\n        for (cen, mu) in stats\n            .centroids\n            .iter()\n            .zip(stats.mean_d_from_centroid.iter())\n        {\n            print_dvec(cen);\n            print!(\" {:1.2} | \", mu);\n        }\n        println!(\"{:1.5}\", err);\n    }\n\n    println!(\"Stoppage condition not reached by iteration {}\", max_iter);\n    (clusters, stats)\n}\n\n/// Uniform sampling on the unit disk.\nfn generate_points(n: u32, rng: &mut impl Rng) -> Vec<Point> {\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new(0.0, 2.0 * PI);\n\n    (0..n)\n        .map(|_| {\n            let root_r = rng.gen::<f64>();\n            let theta = rng.sample(range);\n            DVector::<f64>::from_row_slice(&[root_r * theta.cos(), root_r * theta.sin()])\n        })\n        .collect()\n}\n\n// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.\nfn viz(clusters: &[Cluster], stats: &Stats, k: usize, n: u32, e: f64) {\n    let mut fg = Figure::new();\n    {\n        let prep = |fg: &mut Figure| {\n            let axes: &mut Axes2D = fg.axes2d();\n            let title: String = format!(\"k = {}, n = {}, e = {:4}\", k, n, e);\n            let centroids_x = stats.centroids.iter().map(|c| c[0]);\n            let centroids_y = stats.centroids.iter().map(|c| c[1]);\n            for cluster in clusters.iter() {\n                axes.points(\n                    cluster.members.iter().map(|p| p[0]),\n                    cluster.members.iter().map(|p| p[1]),\n                    &[PointSymbol('O'), PointSize(0.25)],\n                );\n            }\n            axes.set_aspect_ratio(Fix(1.0))\n                .points(\n                    centroids_x,\n                    centroids_y,\n                    &[PointSymbol('o'), PointSize(1.5), Color(\"black\")],\n                )\n                .set_title(&title[..], &[]);\n        };\n        prep(&mut fg);\n    }\n    fg.show();\n}\n\nfn print_dvec(v: &DVector<f64>) {\n    print!(\"(\");\n    for elem in v.iter().take(v.len() - 1) {\n        print!(\"{:+1.2}, \", elem)\n    }\n    print!(\"{:+1.2})\", v.iter().last().unwrap());\n}\n\nfn unseeded_stdrng() -> StdRng {\n    let mut seed = <StdRng as SeedableRng>::Seed::default();\n    for (i, x) in seed.iter_mut().enumerate() {\n        *x = i as u8;\n    }\n    StdRng::from_seed(seed)\n}\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Number of clusters to assign\n    #[structopt(short = \"k\", default_value = \"7\")]\n    clusters: usize,\n\n    /// Operate on this many points on the unit disk\n    #[structopt(short = \"n\", default_value = \"30000\")]\n    points: u32,\n\n    /// Min delta in norm of successive cluster centroids to continue\n    #[structopt(short = \"e\", default_value = \"1e-3\")]\n    epsilon: f64,\n\n    /// Read points from file (overrides -n)\n    #[structopt(short = \"f\", parse(from_os_str))]\n    csv: Option<PathBuf>,\n}\n\nfn main() {\n    let mut opt = Opt::from_args();\n    const MAX_ITERATIONS: u32 = 100u32;\n\n    let mut rng = unseeded_stdrng();\n\n    let points = if let Some(filename) = opt.csv {\n        let mut points = Vec::new();\n        let mut rdr = csv::Reader::from_reader(File::open(&filename).unwrap());\n        for row in rdr.deserialize() {\n            let floats: Vec<f64> = row.unwrap();\n            points.push(DVector::<f64>::from_row_slice(&floats));\n        }\n        assert!(points.iter().all(|v| v.len() == points[0].len()));\n        opt.points = points.len() as u32;\n        println!(\"Read {} points from {}\", points.len(), filename.display());\n        points\n    } else {\n        // Proceed with random 2d data\n        generate_points(opt.points, &mut rng)\n    };\n\n    assert!(points.len() >= opt.clusters);\n    let (clusters, stats) = lloyd(&points, opt.clusters, opt.epsilon, MAX_ITERATIONS, &mut rng);\n\n    println!(\n        \" k       centroid{}mean dist    pop\",\n        \" \".repeat((points[0].len() - 2) * 7 + 7)\n    );\n    println!(\n        \"===  {}  ===========  =====\",\n        \"=\".repeat(points[0].len() * 7 + 2)\n    );\n    for (i, cluster) in clusters.iter().enumerate() {\n        print!(\" {:>1}    \", i);\n        print_dvec(&stats.centroids[i]);\n        println!(\n            \"      {:1.2}       {:>4}\",\n            stats.mean_d_from_centroid[i],\n            cluster.members.len()\n        );\n    }\n\n    if points[0].len() == 2 {\n        viz(&clusters, &stats, opt.clusters, opt.points, opt.epsilon)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{generate_points, lloyd, unseeded_stdrng};\n\n    #[test]\n    fn test_lloyd2d() {\n        let mut rng = unseeded_stdrng();\n        let points = generate_points(1000, &mut rng);\n\n        let (clusters, stats) = lloyd(&points, 4, 0.001, 100, &mut rng);\n\n        assert!(clusters.len() == 4);\n        clusters.iter().for_each(|c| assert!(!c.members.is_empty()));\n\n        assert!(stats.mean_d_from_centroid.iter().all(|d| *d > 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] >= 0f64 && p[1] >= 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] >= 0f64 && p[1] < 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] < 0f64 && p[1] < 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] < 0f64 && p[1] >= 0f64));\n    }\n}\n",
    "path": "tasks/k-meanspp-clustering",
    "remote_code": "extern crate csv;\nextern crate getopts;\nextern crate gnuplot;\nextern crate nalgebra;\nextern crate num;\nextern crate rand;\nextern crate rustc_serialize;\nextern crate test;\n\nuse getopts::Options;\nuse gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};\nuse nalgebra::{DVector, Iterable};\nuse rand::{Rng, SeedableRng, StdRng};\nuse rand::distributions::{IndependentSample, Range};\nuse std::f64::consts::PI;\nuse std::env;\n\ntype Point = DVector<f64>;\n\nstruct Cluster<'a> {\n    members: Vec<&'a Point>,\n    center: Point,\n}\n\nstruct Stats {\n    centroids: Vec<Point>,\n    mean_d_from_centroid: DVector<f64>,\n}\n\n/// DVector doesn't implement BaseFloat, so a custom distance function is required.\nfn sqdist(p1: &Point, p2: &Point) -> f64 {\n    (p1.clone() - p2.clone()).iter().map(|x| x * x).fold(0f64, |a, b| a + b)\n}\n\n/// Returns (distance^2, index) tuple of winning point.\nfn nearest(p: &Point, candidates: &Vec<Point>) -> (f64, usize) {\n    let (dsquared, the_index) = candidates.iter()\n                                          .enumerate()\n                                          .fold((sqdist(p, &candidates[0]), 0),\n                                                |(d, index), next| {\n                                                    let dprime = sqdist(p, &candidates[next.0]);\n                                                    if dprime < d {\n                                                        (dprime, next.0)\n                                                    } else {\n                                                        (d, index)\n                                                    }\n                                                });\n    (dsquared, the_index)\n}\n\n/// Computes starting centroids and makes initial assignments.\nfn kpp(points: &Vec<Point>, k: usize, rng: &mut StdRng) -> Stats {\n    let mut centroids: Vec<Point> = Vec::new();\n    // Random point for first centroid guess:\n    centroids.push(points[rng.gen::<usize>() % points.len()].clone());\n    let mut dists: Vec<f64> = vec![0f64; points.len()];\n\n    for _ in 1..k {\n        let mut sum = 0f64;\n        for (j, p) in points.iter().enumerate() {\n            let (dsquared, _) = nearest(&p, &centroids);\n            dists[j] = dsquared;\n            sum += dsquared;\n        }\n\n        // This part chooses the next cluster center with a probability proportional to d^2\n        sum *= rng.next_f64();\n        for (j, d) in dists.iter().enumerate() {\n            sum -= *d;\n            if sum <= 0f64 {\n                centroids.push(points[j].clone());\n                break;\n            }\n        }\n    }\n\n    let clusters = assign_clusters(points, &centroids);\n    compute_stats(&clusters)\n}\n\nfn assign_clusters<'a>(points: &'a Vec<Point>, centroids: &Vec<Point>) -> Vec<Cluster<'a>> {\n    let mut clusters: Vec<Cluster> = Vec::new();\n\n    for _ in 0..centroids.len() {\n        clusters.push(Cluster {\n            members: Vec::new(),\n            center: DVector::new_zeros(points[0].len()),\n        });\n    }\n\n    for p in points.iter() {\n        let (_, nearest_index) = nearest(p, centroids);\n        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();\n        clusters[nearest_index].members.push(p);\n    }\n\n    for i in 0..clusters.len() {\n        clusters[i].center = clusters[i].center.clone() / clusters[i].members.len() as f64;\n    }\n\n    clusters\n}\n\n/// Computes centroids and mean-distance-from-centroid for each cluster.\nfn compute_stats(clusters: &Vec<Cluster>) -> Stats {\n    let mut centroids = Vec::new();\n    let mut means_vec = Vec::new();\n\n    for c in clusters.iter() {\n        let pts = &c.members;\n        let seed: DVector<f64> = DVector::new_zeros(pts[0].len());\n        let centroid = pts.iter().fold(seed, |a, &b| a + b.clone()) / pts.len() as f64;\n        means_vec.push(pts.iter().fold(0f64, |acc, pt| acc + sqdist(pt, &centroid).sqrt()) /\n                       pts.len() as f64);\n        centroids.push(centroid);\n    }\n\n    Stats {\n        centroids: centroids,\n        mean_d_from_centroid: DVector::from_slice(means_vec.len(), means_vec.as_slice()),\n    }\n}\n\nfn lloyd<'a>(points: &'a Vec<Point>,\n             k: usize,\n             stoppage_delta: f64,\n             max_iter: u32,\n             rng: &mut StdRng)\n             -> (Vec<Cluster<'a>>, Stats) {\n\n    let mut clusters = Vec::new();\n    // Choose starting centroids and make initial assignments\n    let mut stats = kpp(points, k, rng);\n\n    for i in 1..max_iter {\n        let last_means: DVector<f64> = stats.mean_d_from_centroid.clone();\n        clusters = assign_clusters(points, &stats.centroids);\n        stats = compute_stats(&clusters);\n        let err = sqdist(&stats.mean_d_from_centroid, &last_means).sqrt();\n        if err < stoppage_delta {\n            println!(\"Stoppage condition reached on iteration {}\", i);\n            return (clusters, stats);\n        }\n        // Console output\n        print!(\"Iter {}: \", i);\n        for (cen, mu) in stats.centroids.iter().zip(stats.mean_d_from_centroid.iter()) {\n            print_dvec(cen);\n            print!(\" {:1.2} | \", mu);\n        }\n        print!(\"{:1.5}\\n\", err);\n    }\n\n    println!(\"Stoppage condition not reached by iteration {}\", max_iter);\n    (clusters, stats)\n}\n\n/// Uniform sampling on the unit disk.\nfn generate_points(n: u32, rng: &mut StdRng) -> Vec<Point> {\n    let r_range = Range::new(0f64, 1f64);\n    let theta_range = Range::new(0f64, 2f64 * PI);\n    let mut points: Vec<Point> = Vec::new();\n\n    for _ in 0..n {\n        let root_r = r_range.ind_sample(rng).sqrt();\n        let theta = theta_range.ind_sample(rng);\n        points.push(DVector::<f64>::from_slice(2, &[root_r * theta.cos(), root_r * theta.sin()]));\n    }\n\n    points\n}\n\n// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.\nfn viz(clusters: Vec<Cluster>, stats: Stats, k: usize, n: u32, e: f64) {\n    let mut fg = Figure::new();\n    {\n        let prep = |fg: &mut Figure| {\n            let axes: &mut Axes2D = fg.axes2d();\n            let title: String = format!(\"k = {}, n = {}, e = {:4}\", k, n, e);\n            let centroids_x = stats.centroids.iter().map(|c| c[0]);\n            let centroids_y = stats.centroids.iter().map(|c| c[1]);\n            for cluster in clusters.iter() {\n                axes.points(cluster.members.iter().map(|p| p[0]),\n                            cluster.members\n                                   .iter()\n                                   .map(|p| p[1]),\n                            &[PointSymbol('O'), PointSize(0.25)]);\n            }\n            axes.set_aspect_ratio(Fix(1.0))\n                .points(centroids_x,\n                        centroids_y,\n                        &[PointSymbol('o'), PointSize(1.5), Color(\"black\")])\n                .set_title(&title[..], &[]);\n        };\n        prep(&mut fg);\n    }\n    fg.show();\n}\n\nfn print_dvec(v: &DVector<f64>) {\n    print!(\"(\");\n    for elem in v.at.iter().take(v.len() - 1) {\n        print!(\"{:+1.2}, \", elem)\n    }\n    print!(\"{:+1.2})\", v.at.iter().last().unwrap());\n}\n\nfn print_usage(program: &str, opts: Options) {\n    let brief = format!(\"Usage: {} [options]\", program);\n    print!(\"{}\", opts.usage(&brief));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut k: usize = 7;\n    let mut n: u32 = 30000;\n    let mut e: f64 = 1e-3;\n    let max_iterations = 100u32;\n\n    let mut opts = Options::new();\n    opts.optflag(\"?\", \"help\", \"Print this help menu\");\n    opts.optopt(\"k\",\n                \"\",\n                \"Number of clusters to assign (default: 7)\",\n                \"<clusters>\");\n    opts.optopt(\"n\",\n                \"\",\n                \"Operate on this many points on the unit disk (default: 30000)\",\n                \"<pts>\");\n    opts.optopt(\"e\",\n                \"\",\n                \"Min delta in norm of successive cluster centroids to continue (default: 1e-3)\",\n                \"<eps>\");\n    opts.optopt(\"f\", \"\", \"Read points from file (overrides -n)\", \"<csv>\");\n\n    let program = args[0].clone();\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m) => m,\n        Err(f) => panic!(f.to_string()),\n    };\n    if matches.opt_present(\"?\") {\n        print_usage(&program, opts);\n        return;\n    }\n    match matches.opt_str(\"k\") {\n        None => {}\n        Some(x) => k = x.parse::<usize>().unwrap(),\n    };\n    match matches.opt_str(\"n\") {\n        None => {}\n        Some(x) => n = x.parse::<u32>().unwrap(),\n    };\n    match matches.opt_str(\"e\") {\n        None => {}\n        Some(x) => e = x.parse::<f64>().unwrap(),\n    };\n\n    let seed: &[_] = &[1, 2, 3, 4];\n    let mut rng: StdRng = SeedableRng::from_seed(seed);\n\n    let mut points: Vec<Point>;\n\n    match matches.opt_str(\"f\") {\n        None => {\n            // Proceed with random 2d data\n            points = generate_points(n, &mut rng)\n        }\n        Some(file) => {\n            points = Vec::new();\n            let mut rdr = csv::Reader::from_file(file.clone()).unwrap();\n            for row in rdr.records().map(|r| r.unwrap()) {\n                // row is Vec<String>\n                let floats: Vec<f64> = row.iter().map(|s| s.parse::<f64>().unwrap()).collect();\n                points.push(DVector::<f64>::from_slice(floats.len(), floats.as_slice()));\n            }\n            assert!(points.iter().all(|v| v.len() == points[0].len()));\n            n = points.len() as u32;\n            println!(\"Read {} points from {}\", points.len(), file.clone());\n        }\n    };\n\n    assert!(points.len() >= k);\n    let (clusters, stats) = lloyd(&points, k, e, max_iterations, &mut rng);\n\n    println!(\" k       centroid{}mean dist    pop\",\n             std::iter::repeat(\" \").take((points[0].len() - 2) * 7 + 7).collect::<String>());\n    println!(\"===  {}  ===========  =====\",\n             std::iter::repeat(\"=\").take(points[0].len() * 7 + 2).collect::<String>());\n    for i in 0..clusters.len() {\n        print!(\" {:>1}    \", i);\n        print_dvec(&stats.centroids[i]);\n        print!(\"      {:1.2}       {:>4}\\n\",\n               stats.mean_d_from_centroid[i],\n               clusters[i].members.len());\n    }\n\n    if points[0].len() == 2 {\n        viz(clusters, stats, k, n, e)\n    }\n}\n",
    "title": "K-means++ clustering",
    "url": "http://rosettacode.org/wiki/K-means%2B%2B_clustering"
  },
  {
    "local_code": "extern crate num;\nextern crate permutohedron;\n\nuse num::Float;\nuse permutohedron::Heap;\nuse std::f32;\n\nfn find_max(lst: &[f32]) -> Option<f32> {\n    if lst.is_empty() {\n        return None;\n    }\n    let max = lst.iter().fold(f32::NEG_INFINITY, |a, &b| Float::max(a, b));\n    Some(max)\n}\n\nfn with_bits(val: f32, digits: usize) -> f32 {\n    let num = format!(\"{:.*}\", digits, val);\n    num.parse::<f32>().unwrap()\n}\n\nfn kahan_sum(lst: &[f32]) -> f32 {\n    let mut sum = 0.0_f32;\n    let mut c = 0.0_f32;\n    for i in lst {\n        let y = *i - c;\n        let t = sum + y;\n        c = (t - sum) - y;\n        sum = t;\n    }\n    with_bits(sum, 1)\n}\n\nfn all_sums(vec: &mut [f32]) -> Vec<f32> {\n    let mut res = Vec::new();\n    let mut perms = Heap::new(vec);\n    loop {\n        let v = perms.next();\n        match v {\n            Some(v) => {\n                let mut sum = 0.0_f32;\n                for e in &v {\n                    sum += with_bits(*e, 1);\n                }\n                res.push(with_bits(sum, 1));\n            }\n            None => break,\n        }\n    }\n    res\n}\n\n#[allow(clippy::approx_constant)]\nfn main() {\n    let v = vec![10_000_f32, 3.14159, 2.71828];\n    let sums = all_sums(&mut v.clone());\n    let res = kahan_sum(&v);\n    let max = find_max(&sums[..]).unwrap();\n    println!(\"max: {} res: {}\", max, res);\n}\n\n#[test]\n#[allow(clippy::approx_constant)]\nfn test_kahansum() {\n    let v = vec![10000.0f32, 3.14159, 2.71828];\n    let sums = all_sums(&mut v.clone());\n    let res = kahan_sum(&v);\n    let max = find_max(&sums[..]).unwrap();\n    assert!(max < res);\n}\n\n#[test]\nfn test_withbits() {\n    let v = 3.123345f32;\n    let res = with_bits(v, 3);\n    assert!((res - 3.123f32).abs() < f32::EPSILON);\n}\n",
    "path": "tasks/kahan-summation",
    "remote_code": "\nextern crate num;\nextern crate permutohedron;\n\nuse num::Float;\nuse permutohedron::Heap;\nuse std::f32;\n\nfn find_max(lst: &[f32]) -> Option<f32> {\n    if lst.is_empty() {\n        return None;\n    }\n    let max = lst.iter().fold(f32::NEG_INFINITY, |a, &b| Float::max(a, b));\n    Some(max)\n}\n\nfn with_bits(val: f32, digits: usize) -> f32 {\n    let num = format!(\"{:.*}\", digits, val);\n    num.parse::<f32>().unwrap()\n}\n\nfn kahan_sum(lst: &[f32]) -> Option<f32> {\n    let mut sum = 0.0f32;\n    let mut c = 0.0f32;\n    for i in lst {\n        let y = *i - c;\n        let t = sum + y;\n        c = (t - sum) - y;\n        sum = t;\n    }\n    Some(with_bits(sum, 1))\n}\n\nfn all_sums(vec: &mut [f32]) -> Vec<f32> {\n    let mut res = Vec::new();\n    let mut perms = Heap::new(vec);\n    loop {\n        let v = perms.next();\n        match v {\n            Some(v) => {\n                let mut sum = 0.0f32;\n                for e in &v {\n                    sum += with_bits(*e, 1);\n                }\n                res.push(with_bits(sum, 1));\n            }\n            None => break,\n        }\n    }\n    res\n}\n\n#[allow(clippy::approx_constant)]\nfn main() {\n    let v = vec![10_000f32, 3.14159, 2.71828];\n    let sums = all_sums(&mut v.clone());\n    let res = kahan_sum(&v).unwrap();\n    let max = find_max(&sums[..]).unwrap();\n    println!(\"max: {} res: {}\", max, res);\n}\n\n",
    "title": "Kahan summation",
    "url": "http://rosettacode.org/wiki/Kahan_summation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kaprekar numbers",
    "url": "http://rosettacode.org/wiki/Kaprekar_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() -> Result<(), Box<dyn std::error::Error>> {\n    use std::io::{BufRead, BufReader};\n\n    for line in BufReader::new(std::fs::OpenOptions::new().read(true).open(\"data.txt\")?).lines() {\n        let line = line?;\n\n        let magnitude = line\n            .split_whitespace()\n            .nth(2)\n            .and_then(|it| it.parse::<f32>().ok())\n            .ok_or_else(|| format!(\"Could not parse scale: {}\", line))?;\n\n        if magnitude > 6.0 {\n            println!(\"{}\", line);\n        }\n    }\n\n    Ok(())\n}",
    "title": "Kernighans large earthquake problem",
    "url": "http://rosettacode.org/wiki/Kernighans_large_earthquake_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard input/Flush the keyboard buffer",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Flush_the_keyboard_buffer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard input/Keypress check",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Keypress_check"
  },
  {
    "local_code": "#[cfg(feature = \"ncurses\")]\nextern crate ncurses;\n\n#[cfg(feature = \"ncurses\")]\nfn main() {\n    ncurses::initscr();\n    loop {\n        ncurses::printw(\"Yes or no? \");\n        ncurses::refresh();\n\n        match ncurses::getch() as u8 as char {\n            'Y' | 'y' => {\n                ncurses::printw(\"You said yes!\");\n            }\n            'N' | 'n' => {\n                ncurses::printw(\"You said no!\");\n            }\n            _ => {\n                ncurses::printw(\"Try again!\\n\");\n                continue;\n            }\n        }\n\n        break;\n    }\n\n    ncurses::refresh();\n    ncurses::endwin();\n}\n\n#[cfg(not(feature = \"ncurses\"))]\nfn main() {}\n",
    "path": "tasks/keyboard-input/obtain-a-y-or-n-response",
    "remote_code": "//cargo-deps: ncurses\n\nextern crate ncurses;\nuse ncurses::*;\n\nfn main() {\n    initscr();\n    loop {\n        printw(\"Yes or no? \");\n        refresh();\n\n        match getch() as u8 as char {\n            'Y'|'y' => {printw(\"You said yes!\");},\n            'N'|'n' => {printw(\"You said no!\");},\n            _ => {printw(\"Try again!\\n\"); continue;},\n        }\n        break\n    }\n    refresh();\n    endwin();\n}",
    "title": "Keyboard input/Obtain a Y or N response",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard macros",
    "url": "http://rosettacode.org/wiki/Keyboard_macros"
  },
  {
    "local_code": "use std::cmp::max;\nuse std::iter::repeat;\n\n/// This struct is used to store our items that we want in our knap-sack.\n///\n#[derive(Copy, Clone)]\nstruct Want<'a> {\n    name: &'a str,\n    weight: usize,\n    value: usize,\n}\n\n/// Global, immutable allocation of our items. This is so we can reference\n/// this in multiple functions.\nconst ITEMS: &[Want<'static>] = &[\n    Want {\n        name: \"map\",\n        weight: 9,\n        value: 150,\n    },\n    Want {\n        name: \"compass\",\n        weight: 13,\n        value: 35,\n    },\n    Want {\n        name: \"water\",\n        weight: 153,\n        value: 200,\n    },\n    Want {\n        name: \"sandwich\",\n        weight: 50,\n        value: 160,\n    },\n    Want {\n        name: \"glucose\",\n        weight: 15,\n        value: 60,\n    },\n    Want {\n        name: \"tin\",\n        weight: 68,\n        value: 45,\n    },\n    Want {\n        name: \"banana\",\n        weight: 27,\n        value: 60,\n    },\n    Want {\n        name: \"apple\",\n        weight: 39,\n        value: 40,\n    },\n    Want {\n        name: \"cheese\",\n        weight: 23,\n        value: 30,\n    },\n    Want {\n        name: \"beer\",\n        weight: 52,\n        value: 10,\n    },\n    Want {\n        name: \"suntancream\",\n        weight: 11,\n        value: 70,\n    },\n    Want {\n        name: \"camera\",\n        weight: 32,\n        value: 30,\n    },\n    Want {\n        name: \"T-shirt\",\n        weight: 24,\n        value: 15,\n    },\n    Want {\n        name: \"trousers\",\n        weight: 48,\n        value: 10,\n    },\n    Want {\n        name: \"umbrella\",\n        weight: 73,\n        value: 40,\n    },\n    Want {\n        name: \"waterproof trousers\",\n        weight: 42,\n        value: 70,\n    },\n    Want {\n        name: \"waterproof overclothes\",\n        weight: 43,\n        value: 75,\n    },\n    Want {\n        name: \"note-case\",\n        weight: 22,\n        value: 80,\n    },\n    Want {\n        name: \"sunglasses\",\n        weight: 7,\n        value: 20,\n    },\n    Want {\n        name: \"towel\",\n        weight: 18,\n        value: 12,\n    },\n    Want {\n        name: \"socks\",\n        weight: 4,\n        value: 50,\n    },\n    Want {\n        name: \"book\",\n        weight: 30,\n        value: 10,\n    },\n];\n\n/// This is a bottom-up dynamic programming solution to the 0-1 knap-sack problem.\n///\n/// ```\n/// maximize value\n/// subject to weights <= max_weight\n/// ```\nfn knap_01_dp<'a>(xs: &[Want<'a>], max_weight: usize) -> Vec<Want<'a>> {\n    // Save this value, so we don't have to make repeated calls.\n    let xs_len = xs.len();\n\n    // Imagine we wrote a recursive function(item, max_weight) that returns a\n    // usize corresponding to the maximum cumulative value by considering a\n    // subset of items such that the combined weight <= max_weight.\n    //\n    // fn best_value(item: usize, max_weight: usize) -> usize{\n    //     if item == 0 {\n    //         return 0;\n    //     }\n    //     if xs[item - 1].weight > max_weight {\n    //         return best_value(item - 1, max_weight, xs);\n    //     }\n    //     return max(best_value(item - 1, max_weight, xs),\n    //                best_value(item - 1, max_weight - xs[item - 1].weight, xs)\n    //                + xs[item - 1].value);\n    //     }\n    //\n    // best_value(xs_len, max_weight) is equal to the maximum value that we\n    // can add to the bag.\n    //\n    // The problem with using this function is that it performs redudant\n    // calculations.\n    //\n    // The dynamic programming solution is to precompute all of the values we\n    // need and put them into a 2D array.\n    //\n    // In a similar vein, the top-down solution would be to memoize the\n    // function then compute the results on demand.\n\n    let zero_vec: Vec<usize> = repeat(0).take(max_weight + 1).collect();\n    let mut best_value: Vec<Vec<usize>> = repeat(zero_vec).take(xs_len + 1).collect();\n\n    // loop over the items\n    for i in 0..xs_len {\n        // loop over the weights\n        for w in 1..=max_weight {\n            // do we have room in our knapsack?\n            if xs[i].weight > w {\n                // if we don't, then we'll say that the value doesn't change\n                // when considering this item\n                best_value[i + 1][w] = best_value[i][w];\n            } else {\n                // if we do, then we have to see if the value we gain by adding\n                // the item, given the weight, is better than not adding the item\n                best_value[i + 1][w] = max(\n                    best_value[i][w],\n                    best_value[i][w - xs[i].weight] + xs[i].value,\n                );\n            }\n        }\n    }\n\n    // a variable representing the weight left in the bag\n    let mut left_weight = max_weight;\n\n    // a possibly over-allocated dynamically sized vector to push results to\n    let mut result = Vec::with_capacity(xs_len);\n\n    // we built up the solution space through a forward pass over the data,\n    // now we have to traverse backwards to get the solution\n    for i in (1..=xs_len).rev() {\n        // We can check if an item should be added to the knap-sack by comparing\n        // best_value with and without this item. If best_value added this\n        // item then so should we.\n        if best_value[i][left_weight] != best_value[i - 1][left_weight] {\n            result.push(xs[i - 1]);\n            // we remove the weight of the object from the remaining weight\n            // we can add to the bag\n            left_weight -= xs[i - 1].weight;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let xs = knap_01_dp(ITEMS, 400);\n\n    // Print the items. We have to reverse the order because we solved the\n    // problem backward.\n    for i in xs.iter().rev() {\n        println!(\"Item: {}, Weight: {}, Value: {}\", i.name, i.weight, i.value);\n    }\n\n    // Print the sum of weights.\n    let weights = xs.iter().fold(0, |a, &b| a + b.weight);\n    println!(\"Total Weight: {}\", weights);\n\n    // Print the sum of the values.\n    let values = xs.iter().fold(0, |a, &b| a + b.value);\n    println!(\"Total Value: {}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{knap_01_dp, ITEMS};\n\n    #[test]\n    fn test_dp_results() {\n        let dp_results = knap_01_dp(ITEMS, 400);\n        let dp_weights = dp_results.iter().fold(0, |a, &b| a + b.weight);\n        let dp_values = dp_results.iter().fold(0, |a, &b| a + b.value);\n        assert_eq!(dp_weights, 396);\n        assert_eq!(dp_values, 1030);\n    }\n}\n",
    "path": "tasks/knapsack-problem/_0-1",
    "remote_code": "use std::cmp;\n\nstruct Item {\n    name: &'static str,\n    weight: usize,\n    value: usize\n}\n\nfn knapsack01_dyn(items: &[Item], max_weight: usize) -> Vec<&Item> {\n    let mut best_value = vec![vec![0; max_weight + 1]; items.len() + 1];\n    for (i, it) in items.iter().enumerate() {\n        for w in 1 .. max_weight + 1 {\n            best_value[i + 1][w] =\n                if it.weight > w {\n                    best_value[i][w]\n                } else {\n                    cmp::max(best_value[i][w], best_value[i][w - it.weight] + it.value)\n                }\n        }\n    }\n\n    let mut result = Vec::with_capacity(items.len());\n    let mut left_weight = max_weight;\n\n    for (i, it) in items.iter().enumerate().rev() {\n        if best_value[i + 1][left_weight] != best_value[i][left_weight] {\n            result.push(it);\n            left_weight -= it.weight;\n        }\n    }\n\n    result\n}\n\n\nfn main () {\n    const MAX_WEIGHT: usize = 400;\n\n    const ITEMS: &[Item] = &[\n        Item { name: \"map\",                    weight: 9,   value: 150 },\n        Item { name: \"compass\",                weight: 13,  value: 35 },\n        Item { name: \"water\",                  weight: 153, value: 200 },\n        Item { name: \"sandwich\",               weight: 50,  value: 160 },\n        Item { name: \"glucose\",                weight: 15,  value: 60 },\n        Item { name: \"tin\",                    weight: 68,  value: 45 },\n        Item { name: \"banana\",                 weight: 27,  value: 60 },\n        Item { name: \"apple\",                  weight: 39,  value: 40 },\n        Item { name: \"cheese\",                 weight: 23,  value: 30 },\n        Item { name: \"beer\",                   weight: 52,  value: 10 },\n        Item { name: \"suntancream\",            weight: 11,  value: 70 },\n        Item { name: \"camera\",                 weight: 32,  value: 30 },\n        Item { name: \"T-shirt\",                weight: 24,  value: 15 },\n        Item { name: \"trousers\",               weight: 48,  value: 10 },\n        Item { name: \"umbrella\",               weight: 73,  value: 40 },\n        Item { name: \"waterproof trousers\",    weight: 42,  value: 70 },\n        Item { name: \"waterproof overclothes\", weight: 43,  value: 75 },\n        Item { name: \"note-case\",              weight: 22,  value: 80 },\n        Item { name: \"sunglasses\",             weight: 7,   value: 20 },\n        Item { name: \"towel\",                  weight: 18,  value: 12 },\n        Item { name: \"socks\",                  weight: 4,   value: 50 },\n        Item { name: \"book\",                   weight: 30,  value: 10 }\n    ];\n\n    let items = knapsack01_dyn(ITEMS, MAX_WEIGHT);\n\n    // We reverse the order because we solved the problem backward.\n    for it in items.iter().rev() {\n        println!(\"{}\", it.name);\n    }\n\n    println!(\"Total weight: {}\", items.iter().map(|w| w.weight).sum::<usize>());\n    println!(\"Total value: {}\", items.iter().map(|w| w.value).sum::<usize>());\n}",
    "title": "Knapsack problem/0-1",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/0-1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knapsack problem/Bounded",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Bounded"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let items: [(&str, f32, u8); 9] = [\n        (\"beef\", 3.8, 36),\n        (\"pork\", 5.4, 43),\n        (\"ham\", 3.6, 90),\n        (\"greaves\", 2.4, 45),\n        (\"flitch\", 4.0, 30),\n        (\"brawn\", 2.5, 56),\n        (\"welt\", 3.7, 67),\n        (\"salami\", 3.0, 95),\n        (\"sausage\", 5.9, 98),\n    ];\n    let mut weight: f32 = 15.0;\n    let mut values: Vec<(&str, f32, f32)> = Vec::new();\n    for item in &items {\n        values.push((item.0, f32::from(item.2) / item.1, item.1));\n    }\n\n    values.sort_by(|a, b| (a.1).partial_cmp(&b.1).unwrap());\n    values.reverse();\n\n    for choice in values {\n        if choice.2 <= weight {\n            println!(\"Grab {:.1} kgs of {}\", choice.2, choice.0);\n            weight -= choice.2;\n            if (choice.2 - weight).abs() < std::f32::EPSILON {\n                return;\n            }\n        } else {\n            println!(\"Grab {:.1} kgs of {}\", weight, choice.0);\n            return;\n        }\n    }\n}",
    "title": "Knapsack problem/Continuous",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Continuous"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knapsack problem/Unbounded",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Unbounded"
  },
  {
    "local_code": "use std::fmt;\n\nconst SIZE: usize = 8;\nconst MOVES: [(i32, i32); 8] = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n];\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn mov(&self, &(dx, dy): &(i32, i32)) -> Point {\n        Point {\n            x: self.x + dx,\n            y: self.y + dy,\n        }\n    }\n}\n\nstruct Board {\n    field: [[i32; SIZE]; SIZE],\n}\n\nimpl Board {\n    fn new() -> Board {\n        Board {\n            field: [[0; SIZE]; SIZE],\n        }\n    }\n\n    fn available(&self, p: Point) -> bool {\n        let valid = 0 <= p.x && p.x < SIZE as i32 && 0 <= p.y && p.y < SIZE as i32;\n\n        valid && self.field[p.x as usize][p.y as usize] == 0\n    }\n\n    /// calculate the number of possible moves\n    fn count_degree(&self, p: Point) -> i32 {\n        let mut count = 0;\n        for dir in &MOVES {\n            let next = p.mov(dir);\n            if self.available(next) {\n                count += 1;\n            }\n        }\n        count\n    }\n}\n\nimpl Default for Board {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.field {\n            for x in row.iter() {\n                write!(f, \"{:3} \", x)?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}\n\nfn knights_tour(x: i32, y: i32) -> Option<Board> {\n    let mut board = Board::new();\n    let mut p = Point { x, y };\n    let mut step = 1;\n\n    board.field[p.x as usize][p.y as usize] = step;\n    step += 1;\n\n    while step <= (SIZE * SIZE) as i32 {\n        // choose next square by Warnsdorf's rule\n        let mut candidates = vec![];\n\n        for dir in &MOVES {\n            let adj = p.mov(dir);\n            if board.available(adj) {\n                let degree = board.count_degree(adj);\n                candidates.push((degree, adj));\n            }\n        }\n\n        match candidates.iter().min() {\n            Some(&(_, adj)) => p = adj,\n            None => return None,\n        };\n\n        board.field[p.x as usize][p.y as usize] = step;\n        step += 1;\n    }\n\n    Some(board)\n}\n\nfn main() {\n    let (x, y) = (3, 1);\n\n    println!(\"Board size: {}\", SIZE);\n    println!(\"Starting position: ({}, {})\", x, y);\n\n    match knights_tour(x, y) {\n        Some(b) => print!(\"{}\", b),\n        None => println!(\"Fail!\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{knights_tour, SIZE};\n\n    const ANSWER: [[i32; SIZE]; SIZE] = [\n        [23, 20, 3, 32, 25, 10, 5, 8],\n        [2, 33, 24, 21, 4, 7, 26, 11],\n        [19, 22, 51, 34, 31, 28, 9, 6],\n        [50, 1, 40, 29, 54, 35, 12, 27],\n        [41, 18, 55, 52, 61, 30, 57, 36],\n        [46, 49, 44, 39, 56, 53, 62, 13],\n        [17, 42, 47, 60, 15, 64, 37, 58],\n        [48, 45, 16, 43, 38, 59, 14, 63],\n    ];\n\n    #[test]\n    fn test() {\n        let (x, y) = (3, 1);\n        match knights_tour(x, y) {\n            Some(b) => assert_eq!(b.field, ANSWER),\n            None => panic!(),\n        }\n    }\n}\n",
    "path": "tasks/knights-tour",
    "remote_code": "use std::fmt;\n\nconst SIZE: usize = 8;\nconst MOVES: [(i32, i32); 8] = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n];\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn mov(&self, &(dx, dy): &(i32, i32)) -> Self {\n        Self {\n            x: self.x + dx,\n            y: self.y + dy,\n        }\n    }\n}\n\nstruct Board {\n    field: [[i32; SIZE]; SIZE],\n}\n\nimpl Board {\n    fn new() -> Self {\n        Self {\n            field: [[0; SIZE]; SIZE],\n        }\n    }\n\n    fn available(&self, p: Point) -> bool {\n        0 <= p.x\n            && p.x < SIZE as i32\n            && 0 <= p.y\n            && p.y < SIZE as i32\n            && self.field[p.x as usize][p.y as usize] == 0\n    }\n\n    // calculate the number of possible moves\n    fn count_degree(&self, p: Point) -> i32 {\n        let mut count = 0;\n        for dir in MOVES.iter() {\n            let next = p.mov(dir);\n            if self.available(next) {\n                count += 1;\n            }\n        }\n        count\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in self.field.iter() {\n            for x in row.iter() {\n                write!(f, \"{:3} \", x)?;\n            }\n            write!(f, \"\\n\")?;\n        }\n        Ok(())\n    }\n}\n\nfn knights_tour(x: i32, y: i32) -> Option<Board> {\n    let mut board = Board::new();\n    let mut p = Point { x: x, y: y };\n    let mut step = 1;\n    board.field[p.x as usize][p.y as usize] = step;\n    step += 1;\n\n    while step <= (SIZE * SIZE) as i32 {\n        // choose next square by Warnsdorf's rule\n        let mut candidates = vec![];\n        for dir in MOVES.iter() {\n            let adj = p.mov(dir);\n            if board.available(adj) {\n                let degree = board.count_degree(adj);\n                candidates.push((degree, adj));\n            }\n        }\n        match candidates.iter().min() {\n            // move to next square\n            Some(&(_, adj)) => p = adj,\n            // can't move\n            None => return None,\n        };\n        board.field[p.x as usize][p.y as usize] = step;\n        step += 1;\n    }\n    Some(board)\n}\n\nfn main() {\n    let (x, y) = (3, 1);\n    println!(\"Board size: {}\", SIZE);\n    println!(\"Starting position: ({}, {})\", x, y);\n    match knights_tour(x, y) {\n        Some(b) => print!(\"{}\", b),\n        None => println!(\"Fail!\"),\n    }\n}",
    "title": "Knight's tour",
    "url": "http://rosettacode.org/wiki/Knight's_tour"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\n// Since you're probably already using the `rand` crate, you should just use\n// `rand::Rng::shuffle`.\nfn knuth_shuffle<T>(rng: &mut impl Rng, v: &mut [T]) {\n    let l = v.len();\n\n    for n in 0..l {\n        let i = rng.gen_range(0, l - n);\n        v.swap(i, l - n - 1);\n    }\n}\n\nfn main() {\n    let mut v: Vec<_> = (0..10).collect();\n    let mut rng = rand::thread_rng();\n\n    println!(\"before: {:?}\", v);\n    knuth_shuffle(&mut rng, &mut v);\n    println!(\"after:  {:?}\", v);\n}\n",
    "path": "tasks/knuth-shuffle",
    "remote_code": "use rand::Rng;\n\nextern crate rand;\n\nfn knuth_shuffle<T>(v: &mut [T]) {\n    let mut rng = rand::thread_rng();\n    let l = v.len();\n\n    for n in 0..l {\n        let i = rng.gen_range(0, l - n);\n        v.swap(i, l - n - 1);\n    }\n}\n\nfn main() {\n    let mut v: Vec<_> = (0..10).collect();\n\n    println!(\"before: {:?}\", v);\n    knuth_shuffle(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Knuth shuffle",
    "url": "http://rosettacode.org/wiki/Knuth_shuffle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{Rng,weak_rng};\n\nstruct SofN<R: Rng+Sized, T> {\n    rng: R,\n    sample: Vec<T>,\n    i: usize,\n    n: usize,\n}\n\nimpl<R: Rng, T> SofN<R, T> {\n    fn new(rng: R, n: usize) -> Self {\n        SofN{rng, sample: Vec::new(), i: 0, n}\n    }\n\n    fn add(&mut self, item: T) {\n        self.i += 1;\n        if self.i <= self.n {\n            self.sample.push(item);\n        } else if self.rng.gen_range(0, self.i) < self.n {\n            self.sample[self.rng.gen_range(0, self.n)] = item;\n        }\n    }\n\n    fn sample(&self) -> &Vec<T> {\n        &self.sample\n    }\n}\n\n\npub fn main() {\n    const MAX: usize = 10;\n    let mut bin: [i32; MAX] = Default::default();\n    for _ in 0..100000 {\n        let mut s_of_n = SofN::new(weak_rng(), 3);\n        \n        for i in 0..MAX { s_of_n.add(i); }\n\n        for s in s_of_n.sample() {\n            bin[*s] += 1;\n        }\n    }\n    \n    for (i, x) in bin.iter().enumerate() {\n        println!(\"frequency of {}: {}\", i, x);\n    }\n}",
    "title": "Knuth's algorithm S",
    "url": "http://rosettacode.org/wiki/Knuth's_algorithm_S"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knuth's power tree",
    "url": "http://rosettacode.org/wiki/Knuth's_power_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nuse svg::node::element::path::Data;\nuse svg::node::element::Path;\nuse svg::node::element::Rectangle;\n\nconst SQRT3_2: f64 = 0.86602540378444;\n\nfn koch_curve(mut data: Data, x0: f64, y0: f64, x1: f64, y1: f64, order: usize) -> Data {\n    if order == 0 {\n        data = data.line_to((x1, y1));\n    } else {\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n        let x2 = x0 + dx / 3.0;\n        let y2 = y0 + dy / 3.0;\n        let x3 = x0 + dx / 2.0 - dy * SQRT3_2 / 3.0;\n        let y3 = y0 + dy / 2.0 + dx * SQRT3_2 / 3.0;\n        let x4 = x0 + 2.0 * dx / 3.0;\n        let y4 = y0 + 2.0 * dy / 3.0;\n        data = koch_curve(data, x0, y0, x2, y2, order - 1);\n        data = koch_curve(data, x2, y2, x3, y3, order - 1);\n        data = koch_curve(data, x3, y3, x4, y4, order - 1);\n        data = koch_curve(data, x4, y4, x1, y1, order - 1);\n    }\n    data\n}\n\nfn write_koch_snowflake(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n    let length = (size as f64) * SQRT3_2 * 0.95;\n    let x0 = ((size as f64) - length) / 2.0;\n    let y0 = (size as f64) / 2.0 - length * SQRT3_2 / 3.0;\n    let x1 = x0 + length / 2.0;\n    let y1 = y0 + length * SQRT3_2;\n    let x2 = x0 + length;\n\n    let mut data = Data::new().move_to((x0, y0));\n    data = koch_curve(data, x0, y0, x1, y1, order);\n    data = koch_curve(data, x1, y1, x2, y0, order);\n    data = koch_curve(data, x2, y0, x0, y0, order);\n\n    let path = Path::new()\n        .set(\"fill\", \"none\")\n        .set(\"stroke\", \"white\")\n        .set(\"stroke-width\", \"1\")\n        .set(\"d\", data);\n\n    let rect = Rectangle::new()\n        .set(\"width\", \"100%\")\n        .set(\"height\", \"100%\")\n        .set(\"fill\", \"black\");\n\n    let document = svg::Document::new()\n        .set(\"width\", size)\n        .set(\"height\", size)\n        .add(rect)\n        .add(path);\n\n    svg::save(file, &document)\n}\n\nfn main() {\n    write_koch_snowflake(\"koch_snowflake.svg\", 600, 5).unwrap();\n}",
    "title": "Koch curve",
    "url": "http://rosettacode.org/wiki/Koch_curve"
  },
  {
    "local_code": "// extern crate itertools;\nuse itertools::Itertools;\n\nfn get_kolakoski_sequence(iseq: &[usize], size: &usize) -> Vec<usize> {\n    assert!(*size > 0);\n    assert!(!iseq.is_empty());\n\n    let mut kseq: Vec<usize> = Vec::default();\n\n    // create an itertor which keeps repeating the initial sequence infinitely\n    let repeater = iseq.iter().cloned().cycle();\n\n    // push the very first element, repeated as many times as the number\n    kseq.extend_from_slice(&vec![*iseq.get(0).unwrap()].repeat(*iseq.get(0).unwrap()));\n\n    //start cycling throught the initial sequence, but skip the very first one\n    for (k_counter, elem) in repeater.enumerate().skip(1) {\n        // push the given element\n        kseq.push(elem);\n\n        // and repeat the current element as many times\n        // as it's needed based on the previous elements\n        kseq.extend_from_slice(&vec![elem].repeat(*kseq.get(k_counter).unwrap() - 1));\n\n        // finish generation when the Kolakoski sequence has reached the given length\n        if kseq.len() >= *size {\n            break;\n        }\n    }\n\n    // truncate it as it might have more elements than needed\n    kseq[0..*size].to_vec()\n}\n\nfn is_kolakoski(kseq: &[usize]) -> bool {\n    assert!(!kseq.is_empty());\n\n    // calculate the RLE\n    let rle: Vec<usize> = kseq\n        .iter()\n        .batching(|it| {\n            it.next()\n                .map(|v| it.take_while_ref(|&v2| v2 == v).count() + 1)\n        })\n        .collect();\n\n    rle.iter().zip(kseq).filter(|&(a, b)| a == b).count() == rle.len()\n}\n\nfn main() {\n    let lengths = vec![20, 20, 30, 30];\n    let seqs = vec![vec![1, 2], vec![2, 1], vec![1, 3, 1, 2], vec![1, 3, 2, 1]];\n\n    for (seq, length) in seqs.iter().zip(&lengths) {\n        let kseq = get_kolakoski_sequence(seq, length);\n\n        println!(\"Starting sequence: {:?}\", seq);\n        println!(\"Kolakoski sequence: {:?}\", kseq);\n        println!(\"Possible Kolakoski sequence? {:?}\", is_kolakoski(&kseq));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{get_kolakoski_sequence, is_kolakoski};\n\n    #[test]\n    fn test_get_kolakoski_sequence() {\n        let input = vec![1, 2];\n        let output = get_kolakoski_sequence(&input, &10);\n        assert_eq!(output, vec![1, 2, 2, 1, 1, 2, 1, 2, 2, 1]);\n\n        let input = vec![2, 1];\n        let output = get_kolakoski_sequence(&input, &10);\n        assert_eq!(output, vec![2, 2, 1, 1, 2, 1, 2, 2, 1, 2]);\n\n        let input = vec![1, 3, 2, 1];\n        let output = get_kolakoski_sequence(&input, &10);\n        assert_eq!(output, vec![1, 3, 3, 3, 2, 2, 2, 1, 1, 1]);\n    }\n\n    #[test]\n    fn test_is_kolakoski() {\n        let input = vec![1, 2, 2, 1, 1, 2, 1, 2, 2, 1];\n        assert_eq!(is_kolakoski(&input), true);\n\n        let input = vec![2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2];\n        assert_eq!(is_kolakoski(&input), true);\n\n        let input = vec![1, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 2, 2, 1, 1, 3, 2];\n        assert_eq!(is_kolakoski(&input), false);\n    }\n}\n",
    "path": "tasks/kolakoski-sequence",
    "remote_code": "\nuse itertools::Itertools;\n\nfn get_kolakoski_sequence(iseq: &[usize], size: &usize) -> Vec<usize> {\n    assert!(*size > 0);\n    assert!(!iseq.is_empty());\n\n    let mut kseq: Vec<usize> = Vec::default();\n\n    // create an itertor which keeps repeating the initial sequence infinitely\n    let repeater = iseq.iter().cloned().cycle();\n\n    // push the very first element, repeated as many times as the number\n    kseq.extend_from_slice(&vec![*iseq.get(0).unwrap()].repeat(*iseq.get(0).unwrap()));\n\n    //start cycling throught the initial sequence, but skip the very first one\n    for (k_counter, elem) in repeater.enumerate().skip(1) {\n        // push the given element\n        kseq.push(elem);\n\n        // and repeat the current element as many times\n        // as it's needed based on the previous elements\n        kseq.extend_from_slice(&vec![elem].repeat(*kseq.get(k_counter).unwrap() - 1));\n\n        // finish generation when the Kolakoski sequence has reached the given length\n        if kseq.len() >= *size {\n            break;\n        }\n    }\n\n    // truncate it as it might have more elements than needed\n    kseq[0..*size].to_vec()\n}\n\nfn is_kolakoski(kseq: &[usize]) -> bool {\n    assert!(!kseq.is_empty());\n\n    // calculate the RLE\n    let rle: Vec<usize> = kseq\n        .iter()\n        .batching(|it| {\n            it.next()\n                .map(|v| it.take_while_ref(|&v2| v2 == v).count() + 1)\n        })\n        .collect();\n\n    rle.iter().zip(kseq).filter(|&(a, b)| a == b).count() == rle.len()\n}\n\nfn main() {\n    let lengths = vec![20, 20, 30, 30];\n    let seqs = vec![vec![1, 2], vec![2, 1], vec![1, 3, 1, 2], vec![1, 3, 2, 1]];\n\n    for (seq, length) in seqs.iter().zip(&lengths) {\n        let kseq = get_kolakoski_sequence(&seq, length);\n\n        println!(\"Starting sequence: {:?}\", seq);\n        println!(\"Kolakoski sequence: {:?}\", kseq);\n        println!(\"Possible Kolakoski sequence? {:?}\", is_kolakoski(&kseq));\n    }\n}\n",
    "title": "Kolakoski sequence",
    "url": "http://rosettacode.org/wiki/Kolakoski_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kosaraju",
    "url": "http://rosettacode.org/wiki/Kosaraju"
  },
  {
    "local_code": "use ndarray::prelude::*;\nuse ndarray::Data;\nuse ndarray::Zip;\n\nuse num::traits::Zero;\nuse std::ops::Mul;\n\n// works only for 2D arrays\nfn kronecker_product<S, T>(a: &ArrayBase<S, Ix2>, b: &ArrayBase<S, Ix2>) -> Array<T, Ix2>\nwhere\n    T: Copy + Zero + Mul<Output = T>,\n    S: Data<Elem = T>,\n{\n    // create an empty array to hold the results\n    let mut res: Array2<T> = Array2::zeros(Dim([\n        a.raw_dim()[0] * b.raw_dim()[0],\n        a.raw_dim()[1] * b.raw_dim()[1],\n    ]));\n\n    // break down the result array into chunks\n    // according to the second array\n    let res_chunks = res.exact_chunks_mut((b.raw_dim()[0], b.raw_dim()[1]));\n\n    // fill in the product of the two cells\n    Zip::from(res_chunks).and(a).apply(|res_chunk, &a_elem| {\n        Zip::from(b).apply_assign_into(res_chunk, |&b_elem| a_elem * b_elem)\n    });\n\n    res\n}\n\nfn main() {\n    let a = array![[1, 2], [3, 4]];\n    let b = array![[0, 5], [6, 7]];\n\n    let res = kronecker_product(&a, &b);\n    println!(\"RESULT:\\n{}\", res);\n\n    let a = array![[0, 1, 0], [1, 1, 1], [0, 1, 0]];\n    let b = array![[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]];\n\n    let res = kronecker_product(&a, &b);\n    println!(\"RESULT:\\n{}\", res);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::kronecker_product;\n    use ::ndarray::prelude::*;\n\n    #[test]\n    fn test_kronecker_product() {\n        let a = array![[1, 2], [3, 4]];\n        let b = array![[0, 5], [6, 7]];\n\n        assert_eq!(\n            kronecker_product(&a, &b),\n            array![\n                [0, 5, 0, 10],\n                [6, 7, 12, 14],\n                [0, 15, 0, 20],\n                [18, 21, 24, 28]\n            ]\n        );\n\n        let a = array![[1, 2], [3, 4]];\n        let b = array![[0, 5, 1], [6, 7, 2]];\n\n        assert_eq!(\n            kronecker_product(&a, &b),\n            array![\n                [0, 5, 1, 0, 10, 2],\n                [6, 7, 2, 12, 14, 4],\n                [0, 15, 3, 0, 20, 4],\n                [18, 21, 6, 24, 28, 8]\n            ]\n        );\n    }\n}\n",
    "path": "tasks/kronecker-product",
    "remote_code": "fn main() {\n\n    let mut a = vec![vec![1., 2.], vec![3., 4.]];\n    let mut b = vec![vec![0., 5.], vec![6., 7.]];\n\n    let mut a_ref = &mut a;\n    let a_rref = &mut a_ref;\n\n    let mut b_ref = &mut b;\n    let b_rref = &mut b_ref;\n\n    let ab = kronecker_product(a_rref, b_rref);\n\n    println!(\"Kronecker product of\\n\");\n    for i in a {\n        println!(\"{:?}\", i);\n    }\n    println!(\"\\nand\\n\");\n    for i in b {\n        println!(\"{:?}\", i);\n    }\n    println!(\"\\nis\\n\");\n    for i in ab {\n        println!(\"{:?}\", i);\n    }\n\n    println!(\"\\n\\n\");\n\n    let mut a = vec![vec![0., 1., 0.],\n                    vec![1., 1., 1.],\n                    vec![0., 1., 0.]];\n    let mut b = vec![vec![1., 1., 1., 1.],\n                    vec![1., 0., 0., 1.],\n                    vec![1., 1., 1., 1.]];\n\n    let mut a_ref = &mut a;\n    let a_rref = &mut a_ref;\n\n    let mut b_ref = &mut b;\n    let b_rref = &mut b_ref;\n\n    let ab = kronecker_product(a_rref, b_rref);\n\n    println!(\"Kronecker product of\\n\");\n    for i in a {\n        println!(\"{:?}\", i);\n    }\n    println!(\"\\nand\\n\");\n    for i in b {\n        println!(\"{:?}\", i);\n    }\n    println!(\"\\nis\\n\");\n    for i in ab {\n        println!(\"{:?}\", i);\n    }\n\n    println!(\"\\n\\n\");\n\n}\n\nfn kronecker_product(a: &mut Vec<Vec<f64>>, b: &mut Vec<Vec<f64>>) -> Vec<Vec<f64>> {\n    let m = a.len();\n    let n = a[0].len();\n    let p = b.len();\n    let q = b[0].len();\n    let rtn = m * p;\n    let ctn = n * q;\n\n    let mut r = zero_matrix(rtn, ctn);\n\n    for i in 0..m {\n        for j in 0..n {\n            for k in 0..p {\n                for l in 0..q {\n                    r[p * i + k][q * j + l] = a[i][j] * b[k][l];\n                }\n            }\n        }\n    }\n    r\n}\n\nfn zero_matrix(rows: usize, cols: usize) -> Vec<Vec<f64>> {\n    let mut matrix = Vec::with_capacity(cols);\n    for _ in 0..rows {\n        let mut col: Vec<f64> = Vec::with_capacity(rows);\n        for _ in 0..cols {\n            col.push(0.0);\n        }\n        matrix.push(col);\n    }\n    matrix\n}\n",
    "title": "Kronecker product",
    "url": "http://rosettacode.org/wiki/Kronecker_product"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    fmt::{Debug, Display, Write},\n    ops::Mul,\n};\n\n// Rust has (almost) no built-in support for multi-dimensional arrays or so.\n// Let's make a basic one ourselves for our use cases.\n\n#[derive(Clone, Debug)]\npub struct Mat<T> {\n    col_count: usize,\n    row_count: usize,\n    items: Vec<T>,\n}\n\nimpl<T> Mat<T> {\n    pub fn from_vec(items: Vec<T>, col_count: usize, row_count: usize) -> Self {\n        assert_eq!(items.len(), col_count * row_count, \"mismatching dimensions\");\n\n        Self {\n            col_count,\n            row_count,\n            items,\n        }\n    }\n\n    pub fn row_count(&self) -> usize {\n        self.row_count\n    }\n\n    pub fn col_count(&self) -> usize {\n        self.col_count\n    }\n\n    pub fn iter(&self) -> impl Iterator<Item = &T> {\n        self.items.iter()\n    }\n\n    pub fn row_iter(&self, row: usize) -> impl Iterator<Item = &T> {\n        assert!(row < self.row_count, \"index out of bounds\");\n        let start = row * self.col_count;\n        self.items[start..start + self.col_count].iter()\n    }\n\n    pub fn col_iter(&self, col: usize) -> impl Iterator<Item = &T> {\n        assert!(col < self.col_count, \"index out of bounds\");\n        self.items.iter().skip(col).step_by(self.col_count)\n    }\n}\n\nimpl<T: Display> Display for Mat<T> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        // Compute the width of the widest item first\n        let mut len = 0usize;\n        let mut buf = String::new();\n        for item in (0..self.row_count).flat_map(|row| self.row_iter(row)) {\n            buf.clear();\n            write!(buf, \"{}\", item)?;\n            len = std::cmp::max(len, buf.chars().count());\n        }\n\n        // Then render the matrix with proper padding\n\n        len += 1; // To separate cells\n        let width = len * self.col_count + 1;\n        writeln!(f, \"┌{:width$}┐\", \"\", width = width)?;\n\n        for row in (0..self.row_count).map(|row| self.row_iter(row)) {\n            write!(f, \"│\")?;\n\n            for item in row {\n                write!(f, \"{:>width$}\", item, width = len)?;\n            }\n\n            writeln!(f, \" │\")?;\n        }\n\n        write!(f, \"└{:width$}┘\", \"\", width = width)\n    }\n}\n\n// Rust standard libraries have no graphics support. If we want to render\n// an image, we can write, e.g., a PPM file.\n\nimpl<T> Mat<T> {\n    pub fn write_ppm(\n        &self,\n        f: &mut dyn std::io::Write,\n        rgb: impl Fn(&T) -> (u8, u8, u8),\n    ) -> std::io::Result<()> {\n        let bytes = self\n            .iter()\n            .map(rgb)\n            .flat_map(|(r, g, b)| {\n                use std::iter::once;\n                once(r).chain(once(g)).chain(once(b))\n            })\n            .collect::<Vec<u8>>();\n\n        write!(f, \"P6\\n{} {}\\n255\\n\", self.col_count, self.row_count)?;\n        f.write_all(&bytes)\n    }\n}\n\nmod kronecker {\n\n    use super::Mat;\n    use std::ops::Mul;\n\n    // Look ma, no numbers! We can combine anything with Mul (see later)\n\n    pub fn product<T, U>(a: &Mat<T>, b: &Mat<U>) -> Mat<<T as Mul<U>>::Output>\n    where\n        T: Clone + Mul<U>,\n        U: Clone,\n    {\n        let row_count = a.row_count() * b.row_count();\n        let col_count = a.col_count() * b.col_count();\n        let mut items = Vec::with_capacity(row_count * col_count);\n\n        for i in 0..a.row_count() {\n            for k in 0..b.row_count() {\n                for a_x in a.row_iter(i) {\n                    for b_x in b.row_iter(k) {\n                        items.push(a_x.clone() * b_x.clone());\n                    }\n                }\n            }\n        }\n\n        Mat::from_vec(items, col_count, row_count)\n    }\n\n    pub fn power<T>(m: &Mat<T>, n: u32) -> Mat<T>\n    where\n        T: Clone + Mul<T, Output = T>,\n    {\n        match n {\n            0 => m.clone(),\n            _ => (1..n).fold(product(&m, &m), |result, _| product(&result, &m)),\n        }\n    }\n}\n\n// Here we make a char-like type with Mul implementation.\n// We can do fancy things with that later.\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\nstruct Char(char);\n\nimpl Char {\n    fn space() -> Self {\n        Char(' ')\n    }\n\n    fn is_space(&self) -> bool {\n        self.0 == ' '\n    }\n}\n\nimpl Display for Char {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        Display::fmt(&self.0, f)\n    }\n}\n\nimpl Mul for Char {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Self) -> Self {\n        if self.is_space() || rhs.is_space() {\n            Char(' ')\n        } else {\n            self\n        }\n    }\n}\n\nfn main() -> std::io::Result<()> {\n\n    // Vicsek rendered in numbers\n\n    #[rustfmt::skip]\n    let vicsek = Mat::<u8>::from_vec(vec![\n        0, 1, 0,\n        1, 1, 1,\n        0, 1, 0,\n    ], 3, 3);\n\n    println!(\"{}\", vicsek);\n    println!(\"{}\", kronecker::power(&vicsek, 3));\n\n    // We could render something by mapping the numbers to\n    // something else. But we could compute with something\n    // else directly, right?\n    let s = Char::space();\n    let b = Char('\\u{2588}');\n\n    #[rustfmt::skip]\n    let sierpienski = Mat::from_vec(vec![\n        b, b, b,\n        b, s, b,\n        b, b, b,\n    ], 3, 3);\n\n    println!(\"{}\", sierpienski);\n    println!(\"{}\", kronecker::power(&sierpienski, 3));\n\n    #[rustfmt::skip]\n    let matrix = Mat::from_vec(vec![\n        s, s, b, s, s,\n        s, b, b, b, s,\n        b, s, b, s, b,\n        s, s, b, s, s,\n        s, b, s, b, s,\n    ], 5, 5,);\n\n    println!(\"{}\", kronecker::power(&matrix, 1));\n\n    // This is nicer as an actual image\n    kronecker::power(&matrix, 4).write_ppm(\n        &mut std::fs::OpenOptions::new()\n            .write(true)\n            .create(true)\n            .truncate(true)\n            .open(\"kronecker_power.ppm\")?,\n        |&item| {\n            if item.is_space() {\n                (0, 0, 32)\n            } else {\n                (192, 192, 0)\n            }\n        },\n    )\n}\n",
    "title": "Kronecker product based fractals",
    "url": "http://rosettacode.org/wiki/Kronecker_product_based_fractals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#![allow(non_snake_case)]\nuse ndarray::{Array, Axis, Array2, arr2, Zip, NdFloat, s};\n\nfn main() {\n    println!(\"Example 1:\");\n    let A: Array2<f64> = arr2(&[\n        [1.0, 3.0, 5.0],\n        [2.0, 4.0, 7.0],\n        [1.0, 1.0, 0.0],\n    ]);\n    println!(\"A \\n {}\", A);\n    let (L, U, P) = lu_decomp(A);\n    println!(\"L \\n {}\", L);\n    println!(\"U \\n {}\", U);\n    println!(\"P \\n {}\", P);\n\n    println!(\"\\nExample 2:\");\n    let A: Array2<f64> = arr2(&[\n        [11.0, 9.0, 24.0, 2.0],\n        [1.0, 5.0, 2.0, 6.0],\n        [3.0, 17.0, 18.0, 1.0],\n        [2.0, 5.0, 7.0, 1.0],\n    ]);\n    println!(\"A \\n {}\", A);\n    let (L, U, P) = lu_decomp(A);\n    println!(\"L \\n {}\", L);\n    println!(\"U \\n {}\", U);\n    println!(\"P \\n {}\", P);\n}\n\nfn pivot<T>(A: &Array2<T>) -> Array2<T>\nwhere T: NdFloat {\n    let matrix_dimension = A.rows();\n    let mut P: Array2<T> = Array::eye(matrix_dimension);\n    for (i, column) in A.axis_iter(Axis(1)).enumerate() {\n        // find idx of maximum value in column i\n        let mut max_pos = i;\n        for j in i..matrix_dimension {\n            if column[max_pos].abs() < column[j].abs() {\n                max_pos = j;\n            }\n        }\n        // swap rows of P if necessary\n        if max_pos != i {\n            swap_rows(&mut P, i, max_pos);\n        }\n    }\n    P\n}\n\nfn swap_rows<T>(A: &mut Array2<T>, idx_row1: usize, idx_row2: usize)\nwhere T: NdFloat {\n    // to swap rows, get two ArrayViewMuts for the corresponding rows\n    // and apply swap elementwise using ndarray::Zip\n    let (.., mut matrix_rest) = A.view_mut().split_at(Axis(0), idx_row1);\n    let (row0, mut matrix_rest) = matrix_rest.view_mut().split_at(Axis(0), 1);\n    let (_matrix_helper, mut matrix_rest) = matrix_rest.view_mut().split_at(Axis(0), idx_row2 - idx_row1 - 1);\n    let (row1, ..) = matrix_rest.view_mut().split_at(Axis(0), 1);\n    Zip::from(row0).and(row1).apply(std::mem::swap);\n}\n\nfn lu_decomp<T>(A: Array2<T>) -> (Array2<T>, Array2<T>, Array2<T>)\nwhere T: NdFloat {\n\n    let matrix_dimension = A.rows();\n    assert_eq!(matrix_dimension, A.cols(), \"Tried LU decomposition with a non-square matrix.\");\n    let P = pivot(&A);\n    let pivotized_A = P.dot(&A);\n\n    let mut L: Array2<T> = Array::eye(matrix_dimension);\n    let mut U: Array2<T> = Array::zeros((matrix_dimension, matrix_dimension));\n    for idx_col in 0..matrix_dimension {\n        // fill U\n        for idx_row in 0..idx_col+1 {\n            U[[idx_row, idx_col]] = pivotized_A[[idx_row, idx_col]] -\n                U.slice(s![0..idx_row,idx_col]).dot(&L.slice(s![idx_row,0..idx_row]));\n        }\n        // fill L\n        for idx_row in idx_col+1..matrix_dimension {\n            L[[idx_row, idx_col]] = (pivotized_A[[idx_row, idx_col]] -\n                U.slice(s![0..idx_col,idx_col]).dot(&L.slice(s![idx_row,0..idx_col]))) /\n                U[[idx_col, idx_col]];\n        }\n    }\n    (L, U, P)\n}\n",
    "title": "LU decomposition",
    "url": "http://rosettacode.org/wiki/LU_decomposition"
  },
  {
    "local_code": "use std::collections::hash_map::HashMap;\n\n/// Compress using LZW\nfn compress(original_str: &str) -> Vec<i32> {\n    let original = original_str.as_bytes();\n    let mut dict_size = 256;\n    let mut dictionary = HashMap::new();\n\n    for i in 0i32..dict_size {\n        dictionary.insert(vec![i as u8], i);\n    }\n\n    let mut result = vec![];\n    let mut w = vec![];\n    for &c in original {\n        let mut wc = w.clone();\n        wc.push(c);\n\n        match dictionary.get(&wc) {\n            Some(_) => w = wc,\n            None => {\n                result.push(dictionary[&w]);\n                dictionary.insert(wc, dict_size);\n                dict_size += 1;\n                w = vec![c];\n            }\n        }\n    }\n\n    if !w.is_empty() {\n        result.push(dictionary[&w]);\n    }\n\n    result\n}\n\n/// Decompress using LZW\nfn decompress(compressed: &[i32]) -> String {\n    let mut dict_size = 256;\n    let mut dictionary = HashMap::new();\n\n    for i in 0i32..dict_size {\n        dictionary.insert(i, vec![i as u8]);\n    }\n\n    let mut w = vec![compressed[0] as u8];\n    let compressed = &compressed[1..];\n    let mut result = w.clone();\n    for &k in compressed {\n        let entry = match dictionary.get(&k) {\n            Some(v) => v.clone(),\n            None if k == dict_size => {\n                let mut new = w.clone();\n                new.push(w[0]);\n                new\n            }\n            None => panic!(\"Invalid compressed string\"),\n        };\n\n        result.extend(entry.iter().cloned());\n        w.push(entry[0]);\n        dictionary.insert(dict_size, w);\n        dict_size += 1;\n        w = entry;\n    }\n\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    // Show original\n    let original = \"TOBEORNOTTOBEORTOBEORNOT\";\n    println!(\"Original: {}\", original);\n\n    // Show compressed\n    let compressed = compress(original);\n    println!(\"Compressed: {:?}\", compressed);\n\n    // Show decompressed\n    let decompressed = decompress(&compressed[..]);\n    println!(\"Decompressed: {}\", &decompressed[..]);\n}\n\n#[test]\nfn test_coherence() {\n    for s in (50000i32..50100).map(|n| n.to_string()) {\n        let s = &s[..];\n        assert_eq!(&*decompress(&*compress(s)), s);\n    }\n}\n\n#[test]\nfn test_example() {\n    let original = \"TOBEORNOTTOBEORTOBEORNOT\";\n    assert_eq!(\n        compress(original),\n        [84i32, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263,]\n    );\n}\n",
    "path": "tasks/lzw-compression",
    "remote_code": "use std::collections::HashMap;\n\nfn compress(data: &[u8]) -> Vec<u32> {\n    // Build initial dictionary.\n    let mut dictionary: HashMap<Vec<u8>, u32> = (0u32..=255)\n        .map(|i| (vec![i as u8], i))\n        .collect();\n\n    let mut w = Vec::new();\n    let mut compressed = Vec::new();\n\n    for &b in data {\n        let mut wc = w.clone();\n        wc.push(b);\n\n        if dictionary.contains_key(&wc) {\n            w = wc;\n        } else {\n            // Write w to output.\n            compressed.push(dictionary[&w]);\n\n            // wc is a new sequence; add it to the dictionary.\n            dictionary.insert(wc, dictionary.len() as u32);\n            w.clear();\n            w.push(b);\n        }\n    }\n\n    // Write remaining output if necessary.\n    if !w.is_empty() {\n        compressed.push(dictionary[&w]);\n    }\n\n    compressed\n}\n\nfn decompress(mut data: &[u32]) -> Vec<u8> {\n    // Build the dictionary.\n    let mut dictionary: HashMap::<u32, Vec<u8>> = (0u32..=255)\n        .map(|i| (i, vec![i as u8]))\n        .collect();\n\n    let mut w = dictionary[&data[0]].clone();\n    data = &data[1..];\n    let mut decompressed = w.clone();\n\n    for &k in data {\n        let entry = if dictionary.contains_key(&k) {\n            dictionary[&k].clone()\n        } else if k == dictionary.len() as u32 {\n            let mut entry = w.clone();\n            entry.push(w[0]);\n            entry\n        } else {\n            panic!(\"Invalid dictionary!\");\n        };\n\n        decompressed.extend_from_slice(&entry);\n\n        // New sequence; add it to the dictionary.\n        w.push(entry[0]);\n        dictionary.insert(dictionary.len() as u32, w);\n\n        w = entry;\n    }\n\n    decompressed\n}\n\nfn main() {\n    let compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\".as_bytes());\n    println!(\"{:?}\", compressed);\n\n    let decompressed = decompress(&compressed);\n    let decompressed = String::from_utf8(decompressed).unwrap();\n    println!(\"{}\", decompressed);\n}",
    "title": "LZW compression",
    "url": "http://rosettacode.org/wiki/LZW_compression"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Lah numbers",
    "url": "http://rosettacode.org/wiki/Lah_numbers"
  },
  {
    "local_code": "use std::num::Wrapping;\n\nstruct Ant {\n    x: Wrapping<usize>,\n    y: Wrapping<usize>,\n    dir: Direction,\n}\n\n#[derive(Clone, Copy)]\nenum Direction {\n    North,\n    East,\n    South,\n    West,\n}\n\nuse Direction::*;\n\nimpl Ant {\n    fn mv(&mut self, vec: &mut Vec<Vec<u8>>) {\n        let pointer = &mut vec[self.y.0][self.x.0];\n        // change direction\n        match *pointer {\n            0 => self.dir = self.dir.right(),\n            1 => self.dir = self.dir.left(),\n            _ => panic!(\"Unexpected colour in grid\"),\n        }\n        // flip colour\n        // if it's 1 it's black\n        // if it's 0 it's white\n        *pointer ^= 1;\n\n        // move direction\n        match self.dir {\n            North => self.y -= Wrapping(1),\n            South => self.y += Wrapping(1),\n            East => self.x += Wrapping(1),\n            West => self.x -= Wrapping(1),\n        }\n    }\n}\n\nimpl Direction {\n    fn right(self) -> Direction {\n        match self {\n            North => East,\n            East => South,\n            South => West,\n            West => North,\n        }\n    }\n\n    fn left(self) -> Direction {\n        // 3 rights equal a left\n        self.right().right().right()\n    }\n}\n\nfn main() {\n    // create a 100x100 grid using vectors\n    let mut grid: Vec<Vec<u8>> = vec![vec![0; 100]; 100];\n    let mut ant = Ant {\n        x: Wrapping(50),\n        y: Wrapping(50),\n        dir: Direction::North,\n    };\n\n    while ant.x < Wrapping(100) && ant.y < Wrapping(100) {\n        ant.mv(&mut grid);\n    }\n    for each in &grid {\n        // construct string\n        // using iterator methods to quickly convert the vector\n        // to a string\n        let string = each\n            .iter()\n            .map(|&x| if x == 0 { \" \" } else { \"#\" })\n            .fold(String::new(), |x, y| x + y);\n        println!(\"{}\", string);\n    }\n}\n",
    "path": "tasks/langtons-ant",
    "remote_code": "struct Ant {\n    x: usize,\n    y: usize,\n    dir: Direction\n}\n\n#[derive(Clone,Copy)]\nenum Direction {\n    North,\n    East,\n    South,\n    West\n}\n\nuse Direction::*;\n\nimpl Ant {\n    fn mv(&mut self, vec: &mut Vec<Vec<u8>>) {\n        let pointer = &mut vec[self.y][self.x];\n        //change direction\n        match *pointer {\n            0 => self.dir = self.dir.right(),\n            1 => self.dir = self.dir.left(),\n            _ => panic!(\"Unexpected colour in grid\")\n        }\n        //flip colour\n        //if it's 1 it's black\n        //if it's 0 it's white\n        *pointer ^= 1;\n\n        //move direction\n        match self.dir {\n            North => self.y -= 1,\n            South => self.y += 1,\n            East => self.x += 1,\n            West => self.x -= 1,\n        }\n\n    }\n}\n\nimpl Direction {\n    fn right(self) -> Direction {\n        match self {\n            North => East,\n            East => South,\n            South => West,\n            West => North,\n        }\n    }\n\n    fn left(self) -> Direction {\n        //3 rights equal a left\n        self.right().right().right()\n    }\n}\n\nfn main(){\n    //create a 100x100 grid using vectors\n    let mut grid: Vec<Vec<u8>> = vec![vec![0; 100]; 100];\n    let mut ant = Ant {\n        x: 50, y: 50, dir: Direction::North\n    };\n\n    while ant.x < 100 && ant.y < 100 {\n        ant.mv(&mut grid);\n    }\n    for each in grid.iter() {\n        //construct string\n        //using iterator methods to quickly convert the vector\n        //to a string\n        let string = each.iter()\n                         .map(|&x| if x == 0 { \" \" } else { \"#\" })\n                         .fold(String::new(), |x, y| x+y);\n        println!(\"{}\", string);\n    }\n}",
    "title": "Langton's ant",
    "url": "http://rosettacode.org/wiki/Langton's_ant"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn maxcat(a: &mut [u32]) {\n    a.sort_by(|x, y| {\n        let xy = format!(\"{}{}\", x, y);\n        let yx = format!(\"{}{}\", y, x);\n        xy.cmp(&yx).reverse()\n    });\n    for x in a {\n        print!(\"{}\", x);\n    }\n    println!();\n}\n \nfn main() {\n    maxcat(&mut [1, 34, 3, 98, 9, 76, 45, 4]);\n    maxcat(&mut [54, 546, 548, 60]);\n}",
    "title": "Largest int from concatenated ints",
    "url": "http://rosettacode.org/wiki/Largest_int_from_concatenated_ints"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Largest number divisible by its digits",
    "url": "http://rosettacode.org/wiki/Largest_number_divisible_by_its_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Largest proper divisor of n",
    "url": "http://rosettacode.org/wiki/Largest_proper_divisor_of_n"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env::args;\nuse time::{Date, Duration};\n\nfn main() {\n    let year = args().nth(1).unwrap().parse::<i32>().unwrap();\n    (1..=12)\n        .map(|month| Date::try_from_ymd(year + month / 12, ((month % 12) + 1) as u8, 1))\n        .filter_map(|date| date.ok())\n        .for_each(|date| {\n            let days_back =\n                Duration::days(((date.weekday().number_from_sunday() as i64) % 7) + 1);\n            println!(\"{}\", date - days_back);\n        });\n}",
    "title": "Last Friday of each month",
    "url": "http://rosettacode.org/wiki/Last_Friday_of_each_month"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// # Panics\n///\n/// If string is empty.\nfn first_char(string: &str) -> char {\n    string.chars().next().unwrap()\n}\n\n/// # Panics\n///\n/// If string is empty.\nfn first_and_last_char(string: &str) -> (char, char) {\n    (\n        first_char(string),\n        first_char(string.rmatches(|_: char| true).next().unwrap()),\n    )\n}\n\nstruct Pokemon {\n    name: &'static str,\n    first: char,\n    last: char,\n}\n\nimpl Pokemon {\n    fn new(name: &'static str) -> Pokemon {\n        let (first, last) = first_and_last_char(name);\n        Pokemon { name, first, last }\n    }\n}\n\n#[derive(Default)]\nstruct App {\n    max_path_length: usize,\n    max_path_length_count: usize,\n    max_path_example: Vec<&'static str>,\n    pokemon: Vec<Pokemon>,\n}\n\nimpl App {\n    fn search(&mut self, offset: usize) {\n        if offset > self.max_path_length {\n            self.max_path_length = offset;\n            self.max_path_length_count = 1;\n        } else if offset == self.max_path_length {\n            self.max_path_length_count += 1;\n            self.max_path_example.clear();\n            self.max_path_example.extend(\n                self.pokemon[0..offset]\n                    .iter()\n                    .map(|Pokemon { name, .. }| *name),\n            );\n        }\n\n        let last_char = self.pokemon[offset - 1].last;\n        for i in offset..self.pokemon.len() {\n            if self.pokemon[i].first == last_char {\n                self.pokemon.swap(offset, i);\n                self.search(offset + 1);\n                self.pokemon.swap(offset, i);\n            }\n        }\n    }\n}\n\nfn main() {\n    let pokemon_names = [\n        \"audino\",\n        \"bagon\",\n        \"baltoy\",\n        \"banette\",\n        \"bidoof\",\n        \"braviary\",\n        \"bronzor\",\n        \"carracosta\",\n        \"charmeleon\",\n        \"cresselia\",\n        \"croagunk\",\n        \"darmanitan\",\n        \"deino\",\n        \"emboar\",\n        \"emolga\",\n        \"exeggcute\",\n        \"gabite\",\n        \"girafarig\",\n        \"gulpin\",\n        \"haxorus\",\n        \"heatmor\",\n        \"heatran\",\n        \"ivysaur\",\n        \"jellicent\",\n        \"jumpluff\",\n        \"kangaskhan\",\n        \"kricketune\",\n        \"landorus\",\n        \"ledyba\",\n        \"loudred\",\n        \"lumineon\",\n        \"lunatone\",\n        \"machamp\",\n        \"magnezone\",\n        \"mamoswine\",\n        \"nosepass\",\n        \"petilil\",\n        \"pidgeotto\",\n        \"pikachu\",\n        \"pinsir\",\n        \"poliwrath\",\n        \"poochyena\",\n        \"porygon2\",\n        \"porygonz\",\n        \"registeel\",\n        \"relicanth\",\n        \"remoraid\",\n        \"rufflet\",\n        \"sableye\",\n        \"scolipede\",\n        \"scrafty\",\n        \"seaking\",\n        \"sealeo\",\n        \"silcoon\",\n        \"simisear\",\n        \"snivy\",\n        \"snorlax\",\n        \"spoink\",\n        \"starly\",\n        \"tirtouga\",\n        \"trapinch\",\n        \"treecko\",\n        \"tyrogue\",\n        \"vigoroth\",\n        \"vulpix\",\n        \"wailord\",\n        \"wartortle\",\n        \"whismur\",\n        \"wingull\",\n        \"yamask\",\n    ];\n\n    let mut app = App {\n        pokemon: pokemon_names\n            .iter()\n            .map(|name| Pokemon::new(name))\n            .collect(),\n        ..App::default()\n    };\n\n    for i in 0..app.pokemon.len() {\n        app.pokemon.swap(0, i);\n        app.search(1);\n        app.pokemon.swap(0, i);\n    }\n\n    println!(\"Maximum path length: {}\", app.max_path_length);\n    println!(\"Paths of that length: {}\", app.max_path_length_count);\n    println!(\n        \"Example path of that length: {}\",\n        app.max_path_example.join(\" \"),\n    );\n}\n",
    "title": "Last letter-first letter",
    "url": "http://rosettacode.org/wiki/Last_letter-first_letter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Latin Squares in reduced form",
    "url": "http://rosettacode.org/wiki/Latin_Squares_in_reduced_form"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Latin Squares in reduced form/Randomizing using Jacobson and Matthews’ Technique",
    "url": "http://rosettacode.org/wiki/Latin_Squares_in_reduced_form/Randomizing_using_Jacobson_and_Matthews%E2%80%99_Technique"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Law of cosines - triples",
    "url": "http://rosettacode.org/wiki/Law_of_cosines_-_triples"
  },
  {
    "local_code": "fn is_leap_year(year: i32) -> bool {\n    year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n}\n\nfn main() {\n    for &year in &[1900, 1995, 1996, 1999, 2000, 2001] {\n        println!(\n            \"{} {} a leap year\",\n            year,\n            if is_leap_year(year) { \"is\" } else { \"is not\" }\n        );\n    }\n}\n\n#[test]\nfn test_regular_common_year() {\n    assert_eq!(is_leap_year(2014), false);\n}\n\n#[test]\nfn test_regular_leap_year() {\n    assert_eq!(is_leap_year(2012), true);\n}\n\n#[test]\nfn test_century_common_year() {\n    assert_eq!(is_leap_year(1900), false);\n}\n\n#[test]\nfn test_400_leap_year() {\n    assert_eq!(is_leap_year(2000), true);\n}\n",
    "path": "tasks/leap-year",
    "remote_code": "fn is_leap(year: i32) -> bool {\n    let factor = |x| year % x == 0;\n    factor(4) && (!factor(100) || factor(400))\n}",
    "title": "Leap year",
    "url": "http://rosettacode.org/wiki/Leap_year"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp::{max, min};\n\nfn gcd(a: usize, b: usize) -> usize {\n    match ((a, b), (a & 1, b & 1)) {\n        ((x, y), _) if x == y => y,\n        ((0, x), _) | ((x, 0), _) => x,\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\n        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,\n        ((x, y), (1, 1)) => {\n            let (x, y) = (min(x, y), max(x, y));\n            gcd((y - x) >> 1, x)\n        }\n        _ => unreachable!(),\n    }\n}\n\nfn lcm(a: usize, b: usize) -> usize {\n    a * b / gcd(a, b)\n}\n\nfn main() {\n    println!(\"{}\", lcm(6324, 234))\n}",
    "title": "Least common multiple",
    "url": "http://rosettacode.org/wiki/Least_common_multiple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#[cfg(target_pointer_width = \"64\")]\ntype USingle = u32;\n#[cfg(target_pointer_width = \"64\")]\ntype UDouble = u64;\n#[cfg(target_pointer_width = \"64\")]\nconst WORD_LEN: i32 = 32;\n\n#[cfg(not(target_pointer_width = \"64\"))]\ntype USingle = u16;\n#[cfg(not(target_pointer_width = \"64\"))]\ntype UDouble = u32;\n#[cfg(not(target_pointer_width = \"64\"))]\nconst WORD_LEN: i32 = 16;\n\nuse std::cmp;\n\n#[derive(Debug,Clone)]\nstruct BigNum {\n    // rep_.size() == 0 if and only if the value is zero.\n    // Otherwise, the word rep_[0] keeps the least significant bits.\n    rep_: Vec<USingle>,\n}\n\nimpl BigNum {\n    pub fn new(n: USingle) -> BigNum {\n        let mut result = BigNum { rep_: vec![] };\n        if n > 0 { result.rep_.push(n); }\n        result\n    }\n    pub fn equals(&self, n: USingle) -> bool {\n        if n == 0 { return self.rep_.is_empty() }\n        if self.rep_.len() > 1 { return false }\n        self.rep_[0] == n\n    }\n    pub fn add_big(&self, addend: &BigNum) -> BigNum {\n        let mut result = BigNum::new(0);\n        let mut sum = 0 as UDouble;\n        let sz1 = self.rep_.len();\n        let sz2 = addend.rep_.len();\n        for i in 0..cmp::max(sz1, sz2) {\n            if i < sz1 { sum += self.rep_[i] as UDouble }\n            if i < sz2 { sum += addend.rep_[i] as UDouble }\n            result.rep_.push(sum as USingle);\n            sum >>= WORD_LEN;\n        }\n        if sum > 0 { result.rep_.push(sum as USingle) }\n        result\n    }\n    pub fn multiply(&self, factor: USingle) -> BigNum {\n        let mut result = BigNum::new(0);\n        let mut product = 0 as UDouble;\n        for i in 0..self.rep_.len() {\n            product += self.rep_[i] as UDouble * factor as UDouble;\n            result.rep_.push(product as USingle);\n            product >>= WORD_LEN;\n        }\n        if product > 0 {\n            result.rep_.push(product as USingle);\n        }\n        result\n    }\n    pub fn divide(&self, divisor: USingle, quotient: &mut BigNum,\n        remainder: &mut USingle) {\n        quotient.rep_.truncate(0);\n        let mut dividend: UDouble;\n        *remainder = 0;\n        for i in 0..self.rep_.len() {\n            let j = self.rep_.len() - 1 - i;\n            dividend = ((*remainder as UDouble) << WORD_LEN)\n                + self.rep_[j] as UDouble;\n            let quo = (dividend / divisor as UDouble) as USingle;\n            *remainder = (dividend % divisor as UDouble) as USingle;\n            if quo > 0 || j < self.rep_.len() - 1 {\n                quotient.rep_.push(quo);\n            }\n        }\n        quotient.rep_.reverse();\n    }\n    fn to_string(&self) -> String {\n        let mut rep = String::new();\n        let mut dividend = (*self).clone();\n        let mut remainder = 0 as USingle;\n        let mut quotient = BigNum::new(0);\n        loop {\n            dividend.divide(10, &mut quotient, &mut remainder);\n            rep.push(('0' as USingle + remainder) as u8 as char);\n            if quotient.equals(0) { break; }\n            dividend = quotient.clone();\n        }\n        rep.chars().rev().collect::<String>()\n    }\n}\n\nuse std::fmt;\nimpl fmt::Display for BigNum {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.to_string())\n    }\n}\n\nfn lfact(n: USingle) -> BigNum {\n    let mut result = BigNum::new(0);\n    let mut f = BigNum::new(1);\n    for k in 1 as USingle..n + 1 {\n        result = result.add_big(&f);\n        f = f.multiply(k);\n    }\n    result\n}\n\nfn main() {\n    for i in 0..11 {\n        println!(\"!{} = {}\", i, lfact(i));\n    }\n    for i in 2..12 {\n        let j = i * 10;\n        println!(\"!{} = {}\", j, lfact(j));\n    }\n    for i in 1..11 {\n        let j = i * 1000;\n        println!(\"!{} has {} digits.\", j, lfact(j).to_string().len());\n    }\n}\n",
    "title": "Left factorials",
    "url": "http://rosettacode.org/wiki/Left_factorials"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Legendre prime counting function",
    "url": "http://rosettacode.org/wiki/Legendre_prime_counting_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn leonardo(mut n0: u32, mut n1: u32, add: u32) -> impl std::iter::Iterator<Item = u32> {\n    std::iter::from_fn(move || {\n        let n = n0;\n        n0 = n1;\n        n1 += n + add;\n        Some(n)\n    })\n}\n\nfn main() {\n    println!(\"First 25 Leonardo numbers:\");\n    for i in leonardo(1, 1, 1).take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    println!(\"First 25 Fibonacci numbers:\");\n    for i in leonardo(0, 1, 0).take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n}",
    "title": "Leonardo numbers",
    "url": "http://rosettacode.org/wiki/Leonardo_numbers"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::{self, BufReader};\n\n/// Returns a `HashMap` of each letter and its count\nfn count_chars<R: Read>(reader: R) -> io::Result<HashMap<char, usize>> {\n    let reader = BufReader::new(reader);\n\n    let mut map = HashMap::new();\n    for line in reader.lines() {\n        for c in line?.chars() {\n            *map.entry(c).or_insert(0) += 1;\n        }\n    }\n\n    Ok(map)\n}\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"resources/unixdict.txt\")?;\n    let reader = BufReader::new(file);\n    let count = count_chars(reader)?;\n    println!(\"{:?}\", count);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::io::Cursor;\n\n    #[test]\n    fn test_empty() -> io::Result<()> {\n        let map = count_chars(Cursor::new(b\"\"))?;\n        assert!(map.is_empty());\n        Ok(())\n    }\n\n    #[test]\n    fn test_basic() -> io::Result<()> {\n        let map = count_chars(Cursor::new(b\"aaaabbbbc\"))?;\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&'a'], 4);\n        assert_eq!(map[&'b'], 4);\n        assert_eq!(map[&'c'], 1);\n        Ok(())\n    }\n}\n",
    "path": "tasks/letter-frequency",
    "remote_code": "use std::collections::btree_map::BTreeMap;\nuse std::{env, process};\nuse std::io::{self, Read, Write};\nuse std::fmt::Display;\nuse std::fs::File;\n\nfn main() {\n    let filename = env::args().nth(1)\n        .ok_or(\"Please supply a file name\")\n        .unwrap_or_else(|e| exit_err(e, 1));\n\n    let mut buf = String::new();\n    let mut count = BTreeMap::new();\n\n    File::open(&filename)\n        .unwrap_or_else(|e| exit_err(e, 2))\n        .read_to_string(&mut buf)\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n\n    for c in buf.chars() {\n        *count.entry(c).or_insert(0) += 1;\n    }\n\n    println!(\"Number of occurences per character\");\n    for (ch, count) in &count {\n        println!(\"{:?}: {}\", ch, count);\n    }\n}\n\n#[inline]\nfn exit_err<T>(msg: T, code: i32) -> ! where T: Display {\n    writeln!(&mut io::stderr(), \"{}\", msg).expect(\"Could not write to stderr\");\n    process::exit(code)\n}",
    "title": "Letter frequency",
    "url": "http://rosettacode.org/wiki/Letter_frequency"
  },
  {
    "local_code": "#[allow(clippy::needless_range_loop)]\nfn levenshtein_distance(word1: &str, word2: &str) -> usize {\n    let word1_length = word1.len() + 1;\n    let word2_length = word2.len() + 1;\n\n    let mut matrix = vec![vec![0]];\n\n    for i in 1..word1_length {\n        matrix[0].push(i);\n    }\n    for j in 1..word2_length {\n        matrix.push(vec![j]);\n    }\n\n    for j in 1..word2_length {\n        for i in 1..word1_length {\n            let x: usize = if word1.chars().nth(i - 1) == word2.chars().nth(j - 1) {\n                matrix[j - 1][i - 1]\n            } else {\n                let min_distance = [matrix[j][i - 1], matrix[j - 1][i], matrix[j - 1][i - 1]];\n                *min_distance.iter().min().unwrap() + 1\n            };\n\n            matrix[j].push(x);\n        }\n    }\n\n    matrix[word2_length - 1][word1_length - 1]\n}\n\nfn main() {\n    println!(\"{}\", levenshtein_distance(\"kitten\", \"sitting\"));\n    println!(\"{}\", levenshtein_distance(\"saturday\", \"sunday\"));\n    println!(\"{}\", levenshtein_distance(\"rosettacode\", \"raisethysword\"));\n}\n\n#[test]\nfn test_levenshtein_distance() {\n    assert_eq!(levenshtein_distance(\"kitten\", \"sitting\"), 3);\n}\nuse std::collections::VecDeque;\nuse std::iter::repeat;\nuse std::usize;\n\n/// Returns the value of a 2D vector given a pair of indexes.\n/// Returns the default value if indices are out of bounds.\nfn get_val(mat: &[Vec<usize>], r: usize, c: usize, default: usize) -> usize {\n    match mat.get(r) {\n        Some(col) => match col.get(c) {\n            Some(v) => *v,\n            None => default,\n        },\n        None => default,\n    }\n}\n\n/// Implementation of the [Needleman–Wunsch algorithm], with modification\n/// to the scoring method to only allow positive ints.\n///\n/// [Needleman-Wunsch algorithm]: http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm\n#[allow(clippy::needless_range_loop)]\nfn levenshtein_distance(s1: &str, s2: &str) -> (usize, String, String) {\n    let l1 = s1.len() + 1;\n    let l2 = s2.len() + 1;\n\n    let mut mat: Vec<Vec<usize>> = repeat(repeat(0).take(l2).collect()).take(l1).collect();\n    for row in 0..l1 {\n        mat[row][0] = row;\n    }\n    for col in 0..l2 {\n        mat[0][col] = col;\n    }\n    for row in 1..l1 {\n        for col in 1..l2 {\n            mat[row][col] = if s1.chars().nth(row - 1).unwrap() == s2.chars().nth(col - 1).unwrap()\n            {\n                mat[row - 1][col - 1]\n            } else {\n                let vals = [\n                    mat[row - 1][col] + 1,\n                    mat[row][col - 1] + 1,\n                    mat[row - 1][col - 1] + 1,\n                ];\n                *vals.iter().min().unwrap()\n            }\n        }\n    }\n    let mut res1: VecDeque<char> = VecDeque::new();\n    let mut res2: VecDeque<char> = VecDeque::new();\n    let mut cur_row = l1 - 1;\n    let mut cur_col = l2 - 1;\n    while cur_row > 0 || cur_col > 0 {\n        let ins = get_val(&mat, cur_row, cur_col - 1, usize::MAX);\n        let del = get_val(&mat, cur_row - 1, cur_col, usize::MAX);\n        let sub = get_val(&mat, cur_row - 1, cur_col - 1, usize::MAX);\n        let min_val = [sub, ins, del];\n        let min_val = min_val.iter().min().unwrap();\n        if *min_val == sub {\n            cur_row -= 1;\n            cur_col -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front(s2.chars().nth(cur_col).unwrap());\n        } else if *min_val == ins {\n            cur_col -= 1;\n            res1.push_front('-');\n            res2.push_front(s1.chars().nth(cur_col).unwrap());\n        } else if *min_val == del {\n            cur_row -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front('-');\n        }\n    }\n    let aligned1: String = res1.into_iter().collect();\n    let aligned2: String = res2.into_iter().collect();\n    let lev_dist = mat[l1 - 1][l2 - 1];\n\n    (lev_dist, aligned1, aligned2)\n}\n\nfn main() {\n    let (s1, s2) = (\"rosettacode\", \"raisethysword\");\n    let (lev_dist, aligned1, aligned2) = levenshtein_distance(s1, s2);\n    println!(\"Words are: {}, {}\", s1, s2);\n    println!(\"Levenshtein Distance: {}\", lev_dist);\n    println!(\"{}\", aligned1);\n    println!(\"{}\", aligned2);\n}\n\n#[test]\nfn test_lev_distance() {\n    let test_results = vec![\n        (\"sunday\", \"saturday\", (3, \"s--unday\", \"sunurday\")),\n        (\"sitting\", \"kitten\", (3, \"sitting\", \"kitten-\")),\n        (\"test\", \"test\", (0, \"test\", \"test\")),\n    ];\n    for (word1, word2, dist) in test_results {\n        let (d, s1, s2) = levenshtein_distance(word1, word2);\n        assert_eq!((d, &s1[..], &s2[..]), dist);\n    }\n}\n",
    "path": "tasks/levenshtein-distance",
    "remote_code": "fn main() {\n    println!(\"{}\", levenshtein_distance(\"kitten\", \"sitting\"));\n    println!(\"{}\", levenshtein_distance(\"saturday\", \"sunday\"));\n    println!(\"{}\", levenshtein_distance(\"rosettacode\", \"raisethysword\"));\n}\n \nfn levenshtein_distance(word1: &str, word2: &str) -> usize {\n    let w1 = word1.chars().collect::<Vec<_>>();\n    let w2 = word2.chars().collect::<Vec<_>>();\n \n    let word1_length = w1.len() + 1;\n    let word2_length = w2.len() + 1;\n \n    let mut matrix = vec![vec![0; word1_length]; word2_length];\n \n    for i in 1..word1_length { matrix[0][i] = i; }\n    for j in 1..word2_length { matrix[j][0] = j; }\n \n    for j in 1..word2_length {\n        for i in 1..word1_length {\n            let x: usize = if w1[i-1] == w2[j-1] {\n                matrix[j-1][i-1]\n            } else {\n                1 + std::cmp::min(\n                        std::cmp::min(matrix[j][i-1], matrix[j-1][i])\n                        , matrix[j-1][i-1])\n            };\n            matrix[j][i] = x;\n        }\n    }\n    matrix[word2_length-1][word1_length-1]\n}",
    "title": "Levenshtein distance",
    "url": "http://rosettacode.org/wiki/Levenshtein_distance"
  },
  {
    "local_code": "use std::collections::VecDeque;\nuse std::iter::repeat;\nuse std::usize;\n\n/// Returns the value of a 2D vector given a pair of indexes.\n/// Returns the default value if indices are out of bounds.\nfn get_val(mat: &[Vec<usize>], r: usize, c: usize, default: usize) -> usize {\n    match mat.get(r) {\n        Some(col) => match col.get(c) {\n            Some(v) => *v,\n            None => default,\n        },\n        None => default,\n    }\n}\n\n/// Implementation of the [Needleman–Wunsch algorithm], with modification\n/// to the scoring method to only allow positive ints.\n///\n/// [Needleman-Wunsch algorithm]: http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm\n#[allow(clippy::needless_range_loop)]\nfn levenshtein_distance(s1: &str, s2: &str) -> (usize, String, String) {\n    let l1 = s1.len() + 1;\n    let l2 = s2.len() + 1;\n\n    let mut mat: Vec<Vec<usize>> = repeat(repeat(0).take(l2).collect()).take(l1).collect();\n    for row in 0..l1 {\n        mat[row][0] = row;\n    }\n    for col in 0..l2 {\n        mat[0][col] = col;\n    }\n    for row in 1..l1 {\n        for col in 1..l2 {\n            mat[row][col] = if s1.chars().nth(row - 1).unwrap() == s2.chars().nth(col - 1).unwrap()\n            {\n                mat[row - 1][col - 1]\n            } else {\n                let vals = [\n                    mat[row - 1][col] + 1,\n                    mat[row][col - 1] + 1,\n                    mat[row - 1][col - 1] + 1,\n                ];\n                *vals.iter().min().unwrap()\n            }\n        }\n    }\n    let mut res1: VecDeque<char> = VecDeque::new();\n    let mut res2: VecDeque<char> = VecDeque::new();\n    let mut cur_row = l1 - 1;\n    let mut cur_col = l2 - 1;\n    while cur_row > 0 || cur_col > 0 {\n        let ins = get_val(&mat, cur_row, cur_col - 1, usize::MAX);\n        let del = get_val(&mat, cur_row - 1, cur_col, usize::MAX);\n        let sub = get_val(&mat, cur_row - 1, cur_col - 1, usize::MAX);\n        let min_val = [sub, ins, del];\n        let min_val = min_val.iter().min().unwrap();\n        if *min_val == sub {\n            cur_row -= 1;\n            cur_col -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front(s2.chars().nth(cur_col).unwrap());\n        } else if *min_val == ins {\n            cur_col -= 1;\n            res1.push_front('-');\n            res2.push_front(s1.chars().nth(cur_col).unwrap());\n        } else if *min_val == del {\n            cur_row -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front('-');\n        }\n    }\n    let aligned1: String = res1.into_iter().collect();\n    let aligned2: String = res2.into_iter().collect();\n    let lev_dist = mat[l1 - 1][l2 - 1];\n\n    (lev_dist, aligned1, aligned2)\n}\n\nfn main() {\n    let (s1, s2) = (\"rosettacode\", \"raisethysword\");\n    let (lev_dist, aligned1, aligned2) = levenshtein_distance(s1, s2);\n    println!(\"Words are: {}, {}\", s1, s2);\n    println!(\"Levenshtein Distance: {}\", lev_dist);\n    println!(\"{}\", aligned1);\n    println!(\"{}\", aligned2);\n}\n\n#[test]\nfn test_lev_distance() {\n    let test_results = vec![\n        (\"sunday\", \"saturday\", (3, \"s--unday\", \"sunurday\")),\n        (\"sitting\", \"kitten\", (3, \"sitting\", \"kitten-\")),\n        (\"test\", \"test\", (0, \"test\", \"test\")),\n    ];\n    for (word1, word2, dist) in test_results {\n        let (d, s1, s2) = levenshtein_distance(word1, word2);\n        assert_eq!((d, &s1[..], &s2[..]), dist);\n    }\n}\n",
    "path": "tasks/levenshtein-distance/alignment",
    "remote_code": "extern crate edit_distance;\n\nedit_distance(\"rosettacode\", \"raisethysword\");",
    "title": "Levenshtein distance/Alignment",
    "url": "http://rosettacode.org/wiki/Levenshtein_distance/Alignment"
  },
  {
    "local_code": "use linear_congruential_generator::*;\n\nuse rand::distributions::{Alphanumeric, DistString};\nuse rand::prelude::*;\n\nfn main() {\n    println!(\"~~~ BSD ~~~\");\n    let mut bsd = BsdLcg::from_seed_u32(0);\n    for _ in 0..10 {\n        println!(\"{}\", bsd.gen::<u32>());\n    }\n\n    println!(\"~~~ MS ~~~\");\n    let mut ms = MsLcg::from_seed_u32(0);\n    for _ in 0..10 {\n        println!(\"{}\", ms.gen::<u32>());\n    }\n\n    // Because we have implemented the `rand_core::RngCore` and `SeedableRng` traits,\n    // we can generate a variety of other types.\n    //\n    // Note that the alphanumeric sampling and the boolean sampling are broken because\n    // `MsLcg` does not generate a full 32 bits.\n    let mut rng = MsLcg::from_entropy();\n    println!(\"~~~ Others ~~~\");\n    println!(\"{:?}\", rng.gen::<[f32; 5]>());\n    println!(\"{}\", rng.gen::<bool>());\n    println!(\"{}\", Alphanumeric.sample_string(&mut rng, 15));\n}\nuse std::mem::size_of;\n\nuse rand_core::{impls, le, Error, RngCore, SeedableRng};\n\npub struct BsdLcg {\n    state: u32,\n}\n\nimpl RngCore for BsdLcg {\n    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`\n    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`\n    // crate does not provide it however.  If serious usage (not recommended) is required,\n    // implementing this function as a concatenation of two `next_u16`s (elsewhere defined) should\n    // work.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);\n        self.state %= 1 << 31;\n        self.state\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        impls::next_u64_via_u32(self)\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {\n        self.fill_bytes(dest);\n        Ok(())\n    }\n}\n\nimpl BsdLcg {\n    pub fn from_seed_u32(seed: u32) -> Self {\n        Self { state: seed }\n    }\n}\n\nimpl SeedableRng for BsdLcg {\n    type Seed = [u8; size_of::<u32>()];\n\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u32 = [0u32; 1];\n        le::read_u32_into(&seed, &mut seed_u32);\n        Self { state: seed_u32[0] }\n    }\n}\n\npub struct MsLcg {\n    state: u32,\n}\n\nimpl RngCore for MsLcg {\n    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate\n    // four `next_u8`s for serious usage.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);\n        self.state %= 1 << 31;\n        self.state >> 16 //  rand_n = state_n / 2^16\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        impls::next_u64_via_u32(self)\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {\n        self.fill_bytes(dest);\n        Ok(())\n    }\n}\n\nimpl MsLcg {\n    pub fn from_seed_u32(seed: u32) -> Self {\n        Self { state: seed }\n    }\n}\n\nimpl SeedableRng for MsLcg {\n    type Seed = [u8; size_of::<u32>()];\n\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u32 = [0u32; 1];\n        le::read_u32_into(&seed, &mut seed_u32);\n        Self { state: seed_u32[0] }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ms() {\n        let mut rng = MsLcg::from_seed([1, 0, 0, 0]);\n\n        for &num in &[41, 18467, 6334, 26500, 19169] {\n            assert_eq!(rng.next_u32(), num);\n        }\n    }\n\n    #[test]\n    fn test_bsd() {\n        let mut rng = BsdLcg::from_seed([1, 0, 0, 0]);\n\n        for &num in &[1103527590, 377401575, 662824084, 1147902781, 2035015474] {\n            assert_eq!(rng.next_u32(), num);\n        }\n    }\n}\n",
    "path": "tasks/linear-congruential-generator",
    "remote_code": "extern crate rand;\n\npub use rand::{Rng, SeedableRng};\n\npub struct BsdLcg {\n    state: u32,\n}\n\nimpl Rng for BsdLcg {\n    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`\n    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`\n    // crate does not provide it however.  If serious usage is required, implementing this\n    // function as a concatenation of two `next_u16`s (elsewhere defined) should work.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);\n        self.state %= 1 << 31;\n        self.state\n    }\n}\n\nimpl SeedableRng<u32> for BsdLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\npub struct MsLcg {\n    state: u32,\n}\n\nimpl Rng for MsLcg {\n    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate\n    // four `next_u8`s for serious usage.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);\n        self.state %= 1 << 31;\n        self.state >> 16 // rand_n = state_n / 2^16\n    }\n}\n\nimpl SeedableRng<u32> for MsLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\nfn main() {\n    println!(\"~~~ BSD ~~~\");\n    let mut bsd = BsdLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", bsd.next_u32());\n    }\n\n    println!(\"~~~ MS ~~~\");\n    let mut ms = MsLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", ms.next_u32());\n    }\n\n    // Because we have implemented the `rand::Rng` trait, we can generate a variety of other types.\n    println!(\"~~~ Others ~~~\");\n    println!(\"{:?}\", ms.gen::<[u32; 5]>());\n    println!(\"{}\", ms.gen::<bool>());\n    println!(\"{}\", ms.gen_ascii_chars().take(15).collect::<String>());\n}",
    "title": "Linear congruential generator",
    "url": "http://rosettacode.org/wiki/Linear_congruential_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn pyth(n: u32) -> impl Iterator<Item = [u32; 3]> {\n    (1..=n).flat_map(move |x| {\n        (x..=n).flat_map(move |y| {\n            (y..=n).filter_map(move |z| {\n                if x.pow(2) + y.pow(2) == z.pow(2) {\n                    Some([x, y, z])\n                } else {\n                    None\n                }\n            })\n        })\n    })\n}",
    "title": "List comprehensions",
    "url": "http://rosettacode.org/wiki/List_comprehensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "List rooted trees",
    "url": "http://rosettacode.org/wiki/List_rooted_trees"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "2.3         // Normal floating point literal\n3.          // Equivalent to 3.0 (3 would be interpreted as an integer)\n2f64        // The type (in this case f64, a 64-bit floating point number) may be appended to the value\n1_000.2_f32 // Underscores may appear anywhere in the number for clarity.",
    "title": "Literals/Floating point",
    "url": "http://rosettacode.org/wiki/Literals/Floating_point"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "10     // Decimal\n0b10   // Binary\n0x10   // Hexadecimal\n0o10   // Octal\n1_000  // Underscores may appear anywhere in the numeric literal for clarity\n10_i32 // The type (in this case i32, a 32-bit signed integer) may also be appended.\n10i32  // With or without underscores",
    "title": "Literals/Integer",
    "url": "http://rosettacode.org/wiki/Literals/Integer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Literals/String",
    "url": "http://rosettacode.org/wiki/Literals/String"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn boolean_ops(a: bool, b: bool) {\n    println!(\"{} and {} -> {}\", a, b, a && b);\n    println!(\"{} or {} -> {}\", a, b, a || b);\n    println!(\"{} xor {} -> {}\", a, b, a ^ b);\n    println!(\"not {} -> {}\\n\", a, !a);\n}\n\nfn main() {\n    boolean_ops(true, true);\n    boolean_ops(true, false);\n    boolean_ops(false, true);\n    boolean_ops(false, false)\n}\n",
    "title": "Logical operations",
    "url": "http://rosettacode.org/wiki/Logical_operations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Long literals, with continuations",
    "url": "http://rosettacode.org/wiki/Long_literals,_with_continuations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Long multiplication",
    "url": "http://rosettacode.org/wiki/Long_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// main.rs\n// References:\n// https://en.wikipedia.org/wiki/Full_reptend_prime\n// https://en.wikipedia.org/wiki/Primitive_root_modulo_n#Finding_primitive_roots\n\nmod bit_array;\nmod prime_sieve;\n\nuse prime_sieve::PrimeSieve;\n\nfn modpow(mut base: usize, mut exp: usize, n: usize) -> usize {\n    if n == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    base %= n;\n    while exp > 0 {\n        if (exp & 1) == 1 {\n            result = (result * base) % n;\n        }\n        base = (base * base) % n;\n        exp >>= 1;\n    }\n    result\n}\n\nfn is_long_prime(sieve: &PrimeSieve, prime: usize) -> bool {\n    if !sieve.is_prime(prime) {\n        return false;\n    }\n    if 10 % prime == 0 {\n        return false;\n    }\n    let n = prime - 1;\n    let mut m = n;\n    let mut p = 2;\n    while p * p <= n {\n        if sieve.is_prime(p) && m % p == 0 {\n            if modpow(10, n / p, prime) == 1 {\n                return false;\n            }\n            while m % p == 0 {\n                m /= p;\n            }\n        }\n        p += 1;\n    }\n    if m == 1 {\n        return true;\n    }\n    modpow(10, n / m, prime) != 1\n}\n\nfn long_primes(limit1: usize, limit2: usize) {\n    let sieve = PrimeSieve::new(limit2);\n    let mut count = 0;\n    let mut limit = limit1;\n    let mut prime = 3;\n    while prime < limit2 {\n        if is_long_prime(&sieve, prime) {\n            if prime < limit1 {\n                print!(\"{} \", prime);\n            }\n            if prime > limit {\n                print!(\"\\nNumber of long primes up to {}: {}\", limit, count);\n                limit *= 2;\n            }\n            count += 1;\n        }\n        prime += 2;\n    }\n    println!(\"\\nNumber of long primes up to {}: {}\", limit, count);\n}\n\nfn main() {\n    long_primes(500, 8192000);\n}",
    "title": "Long primes",
    "url": "http://rosettacode.org/wiki/Long_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate time; // 0.2.16\n\nuse time::Date;\n\nfn main() {\n    (2000..=2099)\n        .filter(|&year| is_long_year(year))\n        .for_each(|year| println!(\"{}\", year));\n}\n\nfn is_long_year(year: i32) -> bool {\n    Date::try_from_ymd(year, 12, 28).map_or(false, |date| date.week() == 53)\n}\n",
    "title": "Long year",
    "url": "http://rosettacode.org/wiki/Long_year"
  },
  {
    "local_code": "/// Returns the longest common subsequence of a and b.\nfn longest_common_subsequence(a: &str, b: &str) -> String {\n    let a_chars: Vec<_> = a.chars().collect();\n    let b_chars: Vec<_> = b.chars().collect();\n\n    let mut lengths = vec![vec![0; b_chars.len() + 1]; a_chars.len() + 1];\n\n    for (i, a_char) in a_chars.iter().enumerate() {\n        for (j, b_char) in b_chars.iter().enumerate() {\n            if a_char == b_char {\n                lengths[i + 1][j + 1] = lengths[i][j] + 1;\n            } else {\n                lengths[i + 1][j + 1] = std::cmp::max(lengths[i + 1][j], lengths[i][j + 1]);\n            }\n        }\n    }\n\n    let mut lcs = Vec::new();\n    let mut i = a_chars.len();\n    let mut j = b_chars.len();\n\n    while i != 0 && j != 0 {\n        if lengths[i][j] == lengths[i - 1][j] {\n            i -= 1;\n        } else if lengths[i][j] == lengths[i][j - 1] {\n            j -= 1;\n        } else {\n            lcs.push(a_chars[i - 1]);\n            i -= 1;\n            j -= 1;\n        }\n    }\n\n    lcs.into_iter().rev().collect()\n}\n\nfn main() {\n    println!(\"{}\", longest_common_subsequence(\"abc\", \"abcd\"));\n    println!(\"{}\", longest_common_subsequence(\"ABCDGH\", \"AEDFHR\"));\n    println!(\"{}\", longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"));\n    println!(\"{}\", longest_common_subsequence(\"\", \"abcdefg\"));\n    println!(\"{}\", longest_common_subsequence(\"abc\", \"\"));\n    println!(\"{}\", longest_common_subsequence(\"abcdefg\", \"abc\"));\n    println!(\"{}\", longest_common_subsequence(\"aaaa\", \"aaaaaa\"));\n}\n\n#[test]\nfn test_longest_common_subsequence() {\n    assert_eq!(longest_common_subsequence(\"abc\", \"abcdefg\"), \"abc\");\n    assert_eq!(longest_common_subsequence(\"ABCDGH\", \"AEDFHR\"), \"ADH\");\n    assert_eq!(longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"), \"GTAB\");\n    assert_eq!(longest_common_subsequence(\"\", \"abcdefg\"), \"\");\n    assert_eq!(longest_common_subsequence(\"abc\", \"\"), \"\");\n    assert_eq!(longest_common_subsequence(\"abcdefg\", \"abc\"), \"abc\");\n    assert_eq!(longest_common_subsequence(\"aaaa\", \"aaaaaa\"), \"aaaa\");\n}\n\n#[test]\nfn test_unicode() {\n    assert_eq!(\n        longest_common_subsequence(\"самолетов была отмечена в Японском\", \"отмечена в\"),\n        \"отмечена в\"\n    );\n}\n",
    "path": "tasks/longest-common-subsequence",
    "remote_code": "\nuse std::cmp;\n\nfn lcs(string1: String, string2: String) -> (usize, String){\n    let total_rows = string1.len() + 1;\n    let total_columns = string2.len() + 1;\n    // rust doesn't allow accessing string by index\n    let string1_chars = string1.as_bytes();\n    let string2_chars = string2.as_bytes();\n\n    let mut table = vec![vec![0; total_columns]; total_rows];\n\n    for row in 1..total_rows{\n        for col in 1..total_columns {\n            if string1_chars[row - 1] == string2_chars[col - 1]{\n                table[row][col] = table[row - 1][col - 1] + 1;\n            } else {\n                table[row][col] = cmp::max(table[row][col-1], table[row-1][col]);\n            }\n        }\n    }\n\n    let mut common_seq = Vec::new();\n    let mut x = total_rows - 1;\n    let mut y = total_columns - 1;\n\n    while x != 0 && y != 0 {\n        // Check element above is equal\n        if table[x][y] == table[x - 1][y] {\n            x = x - 1;\n        }\n        // check element to the left is equal\n        else if table[x][y] == table[x][y - 1] {\n            y = y - 1;\n        }\n        else {\n            // check the two element at the respective x,y position is same\n            assert_eq!(string1_chars[x-1], string2_chars[y-1]);\n            let char = string1_chars[x - 1];\n            common_seq.push(char);\n            x = x - 1;\n            y = y - 1;\n        }\n    }\n    common_seq.reverse();\n    (table[total_rows - 1][total_columns - 1], String::from_utf8(common_seq).unwrap())\n}\n\nfn main() {\n    let res = lcs(\"abcdaf\".to_string(), \"acbcf\".to_string());\n    assert_eq!((4 as usize, \"abcf\".to_string()), res);\n    let res = lcs(\"thisisatest\".to_string(), \"testing123testing\".to_string());\n    assert_eq!((7 as usize, \"tsitest\".to_string()), res);\n    // LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4.\n    let res = lcs(\"AGGTAB\".to_string(), \"GXTXAYB\".to_string());\n    assert_eq!((4 as usize, \"GTAB\".to_string()), res);\n}",
    "title": "Longest common subsequence",
    "url": "http://rosettacode.org/wiki/Longest_common_subsequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn longest_common_substring(s1: &str, s2: &str) -> String {\n    let s1_chars: Vec<char> = s1.chars().collect();\n    let s2_chars: Vec<char> = s2.chars().collect();\n    let mut lcs = \"\".to_string();\n\n    for i in 0..s1_chars.len() {\n        for j in 0..s2_chars.len() {\n            if s1_chars[i] == s2_chars[j] {\n                let mut tmp_lcs = s2_chars[j].to_string();\n                let mut tmp_i = i + 1;\n                let mut tmp_j = j + 1;\n\n                while tmp_i < s1_chars.len() && tmp_j < s2_chars.len() && s1_chars[tmp_i] == s2_chars[tmp_j] {\n                    tmp_lcs = format!(\"{}{}\", tmp_lcs, s1_chars[tmp_i]);\n                    tmp_i += 1;\n                    tmp_j += 1;\n                }\n\n                if tmp_lcs.len() > lcs.len() {\n                    lcs = tmp_lcs;\n                }\n            }\n        }\n    }\n\n    lcs\n}\n\nfn main() {\n    let s1 = \"thisisatest\";\n    let s2 = \"testing123testing\";\n    let lcs = longest_common_substring(s1, s2);\n    println!(\"{}\", lcs);\n}",
    "title": "Longest common substring",
    "url": "http://rosettacode.org/wiki/Longest_common_substring"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn lis(x: &[i32])-> Vec<i32> {\n    let n = x.len();\n    let mut m = vec![0; n];\n    let mut p = vec![0; n];\n    let mut l = 0;\n\n    for i in 0..n {\n        let mut lo = 1;\n        let mut hi = l;\n\n        while lo <= hi {\n            let mid = (lo + hi) / 2;\n\n            if x[m[mid]] <= x[i] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n\n        let new_l = lo;\n        p[i] = m[new_l - 1];\n        m[new_l] = i;\n\n        if new_l > l {\n            l = new_l;\n        }\n    }\n\n    let mut o = vec![0; l];\n    let mut k = m[l];\n    for i in (0..l).rev() {\n        o[i] = x[k];\n        k    = p[k];\n    }\n\n    o\n}\n\nfn main() {\n    let list = vec![3, 2, 6, 4, 5, 1];\n    println!(\"{:?}\", lis(&list));\n    let list = vec![0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    println!(\"{:?}\", lis(&list));\n}",
    "title": "Longest increasing subsequence",
    "url": "http://rosettacode.org/wiki/Longest_increasing_subsequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp::Ordering;\nuse std::io::BufRead;\n\n/// Compares the length of two strings by iterating over their characters\n/// together until either string has run out.\nfn compare(a: &str, b: &str) -> Ordering {\n    let mut a = a.chars();\n    let mut b = b.chars();\n    loop {\n        match (a.next(), b.next()) {\n            (None, None) => return Ordering::Equal,\n            (Some(_), None) => return Ordering::Greater,\n            (None, Some(_)) => return Ordering::Less,\n            (Some(_), Some(_)) => {}\n        }\n    }\n}\n\n/// Returns the longest lines of the input, separated by newlines.\nfn longest<I: IntoIterator<Item = String>>(input: I) -> String {\n    let mut longest = String::new();\n    let mut output = String::new();\n\n    for line in input {\n        match compare(&line, &longest) {\n            // A longer string replaces the output and longest.\n            Ordering::Greater => {\n                output.clear();\n                output.push_str(&line);\n                longest = line;\n            }\n            // A string of the same length is appended to the output.\n            Ordering::Equal => {\n                output.push('\\n');\n                output.push_str(&line);\n            }\n            // A shorter string is ignored.\n            Ordering::Less => {}\n        }\n    }\n\n    output\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let lines = stdin.lock().lines().map(|l| l.expect(\"Failed to read.\"));\n    \n    println!(\"{}\", longest(lines))\n}",
    "title": "Longest string challenge",
    "url": "http://rosettacode.org/wiki/Longest_string_challenge"
  },
  {
    "local_code": "extern crate run_length_encoding;\n\nuse run_length_encoding::encode;\n\nfn main() {\n    let mut s = look_and_say(\"1\");\n    for _ in 0..20 {\n        println!(\"{}\", s);\n        s = look_and_say(&s[..]);\n    }\n}\n\nfn look_and_say(value: &str) -> String {\n    if value.chars().any(|c| !c.is_digit(10)) {\n        panic!(\"this task requires all digits\");\n    }\n    encode(value)\n}\n\n#[test]\nfn test_say() {\n    assert_eq!(look_and_say(\"11222333\"), \"213233\".to_string());\n}\n",
    "path": "tasks/look-and-say-sequence",
    "remote_code": "fn next_sequence(in_seq: &[i8]) -> Vec<i8> {\n    assert!(!in_seq.is_empty());\n\n    let mut result = Vec::new();\n    let mut current_number = in_seq[0];\n    let mut current_runlength = 1;\n\n    for i in &in_seq[1..] {\n        if current_number == *i {\n            current_runlength += 1;\n        } else {\n            result.push(current_runlength);\n            result.push(current_number);\n            current_runlength = 1;\n            current_number = *i;\n        }\n    }\n    result.push(current_runlength);\n    result.push(current_number);\n    result\n}\n\nfn main() {\n    let mut seq = vec![1];\n\n    for i in 0..10 {\n        println!(\"Sequence {}: {:?}\", i, seq);\n        seq = next_sequence(&seq);\n    }\n}",
    "title": "Look-and-say sequence",
    "url": "http://rosettacode.org/wiki/Look-and-say_sequence"
  },
  {
    "local_code": "fn main() {\n    let a1 = [\"a\", \"b\", \"c\"];\n    let a2 = [\"A\", \"B\", \"C\"];\n    let a3 = [1, 2, 3];\n\n    for ((&x, &y), &z) in a1.iter().zip(a2.iter()).zip(a3.iter()) {\n        println!(\"{}{}{}\", x, y, z);\n    }\n}\n",
    "path": "tasks/loop-over-multiple-arrays-simultaneously",
    "remote_code": "fn main() {\n    let a1 = [\"a\", \"b\", \"c\"];\n    let a2 = [\"A\", \"B\", \"C\"];\n    let a3 = [1, 2, 3];\n\n    for ((&x, &y), &z) in a1.iter().zip(a2.iter()).zip(a3.iter()) {\n        println!(\"{}{}{}\", x, y, z);\n    }\n}",
    "title": "Loop over multiple arrays simultaneously",
    "url": "http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    loop {\n        let num = rng.gen_range(0, 20);\n        println!(\"{}\", num);\n        if num == 10 {\n            break;\n        }\n        println!(\"{}\", rng.gen_range(0, 20));\n    }\n}\n",
    "path": "tasks/loops/break",
    "remote_code": "// cargo-deps: rand\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\n \nfn main() {\n    let mut rng = thread_rng();\n    loop {\n        let num = rng.gen_range(0, 20);\n        if num == 10 {\n            println!(\"{}\", num);\n            break;\n        }\n        println!(\"{}\", rng.gen_range(0, 20));\n    }\n}",
    "title": "Loops/Break",
    "url": "http://rosettacode.org/wiki/Loops/Break"
  },
  {
    "local_code": "fn main() {\n    for i in 1..10 + 1 {\n        print!(\"{}\", i);\n        if i % 5 == 0 {\n            println!();\n            continue;\n        }\n        print!(\", \");\n    }\n}\n",
    "path": "tasks/loops/continue",
    "remote_code": "fn main() {\n    for i in 1..=10 {\n        print!(\"{}\", i);\n        if i % 5 == 0 {\n            println!();\n            continue;\n        }\n        print!(\", \");\n    }\n}",
    "title": "Loops/Continue",
    "url": "http://rosettacode.org/wiki/Loops/Continue"
  },
  {
    "local_code": "//! Rust does not have a `do...while` loop. Instead, the keyword `loop` is used with a termination\n//! condition.\n\nfn main() {\n    let mut x = 0;\n\n    loop {\n        x += 1;\n        println!(\"{}\", x);\n\n        if x % 6 == 0 {\n            break;\n        }\n    }\n}\n",
    "path": "tasks/loops/do-while",
    "remote_code": "let mut x = 0;\n\nloop {\n    x += 1;\n    println!(\"{}\", x);\n\n    if x % 6 == 0 { break; }\n}",
    "title": "Loops/Do-while",
    "url": "http://rosettacode.org/wiki/Loops/Do-while"
  },
  {
    "local_code": "fn main() {\n    for i in (1..=10).rev() {\n        println!(\"{}\", i);\n    }\n}\n",
    "path": "tasks/loops/downward-for",
    "remote_code": "fn main() {\n    for i in (0..=10).rev() {\n        println!(\"{}\", i);\n    }\n}",
    "title": "Loops/Downward for",
    "url": "http://rosettacode.org/wiki/Loops/Downward_for"
  },
  {
    "local_code": "fn main() {\n    for i in 1..6 {\n        for _ in 1..=i {\n            print!(\"*\");\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/loops/for",
    "remote_code": "fn main() {\n    for i in 0..5 {\n        for _ in 0..=i {\n            print!(\"*\");\n        }\n\n        println!();\n    }\n}",
    "title": "Loops/For",
    "url": "http://rosettacode.org/wiki/Loops/For"
  },
  {
    "local_code": "fn main() {\n    for i in (2..8 + 1).step_by(2) {\n        print!(\"{}\", i);\n    }\n    println!(\"who do we appreciate?!\");\n}\n",
    "path": "tasks/loops/for-with-a-specified-step",
    "remote_code": "fn main() {\n  for i in (2..=8).step_by(2) {\n    print!(\"{}\", i);\n  }\n  println!(\"who do we appreciate?!\");\n}",
    "title": "Loops/For with a specified step",
    "url": "http://rosettacode.org/wiki/Loops/For_with_a_specified_step"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    // Rust's for-loop already is a foreach-loop.\n    let collection = vec![1, 2, 3, 4, 5];\n    for elem in collection {\n        println!(\"{}\", elem);\n    }\n\n    // Do note that Rust moves values by default and doesn't copy them. A vector would be unusable\n    // after looping over it like above. To preserve it, borrow it or use an Iter, to mutate values\n    // do a mutable borrow or create an IterMut. To get an immutable reference omit the mut-part.\n\n    let mut collection = vec![1, 2, 3, 4, 5];\n    for mut_ref in &mut collection {\n        // alternatively:\n        // for mut_ref in collection.iter_mut() {\n        *mut_ref *= 2;\n        println!(\"{}\", *mut_ref);\n    }\n\n    // immutable borrow\n    for immut_ref in &collection {\n        // alternatively:\n        // for immut_ref in collection.iter() {\n        println!(\"{}\", *immut_ref);\n    }\n\n    // Iterate through the characters of a string\n    let s = \"hello, world!\";\n    for i in s.chars() {\n        print!(\"{}\", i);\n    }\n    println!();\n\n    // Iterate through the elements of a slice\n    let array = [1, 2, 3, 4, 5];\n    for i in &array {\n        print!(\"{}\", i);\n    }\n    println!();\n\n    // Iterate through the elements of a hashmap\n    let mut hashmap = HashMap::new();\n    hashmap.insert(\"a\", 1u8);\n    hashmap.insert(\"b\", 2);\n    hashmap.insert(\"c\", 3);\n    for (c, i) in &hashmap {\n        println!(\"{}: '{}'\", c, i)\n    }\n}\n",
    "path": "tasks/loops/foreach",
    "remote_code": "let collection = vec![1,2,3,4,5];\nfor elem in collection {\n    println!(\"{}\", elem);\n}",
    "title": "Loops/Foreach",
    "url": "http://rosettacode.org/wiki/Loops/Foreach"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/Increment loop index within loop body",
    "url": "http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body"
  },
  {
    "local_code": "fn main() {\n    loop {\n        println!(\"spam\");\n    }\n}\n",
    "path": "tasks/loops/infinite",
    "remote_code": "fn main() {\n    loop {\n        println!(\"SPAM\");\n    }\n}",
    "title": "Loops/Infinite",
    "url": "http://rosettacode.org/wiki/Loops/Infinite"
  },
  {
    "local_code": "fn main() {\n    for i in 1..11 {\n        print!(\"{}\", i);\n        if i == 10 {\n            break;\n        }\n        print!(\", \");\n    }\n}\n",
    "path": "tasks/loops/n-plus-one-half",
    "remote_code": "fn main() {\n    for i in 1..=10 {\n        print!(\"{}{}\", i, if i < 10 { \", \" } else { \"\\n\" });\n    }\n}",
    "title": "Loops/N plus one half",
    "url": "http://rosettacode.org/wiki/Loops/N_plus_one_half"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let mut matrix = [[0u8; 10]; 10];\n    let mut rng = rand::thread_rng();\n\n    for row in &mut matrix {\n        for item in &mut *row {\n            *item = rng.gen_range(0, 21);\n        }\n    }\n\n    'outer: for row in &matrix {\n        for &item in row {\n            print!(\"{:2} \", item);\n            if item == 20 {\n                break 'outer;\n            }\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/loops/nested",
    "remote_code": "use rand::Rng;\n\nextern crate rand;\n\nfn main() {\n    let mut matrix = [[0u8; 10]; 10];\n    let mut rng = rand::thread_rng();\n\n    for row in matrix.iter_mut() {\n        for item in row.iter_mut() {\n            *item = rng.gen_range(0, 21);\n        }\n    }\n\n    'outer: for row in matrix.iter() {\n        for &item in row.iter() {\n            print!(\"{:2} \", item);\n            if item == 20 { break 'outer }\n        }\n        println!();\n    }\n}",
    "title": "Loops/Nested",
    "url": "http://rosettacode.org/wiki/Loops/Nested"
  },
  {
    "local_code": "fn main() {\n    let mut i = 1024;\n    while i > 0 {\n        println!(\"{}\", i);\n        i /= 2;\n    }\n}\n",
    "path": "tasks/loops/while",
    "remote_code": "fn main() {\n    let mut n: i32 = 1024;\n    while n > 0 {\n        println!(\"{}\", n);\n        n /= 2;\n    }\n}",
    "title": "Loops/While",
    "url": "http://rosettacode.org/wiki/Loops/While"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/With multiple ranges",
    "url": "http://rosettacode.org/wiki/Loops/With_multiple_ranges"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/Wrong ranges",
    "url": "http://rosettacode.org/wiki/Loops/Wrong_ranges"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n\nextern crate rug;\nextern crate primal;\n\nuse rug::Integer;\nuse rug::ops::Pow;\nuse std::thread::spawn;\n\nfn is_mersenne (p : usize) {\n    let p = p as u32;\n    let mut m = Integer::from(1);\n    m = m << p;  \n    m = Integer::from(&m - 1);\n    let mut flag1 = false;\n    for k in 1..10_000 {\n        let mut flag2 = false;\n        let mut div : u32 = 2*k*p + 1;\n        if &div >= &m {break; }\n        for j in [3,5,7,11,13,17,19,23,29,31,37].iter() {\n            if div % j == 0 {\n                flag2 = true;\n                break;\n            }   \n        }\n        if flag2 == true {continue;}\n        if div % 8 != 1 && div % 8 != 7 { continue; }\n        if m.is_divisible_u(div) { \n            flag1 = true;\n            break;\n        }\n    }\n    if flag1 == true {return ()}\n    let mut s = Integer::from(4);\n    let two = Integer::from(2);\n    for _i in 2..p {\n\t\tlet mut sqr = s.pow(2);\n\t\ts = Integer::from(&Integer::from(&sqr & &m) + &Integer::from(&sqr >> p));\n\t\tif &s >= &m {s = s - &m}\n\t\ts = Integer::from(&s - &two);\n    }\n\tif s == 0 {println!(\"Mersenne : {}\",p);} \n}\n\nfn main () {\n    println!(\"Mersenne : 2\");\n    let limit = 11_214;\n    let mut thread_handles = vec![];\n    for p in primal::Primes::all().take_while(|p| *p < limit) {\n        thread_handles.push(spawn(move || is_mersenne(p))); \n    }\n    for handle in thread_handles {\n        handle.join().unwrap();\n    }\n}\n",
    "title": "Lucas-Lehmer test",
    "url": "http://rosettacode.org/wiki/Lucas-Lehmer_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Lucky and even lucky numbers",
    "url": "http://rosettacode.org/wiki/Lucky_and_even_lucky_numbers"
  },
  {
    "local_code": "const ARRAY_MAX: usize = 25_000;\nconst LUDIC_MAX: usize = 2100;\n\n/// Calculates and returns the first `LUDIC_MAX` Ludic numbers.\n///\n/// Needs a sufficiently large `ARRAY_MAX`.\nfn ludic_numbers() -> Vec<usize> {\n    // The first two Ludic numbers\n    let mut numbers = vec![1, 2];\n    // We start the array with an immediate first removal to reduce memory usage by\n    // collecting only odd numbers.\n    numbers.extend((3..ARRAY_MAX).step_by(2));\n\n    // We keep the correct Ludic numbers in place, removing the incorrect ones.\n    for ludic_idx in 2..LUDIC_MAX {\n        let next_ludic = numbers[ludic_idx];\n\n        // We remove incorrect numbers by counting the indices after the correct numbers.\n        // We start from zero and keep until we reach the potentially incorrect numbers.\n        // Then we keep only those not divisible by the `next_ludic`.\n        let mut idx = 0;\n        numbers.retain(|_| {\n            let keep = idx <= ludic_idx || (idx - ludic_idx) % next_ludic != 0;\n            idx += 1;\n            keep\n        });\n    }\n\n    numbers\n}\n\nfn main() {\n    let ludic_numbers = ludic_numbers();\n\n    print!(\"First 25: \");\n    print_n_ludics(&ludic_numbers, 25);\n    println!();\n    print!(\"Number of Ludics below 1000: \");\n    print_num_ludics_upto(&ludic_numbers, 1000);\n    println!();\n    print!(\"Ludics from 2000 to 2005: \");\n    print_ludics_from_to(&ludic_numbers, 2000, 2005);\n    println!();\n    println!(\"Triplets below 250: \");\n    print_triplets_until(&ludic_numbers, 250);\n}\n\n/// Prints the first `n` Ludic numbers.\nfn print_n_ludics(x: &[usize], n: usize) {\n    println!(\"{:?}\", &x[..n]);\n}\n\n/// Calculates how many Ludic numbers are below `max_num`.\nfn print_num_ludics_upto(x: &[usize], max_num: usize) {\n    let num = x.iter().take_while(|&&i| i < max_num).count();\n    println!(\"{}\", num);\n}\n\n/// Prints Ludic numbers between two numbers.\nfn print_ludics_from_to(x: &[usize], from: usize, to: usize) {\n    println!(\"{:?}\", &x[from - 1..to - 1]);\n}\n\n/// Calculates triplets until a certain Ludic number.\nfn triplets_below(ludics: &[usize], limit: usize) -> Vec<(usize, usize, usize)> {\n    ludics\n        .iter()\n        .enumerate()\n        .take_while(|&(_, &num)| num < limit)\n        .filter_map(|(idx, &number)| {\n            let triplet_2 = number + 2;\n            let triplet_3 = number + 6;\n\n            // Search for the other two triplet numbers.  We know they are larger than\n            // `number` so we can give the searches lower bounds of `idx + 1` and\n            // `idx + 2`.  We also know that the `n + 2` number can only ever be two\n            // numbers away from the previous and the `n + 6` number can only be four\n            // away (because we removed some in between).  Short circuiting and doing\n            // the check more likely to fail first are also useful.\n            let is_triplet = ludics[idx + 1..idx + 3].binary_search(&triplet_2).is_ok()\n                && ludics[idx + 2..idx + 5].binary_search(&triplet_3).is_ok();\n\n            if is_triplet {\n                Some((number, triplet_2, triplet_3))\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\n/// Prints triplets until a certain Ludic number.\nfn print_triplets_until(ludics: &[usize], limit: usize) {\n    for (number, triplet_2, triplet_3) in triplets_below(ludics, limit) {\n        println!(\"{} {} {}\", number, triplet_2, triplet_3);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn solutions() {\n        let ludics = ludic_numbers();\n\n        // First 25\n        let first_25 = [\n            1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43, 47, 53, 61, 67, 71, 77, 83, 89, 91,\n            97, 107,\n        ];\n        assert_eq!(ludics[..25], first_25);\n\n        // Count below 1000\n        assert_eq!(ludics.iter().take_while(|&&i| i < 1000).count(), 142);\n\n        // 2000th to 2005th numbers\n        let expected_range = [21475, 21481, 21487, 21493, 21503];\n        assert_eq!(ludics[2000 - 1..2005 - 1], expected_range);\n\n        // Triplets\n        let expected_triplets = [\n            (1, 3, 7),\n            (5, 7, 11),\n            (11, 13, 17),\n            (23, 25, 29),\n            (41, 43, 47),\n            (173, 175, 179),\n            (221, 223, 227),\n            (233, 235, 239),\n        ];\n        let tested_triplets = triplets_below(&ludics, 250);\n        assert_eq!(expected_triplets, tested_triplets.as_slice());\n    }\n}\n",
    "path": "tasks/ludic-numbers",
    "remote_code": "\nconst ARRAY_MAX: usize = 25_000;\nconst LUDIC_MAX: usize = 2100;\n\n/// Calculates and returns the first `LUDIC_MAX` Ludic numbers.\n///\n/// Needs a sufficiently large `ARRAY_MAX`.\nfn ludic_numbers() -> Vec<usize> {\n    // The first two Ludic numbers\n    let mut numbers = vec![1, 2];\n    // We start the array with an immediate first removal to reduce memory usage by\n    // collecting only odd numbers.\n    numbers.extend((3..ARRAY_MAX).step_by(2));\n\n    // We keep the correct Ludic numbers in place, removing the incorrect ones.\n    for ludic_idx in 2..LUDIC_MAX {\n        let next_ludic = numbers[ludic_idx];\n\n        // We remove incorrect numbers by counting the indices after the correct numbers.\n        // We start from zero and keep until we reach the potentially incorrect numbers.\n        // Then we keep only those not divisible by the `next_ludic`.\n        let mut idx = 0;\n        numbers.retain(|_| {\n            let keep = idx <= ludic_idx || (idx - ludic_idx) % next_ludic != 0;\n            idx += 1;\n            keep\n        });\n    }\n\n    numbers\n}\n\nfn main() {\n    let ludic_numbers = ludic_numbers();\n\n    print!(\"First 25: \");\n    print_n_ludics(&ludic_numbers, 25);\n    println!();\n    print!(\"Number of Ludics below 1000: \");\n    print_num_ludics_upto(&ludic_numbers, 1000);\n    println!();\n    print!(\"Ludics from 2000 to 2005: \");\n    print_ludics_from_to(&ludic_numbers, 2000, 2005);\n    println!();\n    println!(\"Triplets below 250: \");\n    print_triplets_until(&ludic_numbers, 250);\n}\n\n/// Prints the first `n` Ludic numbers.\nfn print_n_ludics(x: &[usize], n: usize) {\n    println!(\"{:?}\", &x[..n]);\n}\n\n/// Calculates how many Ludic numbers are below `max_num`.\nfn print_num_ludics_upto(x: &[usize], max_num: usize) {\n    let num = x.iter().take_while(|&&i| i < max_num).count();\n    println!(\"{}\", num);\n}\n\n/// Prints Ludic numbers between two numbers.\nfn print_ludics_from_to(x: &[usize], from: usize, to: usize) {\n    println!(\"{:?}\", &x[from - 1..to - 1]);\n}\n\n/// Calculates triplets until a certain Ludic number.\nfn triplets_below(ludics: &[usize], limit: usize) -> Vec<(usize, usize, usize)> {\n    ludics\n        .iter()\n        .enumerate()\n        .take_while(|&(_, &num)| num < limit)\n        .filter_map(|(idx, &number)| {\n            let triplet_2 = number + 2;\n            let triplet_3 = number + 6;\n\n            // Search for the other two triplet numbers.  We know they are larger than\n            // `number` so we can give the searches lower bounds of `idx + 1` and\n            // `idx + 2`.  We also know that the `n + 2` number can only ever be two\n            // numbers away from the previous and the `n + 6` number can only be four\n            // away (because we removed some in between).  Short circuiting and doing\n            // the check more likely to fail first are also useful.\n            let is_triplet = ludics[idx + 1..idx + 3].binary_search(&triplet_2).is_ok()\n                && ludics[idx + 2..idx + 5].binary_search(&triplet_3).is_ok();\n\n            if is_triplet {\n                Some((number, triplet_2, triplet_3))\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\n/// Prints triplets until a certain Ludic number.\nfn print_triplets_until(ludics: &[usize], limit: usize) {\n    for (number, triplet_2, triplet_3) in triplets_below(ludics, limit) {\n        println!(\"{} {} {}\", number, triplet_2, triplet_3);\n    }\n}\n",
    "title": "Ludic numbers",
    "url": "http://rosettacode.org/wiki/Ludic_numbers"
  },
  {
    "local_code": "struct Digits {\n    m: u64,\n}\n\nimpl Iterator for Digits {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        match self.m {\n            0 => None,\n            n => {\n                let ret = n % 10;\n                self.m = n / 10;\n                Some(ret)\n            }\n        }\n    }\n}\n\n#[derive(Copy, Clone)]\nenum LuhnState {\n    Even,\n    Odd,\n}\n\nfn digits(n: u64) -> Digits {\n    Digits { m: n }\n}\n\npub fn luhn_test(n: u64) -> bool {\n    let odd_even = [LuhnState::Odd, LuhnState::Even];\n    let numbers = digits(n).zip(odd_even.iter().cycle().cloned());\n    let sum = numbers.fold(0u64, |s, n| {\n        s + match n {\n            (n, LuhnState::Odd) => n,\n            (n, LuhnState::Even) => digits(n * 2).sum(),\n        }\n    });\n    sum % 10 == 0\n}\n\n#[test]\nfn test_inputs() {\n    assert!(luhn_test(49927398716));\n    assert!(!luhn_test(49927398717));\n    assert!(!luhn_test(1234567812345678));\n    assert!(luhn_test(1234567812345670));\n}\n",
    "path": "tasks/luhn-test-of-credit-card-numbers",
    "remote_code": "extern crate luhn_test_of_credit_card_numbers;\n\nuse luhn_test_of_credit_card_numbers::luhn_test;\n\nfn validate_isin(isin: &str) -> bool {\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len() != 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes\n        .iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            } else {\n                (c + 10 - ('A' as u8)).to_string().into_bytes()\n            }\n        })\n        .collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<u64>().unwrap();\n\n    return luhn_test(number as u64);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::validate_isin;\n\n    #[test]\n    fn test_validate_isin() {\n        assert_eq!(validate_isin(\"US0378331005\"), true);\n        assert_eq!(validate_isin(\"US0373831005\"), false);\n        assert_eq!(validate_isin(\"U50378331005\"), false);\n        assert_eq!(validate_isin(\"US03378331005\"), false);\n        assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n        assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n        assert_eq!(validate_isin(\"FR0000988040\"), true);\n    }\n}",
    "title": "Luhn test of credit card numbers",
    "url": "http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::BigInt;\nuse num::FromPrimitive;\n\nuse std::collections::HashSet;\n\n/// Reverse a number then add it to the original.\nfn rev_add(num: &BigInt) -> BigInt {\n    let rev_string: String = num.to_string().chars().rev().collect();\n    // should be safe, our string is guaranteed to be a number\n    let rev_val: BigInt = rev_string.parse().unwrap();\n    num + rev_val\n}\n\n/// Check if a number is a palindrome when written in base 10.\nfn is_palindrome(num: &BigInt) -> bool {\n    let num_string = num.to_string();\n    let rev_string = num_string.chars().rev();\n    let comp_len = num_string.len() / 2;\n    num_string\n        .chars()\n        .take(comp_len)\n        .eq(rev_string.take(comp_len))\n}\n\n/// Perform a lychrel test on a number, stopping after `max_tests`\n/// Returns the sequence of numbers if this number is a lychrel, None otherwise.\nfn test_lychrel(num: &BigInt, max_tests: usize) -> Option<Vec<BigInt>> {\n    let mut sequence = Vec::<BigInt>::new();\n\n    let is_lychrel = (0..max_tests)\n        .scan(num.clone(), |current, _| {\n            *current = rev_add(current);\n            Some(current.clone())\n        })\n        .inspect(|current| sequence.push(current.clone()))\n        .all(|cur| !is_palindrome(&cur));\n\n    if is_lychrel {\n        Some(sequence)\n    } else {\n        None\n    }\n}\n\n/// Determine if the sequence for a lychrel number is related to a previously seen sequence\nfn is_related(seq: &[BigInt], lychrel_seq_numbers: &HashSet<BigInt>) -> bool {\n    seq.iter().any(|num| lychrel_seq_numbers.contains(num))\n}\n\n/// Find the lychrel numbers up to `max_num` (inclusive).\n/// Returns a tuple (lychrel numbers, related numbers, palindrome lychrel/related numbers)\nfn find_lychrels(max_num: u64, max_tests: usize) -> (Vec<BigInt>, Vec<BigInt>, Vec<BigInt>) {\n    // storage for various outputs\n    let mut lychrels = Vec::<BigInt>::new();\n    let mut relateds = Vec::<BigInt>::new();\n    let mut palindrome_lychrels = Vec::<BigInt>::new();\n\n    let mut lychrel_seq_numbers: HashSet<BigInt> = HashSet::new();\n\n    for i in 1..(max_num + 1) {\n        let num = FromPrimitive::from_u64(i).unwrap();\n        let maybe_lychrel = test_lychrel(&num, max_tests);\n\n        if let Some(lychrel_seq) = maybe_lychrel {\n            // it's a lychrel - check if it's a related number\n            let related = is_related(&lychrel_seq, &lychrel_seq_numbers);\n\n            // update our sequences\n            for seq_num in lychrel_seq {\n                lychrel_seq_numbers.insert(seq_num);\n            }\n\n            if !related {\n                // the number has a new lychrel sequence, store it\n                lychrels.push(num.clone());\n            } else {\n                // just count it as a related number\n                relateds.push(num.clone());\n            }\n\n            if is_palindrome(&num) {\n                // doesn't matter if palindromes are related or not\n                palindrome_lychrels.push(num.clone());\n            }\n        }\n    }\n\n    (lychrels, relateds, palindrome_lychrels)\n}\n\nfn print_nums(before: &str, numbers: &[BigInt]) {\n    print!(\"{}\", before);\n    for (i, current) in numbers.iter().enumerate() {\n        print!(\"{}\", current);\n        if i + 1 < numbers.len() {\n            print!(\", \");\n        }\n    }\n    println!();\n}\n\nfn main() {\n    let max_num: u64 = 10_000;\n    let max_tests: usize = 500;\n\n    println!(\n        \"Calculations using n = 1..{} and limiting each search to {} reverse-digits-and-adds\",\n        max_num, max_tests\n    );\n\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(max_num, max_tests);\n\n    println!(\"Number of Lychrel numbers: {}\", lychrels.len());\n    print_nums(\"Lychrel numbers: \", &lychrels);\n    println!(\"Number of Lychrel related: {}\", relateds.len());\n    println!(\n        \"Number of Lychrel palindromes: {}\",\n        palindrome_lychrels.len()\n    );\n    print_nums(\"Lychrel palindromes: \", &palindrome_lychrels);\n}\n\n#[test]\n#[ignore]\nfn test_lychrel_numbers() {\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(10_000, 500);\n\n    let expected_lychrels = [196, 879, 1997, 7059, 9999]\n        .iter()\n        .map(|&num| FromPrimitive::from_u64(num).unwrap())\n        .collect::<Vec<_>>();\n    assert_eq!(lychrels, expected_lychrels);\n\n    assert_eq!(relateds.len(), 244);\n\n    let expected_palindromes = [4994, 8778, 9999]\n        .iter()\n        .map(|&num| FromPrimitive::from_u64(num).unwrap())\n        .collect::<Vec<_>>();\n    assert_eq!(palindrome_lychrels, expected_palindromes);\n}\n",
    "path": "tasks/lychrel-numbers",
    "remote_code": "extern crate num;\nuse num::FromPrimitive;\nuse num::bigint::BigInt;\n\nuse std::collections::HashSet;\n\n/// Reverse a number then add it to the original.\nfn rev_add(num: &BigInt) -> BigInt {\n    let rev_string: String = num.to_string().chars().rev().collect();\n    // should be safe, our string is guaranteed to be a number\n    let rev_val: BigInt = rev_string.parse().unwrap();\n    num + rev_val\n}\n\n/// Check if a number is a palindrome when written in base 10.\nfn is_palindrome(num: &BigInt) -> bool {\n    let num_string = num.to_string();\n    let rev_string: String = num_string.chars().rev().collect();\n    let comp_len = num_string.len() / 2;\n    num_string[0..comp_len] == rev_string[0..comp_len]\n}\n\n/// Perform a lychrel test on a number, stopping after max_tests\n/// Returns the sequence of numbers if this number is a lychrel, None otherwise.\nfn test_lychrel(num: &BigInt, max_tests: usize) -> Option<Vec<BigInt>> {\n    let mut sequence = Vec::<BigInt>::new();\n\n    let is_lychrel = (0..max_tests)\n        .scan(num.clone(), |current, _| {\n            *current = rev_add(current);\n            Some(current.clone())\n        })\n        .inspect(|current| sequence.push(current.clone()))\n        .filter(|curent| is_palindrome(curent))\n        .next()\n        .is_none();\n\n    if is_lychrel {\n        Some(sequence)\n    }\n    else {\n        None\n    }\n}\n\n/// Determine if the sequence for a lychrel number is related to a previously seen sequence\nfn is_related(seq: &Vec<BigInt>, lychrel_seq_numbers: &HashSet<BigInt>) -> bool {\n    seq.iter().filter(|num| lychrel_seq_numbers.contains(num)).next().is_some()\n}\n\n/// Find the lychrel numbers up to max_num (inclusive).\n/// Returns a tuple (lychrel numbers, related numbers, palindrome lychrel/related numbers)\nfn find_lychrels(max_num: u64, max_tests: usize) -> (Vec<BigInt>, Vec<BigInt>, Vec<BigInt>) {\n    // storage for various outputs\n    let mut lychrels = Vec::<BigInt>::new();\n    let mut relateds = Vec::<BigInt>::new();\n    let mut palindrome_lychrels = Vec::<BigInt>::new();\n\n    let mut lychrel_seq_numbers: HashSet<BigInt> = HashSet::new();\n\n    for i in (1..(max_num + 1)) {\n        let num = FromPrimitive::from_u64(i).unwrap();\n        let maybe_lychrel = test_lychrel(&num, max_tests);\n\n        if let Some(lychrel_seq) = maybe_lychrel {\n            // it's a lychrel - check if it's a related number\n            let related = is_related(&lychrel_seq, &lychrel_seq_numbers);\n\n            // update our sequences\n            for seq_num in lychrel_seq.into_iter() {\n                lychrel_seq_numbers.insert(seq_num);\n            }\n\n            if !related {\n                // the number has a new lychrel sequence, store it\n                lychrels.push(num.clone());\n            }\n            else {\n                // just count it as a related number\n                relateds.push(num.clone());\n            }\n\n            if is_palindrome(&num) {\n                // doesn't matter if palindromes are related or not\n                palindrome_lychrels.push(num.clone());\n            }\n        }\n    }\n\n    (lychrels, relateds, palindrome_lychrels)\n}\n\nfn print_nums(before: &str, numbers: &Vec<BigInt>) {\n    print!(\"{}\", before);\n    for (i, current) in numbers.iter().enumerate() {\n        print!(\"{}\", current);\n        if i + 1 < numbers.len() {\n            print!(\", \");\n        }\n    }\n    println!(\"\");\n}\n\nfn main() {\n    let max_num: u64 = 10_000;\n    let max_tests: usize = 500;\n\n    println!(\"Calculations using n = 1..{} and limiting each search to {} reverse-digits-and-adds\",\n        max_num, max_tests);\n\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(max_num, max_tests);\n\n    println!(\"Number of Lychrel numbers: {}\", lychrels.len());\n    print_nums(\"Lychrel numbers: \", &lychrels);\n    println!(\"Number of Lychrel related: {}\", relateds.len());\n    println!(\"Number of Lychrel palindromes: {}\", palindrome_lychrels.len());\n    print_nums(\"Lychrel palindromes: \", &palindrome_lychrels);\n}",
    "title": "Lychrel numbers",
    "url": "http://rosettacode.org/wiki/Lychrel_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate reqwest;\n\nuse std::{thread, time};\n\nfn get_vendor(mac: &str) -> Option<String> {\n    let mut url = String::from(\"http://api.macvendors.com/\");\n    url.push_str(mac);\n    let url_ref = &url;\n    match reqwest::get(url_ref) {\n        Ok(mut res) => match res.text() {\n            Ok(text) => {\n                if text.contains(\"Not Found\") {\n                    Some(\"N/A\".to_string())\n                } else {\n                    Some(text)\n                }\n            }\n            Err(e) => {\n                println!(\"{:?}\", e);\n                None\n            }\n        },\n        Err(e) => {\n            println!(\"{:?}\", e);\n            None\n        }\n    }\n}\n\nfn main() {\n    let duration = time::Duration::from_millis(1000);\n    match get_vendor(\"88:53:2E:67:07:BE\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"FC:FB:FB:01:FA:21\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"FC-A1-3E\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"abcdefg\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n}\n",
    "title": "MAC vendor lookup",
    "url": "http://rosettacode.org/wiki/MAC_vendor_lookup"
  },
  {
    "local_code": "// MD4, based on RFC 1186 and RFC 1320.\n//\n// https://www.ietf.org/rfc/rfc1186.txt\n// https://tools.ietf.org/html/rfc1320\n//\n\nuse std::fmt::Write;\nuse std::mem;\n\n// Let not(X) denote the bit-wise complement of X.\n// Let X v Y denote the bit-wise OR of X and Y.\n// Let X xor Y denote the bit-wise XOR of X and Y.\n// Let XY denote the bit-wise AND of X and Y.\n\n// f(X,Y,Z)  =  XY v not(X)Z\nfn f(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (!x & z)\n}\n\n// g(X,Y,Z)  =  XY v XZ v YZ\nfn g(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (x & z) | (y & z)\n}\n\n// h(X,Y,Z)  =  X xor Y xor Z\nfn h(x: u32, y: u32, z: u32) -> u32 {\n    x ^ y ^ z\n}\n\n// Round 1 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + f(B,C,D) + X[i]) <<< s\nmacro_rules! md4round1 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        // Rust defaults to non-overflowing arithmetic, so we need to specify wrapping add.\n        $a = ($a.wrapping_add(f($b, $c, $d)).wrapping_add($x[$i])).rotate_left($s);\n    }};\n}\n\n// Round 2 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .\nmacro_rules! md4round2 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        $a = ($a\n            .wrapping_add(g($b, $c, $d))\n            .wrapping_add($x[$i])\n            .wrapping_add(0x5a82_7999_u32))\n        .rotate_left($s);\n    }};\n}\n\n// Round 3 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s .\nmacro_rules! md4round3 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        $a = ($a\n            .wrapping_add(h($b, $c, $d))\n            .wrapping_add($x[$i])\n            .wrapping_add(0x6ed9_eba1_u32))\n        .rotate_left($s);\n    }};\n}\n\nfn convert_byte_vec_to_u32(mut bytes: Vec<u8>) -> Vec<u32> {\n    bytes.shrink_to_fit();\n    let num_bytes = bytes.len();\n    let num_words = num_bytes / 4;\n    unsafe {\n        let words = Vec::from_raw_parts(bytes.as_mut_ptr() as *mut u32, num_words, num_words);\n        mem::forget(bytes);\n        words\n    }\n}\n\n// Returns a 128-bit MD4 hash as an array of four 32-bit words.\n// Based on RFC 1186 from https://www.ietf.org/rfc/rfc1186.txt\n#[allow(clippy::many_single_char_names)]\nfn md4<T: Into<Vec<u8>>>(input: T) -> [u32; 4] {\n    let mut bytes = input.into().to_vec();\n    let initial_bit_len = (bytes.len() << 3) as u64;\n\n    // Step 1. Append padding bits\n    // Append one '1' bit, then append 0 ≤ k < 512 bits '0', such that the resulting message\n    // length in bis is congruent to 448 (mod 512).\n    // Since our message is in bytes, we use one byte with a set high-order bit (0x80) plus\n    // a variable number of zero bytes.\n\n    // Append zeros\n    // Number of padding bytes needed is 448 bits (56 bytes) modulo 512 bits (64 bytes)\n    bytes.push(0x80_u8);\n    while (bytes.len() % 64) != 56 {\n        bytes.push(0_u8);\n    }\n\n    // Everything after this operates on 32-bit words, so reinterpret the buffer.\n    let mut w = convert_byte_vec_to_u32(bytes);\n\n    // Step 2. Append length\n    // A 64-bit representation of b (the length of the message before the padding bits were added)\n    // is appended to the result of the previous step, low-order bytes first.\n    w.push(initial_bit_len as u32); // Push low-order bytes first\n    w.push((initial_bit_len >> 32) as u32);\n\n    // Step 3. Initialize MD buffer\n    let mut a = 0x6745_2301_u32;\n    let mut b = 0xefcd_ab89_u32;\n    let mut c = 0x98ba_dcfe_u32;\n    let mut d = 0x1032_5476_u32;\n\n    // Step 4. Process message in 16-word blocks\n    let n = w.len();\n    for i in 0..n / 16 {\n        // Select the next 512-bit (16-word) block to process.\n        let x = &w[i * 16..i * 16 + 16];\n\n        let aa = a;\n        let bb = b;\n        let cc = c;\n        let dd = d;\n\n        // [Round 1]\n        md4round1!(a, b, c, d, 0, 3, x); // [A B C D 0 3]\n        md4round1!(d, a, b, c, 1, 7, x); // [D A B C 1 7]\n        md4round1!(c, d, a, b, 2, 11, x); // [C D A B 2 11]\n        md4round1!(b, c, d, a, 3, 19, x); // [B C D A 3 19]\n        md4round1!(a, b, c, d, 4, 3, x); // [A B C D 4 3]\n        md4round1!(d, a, b, c, 5, 7, x); // [D A B C 5 7]\n        md4round1!(c, d, a, b, 6, 11, x); // [C D A B 6 11]\n        md4round1!(b, c, d, a, 7, 19, x); // [B C D A 7 19]\n        md4round1!(a, b, c, d, 8, 3, x); // [A B C D 8 3]\n        md4round1!(d, a, b, c, 9, 7, x); // [D A B C 9 7]\n        md4round1!(c, d, a, b, 10, 11, x); // [C D A B 10 11]\n        md4round1!(b, c, d, a, 11, 19, x); // [B C D A 11 19]\n        md4round1!(a, b, c, d, 12, 3, x); // [A B C D 12 3]\n        md4round1!(d, a, b, c, 13, 7, x); // [D A B C 13 7]\n        md4round1!(c, d, a, b, 14, 11, x); // [C D A B 14 11]\n        md4round1!(b, c, d, a, 15, 19, x); // [B C D A 15 19]\n\n        // [Round 2]\n        md4round2!(a, b, c, d, 0, 3, x); //[A B C D 0  3]\n        md4round2!(d, a, b, c, 4, 5, x); //[D A B C 4  5]\n        md4round2!(c, d, a, b, 8, 9, x); //[C D A B 8  9]\n        md4round2!(b, c, d, a, 12, 13, x); //[B C D A 12 13]\n        md4round2!(a, b, c, d, 1, 3, x); //[A B C D 1  3]\n        md4round2!(d, a, b, c, 5, 5, x); //[D A B C 5  5]\n        md4round2!(c, d, a, b, 9, 9, x); //[C D A B 9  9]\n        md4round2!(b, c, d, a, 13, 13, x); //[B C D A 13 13]\n        md4round2!(a, b, c, d, 2, 3, x); //[A B C D 2  3]\n        md4round2!(d, a, b, c, 6, 5, x); //[D A B C 6  5]\n        md4round2!(c, d, a, b, 10, 9, x); //[C D A B 10 9]\n        md4round2!(b, c, d, a, 14, 13, x); //[B C D A 14 13]\n        md4round2!(a, b, c, d, 3, 3, x); //[A B C D 3  3]\n        md4round2!(d, a, b, c, 7, 5, x); //[D A B C 7  5]\n        md4round2!(c, d, a, b, 11, 9, x); //[C D A B 11 9]\n        md4round2!(b, c, d, a, 15, 13, x); //[B C D A 15 13]\n\n        // [Round 3]\n        md4round3!(a, b, c, d, 0, 3, x); //[A B C D 0  3]\n        md4round3!(d, a, b, c, 8, 9, x); //[D A B C 8  9]\n        md4round3!(c, d, a, b, 4, 11, x); //[C D A B 4  11]\n        md4round3!(b, c, d, a, 12, 15, x); //[B C D A 12 15]\n        md4round3!(a, b, c, d, 2, 3, x); //[A B C D 2  3]\n        md4round3!(d, a, b, c, 10, 9, x); //[D A B C 10 9]\n        md4round3!(c, d, a, b, 6, 11, x); //[C D A B 6  11]\n        md4round3!(b, c, d, a, 14, 15, x); //[B C D A 14 15]\n        md4round3!(a, b, c, d, 1, 3, x); //[A B C D 1  3]\n        md4round3!(d, a, b, c, 9, 9, x); //[D A B C 9  9]\n        md4round3!(c, d, a, b, 5, 11, x); //[C D A B 5  11]\n        md4round3!(b, c, d, a, 13, 15, x); //[B C D A 13 15]\n        md4round3!(a, b, c, d, 3, 3, x); //[A B C D 3  3]\n        md4round3!(d, a, b, c, 11, 9, x); //[D A B C 11 9]\n        md4round3!(c, d, a, b, 7, 11, x); //[C D A B 7  11]\n        md4round3!(b, c, d, a, 15, 15, x); //[B C D A 15 15]\n\n        a = a.wrapping_add(aa);\n        b = b.wrapping_add(bb);\n        c = c.wrapping_add(cc);\n        d = d.wrapping_add(dd);\n    }\n\n    // Step 5. Output\n    // The message digest produced as output is A, B, C, D. That is, we begin with the low-order\n    // byte of A, and end with the high-order byte of D.\n    [\n        u32::from_be(a),\n        u32::from_be(b),\n        u32::from_be(c),\n        u32::from_be(d),\n    ]\n}\n\nfn digest_to_str(digest: &[u32]) -> String {\n    let mut s = String::new();\n    for &word in digest {\n        write!(&mut s, \"{:08x}\", word).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let val = \"Rosetta Code\";\n    println!(\"md4(\\\"{}\\\") = {}\", val, digest_to_str(&md4(val)));\n}\n\n#[test]\nfn test_rfc1320() {\n    // The following test vectors are defined in RFC 1320 (The MD4 Message-Digest Algorithm).\n    assert_eq!(\"31d6cfe0d16ae931b73c59d7e0c089c0\", digest_to_str(&md4(\"\")));\n    assert_eq!(\"bde52cb31de33e46245e05fbdbd6fb24\", digest_to_str(&md4(\"a\")));\n\n    assert_eq!(\n        \"a448017aaf21d8525fc10ae87aa6729d\",\n        digest_to_str(&md4(\"abc\"))\n    );\n\n    assert_eq!(\n        \"d9130a8164549fe818874806e1c7014b\",\n        digest_to_str(&md4(\"message digest\"))\n    );\n\n    assert_eq!(\n        \"d79e1c308aa5bbcdeea8ed63df412da9\",\n        digest_to_str(&md4(\"abcdefghijklmnopqrstuvwxyz\"))\n    );\n\n    assert_eq!(\n        \"043f8582f241db351ce627e153e7f0e4\",\n        digest_to_str(&md4(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n                            0123456789\"))\n    );\n\n    assert_eq!(\n        \"e33b4ddc9c38f2199c3e7b164fcc0536\",\n        digest_to_str(&md4(\n            \"12345678901234567890123456789012345678901234567890123456789\\\n             012345678901234567890\"\n        ))\n    );\n}\n",
    "path": "tasks/md4",
    "remote_code": "// MD4, based on RFC 1186 and RFC 1320.\n//\n// https://www.ietf.org/rfc/rfc1186.txt\n// https://tools.ietf.org/html/rfc1320\n//\n\nuse std::fmt::Write;\nuse std::mem;\n\n// Let not(X) denote the bit-wise complement of X.\n// Let X v Y denote the bit-wise OR of X and Y.\n// Let X xor Y denote the bit-wise XOR of X and Y.\n// Let XY denote the bit-wise AND of X and Y.\n\n// f(X,Y,Z)  =  XY v not(X)Z\nfn f(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (!x & z)\n}\n\n// g(X,Y,Z)  =  XY v XZ v YZ\nfn g(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (x & z) | (y & z)\n}\n\n// h(X,Y,Z)  =  X xor Y xor Z\nfn h(x: u32, y: u32, z: u32) -> u32 {\n    x ^ y ^ z\n}\n\n// Round 1 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + f(B,C,D) + X[i]) <<< s\nmacro_rules! md4round1 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            // Rust defaults to non-overflowing arithmetic, so we need to specify wrapping add.\n            $a = ($a.wrapping_add( f($b, $c, $d) ).wrapping_add( $x[$i] ) ).rotate_left($s);\n        }\n    };\n}\n\n// Round 2 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .\nmacro_rules! md4round2 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            $a = ($a.wrapping_add( g($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x5a827999_u32)).rotate_left($s);\n        }\n    };\n}\n\n// Round 3 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s .\nmacro_rules! md4round3 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            $a = ($a.wrapping_add(h($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x6ed9eba1_u32)).rotate_left($s);\n        }\n    };\n}\n\nfn convert_byte_vec_to_u32(mut bytes: Vec<u8>) -> Vec<u32> {\n\n    bytes.shrink_to_fit();\n    let num_bytes = bytes.len();\n    let num_words = num_bytes / 4;\n    unsafe {\n        let words = Vec::from_raw_parts(bytes.as_mut_ptr() as *mut u32, num_words, num_words);\n        mem::forget(bytes);\n        words\n    }\n}\n\n// Returns a 128-bit MD4 hash as an array of four 32-bit words.\n// Based on RFC 1186 from https://www.ietf.org/rfc/rfc1186.txt\nfn md4<T: Into<Vec<u8>>>(input: T) -> [u32; 4] {\n\n    let mut bytes = input.into().to_vec();\n    let initial_bit_len = (bytes.len() << 3) as u64;\n\n    // Step 1. Append padding bits\n    // Append one '1' bit, then append 0 ≤ k < 512 bits '0', such that the resulting message\n    // length in bis is congruent to 448 (mod 512).\n    // Since our message is in bytes, we use one byte with a set high-order bit (0x80) plus\n    // a variable number of zero bytes.\n\n    // Append zeros\n    // Number of padding bytes needed is 448 bits (56 bytes) modulo 512 bits (64 bytes)\n    bytes.push(0x80_u8);\n    while (bytes.len() % 64) != 56 {\n        bytes.push(0_u8);\n    }\n\n    // Everything after this operates on 32-bit words, so reinterpret the buffer.\n    let mut w = convert_byte_vec_to_u32(bytes);\n\n    // Step 2. Append length\n    // A 64-bit representation of b (the length of the message before the padding bits were added)\n    // is appended to the result of the previous step, low-order bytes first.\n    w.push(initial_bit_len as u32); // Push low-order bytes first\n    w.push((initial_bit_len >> 32) as u32);\n\n    // Step 3. Initialize MD buffer\n    let mut a = 0x67452301_u32;\n    let mut b = 0xefcdab89_u32;\n    let mut c = 0x98badcfe_u32;\n    let mut d = 0x10325476_u32;\n\n    // Step 4. Process message in 16-word blocks\n    let n = w.len();\n    for i in 0..n / 16 {\n\n        // Select the next 512-bit (16-word) block to process.\n        let x = &w[i * 16..i * 16 + 16];\n\n        let aa = a;\n        let bb = b;\n        let cc = c;\n        let dd = d;\n\n        // [Round 1]\n        md4round1!(a, b, c, d, 0, 3, x);  // [A B C D 0 3]\n        md4round1!(d, a, b, c, 1, 7, x);  // [D A B C 1 7]\n        md4round1!(c, d, a, b, 2, 11, x); // [C D A B 2 11]\n        md4round1!(b, c, d, a, 3, 19, x); // [B C D A 3 19]\n        md4round1!(a, b, c, d, 4, 3, x);  // [A B C D 4 3]\n        md4round1!(d, a, b, c, 5, 7, x);  // [D A B C 5 7]\n        md4round1!(c, d, a, b, 6, 11, x); // [C D A B 6 11]\n        md4round1!(b, c, d, a, 7, 19, x); // [B C D A 7 19]\n        md4round1!(a, b, c, d, 8, 3, x);  // [A B C D 8 3]\n        md4round1!(d, a, b, c, 9, 7, x);  // [D A B C 9 7]\n        md4round1!(c, d, a, b, 10, 11, x);// [C D A B 10 11]\n        md4round1!(b, c, d, a, 11, 19, x);// [B C D A 11 19]\n        md4round1!(a, b, c, d, 12, 3, x); // [A B C D 12 3]\n        md4round1!(d, a, b, c, 13, 7, x); // [D A B C 13 7]\n        md4round1!(c, d, a, b, 14, 11, x);// [C D A B 14 11]\n        md4round1!(b, c, d, a, 15, 19, x);// [B C D A 15 19]\n\n        // [Round 2]\n        md4round2!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]\n        md4round2!(d, a, b, c, 4, 5, x);  //[D A B C 4  5]\n        md4round2!(c, d, a, b, 8, 9, x);  //[C D A B 8  9]\n        md4round2!(b, c, d, a, 12, 13, x);//[B C D A 12 13]\n        md4round2!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]\n        md4round2!(d, a, b, c, 5, 5, x);  //[D A B C 5  5]\n        md4round2!(c, d, a, b, 9, 9, x);  //[C D A B 9  9]\n        md4round2!(b, c, d, a, 13, 13, x);//[B C D A 13 13]\n        md4round2!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]\n        md4round2!(d, a, b, c, 6, 5, x);  //[D A B C 6  5]\n        md4round2!(c, d, a, b, 10, 9, x); //[C D A B 10 9]\n        md4round2!(b, c, d, a, 14, 13, x);//[B C D A 14 13]\n        md4round2!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]\n        md4round2!(d, a, b, c, 7, 5, x);  //[D A B C 7  5]\n        md4round2!(c, d, a, b, 11, 9, x); //[C D A B 11 9]\n        md4round2!(b, c, d, a, 15, 13, x);//[B C D A 15 13]\n\n        // [Round 3]\n        md4round3!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]\n        md4round3!(d, a, b, c, 8, 9, x);  //[D A B C 8  9]\n        md4round3!(c, d, a, b, 4, 11, x); //[C D A B 4  11]\n        md4round3!(b, c, d, a, 12, 15, x);//[B C D A 12 15]\n        md4round3!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]\n        md4round3!(d, a, b, c, 10, 9, x); //[D A B C 10 9]\n        md4round3!(c, d, a, b, 6, 11, x); //[C D A B 6  11]\n        md4round3!(b, c, d, a, 14, 15, x);//[B C D A 14 15]\n        md4round3!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]\n        md4round3!(d, a, b, c, 9, 9, x);  //[D A B C 9  9]\n        md4round3!(c, d, a, b, 5, 11, x); //[C D A B 5  11]\n        md4round3!(b, c, d, a, 13, 15, x);//[B C D A 13 15]\n        md4round3!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]\n        md4round3!(d, a, b, c, 11, 9, x); //[D A B C 11 9]\n        md4round3!(c, d, a, b, 7, 11, x); //[C D A B 7  11]\n        md4round3!(b, c, d, a, 15, 15, x);//[B C D A 15 15]\n\n        a = a.wrapping_add(aa);\n        b = b.wrapping_add(bb);\n        c = c.wrapping_add(cc);\n        d = d.wrapping_add(dd);\n    }\n\n    // Step 5. Output\n    // The message digest produced as output is A, B, C, D. That is, we begin with the low-order\n    // byte of A, and end with the high-order byte of D.\n    [u32::from_be(a), u32::from_be(b), u32::from_be(c), u32::from_be(d)]\n}\n\nfn digest_to_str(digest: &[u32]) -> String {\n    let mut s = String::new();\n    for &word in digest {\n        write!(&mut s, \"{:08x}\", word).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let val = \"Rosetta Code\";\n    println!(\"md4(\\\"{}\\\") = {}\", val, digest_to_str(&md4(val)));\n}",
    "title": "MD4",
    "url": "http://rosettacode.org/wiki/MD4"
  },
  {
    "local_code": "//! Ported from C - Simple MD5 implementation\n//! on Wikipedia: <https://en.wikipedia.org/wiki/MD5>\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping as wr;\n\nfn main() {\n    let inputs = [\n        &b\"a\"[..],\n        &b\"abc\"[..],\n        &b\"message digest\"[..],\n        &b\"abcdefghijklmnopqrstuvwxyz\"[..],\n        &b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[..],\n        &b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"[..],\n    ];\n\n    for &input in &inputs {\n        println!(\"{:?}\", md5(input));\n    }\n}\n\n/// Constants are the integer part of the sines of integers (in radians) * 2^32.\nconst K: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n\n/// R specifies the per-round shift amounts\nconst R: [u32; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\n/// \"newtype\" for [u8; 16] to specify it's a MD5 hash\nstruct MD5([u8; 16]);\n\nimpl Debug for MD5 {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let MD5(md5) = *self;\n        for b in &md5 {\n            write!(f, \"{:02x}\", *b)?;\n        }\n        Ok(())\n    }\n}\n\nfn to_bytes(val: u64) -> [u8; 8] {\n    let mut tmp: [u8; 8] = [0u8; 8];\n    for (i, byte) in tmp.iter_mut().enumerate() {\n        *byte = (val >> (8 * i)) as u8;\n    }\n    tmp\n}\n\n#[allow(clippy::many_single_char_names)]\nfn md5(initial_msg: &[u8]) -> MD5 {\n    let initial_len = initial_msg.len() as u64;\n\n    // These vars will contain the hash\n    let mut h: [wr<u32>; 4] = [\n        wr(0x6745_2301),\n        wr(0xefcd_ab89),\n        wr(0x98ba_dcfe),\n        wr(0x1032_5476),\n    ];\n\n    // Pre-processing:\n    // append \"1\" bit to message\n    // append \"0\" bits until message length in bits ≡ 448 (mod 512)\n    // append length mod (2^64) to message\n    let mut new_len = initial_len;\n    while new_len % (512 / 8) != 448 / 8 {\n        new_len += 1;\n    }\n\n    let mut msg = initial_msg.to_vec();\n    msg.push(0x80u8); // append the \"1\" bit; most significant bit is \"first\"\n\n    // append \"0\" bits\n    msg.resize(new_len as usize, 0);\n\n    // append the len in bits at the end of the buffer.\n    msg.extend_from_slice(&to_bytes(initial_len << 3));\n\n    assert_eq!(msg.len() % 64, 0);\n\n    let mut w: [u32; 16] = [0u32; 16];\n    // Process the message in successive 512-bit chunks:\n    // for each 512-bit chunk of message:\n    for offset in (0u64..new_len).step_by(512 / 8) {\n        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15\n        for i in 0u32..16 {\n            let j = i as usize * 4 + offset as usize;\n            w[i as usize] = u32::from(msg[j])\n                | u32::from(msg[j + 1]) << 8\n                | u32::from(msg[j + 2]) << 16\n                | u32::from(msg[j + 3]) << 24;\n        }\n\n        // Initialize hash value for this chunk:\n        let (mut a, mut b, mut c, mut d) = (h[0], h[1], h[2], h[3]);\n\n        // Main loop:\n        for ind in 0..64 {\n            let (f, g) = match ind {\n                i @ 0..=15 => ((b & c) | ((!b) & d) /* f */, i), //g\n                i @ 16..=31 => ((d & b) | ((!d) & c), (5 * i + 1) % 16),\n                i @ 32..=47 => (b ^ c ^ d, (3 * i + 5) % 16),\n                i => (c ^ (b | (!d)), (7 * i) % 16),\n            };\n\n            let temp = d;\n            d = c;\n            c = b;\n            b += wr((a + f + wr(K[ind]) + wr(w[g])).0.rotate_left(R[ind]));\n            a = temp;\n        }\n\n        // Add this chunk's hash to result so far:\n        h[0] += a;\n        h[1] += b;\n        h[2] += c;\n        h[3] += d;\n    }\n    drop(msg); // cleanup, msg is freed\n\n    // var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)\n    let mut digest = [0u8; 16];\n    for (i, s) in h.iter().enumerate() {\n        digest[i * 4] = (*s).0 as u8;\n        digest[i * 4 + 1] = (*s >> 8).0 as u8;\n        digest[i * 4 + 2] = (*s >> 16).0 as u8;\n        digest[i * 4 + 3] = (*s >> 24).0 as u8;\n    }\n    MD5(digest)\n}\n\n#[test]\nfn helper_fns() {\n    assert_eq!(64, 8u32.rotate_left(3));\n\n    let exp: [u8; 8] = [64u8, 226, 1, 0, 0, 0, 0, 0];\n    assert!(to_bytes(123456) == exp);\n}\n\n#[test]\nfn known_hashes() {\n    let in_out: &[(&[u8], &str)] = &[\n        (b\"\", \"d41d8cd98f00b204e9800998ecf8427e\"),\n        (b\"a\", \"0cc175b9c0f1b6a831c399e269772661\"),\n        (b\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"),\n        (b\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"),\n        (\n            b\"abcdefghijklmnopqrstuvwxyz\",\n            \"c3fcd3d76192e4007dfb496cca67e13b\",\n        ),\n        (\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            \"d174ab98d277d9f5a5611c2c9f419d9f\",\n        ),\n        (\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n            \"57edf4a22be3c955ac49da2e2107b67a\",\n        ),\n    ];\n\n    for &(i, o) in in_out {\n        let m = md5(i);\n        assert_eq!(format!(\"{:?}\", m), o.to_string());\n    }\n}\nuse md5::{Digest, Md5};\nfn main() {\n    // digest is a convenience function\n    // when you have the full value to hash\n    let hash = Md5::digest(b\"The quick brown fox jumped over the lazy dog's back\");\n    // print the hashed value\n    // with the handy formatting traits:\n    // https://doc.rust-lang.org/std/fmt/index.html#formatting-traits\n    println!(\"{:x}\", hash);\n}\n",
    "path": "tasks/md5",
    "remote_code": "\nextern crate crypto;\n\nuse crypto::digest::Digest;\nuse crypto::md5::Md5;\n\nfn main() {\n    let mut sh = Md5::new();\n    sh.input_str(\"The quick brown fox jumped over the lazy dog's back\");\n    println!(\"{}\", sh.result_str());\n}\n",
    "title": "MD5",
    "url": "http://rosettacode.org/wiki/MD5"
  },
  {
    "local_code": "//! Ported from C - Simple MD5 implementation\n//! on Wikipedia: <https://en.wikipedia.org/wiki/MD5>\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping as wr;\n\nfn main() {\n    let inputs = [\n        &b\"a\"[..],\n        &b\"abc\"[..],\n        &b\"message digest\"[..],\n        &b\"abcdefghijklmnopqrstuvwxyz\"[..],\n        &b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[..],\n        &b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"[..],\n    ];\n\n    for &input in &inputs {\n        println!(\"{:?}\", md5(input));\n    }\n}\n\n/// Constants are the integer part of the sines of integers (in radians) * 2^32.\nconst K: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n\n/// R specifies the per-round shift amounts\nconst R: [u32; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\n/// \"newtype\" for [u8; 16] to specify it's a MD5 hash\nstruct MD5([u8; 16]);\n\nimpl Debug for MD5 {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let MD5(md5) = *self;\n        for b in &md5 {\n            write!(f, \"{:02x}\", *b)?;\n        }\n        Ok(())\n    }\n}\n\nfn to_bytes(val: u64) -> [u8; 8] {\n    let mut tmp: [u8; 8] = [0u8; 8];\n    for (i, byte) in tmp.iter_mut().enumerate() {\n        *byte = (val >> (8 * i)) as u8;\n    }\n    tmp\n}\n\n#[allow(clippy::many_single_char_names)]\nfn md5(initial_msg: &[u8]) -> MD5 {\n    let initial_len = initial_msg.len() as u64;\n\n    // These vars will contain the hash\n    let mut h: [wr<u32>; 4] = [\n        wr(0x6745_2301),\n        wr(0xefcd_ab89),\n        wr(0x98ba_dcfe),\n        wr(0x1032_5476),\n    ];\n\n    // Pre-processing:\n    // append \"1\" bit to message\n    // append \"0\" bits until message length in bits ≡ 448 (mod 512)\n    // append length mod (2^64) to message\n    let mut new_len = initial_len;\n    while new_len % (512 / 8) != 448 / 8 {\n        new_len += 1;\n    }\n\n    let mut msg = initial_msg.to_vec();\n    msg.push(0x80u8); // append the \"1\" bit; most significant bit is \"first\"\n\n    // append \"0\" bits\n    msg.resize(new_len as usize, 0);\n\n    // append the len in bits at the end of the buffer.\n    msg.extend_from_slice(&to_bytes(initial_len << 3));\n\n    assert_eq!(msg.len() % 64, 0);\n\n    let mut w: [u32; 16] = [0u32; 16];\n    // Process the message in successive 512-bit chunks:\n    // for each 512-bit chunk of message:\n    for offset in (0u64..new_len).step_by(512 / 8) {\n        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15\n        for i in 0u32..16 {\n            let j = i as usize * 4 + offset as usize;\n            w[i as usize] = u32::from(msg[j])\n                | u32::from(msg[j + 1]) << 8\n                | u32::from(msg[j + 2]) << 16\n                | u32::from(msg[j + 3]) << 24;\n        }\n\n        // Initialize hash value for this chunk:\n        let (mut a, mut b, mut c, mut d) = (h[0], h[1], h[2], h[3]);\n\n        // Main loop:\n        for ind in 0..64 {\n            let (f, g) = match ind {\n                i @ 0..=15 => ((b & c) | ((!b) & d) /* f */, i), //g\n                i @ 16..=31 => ((d & b) | ((!d) & c), (5 * i + 1) % 16),\n                i @ 32..=47 => (b ^ c ^ d, (3 * i + 5) % 16),\n                i => (c ^ (b | (!d)), (7 * i) % 16),\n            };\n\n            let temp = d;\n            d = c;\n            c = b;\n            b += wr((a + f + wr(K[ind]) + wr(w[g])).0.rotate_left(R[ind]));\n            a = temp;\n        }\n\n        // Add this chunk's hash to result so far:\n        h[0] += a;\n        h[1] += b;\n        h[2] += c;\n        h[3] += d;\n    }\n    drop(msg); // cleanup, msg is freed\n\n    // var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)\n    let mut digest = [0u8; 16];\n    for (i, s) in h.iter().enumerate() {\n        digest[i * 4] = (*s).0 as u8;\n        digest[i * 4 + 1] = (*s >> 8).0 as u8;\n        digest[i * 4 + 2] = (*s >> 16).0 as u8;\n        digest[i * 4 + 3] = (*s >> 24).0 as u8;\n    }\n    MD5(digest)\n}\n\n#[test]\nfn helper_fns() {\n    assert_eq!(64, 8u32.rotate_left(3));\n\n    let exp: [u8; 8] = [64u8, 226, 1, 0, 0, 0, 0, 0];\n    assert!(to_bytes(123456) == exp);\n}\n\n#[test]\nfn known_hashes() {\n    let in_out: &[(&[u8], &str)] = &[\n        (b\"\", \"d41d8cd98f00b204e9800998ecf8427e\"),\n        (b\"a\", \"0cc175b9c0f1b6a831c399e269772661\"),\n        (b\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"),\n        (b\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"),\n        (\n            b\"abcdefghijklmnopqrstuvwxyz\",\n            \"c3fcd3d76192e4007dfb496cca67e13b\",\n        ),\n        (\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            \"d174ab98d277d9f5a5611c2c9f419d9f\",\n        ),\n        (\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n            \"57edf4a22be3c955ac49da2e2107b67a\",\n        ),\n    ];\n\n    for &(i, o) in in_out {\n        let m = md5(i);\n        assert_eq!(format!(\"{:?}\", m), o.to_string());\n    }\n}\n",
    "path": "tasks/md5/implementation",
    "remote_code": "\n#![allow(non_snake_case)] // RFC 1321 uses many capitalized variables\nuse std::mem;\n\nfn md5(mut msg: Vec<u8>) -> (u32, u32, u32, u32) {\n    let bitcount = msg.len().saturating_mul(8) as u64;\n\n    // Step 1: Append Padding Bits\n    msg.push(0b10000000);\n    while (msg.len() * 8) % 512 != 448 {\n        msg.push(0u8);\n    }\n\n    // Step 2. Append Length  (64 bit integer)\n    msg.extend(&[\n        bitcount as u8,\n        (bitcount >> 8) as u8,\n        (bitcount >> 16) as u8,\n        (bitcount >> 24) as u8,\n        (bitcount >> 32) as u8,\n        (bitcount >> 40) as u8,\n        (bitcount >> 48) as u8,\n        (bitcount >> 56) as u8,\n    ]);\n\n    // Step 3. Initialize MD Buffer\n    /*A four-word buffer (A,B,C,D) is used to compute the message digest.\n    Here each of A, B, C, D is a 32-bit register.*/\n    let mut A = 0x67452301u32;\n    let mut B = 0xefcdab89u32;\n    let mut C = 0x98badcfeu32;\n    let mut D = 0x10325476u32;\n\n    // Step 4. Process Message in 16-Word Blocks\n    /* We first define four auxiliary functions */\n    let F = |X: u32, Y: u32, Z: u32| -> u32 { X & Y | !X & Z };\n    let G = |X: u32, Y: u32, Z: u32| -> u32 { X & Z | Y & !Z };\n    let H = |X: u32, Y: u32, Z: u32| -> u32 { X ^ Y ^ Z };\n    let I = |X: u32, Y: u32, Z: u32| -> u32 { Y ^ (X | !Z) };\n\n    /* This step uses a 64-element table T[1 ... 64] constructed from the sine function.  */\n    let T = [\n        0x00000000, // enable use as a 1-indexed table\n        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,\n        0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193,\n        0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d,\n        0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,\n        0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,\n        0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244,\n        0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,\n        0xeb86d391,\n    ];\n\n    /* Process each 16-word block. (since 1 word is 4 bytes, then 16 words is 64 bytes) */\n    for mut block in msg.chunks_exact_mut(64) {\n        /* Copy block into X. */\n        #![allow(unused_mut)]\n        let mut X = unsafe { mem::transmute::<&mut [u8], &mut [u32]>(&mut block) };\n        #[cfg(target_endian = \"big\")]\n        for j in 0..16 {\n            X[j] = X[j].swap_bytes();\n        }\n\n        /* Save Registers A,B,C,D */\n        let AA = A;\n        let BB = B;\n        let CC = C;\n        let DD = D;\n\n        /* Round 1.  Let [abcd k s i] denote the operation\n        a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op1 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(F($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op1!(A, B, C, D, 0, 7, 1);\n        op1!(D, A, B, C, 1, 12, 2);\n        op1!(C, D, A, B, 2, 17, 3);\n        op1!(B, C, D, A, 3, 22, 4);\n\n        op1!(A, B, C, D, 4, 7, 5);\n        op1!(D, A, B, C, 5, 12, 6);\n        op1!(C, D, A, B, 6, 17, 7);\n        op1!(B, C, D, A, 7, 22, 8);\n\n        op1!(A, B, C, D, 8, 7, 9);\n        op1!(D, A, B, C, 9, 12, 10);\n        op1!(C, D, A, B, 10, 17, 11);\n        op1!(B, C, D, A, 11, 22, 12);\n\n        op1!(A, B, C, D, 12, 7, 13);\n        op1!(D, A, B, C, 13, 12, 14);\n        op1!(C, D, A, B, 14, 17, 15);\n        op1!(B, C, D, A, 15, 22, 16);\n\n        /* Round 2. Let [abcd k s i] denote the operation\n        a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op2 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(G($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op2!(A, B, C, D, 1, 5, 17);\n        op2!(D, A, B, C, 6, 9, 18);\n        op2!(C, D, A, B, 11, 14, 19);\n        op2!(B, C, D, A, 0, 20, 20);\n\n        op2!(A, B, C, D, 5, 5, 21);\n        op2!(D, A, B, C, 10, 9, 22);\n        op2!(C, D, A, B, 15, 14, 23);\n        op2!(B, C, D, A, 4, 20, 24);\n\n        op2!(A, B, C, D, 9, 5, 25);\n        op2!(D, A, B, C, 14, 9, 26);\n        op2!(C, D, A, B, 3, 14, 27);\n        op2!(B, C, D, A, 8, 20, 28);\n\n        op2!(A, B, C, D, 13, 5, 29);\n        op2!(D, A, B, C, 2, 9, 30);\n        op2!(C, D, A, B, 7, 14, 31);\n        op2!(B, C, D, A, 12, 20, 32);\n\n        /* Round 3. Let [abcd k s t] denote the operation\n        a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op3 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(H($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op3!(A, B, C, D, 5, 4, 33);\n        op3!(D, A, B, C, 8, 11, 34);\n        op3!(C, D, A, B, 11, 16, 35);\n        op3!(B, C, D, A, 14, 23, 36);\n\n        op3!(A, B, C, D, 1, 4, 37);\n        op3!(D, A, B, C, 4, 11, 38);\n        op3!(C, D, A, B, 7, 16, 39);\n        op3!(B, C, D, A, 10, 23, 40);\n\n        op3!(A, B, C, D, 13, 4, 41);\n        op3!(D, A, B, C, 0, 11, 42);\n        op3!(C, D, A, B, 3, 16, 43);\n        op3!(B, C, D, A, 6, 23, 44);\n\n        op3!(A, B, C, D, 9, 4, 45);\n        op3!(D, A, B, C, 12, 11, 46);\n        op3!(C, D, A, B, 15, 16, 47);\n        op3!(B, C, D, A, 2, 23, 48);\n\n        /* Round 4. Let [abcd k s t] denote the operation\n        a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op4 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(I($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op4!(A, B, C, D, 0, 6, 49);\n        op4!(D, A, B, C, 7, 10, 50);\n        op4!(C, D, A, B, 14, 15, 51);\n        op4!(B, C, D, A, 5, 21, 52);\n\n        op4!(A, B, C, D, 12, 6, 53);\n        op4!(D, A, B, C, 3, 10, 54);\n        op4!(C, D, A, B, 10, 15, 55);\n        op4!(B, C, D, A, 1, 21, 56);\n\n        op4!(A, B, C, D, 8, 6, 57);\n        op4!(D, A, B, C, 15, 10, 58);\n        op4!(C, D, A, B, 6, 15, 59);\n        op4!(B, C, D, A, 13, 21, 60);\n\n        op4!(A, B, C, D, 4, 6, 61);\n        op4!(D, A, B, C, 11, 10, 62);\n        op4!(C, D, A, B, 2, 15, 63);\n        op4!(B, C, D, A, 9, 21, 64);\n\n        /* . . . increment each of the four registers by the value \n        it had before this block was started.) */\n\n        A = A.wrapping_add(AA);\n        B = B.wrapping_add(BB);\n        C = C.wrapping_add(CC);\n        D = D.wrapping_add(DD);\n    }\n    (\n        A.swap_bytes(),\n        B.swap_bytes(),\n        C.swap_bytes(),\n        D.swap_bytes(),\n    )\n}\n\nfn md5_utf8(smsg: &str) -> String {\n    let mut msg = vec![0u8; 0];\n    msg.extend(smsg.as_bytes());\n    let (A, B, C, D) = md5(msg);\n    format!(\"{:08x}{:08x}{:08x}{:08x}\", A, B, C, D)\n}\n\nfn main() {\n    assert!(md5_utf8(\"\") == \"d41d8cd98f00b204e9800998ecf8427e\");\n    assert!(md5_utf8(\"a\") == \"0cc175b9c0f1b6a831c399e269772661\");\n    assert!(md5_utf8(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\");\n    assert!(md5_utf8(\"message digest\") == \"f96b697d7cb7938d525a2f31aaf161d0\");\n    assert!(md5_utf8(\"abcdefghijklmnopqrstuvwxyz\") == \"c3fcd3d76192e4007dfb496cca67e13b\");\n    assert!(md5_utf8(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") == \"d174ab98d277d9f5a5611c2c9f419d9f\");\n    assert!(md5_utf8(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\") == \"57edf4a22be3c955ac49da2e2107b67a\");\n}\n",
    "title": "MD5/Implementation",
    "url": "http://rosettacode.org/wiki/MD5/Implementation"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(target_pointer_width = \"32\", target_pointer_width = \"64\")\n))]\nfn main() {\n    use std::mem;\n    use std::ptr;\n\n    let page_size: usize = 4096;\n    let (bytes, size): (Vec<u8>, usize) = if cfg!(target_pointer_width = \"32\") {\n        (\n            vec![0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3],\n            9,\n        )\n    } else {\n        (vec![0x48, 0x89, 0xf8, 0x48, 0x01, 0xf0, 0xc3], 7)\n    };\n    let f: fn(u8, u8) -> u8 = unsafe {\n        let mut page: *mut libc::c_void = ptr::null_mut();\n        libc::posix_memalign(&mut page, page_size, size);\n        libc::mprotect(\n            page,\n            size,\n            libc::PROT_EXEC | libc::PROT_READ | libc::PROT_WRITE,\n        );\n        let contents: *mut u8 = page as *mut u8;\n        ptr::copy(bytes.as_ptr(), contents, 9);\n        mem::transmute(contents)\n    };\n\n    let return_value = f(7, 12);\n    println!(\"Returned value: {}\", return_value);\n    assert_eq!(return_value, 19);\n}\n\n#[cfg(any(\n    not(target_os = \"linux\"),\n    not(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))\n))]\nfn main() {\n    println!(\"Not supported on this platform.\");\n}\n",
    "path": "tasks/machine-code",
    "remote_code": "extern crate libc;\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(target_pointer_width = \"32\", target_pointer_width = \"64\")\n))]\nfn main() {\n    use std::mem;\n    use std::ptr;\n\n    let page_size: usize = 4096;\n    let (bytes, size): (Vec<u8>, usize) = if cfg!(target_pointer_width = \"32\") {\n        (\n            vec![0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3],\n            9,\n        )\n    } else {\n        (vec![0x48, 0x89, 0xf8, 0x48, 0x01, 0xf0, 0xc3], 7)\n    };\n    let f: fn(u8, u8) -> u8 = unsafe {\n        let mut page: *mut libc::c_void = ptr::null_mut();\n        libc::posix_memalign(&mut page, page_size, size);\n        libc::mprotect(\n            page,\n            size,\n            libc::PROT_EXEC | libc::PROT_READ | libc::PROT_WRITE,\n        );\n        let contents: *mut u8 = page as *mut u8;\n        ptr::copy(bytes.as_ptr(), contents, 9);\n        mem::transmute(contents)\n    };\n\n    let return_value = f(7, 12);\n    println!(\"Returned value: {}\", return_value);\n    assert_eq!(return_value, 19);\n}\n\n#[cfg(any(\n    not(target_os = \"linux\"),\n    not(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))\n))]\nfn main() {\n    println!(\"Not supported on this platform.\");\n}\n",
    "title": "Machine code",
    "url": "http://rosettacode.org/wiki/Machine_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate regex;\n\nuse regex::Regex;\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut input_line = String::new();\n    let mut template = String::new();\n\n    println!(\"Please enter a multi-line story template with <parts> to replace, terminated by a blank line.\\n\");\n    loop {\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        if input_line.trim().is_empty() {\n            break;\n        }\n        template.push_str(&input_line);\n        input_line.clear();\n    }\n\n    let re = Regex::new(r\"<[^>]+>\").unwrap();\n    let mut parts: HashMap<_, _> = re\n        .captures_iter(&template)\n        .map(|x| (x.get(0).unwrap().as_str().to_string(), \"\".to_string()))\n        .collect();\n    if parts.is_empty() {\n        println!(\"No <parts> to replace.\\n\");\n    } else {\n        for (k, v) in parts.iter_mut() {\n            println!(\"Please provide a replacement for {}: \", k);\n            io::stdin()\n                .read_line(&mut input_line)\n                .expect(\"The read line failed.\");\n            *v = input_line.trim().to_string();\n            println!();\n            template = template.replace(k, v);\n            input_line.clear();\n        }\n    }\n    println!(\"Resulting story:\\n\\n{}\", template);\n}",
    "title": "Mad Libs",
    "url": "http://rosettacode.org/wiki/Mad_Libs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse std::io;\n\nfn main() {\n    let answers = [\n        \"It is certain\",\n        \"It is decidedly so\",\n        \"Without a doubt\",\n        \"Yes, definitely\",\n        \"You may rely on it\",\n        \"As I see it, yes\",\n        \"Most likely\",\n        \"Outlook good\",\n        \"Signs point to yes\",\n        \"Yes\",\n        \"Reply hazy, try again\",\n        \"Ask again later\",\n        \"Better not tell you now\",\n        \"Cannot predict now\",\n        \"Concentrate and ask again\",\n        \"Don't bet on it\",\n        \"My reply is no\",\n        \"My sources say no\",\n        \"Outlook not so good\",\n        \"Very doubtful\",\n    ];\n    let mut rng = rand::thread_rng();\n    let mut input_line = String::new();\n\n    println!(\"Please enter your question or a blank line to quit.\\n\");\n    loop {\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        if input_line.trim() == \"\" {\n            break;\n        }\n        println!(\"{}\\n\", answers.choose(&mut rng).unwrap());\n        input_line.clear();\n    }\n}",
    "title": "Magic 8-ball",
    "url": "http://rosettacode.org/wiki/Magic_8-ball"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Magic constant",
    "url": "http://rosettacode.org/wiki/Magic_constant"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let n: usize = match env::args()\n        .nth(1)\n        .and_then(|arg| arg.parse().ok())\n        .ok_or(\"Please specify the size of the magic square, as a positive multiple of 4.\")\n    {\n        Ok(arg) if arg >= 4 && arg % 4 == 0 => arg,\n        Err(e) => panic!(e),\n        _ => panic!(\"Argument must be a positive multiple of 4.\"),\n    };\n\n    let mc = (n * n + 1) * n / 2;\n    println!(\"Magic constant: {}\\n\", mc);\n    let bits = 0b1001_0110_0110_1001u32;\n    let size = n * n;\n    let width = size.to_string().len() + 1;\n    let mult = n / 4;\n    let mut i = 0;\n    for r in 0..n {\n        for c in 0..n {\n            let bit_pos = c / mult + (r / mult) * 4;\n            print!(\n                \"{e:>w$}\",\n                e = if bits & (1 << bit_pos) != 0 {\n                    i + 1\n                } else {\n                    size - i\n                },\n                w = width\n            );\n            i += 1;\n        }\n        println!();\n    }\n}",
    "title": "Magic squares of doubly even order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order"
  },
  {
    "local_code": "fn main() {\n    let n = 9;\n    let mut square = vec![vec![0; n]; n];\n    for (i, row) in square.iter_mut().enumerate() {\n        for (j, e) in row.iter_mut().enumerate() {\n            *e = n * (((i + 1) + (j + 1) - 1 + (n >> 1)) % n)\n                + (((i + 1) + (2 * (j + 1)) - 2) % n)\n                + 1;\n            print!(\"{:3} \", e);\n        }\n        println!();\n    }\n    let sum = n * (((n * n) + 1) / 2);\n    println!(\"The sum of the square is {}.\", sum);\n}\n",
    "path": "tasks/magic-squares-of-odd-order",
    "remote_code": "fn main() {\n    let n = 9;\n    let mut square = vec![vec![0; n]; n];\n    for (i, row) in square.iter_mut().enumerate() {\n        for (j, e) in row.iter_mut().enumerate() {\n            *e = n * (((i + 1) + (j + 1) - 1 + (n >> 1)) % n) + (((i + 1) + (2 * (j + 1)) - 2) % n) + 1;\n            print!(\"{:3} \", e);\n        }\n        println!(\"\");\n    }\n    let sum = n * (((n * n) + 1) / 2);\n    println!(\"The sum of the square is {}.\", sum);\n}",
    "title": "Magic squares of odd order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_odd_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let n: usize =\n        match env::args().nth(1).and_then(|arg| arg.parse().ok()).ok_or(\n            \"Please specify the size of the magic square, as a positive multiple of 4 plus 2.\",\n        ) {\n            Ok(arg) if arg % 2 == 1 || arg >= 6 && (arg - 2) % 4 == 0 => arg,\n            Err(e) => panic!(e),\n            _ => panic!(\"Argument must be a positive multiple of 4 plus 2.\"),\n        };\n\n    let (ms, mc) = magic_square_singly_even(n);\n    println!(\"n: {}\", n);\n    println!(\"Magic constant: {}\\n\", mc);\n    let width = (n * n).to_string().len() + 1;\n    for row in ms {\n        for elem in row {\n            print!(\"{e:>w$}\", e = elem, w = width);\n        }\n        println!();\n    }\n}\n\nfn magic_square_singly_even(n: usize) -> (Vec<Vec<usize>>, usize) {\n    let size = n * n;\n    let half = n / 2;\n    let sub_square_size = size / 4;\n    let sub_square = magic_square_odd(half);\n    let quadrant_factors = [0, 2, 3, 1];\n    let cols_left = half / 2;\n    let cols_right = cols_left - 1;\n\n    let ms = (0..n)\n        .map(|r| {\n            (0..n)\n                .map(|c| {\n                    let localr = if (c < cols_left\n                        || c >= n - cols_right\n                        || c == cols_left && r % half == cols_left)\n                        && !(c == 0 && r % half == cols_left)\n                    {\n                        if r >= half {\n                            r - half\n                        } else {\n                            r + half\n                        }\n                    } else {\n                        r\n                    };\n                    let quadrant = localr / half * 2 + c / half;\n                    let v = sub_square[localr % half][c % half];\n                    v + quadrant_factors[quadrant] * sub_square_size\n                })\n                .collect()\n        })\n        .collect::<Vec<Vec<_>>>();\n    (ms, (n * n + 1) * n / 2)\n}\n\nfn magic_square_odd(n: usize) -> Vec<Vec<usize>> {\n    (0..n)\n        .map(|r| {\n            (0..n)\n                .map(|c| {\n                    n * (((c + 1) + (r + 1) - 1 + (n >> 1)) % n)\n                        + (((c + 1) + (2 * (r + 1)) - 2) % n)\n                        + 1\n                })\n                .collect::<Vec<_>>()\n        })\n        .collect::<Vec<Vec<_>>>()\n}",
    "title": "Magic squares of singly even order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_singly_even_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn is_magnanimous(n: u32) -> bool {\n    let mut p: u32 = 10;\n    while n >= p {\n        if !is_prime(n % p + n / p) {\n            return false;\n        }\n        p *= 10;\n    }\n    true\n}\n\nfn main() {\n    let mut m = (0..).filter(|x| is_magnanimous(*x)).take(400);\n    println!(\"First 45 magnanimous numbers:\");\n    for (i, n) in m.by_ref().take(45).enumerate() {\n        if i > 0 && i % 15 == 0 {\n            println!();\n        }\n        print!(\"{:3} \", n);\n    }\n    println!(\"\\n\\n241st through 250th magnanimous numbers:\");\n    for n in m.by_ref().skip(195).take(10) {\n        print!(\"{} \", n);\n    }\n    println!(\"\\n\\n391st through 400th magnanimous numbers:\");\n    for n in m.by_ref().skip(140) {\n        print!(\"{} \", n);\n    }\n    println!();\n}",
    "title": "Magnanimous numbers",
    "url": "http://rosettacode.org/wiki/Magnanimous_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::convert::TryInto;\nuse std::env;\nuse std::num::Wrapping;\n\nconst REPLACEMENT_TABLE: [[u8; 16]; 8] = [\n    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],\n    [14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9],\n    [5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11],\n    [7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3],\n    [6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2],\n    [4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14],\n    [13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12],\n    [1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12],\n];\nconst KEYS: [u32; 8] = [\n    0xE2C1_04F9,\n    0xE41D_7CDE,\n    0x7FE5_E857,\n    0x0602_65B4,\n    0x281C_CC85,\n    0x2E2C_929A,\n    0x4746_4503,\n    0xE00_CE510,\n];\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        let plain_text: Vec<u8> = vec![0x04, 0x3B, 0x04, 0x21, 0x04, 0x32, 0x04, 0x30];\n        println!(\n            \"Before one step: {}\\n\",\n            plain_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n        let encoded_text = main_step(plain_text, KEYS[0]);\n        println!(\n            \"After one step : {}\\n\",\n            encoded_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n    } else {\n        let mut t = args[1].clone(); // \"They call him... Баба Яга\"\n        t += &\" \".repeat((8 - t.len() % 8) % 8);\n        let text_bytes = t.bytes().collect::<Vec<_>>();\n        let plain_text = text_bytes.chunks(8).collect::<Vec<_>>();\n        println!(\n            \"Plain text  : {}\\n\",\n            plain_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let encoded_text = plain_text\n            .iter()\n            .map(|c| encode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Encoded text: {}\\n\",\n            encoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let decoded_text = encoded_text\n            .iter()\n            .map(|c| decode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Decoded text: {}\\n\",\n            decoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let recovered_text =\n            String::from_utf8(decoded_text.iter().cloned().flatten().collect::<Vec<_>>()).unwrap();\n        println!(\"Recovered text: {}\\n\", recovered_text);\n    }\n}\n\nfn encode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block;\n    for i in 0..24 {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    for i in (0..8).rev() {\n        step = main_step(step, KEYS[i]);\n    }\n    step\n}\n\nfn decode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block[4..].to_vec();\n    let mut temp = text_block[..4].to_vec();\n    step.append(&mut temp);\n    for key in &KEYS {\n        step = main_step(step, *key);\n    }\n    for i in (0..24).rev() {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    let mut ans = step[4..].to_vec();\n    let mut temp = step[..4].to_vec();\n    ans.append(&mut temp);\n    ans\n}\n\nfn main_step(text_block: Vec<u8>, key_element: u32) -> Vec<u8> {\n    let mut n = text_block;\n    let mut s = (Wrapping(\n        u32::from(n[0]) << 24 | u32::from(n[1]) << 16 | u32::from(n[2]) << 8 | u32::from(n[3]),\n    ) + Wrapping(key_element))\n    .0;\n    let mut new_s: u32 = 0;\n    for mid in 0..4 {\n        let cell = (s >> (mid << 3)) & 0xFF;\n        new_s += (u32::from(REPLACEMENT_TABLE[(mid * 2) as usize][(cell & 0x0f) as usize])\n            + (u32::from(REPLACEMENT_TABLE[(mid * 2 + 1) as usize][(cell >> 4) as usize]) << 4))\n            << (mid << 3);\n    }\n    s = ((new_s << 11) + (new_s >> 21))\n        ^ (u32::from(n[4]) << 24 | u32::from(n[5]) << 16 | u32::from(n[6]) << 8 | u32::from(n[7]));\n    n[4] = n[0];\n    n[5] = n[1];\n    n[6] = n[2];\n    n[7] = n[3];\n    n[0] = (s >> 24).try_into().unwrap();\n    n[1] = ((s >> 16) & 0xFF).try_into().unwrap();\n    n[2] = ((s >> 8) & 0xFF).try_into().unwrap();\n    n[3] = (s & 0xFF).try_into().unwrap();\n    n\n}",
    "title": "Main step of GOST 28147-89",
    "url": "http://rosettacode.org/wiki/Main_step_of_GOST_28147-89"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs;\n\nfn main() {\n    fs::create_dir_all(\"./path/to/dir\").expect(\"An Error Occured!\")\n}",
    "title": "Make directory path",
    "url": "http://rosettacode.org/wiki/Make_directory_path"
  },
  {
    "local_code": "//! As originally [posted] by Kimundi on Reddit\n//!\n//! [posted]: http://www.reddit.com/r/rust/comments/2t80mw/the_man_or_boy_test_in_rust/\n\nuse std::cell::Cell;\n\nfn a(\n    k: i32,\n    x1: &dyn Fn() -> i32,\n    x2: &dyn Fn() -> i32,\n    x3: &dyn Fn() -> i32,\n    x4: &dyn Fn() -> i32,\n    x5: &dyn Fn() -> i32,\n) -> i32 {\n    let k = Cell::new(k);\n\n    let (b, tmp): (Cell<Option<&dyn Fn() -> i32>>, _);\n    b = Cell::new(None);\n    tmp = || {\n        k.set(k.get() - 1);\n        a(k.get(), &*b.get().unwrap(), x1, x2, x3, x4)\n    };\n    b.set(Some(&tmp));\n\n    if k.get() <= 0 {\n        x4() + x5()\n    } else {\n        b.get().unwrap()()\n    }\n}\n\nfn main() {\n    println!(\"%{}\", a(10, &|| 1, &|| -1, &|| -1, &|| 1, &|| 0));\n}\n\n#[test]\nfn result() {\n    assert_eq!(a(10, &|| 1, &|| -1, &|| -1, &|| 1, &|| 0), -67)\n}\n",
    "path": "tasks/man-or-boy-test",
    "remote_code": "use std::cell::Cell;\n\ntrait Arg {\n    fn run(&self) -> i32;\n}\n\nimpl Arg for i32 {\n    fn run(&self) -> i32 { *self }\n}\n\nstruct B<'a> {\n    k: &'a Cell<i32>,\n    x1: &'a Arg,\n    x2: &'a Arg,\n    x3: &'a Arg,\n    x4: &'a Arg,\n}\n\nimpl<'a> Arg for B<'a> {\n    fn run(&self) -> i32 {\n        self.k.set(self.k.get() - 1);\n        a(self.k.get(), self, self.x1, self.x2, self.x3, self.x4)\n    }\n}\n\nfn a(k: i32, x1: &Arg, x2: &Arg, x3: &Arg, x4: &Arg, x5: &Arg) -> i32 {\n    if k <= 0 {\n        x4.run() + x5.run()\n    } else {\n        B{\n            k: &Cell::new(k),\n            x1, x2, x3, x4\n        }.run()\n    }\n}\n\npub fn main() {\n    println!(\"{}\", a(10, &1, &-1, &-1, &1, &0));\n}",
    "title": "Man or boy test",
    "url": "http://rosettacode.org/wiki/Man_or_boy_test"
  },
  {
    "local_code": "use image::DynamicImage::ImageLuma8;\nuse num_complex::Complex;\n\nfn main() {\n    let max_iterations = 256u16;\n    let img_side = 800u32;\n    let cxmin = -2f32;\n    let cxmax = 1f32;\n    let cymin = -1.5f32;\n    let cymax = 1.5f32;\n    let scalex = (cxmax - cxmin) / img_side as f32;\n    let scaley = (cymax - cymin) / img_side as f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Calculate for each pixel\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n        let cx = cxmin + x as f32 * scalex;\n        let cy = cymin + y as f32 * scaley;\n\n        let c = Complex::new(cx, cy);\n        let mut z = Complex::new(0f32, 0f32);\n\n        let mut i = 0;\n        for t in 0..max_iterations {\n            if z.norm() > 2.0 {\n                break;\n            }\n            z = z * z + c;\n            i = t;\n        }\n\n        *pixel = image::Luma([i as u8]);\n    }\n\n    ImageLuma8(imgbuf).save(\"fractal.png\").unwrap();\n}\n",
    "path": "tasks/mandelbrot-set",
    "remote_code": "extern crate image;\nextern crate num_complex;\n\nuse std::fs::File;\nuse num_complex::Complex;\n\nfn main() {\n    let max_iterations = 256u16;\n    let img_side = 800u32;\n    let cxmin = -2f32;\n    let cxmax = 1f32;\n    let cymin = -1.5f32;\n    let cymax = 1.5f32;\n    let scalex = (cxmax - cxmin) / img_side as f32;\n    let scaley = (cymax - cymin) / img_side as f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Calculate for each pixel\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n        let cx = cxmin + x as f32 * scalex;\n        let cy = cymin + y as f32 * scaley;\n\n        let c = Complex::new(cx, cy);\n        let mut z = Complex::new(0f32, 0f32);\n\n        let mut i = 0;\n        for t in 0..max_iterations {\n            if z.norm() > 2.0 {\n                break;\n            }\n            z = z * z + c;\n            i = t;\n        }\n\n        *pixel = image::Luma([i as u8]);\n    }\n\n    // Save image\n    imgbuf.save(\"fractal.png\").unwrap();\n}",
    "title": "Mandelbrot set",
    "url": "http://rosettacode.org/wiki/Mandelbrot_set"
  },
  {
    "local_code": "use std::f64;\n\nfn map_range(from_range: (f64, f64), to_range: (f64, f64), s: f64) -> f64 {\n    to_range.0 + (s - from_range.0) * (to_range.1 - to_range.0) / (from_range.1 - from_range.0)\n}\n\nfn main() {\n    let input: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let result = input\n        .into_iter()\n        .map(|x| map_range((0.0, 10.0), (-1.0, 0.0), x))\n        .collect::<Vec<f64>>();\n    print!(\"{:?}\", result);\n}\n\n#[test]\nfn test_basic() {\n    assert!((map_range((1.0, 5.0), (10.0, 50.0), 2.0) - 20.0) < f64::EPSILON);\n}\n",
    "path": "tasks/map-range",
    "remote_code": "use std::ops::{Add, Sub, Mul, Div};\n\nfn map_range<T: Copy>(from_range: (T, T), to_range: (T, T), s: T) -> T \n    where T: Add<T, Output=T> +\n             Sub<T, Output=T> +\n             Mul<T, Output=T> +\n             Div<T, Output=T>\n{\n    to_range.0 + (s - from_range.0) * (to_range.1 - to_range.0) / (from_range.1 - from_range.0)\n}\n\nfn main() {\n    let input: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let result = input.into_iter()\n        .map(|x| map_range((0.0, 10.0), (-1.0, 0.0), x))\n        .collect::<Vec<f64>>();\n    print!(\"{:?}\", result);\n}",
    "title": "Map range",
    "url": "http://rosettacode.org/wiki/Map_range"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse std::io;\n\nfn main() {\n    let mut input_line = String::new();\n    let colors_n;\n    let code_len;\n    let guesses_max;\n    let colors_dup;\n\n    loop {\n        println!(\"Please enter the number of colors to be used in the game (2 - 20): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= 2 && n <= 20 {\n                    colors_n = n;\n                    break;\n                } else {\n                    println!(\"Outside of range (2 - 20).\");\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    let colors = &\"ABCDEFGHIJKLMNOPQRST\"[..colors_n as usize];\n\n    println!(\"Playing with colors {}.\\n\", colors);\n\n    loop {\n        println!(\"Are duplicated colors allowed in the code? (Y/N): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        if [\"Y\", \"N\"].contains(&&input_line.trim().to_uppercase()[..]) {\n            colors_dup = input_line.trim().to_uppercase() == \"Y\";\n            break;\n        } else {\n            println!(\"Invalid input.\");\n        }\n    }\n    println!(\n        \"Duplicated colors {}allowed.\\n\",\n        if colors_dup { \"\" } else { \"not \" }\n    );\n    loop {\n        let min_len = if colors_dup { 4 } else { 4.min(colors_n) };\n        let max_len = if colors_dup { 10 } else { 10.min(colors_n) };\n        println!(\n            \"Please enter the length of the code ({} - {}): \",\n            min_len, max_len\n        );\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= min_len && n <= max_len {\n                    code_len = n;\n                    break;\n                } else {\n                    println!(\"Outside of range ({} - {}).\", min_len, max_len);\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    println!(\"Code of length {}.\\n\", code_len);\n    loop {\n        println!(\"Please enter the number of guesses allowed (7 - 20): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= 7 && n <= 20 {\n                    guesses_max = n;\n                    break;\n                } else {\n                    println!(\"Outside of range (7 - 20).\");\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    println!(\"{} guesses allowed.\\n\", guesses_max);\n\n    let mut rng = rand::thread_rng();\n    let mut code;\n    if colors_dup {\n        code = (0..code_len)\n            .map(|_| ((65 + rng.gen_range(0, colors_n) as u8) as char))\n            .collect::<Vec<_>>();\n    } else {\n        code = colors.chars().collect::<Vec<_>>();\n        code.shuffle(&mut rng);\n        code = code[..code_len as usize].to_vec();\n    }\n    //code = vec!['J', 'A', 'R', 'D', 'A', 'N', 'I'];\n    //println!(\"Secret code: {:?}\", code);\n    let mut guesses: Vec<(String, String)> = vec![];\n    let mut i = 1;\n    loop {\n        println!(\"Your guess ({}/{})?: \", i, guesses_max);\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        let mut guess = input_line.trim().to_uppercase();\n        if guess.len() as i32 > code_len {\n            guess = guess[..code_len as usize].to_string();\n        }\n        let guess_v = guess.chars().collect::<Vec<char>>();\n        let res = evaluate(&code, &guess_v);\n        guesses.push((guess, res.clone()));\n        let width = 8 + guesses_max.to_string().len() + code_len as usize * 2;\n        println!(\"{}\", \"-\".repeat(width));\n        for (i, guess) in guesses.iter().enumerate() {\n            let line = format!(\n                \" {:w1$} : {:w2$} : {:w2$} \",\n                i + 1,\n                guess.0,\n                guess.1,\n                w1 = guesses_max.to_string().len(),\n                w2 = code_len as usize\n            );\n            println!(\"{}\", line);\n        }\n        println!(\"{}\", \"-\".repeat(width));\n        if res == \"X\".repeat(code_len as usize) {\n            println!(\"You won! Code: {}\", code.into_iter().collect::<String>());\n            break;\n        }\n        i += 1;\n        if i > guesses_max {\n            println!(\"You lost. Code: {}\", code.into_iter().collect::<String>());\n            break;\n        }\n    }\n}\n\nfn evaluate(code: &[char], guess: &[char]) -> String {\n    let mut res: Vec<char> = vec![];\n    for i in 0..guess.len() {\n        if guess[i] == code[i] {\n            res.push('X');\n        } else if code.contains(&guess[i]) {\n            res.push('O');\n        } else {\n            res.push('-');\n        }\n    }\n    res.sort_by(|a, b| b.cmp(a));\n    res.into_iter().collect()\n}",
    "title": "Mastermind",
    "url": "http://rosettacode.org/wiki/Mastermind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    println!(\"{}\\n\", mcm_display(vec![5, 6, 3, 1]));\n    println!(\n        \"{}\\n\",\n        mcm_display(vec![1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2])\n    );\n    println!(\n        \"{}\\n\",\n        mcm_display(vec![1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10])\n    );\n}\n\nfn mcm_display(dims: Vec<i32>) -> String {\n    let mut costs: HashMap<Vec<i32>, (i32, Vec<usize>)> = HashMap::new();\n    let mut line = format!(\"Dims : {:?}\\n\", dims);\n    let ans = mcm(dims, &mut costs);\n    let mut mats = (1..=ans.1.len() + 1)\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>();\n    for i in 0..ans.1.len() {\n        let mat_taken = mats[ans.1[i]].clone();\n        mats.remove(ans.1[i]);\n        mats[ans.1[i]] = \"(\".to_string() + &mat_taken + \"*\" + &mats[ans.1[i]] + \")\";\n    }\n    line += &format!(\"Order: {}\\n\", mats[0]);\n    line += &format!(\"Cost : {}\", ans.0);\n    line\n}\n\nfn mcm(dims: Vec<i32>, costs: &mut HashMap<Vec<i32>, (i32, Vec<usize>)>) -> (i32, Vec<usize>) {\n    match costs.get(&dims) {\n        Some(c) => c.clone(),\n        None => {\n            let ans = if dims.len() == 3 {\n                (dims[0] * dims[1] * dims[2], vec![0])\n            } else {\n                let mut min_cost = std::i32::MAX;\n                let mut min_path = Vec::new();\n                for i in 1..dims.len() - 1 {\n                    let taken = dims[(i - 1)..(i + 2)].to_vec();\n                    let mut rest = dims[..i].to_vec();\n                    rest.extend_from_slice(&dims[(i + 1)..]);\n                    let a1 = mcm(taken, costs);\n                    let a2 = mcm(rest, costs);\n                    if a1.0 + a2.0 < min_cost {\n                        min_cost = a1.0 + a2.0;\n                        min_path = vec![i - 1];\n                        min_path.extend_from_slice(&a2.1);\n                    }\n                }\n                (min_cost, min_path)\n            };\n            costs.insert(dims, ans.clone());\n            ans\n        }\n    }\n}",
    "title": "Matrix chain multiplication",
    "url": "http://rosettacode.org/wiki/Matrix_chain_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#![warn(clippy::pedantic)] // make sure that clippy is even more annoying\n\nuse rand::prelude::{ThreadRng, SliceRandom};\nuse rand::{thread_rng, Rng};\nuse termion::{color::Rgb};\nuse termion::input::TermRead;\nuse termion::raw::IntoRawMode;\nuse std::sync::mpsc::{channel, TryRecvError};\nuse std::thread;\nuse std::{io::{Write, stdout, stdin}, iter::repeat, time::Duration};\n\n/// Character pool to pick from\n/// If your terminal is struggling with that choice, replace them by ordinary latin characters.\n/// There's currently no nicer way to initialize constant array in Rust\nconst CHARS: [char; 322] = [\n    'M', 'Ї', 'Љ', 'Њ', 'Ћ', 'Ќ', 'Ѝ', 'Ў', 'Џ', 'Б', 'Г', 'Д', 'Ж', 'И', 'Й', 'Л', 'П', 'Ф', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ',\n    'Ы', 'Э', 'Ю', 'Я', 'в', 'д', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'п', 'т', 'ф', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы',\n    'ь', 'э', 'ю', 'я', 'ѐ', 'ё', 'ђ', 'ѓ', 'є', 'ї', 'љ', 'њ', 'ћ', 'ќ', 'ѝ', 'ў', 'џ', 'Ѣ', 'ѣ', 'ѧ', 'Ѯ', 'ѱ', 'Ѳ',\n    'ѳ', 'ҋ', 'Ҍ', 'ҍ', 'Ҏ', 'ҏ', 'Ґ', 'ґ', 'Ғ', 'ғ', 'Ҕ', 'ҕ', 'Җ', 'җ', 'Ҙ', 'ҙ', 'Қ', 'қ', 'ҝ', 'ҟ', 'ҡ', 'Ң', 'ң',\n    'Ҥ', 'ҥ', 'ҩ', 'Ҫ', 'ҫ', 'Ҭ', 'ҭ', 'Ұ', 'ұ', 'Ҳ', 'ҳ', 'ҵ', 'ҷ', 'ҹ', 'Һ', 'ҿ', 'Ӂ', 'ӂ', 'Ӄ', 'ӄ', 'ӆ', 'Ӈ', 'ӈ',\n    'ӊ', 'Ӌ', 'ӌ', 'ӎ', 'Ӑ', 'ӑ', 'Ӓ', 'ӓ', 'Ӕ', 'ӕ', 'Ӗ', 'ӗ', 'Ә', 'ә', 'Ӛ', 'ӛ', 'Ӝ', 'ӝ', 'Ӟ', 'ӟ', 'ӡ', 'Ӣ', 'ӣ',\n    'Ӥ', 'ӥ', 'Ӧ', 'ӧ', 'Ө', 'ө', 'Ӫ', 'ӫ', 'Ӭ', 'ӭ', 'Ӯ', 'ӯ', 'Ӱ', 'ӱ', 'Ӳ', 'ӳ', 'Ӵ', 'ӵ', 'Ӷ', 'ӷ', 'Ӹ', 'ӹ', 'Ӻ',\n    'ӽ', 'ӿ', 'Ԁ', 'ԍ', 'ԏ', 'Ԑ', 'ԑ', 'ԓ', 'Ԛ', 'ԟ', 'Ԧ', 'ԧ', 'Ϥ', 'ϥ', 'ϫ', 'ϭ', 'ｩ', 'ｪ', 'ｫ', 'ｬ', 'ｭ', 'ｮ', 'ｯ',\n    'ｰ', 'ｱ', 'ｲ', 'ｳ', 'ｴ', 'ｵ', 'ｶ', 'ｷ', 'ｸ', 'ｹ', 'ｺ', 'ｻ', 'ｼ', 'ｽ', 'ｾ', 'ｿ', 'ﾀ', 'ﾁ', 'ﾂ', 'ﾃ', 'ﾄ', 'ﾅ', 'ﾆ',\n    'ﾇ', 'ﾈ', 'ﾉ', 'ﾊ', 'ﾋ', 'ﾌ', 'ﾍ', 'ﾎ', 'ﾏ', 'ﾐ', 'ﾑ', 'ﾒ', 'ﾓ', 'ﾔ', 'ﾕ', 'ﾖ', 'ﾗ', 'ﾘ', 'ﾙ', 'ﾚ', 'ﾛ', 'ﾜ', 'ﾝ',\n    'ⲁ', 'Ⲃ', 'ⲃ', 'Ⲅ', 'Γ', 'Δ', 'Θ', 'Λ', 'Ξ', 'Π', 'Ѐ', 'Ё', 'Ђ', 'Ѓ', 'Є', 'ⲉ', 'Ⲋ', 'ⲋ', 'Ⲍ', 'ⲍ', 'ⲏ', 'ⲑ', 'ⲓ',\n    'ⲕ', 'ⲗ', 'ⲙ', 'ⲛ', 'Ⲝ', 'ⲝ', 'ⲡ', 'ⲧ', 'ⲩ', 'ⲫ', 'ⲭ', 'ⲯ', 'ⳁ', 'Ⳉ', 'ⳉ', 'ⳋ', 'ⳤ', '⳥', '⳦', '⳨', '⳩', '∀', '∁',\n    '∂', '∃', '∄', '∅', '∆', '∇', '∈', '∉', '∊', '∋', '∌', '∍', '∎', '∏', '∐', '∑', '∓', 'ℇ', 'ℏ', '℥', 'Ⅎ', 'ℷ', '⩫',\n    '⨀', '⨅', '⨆', '⨉', '⨍', '⨎', '⨏', '⨐', '⨑', '⨒', '⨓', '⨔', '⨕', '⨖', '⨗', '⨘', '⨙', '⨚', '⨛', '⨜', '⨝', '⨿', '⩪',\n    ];\n\n/// convert a brightness value to a green-ish gradient color\nfn color(brightness: u8) -> Rgb {\n    let v = f32::from(brightness) / 255.0;\n    let r = v.powi(7);\n    let g = v.powi(1);\n    let b = v.powi(4);\n    // r, g, b will be in 0.0..=1.0 so there's no risk of exceeding the u8's range\n    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n    Rgb ((r * 255.0).round() as u8, (g * 255.0).round() as u8, (b * 255.0).round() as u8)\n}\n\n/// A single character on the screen with its current brightness\n#[derive(Clone, Copy)]\nstruct Symbol {\n    char: char,\n    brightness: u8,\n}\n\n/// Start with a black space by default\nimpl Default for Symbol {\n    fn default() -> Self {\n        Self { char: ' ', brightness: 0 }\n    }\n}\n\nimpl Symbol {\n    /// output the colored symbol at the current cursor position\n    fn print<W: Write>(self, out: &mut W) {\n        write!(out, \"{}{}\", termion::color::Fg(color(self.brightness)), self.char).unwrap();\n    }\n\n    /// reduce the brightness of the symbol by a certain amount and make sure the value doesn't underrun\n    fn darken(&mut self) {\n        self.brightness = self.brightness.saturating_sub(10);\n    }\n\n    /// replace the character for this symbol and bring it to full brightness\n    fn set(&mut self, char: char) {\n        self.char = char;\n        self.brightness = 255;\n    }\n}\n\n/// a single column of symbols\n#[derive(Clone)]\nstruct Column {\n    symbols: Vec<Symbol>,\n}\n\nimpl Column {\n    /// create a new column with a given height\n    fn new(height: usize) -> Self {\n        Self {\n            symbols: vec![Symbol::default(); height],\n        }\n    }\n\n    /// print out a single colored symbol of this column\n    fn print_symbol<W: Write>(&self, out: &mut W, row: usize) {\n        self.symbols[row].print(out);\n    }\n\n    /// reduce the brightness of the entire column\n    fn darken(&mut self) {\n        self.symbols.iter_mut().for_each(Symbol::darken);\n    }\n\n    fn set(&mut self, row: usize, char: char) {\n        self.symbols[row].set(char);\n    }\n}\n\n/// Current position of a _falling symbol_\nstruct Droplet {\n    /// For the start of the animation we want to be able to place the symbol _above_ the screen,\n    /// that's we need negative row values as well.\n    row: isize,\n    col: usize,\n}\n\nimpl Droplet {\n    /// create a new Droplet at a random location somewhere above the actual screen\n    fn new_random(rng: &mut ThreadRng, width: usize, height: usize) -> Self {\n        // the height of the terminal is expected lie within a sane range of this type\n        #[allow(clippy::cast_possible_wrap)]\n        Self {\n            row: -(rng.gen_range(0..height) as isize),\n            col: rng.gen_range(0..width),\n        }\n    }\n\n    /// move the droplet down by one row\n    /// if it hits the bottom row, move it back up to a random column\n    fn update(&mut self, width: usize, height: usize) {\n        self.row += 1;\n        // the height of the terminal is expected lie within a sane range of this type\n        #[allow(clippy::cast_possible_wrap)]\n        if self.row >= height as isize {\n            let mut rng = thread_rng();\n            self.col = rng.gen_range(0..width);\n            self.row = 0;\n        }\n    }\n}\n\n/// The entire screen filled with colored symbols\nstruct Screen {\n    width: usize,\n    height: usize,\n    columns: Vec<Column>,\n    droplets: Vec<Droplet>,\n}\n\nimpl Screen {\n\n    /// create a new empty screen with the given dimensions\n    fn new(width: usize, height: usize) -> Self {\n        let mut rng = thread_rng();\n        Self {\n            width,\n            height,\n            columns: repeat(Column::new(height)).take(width).collect(),\n            droplets: (0..width).map(|_| Droplet::new_random(&mut rng, width, height)).collect(),\n        }\n    }\n\n    /// print the entire screen to the terminal\n    fn print<W: Write>(&self, out: &mut W) {\n        for row in 0..self.height {\n            for column in &self.columns {\n                column.print_symbol(out, row);\n            }\n            write!(out, \"\\r\\n\").unwrap();\n        }\n    }\n\n    // make all droplets fall down by one row\n    fn update_droplets(&mut self) {\n        let mut rng = thread_rng();\n        for droplet in &mut self.droplets {\n            droplet.update(self.width, self.height);\n            if let Ok(row) = droplet.row.try_into() {\n                let ch = CHARS.choose(&mut rng).copied().unwrap_or(' ');\n                self.columns[droplet.col].set(row, ch);\n            }\n        }\n    }\n\n    // reduce the brightness of all symbols in this screen\n    fn darken(&mut self) {\n        self.columns.iter_mut().for_each(Column::darken);\n    }\n\n}\n\nfn main() {\n    // create the screen with the terminal's dimensions (omit the last row to prevent auto-scrolling)\n    let (width, height) = termion::terminal_size().unwrap();\n    let mut screen = Screen::new(width as usize, height as usize - 1);\n\n    // create a channel which allows to send stuff between thread boundaries\n    let (tx, rx) = channel();\n    \n    // spawn a new thread which will blockingly wait for a key to be pressed\n    thread::spawn(move || {\n        stdin().keys().next();\n        // send something down the channel to notify the main thread that a key has been pressed\n        tx.send(()).expect(\"Could not send signal on channel.\");\n    });\n\n    // get write access to the terminal\n    let mut stdout = stdout().into_raw_mode().unwrap();\n\n    // clear the screen and hide the cursor\n    write!(stdout, \"{}{}\", termion::clear::All, termion::cursor::Hide).unwrap();\n\n    // continue while no key has been pressed (i.e. the notification channel is empty)\n    while rx.try_recv() == Err(TryRecvError::Empty) {\n        // move cursor to the top left and set background color to black\n        write!(stdout, \"{}{}\", termion::cursor::Goto(1, 1), termion::color::Bg(termion::color::Rgb(0, 0, 0))).unwrap();\n\n        // screen update\n        screen.print(&mut stdout);\n        screen.darken();\n        screen.update_droplets();\n        // make sure the terminal updates _now_\n        stdout.flush().unwrap();\n\n        // slow down animation\n        std::thread::sleep(Duration::from_millis(50));\n    }\n\n    // reset Terminal back to normal\n    write!(stdout, \"{}\", termion::style::Reset).unwrap();\n    write!(stdout, \"{}\", termion::clear::All).unwrap();\n    write!(stdout, \"{}\", termion::cursor::Goto(1, 1)).unwrap();\n    write!(stdout, \"{}\", termion::cursor::Show).unwrap();\n}\n",
    "title": "Matrix digital rain",
    "url": "http://rosettacode.org/wiki/Matrix_digital_rain"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct Matrix {\n    dat: [[f32; 3]; 3]\n}\n\nimpl Matrix {\n    pub fn mult_m(a: Matrix, b: Matrix) -> Matrix\n    {\n        let mut out = Matrix {\n            dat: [[0., 0., 0.],\n                  [0., 0., 0.],\n                  [0., 0., 0.]\n                  ]\n        };\n\n        for i in 0..3{\n            for j in 0..3 {\n                for k in 0..3 {\n                    out.dat[i][j] += a.dat[i][k] * b.dat[k][j];\n                }\n            }\n        }\n\n        out\n    }\n\n    pub fn print(self)\n    {\n        for i in 0..3 {\n            for j in 0..3 {\n                print!(\"{} \", self.dat[i][j]);\n            }\n            print!(\"\\n\");\n        }\n    }\n}\n\nfn main()\n{\n    let  a = Matrix {\n        dat: [[1., 2., 3.],\n              [4., 5., 6.],\n              [7., 8., 9.]\n              ]\n    };\n\n    let  b = Matrix {\n        dat: [[1., 0., 0.],\n              [0., 1., 0.],\n              [0., 0., 1.]]\n    };\n\t\n\n    \n        let c = Matrix::mult_m(a, b);\n    \n\n    c.print();\n}\n\n",
    "title": "Matrix multiplication",
    "url": "http://rosettacode.org/wiki/Matrix_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct Matrix {\n    dat: [[i32; 3]; 3]\n}\n \n\n \nimpl Matrix {\n    pub fn transpose_m(a: Matrix) -> Matrix\n    {\n        let mut out = Matrix {\n            dat: [[0, 0, 0],\n                  [0, 0, 0],\n                  [0, 0, 0]\n                  ]\n        };\n        \n        for i in 0..3{\n            for j in 0..3{\n                \n                    out.dat[i][j] = a.dat[j][i];\n            }\n        }\n \n        out\n    }\n \n    pub fn print(self)\n    {\n        for i in 0..3 {\n            for j in 0..3 {\n                print!(\"{} \", self.dat[i][j]);\n            }\n            print!(\"\\n\");\n        }\n    }\n}\n \nfn main()\n{\n    let  a = Matrix {\n        dat: [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9] ]\n    };\n\nlet c = Matrix::transpose_m(a);\n    c.print();\n}\n",
    "title": "Matrix transposition",
    "url": "http://rosettacode.org/wiki/Matrix_transposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt;\nuse std::ops;\nconst WIDTH: usize = 6;\n\n#[derive(Clone)]\nstruct SqMat {\n    data: Vec<Vec<i64>>,\n}\n\nimpl fmt::Debug for SqMat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut row = \"\".to_string();\n        for i in &self.data {\n            for j in i {\n                row += &format!(\"{:>w$} \", j, w = WIDTH);\n            }\n            row += &\"\\n\";\n        }\n        write!(f, \"{}\", row)\n    }\n}\n\nimpl ops::BitXor<u32> for SqMat {\n    type Output = Self;\n\n    fn bitxor(self, n: u32) -> Self::Output {\n        let mut aux = self.data.clone();\n        let mut ans: SqMat = SqMat {\n            data: vec![vec![0; aux.len()]; aux.len()],\n        };\n        for i in 0..aux.len() {\n            ans.data[i][i] = 1;\n        }\n        let mut b = n;\n        while b > 0 {\n            if b & 1 > 0 {\n                // ans = ans * aux\n                let mut tmp = aux.clone();\n                for i in 0..aux.len() {\n                    for j in 0..aux.len() {\n                        tmp[i][j] = 0;\n                        for k in 0..aux.len() {\n                            tmp[i][j] += ans.data[i][k] * aux[k][j];\n                        }\n                    }\n                }\n                ans.data = tmp;\n            }\n            b >>= 1;\n            if b > 0 {\n                // aux = aux * aux\n                let mut tmp = aux.clone();\n                for i in 0..aux.len() {\n                    for j in 0..aux.len() {\n                        tmp[i][j] = 0;\n                        for k in 0..aux.len() {\n                            tmp[i][j] += aux[i][k] * aux[k][j];\n                        }\n                    }\n                }\n                aux = tmp;\n            }\n        }\n        ans\n    }\n}\n\nfn main() {\n    let sm: SqMat = SqMat {\n        data: vec![vec![1, 2, 0], vec![0, 3, 1], vec![1, 0, 0]],\n    };\n    for i in 0..11 {\n        println!(\"Power of {}:\\n{:?}\", i, sm.clone() ^ i);\n    }\n}",
    "title": "Matrix-exponentiation operator",
    "url": "http://rosettacode.org/wiki/Matrix-exponentiation_operator"
  },
  {
    "local_code": "use std::cmp;\n\nconst TRIANGLE: &str = r\"55\n94 48\n95 30 96\n77 71 26 67\n97 13 76 38 45\n07 36 79 16 37 68\n48 07 09 18 70 26 06\n18 72 79 46 59 79 29 90\n20 76 87 11 32 07 07 49 18\n27 83 58 35 71 11 25 57 29 85\n14 64 36 96 27 11 58 56 92 18 55\n02 90 03 60 48 49 41 46 33 36 47 23\n92 50 48 02 36 59 42 79 72 20 82 77 42\n56 78 38 80 39 75 02 71 66 66 01 03 55 72\n44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\nfn max_path(vector: &mut Vec<Vec<u32>>) -> u32 {\n    while vector.len() > 1 {\n        let last = vector.pop().unwrap();\n        let ante = vector.pop().unwrap();\n\n        let mut new: Vec<u32> = Vec::new();\n\n        for (i, value) in ante.iter().enumerate() {\n            new.push(cmp::max(last[i], last[i + 1]) + value);\n        }\n\n        vector.push(new);\n    }\n\n    vector[0][0]\n}\n\nfn main() {\n    let mut vector = TRIANGLE\n        .split('\\n')\n        .map(|x| {\n            x.split(' ')\n                .map(|s: &str| s.parse::<u32>().unwrap())\n                .collect::<Vec<u32>>()\n        })\n        .collect::<Vec<Vec<u32>>>();\n\n    let max_value = max_path(&mut vector);\n\n    println!(\"{}\", max_value);\n}\n\n#[test]\nfn test_maximum_triangle_path_sum() {\n    let mut vector = TRIANGLE\n        .split('\\n')\n        .map(|x| {\n            x.split(' ')\n                .map(|s: &str| s.parse::<u32>().unwrap())\n                .collect::<Vec<u32>>()\n        })\n        .collect::<Vec<Vec<u32>>>();\n\n    let max_value = max_path(&mut vector);\n\n    assert_eq!(1320, max_value);\n}\n",
    "path": "tasks/maximum-triangle-path-sum",
    "remote_code": "use std::cmp::max;\n\nfn max_path(vector: &mut Vec<Vec<u32>>) -> u32 {\n    \n    while vector.len() > 1 {\n        \n        let last = vector.pop().unwrap();\n        let ante = vector.pop().unwrap();\n        \n        let mut new: Vec<u32> = Vec::new();\n        \n        for (i, value) in ante.iter().enumerate() {\n            new.push(max(last[i], last[i+1]) + value);\n        };\n        \n        vector.push(new);\n    };\n    \n    vector[0][0]\n}\n\nfn main() {\n    let mut data = \"55\n94 48\n95 30 96\n77 71 26 67\n97 13 76 38 45\n07 36 79 16 37 68\n48 07 09 18 70 26 06\n18 72 79 46 59 79 29 90\n20 76 87 11 32 07 07 49 18\n27 83 58 35 71 11 25 57 29 85\n14 64 36 96 27 11 58 56 92 18 55\n02 90 03 60 48 49 41 46 33 36 47 23\n92 50 48 02 36 59 42 79 72 20 82 77 42\n56 78 38 80 39 75 02 71 66 66 01 03 55 72\n44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\n    let mut vector = data.split(\"\\n\").map(|x| x.split(\" \").map(|s: &str| s.parse::<u32>().unwrap())\n        .collect::<Vec<u32>>()).collect::<Vec<Vec<u32>>>();\n    \n    let max_value = max_path(&mut vector);\n    \n    println!(\"{}\", max_value);\n    //=> 7273\n}",
    "title": "Maximum triangle path sum",
    "url": "http://rosettacode.org/wiki/Maximum_triangle_path_sum"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Mayan calendar",
    "url": "http://rosettacode.org/wiki/Mayan_calendar"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const ONE: &str = \"●\";\nconst FIVE: &str = \"——\";\nconst ZERO: &str = \"Θ\";\n\nfn main() {\n    println!(\"{}\", mayan(4005));\n    println!(\"{}\", mayan(8017));\n    println!(\"{}\", mayan(326_205));\n    println!(\"{}\", mayan(886_205));\n    println!(\"{}\", mayan(69));\n    println!(\"{}\", mayan(420));\n    println!(\"{}\", mayan(1_063_715_456));\n}\n\nfn mayan(dec: i64) -> String {\n    let mut digits = vec![];\n    let mut num = dec;\n    while num > 0 {\n        digits.push(num % 20);\n        num /= 20;\n    }\n    digits = digits.into_iter().rev().collect();\n    let mut boxes = vec![\"\".to_string(); 6];\n    let n = digits.len();\n    for (i, digit) in digits.iter().enumerate() {\n        if i == 0 {\n            boxes[0] = \"┏━━━━\".to_string();\n            if i == n - 1 {\n                boxes[0] += \"┓\";\n            }\n        } else if i == n - 1 {\n            boxes[0] += \"┳━━━━┓\";\n        } else {\n            boxes[0] += \"┳━━━━\";\n        }\n        for j in 1..5 {\n            boxes[j] += \"┃\";\n            let elem = 0.max(digit - (4 - j as i64) * 5);\n            if elem >= 5 {\n                boxes[j] += &format!(\"{: ^4}\", FIVE);\n            } else if elem > 0 {\n                boxes[j] += &format!(\"{: ^4}\", ONE.repeat(elem as usize % 15));\n            } else if j == 4 {\n                boxes[j] += &format!(\"{: ^4}\", ZERO);\n            } else {\n                boxes[j] += &\"    \";\n            }\n            if i == n - 1 {\n                boxes[j] += \"┃\";\n            }\n        }\n        if i == 0 {\n            boxes[5] = \"┗━━━━\".to_string();\n            if i == n - 1 {\n                boxes[5] += \"┛\";\n            }\n        } else if i == n - 1 {\n            boxes[5] += \"┻━━━━┛\";\n        } else {\n            boxes[5] += \"┻━━━━\";\n        }\n    }\n\n    let mut mayan = format!(\"Mayan {}:\\n\", dec);\n    for b in boxes {\n        mayan += &(b + \"\\n\");\n    }\n    mayan\n}",
    "title": "Mayan numerals",
    "url": "http://rosettacode.org/wiki/Mayan_numerals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{thread_rng, Rng, rngs::ThreadRng};\n\nconst WIDTH: usize = 16;\nconst HEIGHT: usize = 16;\n\n#[derive(Clone, Copy)]\nstruct Cell {\n    col: usize,\n    row: usize,\n}\n\nimpl Cell {\n    fn from(col: usize, row: usize) -> Cell {\n        Cell {col, row}\n    }\n}\n\nstruct Maze {\n    cells: [[bool; HEIGHT]; WIDTH],         //cell visited/non visited\n    walls_h: [[bool; WIDTH]; HEIGHT + 1],   //horizontal walls existing/removed\n    walls_v: [[bool; WIDTH + 1]; HEIGHT],   //vertical walls existing/removed\n    thread_rng: ThreadRng,                  //Random numbers generator\n}\n\nimpl Maze {\n\n    ///Inits the maze, with all the cells unvisited and all the walls active\n    fn new() -> Maze {\n        Maze { \n            cells: [[true; HEIGHT]; WIDTH], \n            walls_h: [[true; WIDTH]; HEIGHT + 1],\n            walls_v: [[true; WIDTH + 1]; HEIGHT],\n            thread_rng: thread_rng(),\n        }\n    }\n\n    ///Randomly chooses the starting cell\n    fn first(&mut self) -> Cell {\n        Cell::from(self.thread_rng.gen_range(0, WIDTH), self.thread_rng.gen_range(0, HEIGHT))\n    }\n\n    ///Opens the enter and exit doors\n    fn open_doors(&mut self) {\n        let from_top: bool = self.thread_rng.gen();\n        let limit = if from_top { WIDTH } else { HEIGHT };\n        let door = self.thread_rng.gen_range(0, limit);\n        let exit = self.thread_rng.gen_range(0, limit);\n        if from_top { \n            self.walls_h[0][door] = false;\n            self.walls_h[HEIGHT][exit] = false;\n        } else {\n            self.walls_v[door][0] = false;\n            self.walls_v[exit][WIDTH] = false;\n        }\n    }\n\n    ///Removes a wall between the two Cell arguments\n    fn remove_wall(&mut self, cell1: &Cell, cell2: &Cell) {\n        if cell1.row == cell2.row {\n            self.walls_v[cell1.row][if cell1.col > cell2.col { cell1.col } else { cell2.col }] = false;\n        } else { \n            self.walls_h[if cell1.row > cell2.row { cell1.row } else { cell2.row }][cell1.col] = false;\n        };\n    }\n\n    ///Returns a random non-visited neighbor of the Cell passed as argument\n    fn neighbor(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            self.remove_wall(cell, next);\n            Some(*next)\n        }\n    }\n\n    ///Builds the maze (runs the Depth-first search algorithm)\n    fn build(&mut self) {\n        let mut cell_stack: Vec<Cell> = Vec::new();\n        let mut next = self.first();\n        loop {\n            while let Some(cell) = self.neighbor(&next) {\n                cell_stack.push(cell);\n                next = cell;\n            }\n            match cell_stack.pop() {\n                Some(cell) => next = cell,\n                None => break,\n            }\n        }\n    }\n\n    ///Displays a wall\n    fn paint_wall(h_wall: bool, active: bool) {\n        if h_wall {\n            print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n        } else {\n            print!(\"{}\", if active { \"|   \" } else { \"    \" });\n        }\n    }\n\n    ///Displays a final wall for a row\n    fn paint_close_wall(h_wall: bool) {\n        if h_wall { println!(\"+\") } else { println!() }\n    }\n\n    ///Displays a whole row of walls\n    fn paint_row(&self, h_walls: bool, index: usize) {\n        let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n        for &wall in iter {\n            Maze::paint_wall(h_walls, wall);\n        }\n        Maze::paint_close_wall(h_walls);\n    } \n\n    ///Paints the maze\n    fn paint(&self) {\n        for i in 0 .. HEIGHT {\n            self.paint_row(true, i);\n            self.paint_row(false, i);\n        }\n        self.paint_row(true, HEIGHT);\n    }\n}\n\nfn main() {\n    let mut maze = Maze::new();\n    maze.build();\n    maze.open_doors();\n    maze.paint();\n}",
    "title": "Maze generation",
    "url": "http://rosettacode.org/wiki/Maze_generation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{thread_rng, Rng, rngs::ThreadRng};\n \nconst WIDTH: usize = 16;\nconst HEIGHT: usize = 16;\n \n#[derive(Clone, Copy, PartialEq)]\nstruct Cell {\n    col: usize,\n    row: usize,\n}\n\nimpl Cell {\n    fn from(col: usize, row: usize) -> Cell {\n        Cell {col, row}\n    }\n}\n \nstruct Maze {\n    cells: [[bool; HEIGHT]; WIDTH],         //cell visited/non visited\n    walls_h: [[bool; WIDTH]; HEIGHT + 1],   //horizontal walls existing/removed\n    walls_v: [[bool; WIDTH + 1]; HEIGHT],   //vertical walls existing/removed\n    thread_rng: ThreadRng,                  //Random numbers generator\n}\n \nimpl Maze {\n \n    ///Inits the maze, with all the cells unvisited and all the walls active\n    fn new() -> Maze {\n        Maze { \n            cells: [[true; HEIGHT]; WIDTH], \n            walls_h: [[true; WIDTH]; HEIGHT + 1],\n            walls_v: [[true; WIDTH + 1]; HEIGHT],\n            thread_rng: thread_rng(),\n        }\n    }\n \n    ///Randomly chooses the starting cell\n    fn first(&mut self) -> Cell {\n        Cell::from(self.thread_rng.gen_range(0, WIDTH), self.thread_rng.gen_range(0, HEIGHT))\n    }\n \n    ///Opens the enter and exit doors\n    fn open_doors(&mut self) {\n        let from_top: bool = self.thread_rng.gen();\n        let limit = if from_top { WIDTH } else { HEIGHT };\n        let door = self.thread_rng.gen_range(0, limit);\n        let exit = self.thread_rng.gen_range(0, limit);\n        if from_top { \n            self.walls_h[0][door] = false;\n            self.walls_h[HEIGHT][exit] = false;\n        } else {\n            self.walls_v[door][0] = false;\n            self.walls_v[exit][WIDTH] = false;\n        }\n    }\n \n    ///Removes a wall between the two Cell arguments\n    fn remove_wall(&mut self, cell1: &Cell, cell2: &Cell) {\n        if cell1.row == cell2.row {\n            self.walls_v[cell1.row][if cell1.col > cell2.col { cell1.col } else { cell2.col }] = false;\n        } else { \n            self.walls_h[if cell1.row > cell2.row { cell1.row } else { cell2.row }][cell1.col] = false;\n        };\n    }\n \n    ///Returns a random non-visited neighbor of the Cell passed as argument\n    fn neighbor(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            self.remove_wall(cell, next);\n            Some(*next)\n        }\n    }\n \n    ///Builds the maze (runs the Depth-first search algorithm)\n    fn build(&mut self) {\n        let mut cell_stack: Vec<Cell> = Vec::new();\n        let mut next = self.first();\n        loop {\n            while let Some(cell) = self.neighbor(&next) {\n                cell_stack.push(cell);\n                next = cell;\n            }\n            match cell_stack.pop() {\n                Some(cell) => next = cell,\n                None => break,\n            }\n        }\n    }\n \n    ///MAZE SOLVING: Find the starting cell of the solution\n    fn solution_first(&self) -> Option<Cell> {\n        for (i, wall) in self.walls_h[0].iter().enumerate() {\n            if !wall {\n                return Some(Cell::from(i, 0));\n            }\n        }\n        for (i, wall) in self.walls_v.iter().enumerate() {\n            if !wall[0] {\n                return Some(Cell::from(0, i));\n            }\n        }\n        None\n    }\n\n    ///MAZE SOLVING: Find the last cell of the solution\n    fn solution_last(&self) -> Option<Cell> {\n        for (i, wall) in self.walls_h[HEIGHT].iter().enumerate() {\n            if !wall {\n                return Some(Cell::from(i, HEIGHT - 1));\n            }\n        }\n        for (i, wall) in self.walls_v.iter().enumerate() {\n            if !wall[WIDTH] {\n                return Some(Cell::from(WIDTH - 1, i));\n            }\n        }\n        None\n    }\n\n    ///MAZE SOLVING: Get the next candidate cell\n    fn solution_next(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] && !self.walls_v[cell.row][cell.col] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] && !self.walls_h[cell.row][cell.col] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] && !self.walls_v[cell.row][cell.col + 1] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] && !self.walls_h[cell.row + 1][cell.col] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            Some(*next)\n        }\n    }\n\n    ///MAZE SOLVING: solve the maze\n    ///Uses self.cells to store the solution cells (true)\n    fn solve(&mut self) {\n        self.cells = [[true; HEIGHT]; WIDTH];\n        let mut solution: Vec<Cell> = Vec::new();\n        let mut next = self.solution_first().unwrap();\n        solution.push(next);\n        let last = self.solution_last().unwrap();\n        'main: loop {\n            while let Some(cell) = self.solution_next(&next) {\n                solution.push(cell);\n                if cell == last {\n                    break 'main;\n                }\n                next = cell;\n            }\n            solution.pop().unwrap();\n            next = *solution.last().unwrap();\n        }\n        self.cells = [[false; HEIGHT]; WIDTH];\n        for cell in solution {\n            self.cells[cell.col][cell.row] = true;\n        }\n    }\n\n    ///MAZE SOLVING: Ask if cell is part of the solution (cells[col][row] == true)\n    fn is_solution(&self, col: usize, row: usize) -> bool {\n        self.cells[col][row]\n    }\n\n    ///Displays a wall\n    ///MAZE SOLVING: Leave space for printing '*' if cell is part of the solution \n    /// (only when painting vertical walls)\n    /// \n    // fn paint_wall(h_wall: bool, active: bool) {\n    //     if h_wall {\n    //         print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n    //     } else {\n    //         print!(\"{}\", if active { \"|   \" } else { \"    \" });\n    //     }\n    // }\n    fn paint_wall(h_wall: bool, active: bool, with_solution: bool) {\n        if h_wall {\n            print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n        } else {\n            print!(\"{}{}\", if active { \"|\" } else { \" \" }, if with_solution { \"\" } else { \"   \" });\n        }\n    }\n    \n    ///MAZE SOLVING: Paint * if cell is part of the solution\n    fn paint_solution(is_part: bool) {\n        print!(\"{}\", if is_part { \" * \" } else {\"   \"});\n    }\n\n    ///Displays a final wall for a row\n    fn paint_close_wall(h_wall: bool) {\n        if h_wall { println!(\"+\") } else { println!() }\n    }\n \n    ///Displays a whole row of walls\n    ///MAZE SOLVING: Displays a whole row of walls and, optionally, the included solution cells.\n    // fn paint_row(&self, h_walls: bool, index: usize) {\n    //     let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n    //     for &wall in iter {\n    //         Maze::paint_wall(h_walls, wall);\n    //     }\n    //     Maze::paint_close_wall(h_walls);\n    // }\n    fn paint_row(&self, h_walls: bool, index: usize, with_solution: bool) {\n        let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n        for (col, &wall) in iter.enumerate() {\n            Maze::paint_wall(h_walls, wall, with_solution);\n            if !h_walls && with_solution && col < WIDTH  {\n                Maze::paint_solution(self.is_solution(col, index));\n            }\n        }\n        Maze::paint_close_wall(h_walls);\n    }\n\n    ///Paints the maze\n    ///MAZE SOLVING: Displaying the solution is an option\n    // fn paint(&self) {\n    //     for i in 0 .. HEIGHT {\n    //         self.paint_row(true, i);\n    //         self.paint_row(false, i);\n    //     }\n    //     self.paint_row(true, HEIGHT);\n    // }\n    fn paint(&self, with_solution: bool) {\n        for i in 0 .. HEIGHT {\n            self.paint_row(true, i, with_solution);\n            self.paint_row(false, i, with_solution);\n        }\n        self.paint_row(true, HEIGHT, with_solution);\n    }\n}\n\nfn main() {\n    let mut maze = Maze::new();\n    maze.build();\n    maze.open_doors();\n    \n    println!(\"The maze:\");\n    maze.paint(false);\n\n    maze.solve();\n    println!(\"The maze, solved:\");\n    maze.paint(true);\n}",
    "title": "Maze solving",
    "url": "http://rosettacode.org/wiki/Maze_solving"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let test_cases = vec![\n        [6, 9, 20],\n        [12, 14, 17],\n        [12, 13, 34],\n        [5, 9, 21],\n        [10, 18, 21],\n        [71, 98, 99],\n        [7_074_047, 8_214_596, 9_098_139],\n        [582_795_988, 1_753_241_221, 6_814_151_015],\n        [4, 30, 16],\n        [12, 12, 13],\n        [6, 15, 1],\n    ];\n    for case in &test_cases {\n        print!(\"g({}, {}, {}) = \", case[0], case[1], case[2]);\n        println!(\n            \"{}\",\n            match frobenius(case.to_vec()) {\n                Ok(g) => format!(\"{}\", g),\n                Err(e) => e,\n            }\n        );\n    }\n}\n\nfn frobenius(unsorted_a: Vec<i64>) -> Result<i64, String> {\n    let mut a = unsorted_a;\n    a.sort();\n    assert!(a[0] >= 1);\n    if gcd(gcd(a[0], a[1]), a[2]) > 1 {\n        return Err(\"Undefined\".to_string());\n    }\n    let d12 = gcd(a[0], a[1]);\n    let d13 = gcd(a[0] / d12, a[2]);\n    let d23 = gcd(a[1] / d12, a[2] / d13);\n    let mut a_prime = vec![a[0] / d12 / d13, a[1] / d12 / d23, a[2] / d13 / d23];\n    a_prime.sort();\n    let rod = if a_prime[0] == 1 {\n        -1\n    } else {\n        // Rødseth’s Algorithm\n        let mut a1 = a_prime[0];\n        let mut s0 = congruence(a_prime[1], a_prime[2], a_prime[0]);\n        let mut s = vec![a1];\n        let mut q: Vec<i64> = vec![];\n        while s0 != 0 {\n            s.push(s0);\n            let s1 = if s0 == 1 { 0 } else { s0 - (a1 % s0) };\n            let q1 = (a1 + s1) / s0;\n            q.push(q1);\n            a1 = s0;\n            s0 = s1;\n        }\n        let mut p = vec![0, 1];\n        let mut r = (s[1] * a_prime[1] - p[1] * a_prime[2]) / a_prime[0];\n        let mut i = 1;\n        while r > 0 {\n            let p_next = q[i - 1] * p[i] - p[i - 1];\n            p.push(p_next);\n            r = (s[i + 1] * a_prime[1] - p_next * a_prime[2]) / a_prime[0];\n            i += 1;\n        }\n        let v = i - 1;\n        -a_prime[0] + a_prime[1] * (s[v] - 1) + a_prime[2] * (p[v + 1] - 1)\n            - (a_prime[1] * s[v + 1]).min(a_prime[2] * p[v])\n    };\n    Ok(rod * d12 * d13 * d23 + a[0] * (d23 - 1) + a[1] * (d13 - 1) + a[2] * (d12 - 1))\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn congruence(a: i64, c: i64, m: i64) -> i64 {\n    // Solves ax ≡ c mod m\n    let aa = a % m;\n    let cc = (c + a * m) % m;\n    if aa == 1 {\n        cc\n    } else {\n        let y = congruence(m, -cc, aa);\n        (m * y + cc) / aa\n    }\n}",
    "title": "McNuggets problem",
    "url": "http://rosettacode.org/wiki/McNuggets_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Median filter",
    "url": "http://rosettacode.org/wiki/Median_filter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// we have to use `unsafe` here because \n// we will be dereferencing a raw pointer\nunsafe {\n    use std::alloc::{Layout, alloc, dealloc};\n    // define a layout of a block of memory\n    let int_layout = Layout::new::<i32>();\n\n    // memory is allocated here\n    let ptr = alloc(int_layout);\n\n    // let us point to some data\n    *ptr = 123;\n    assert_eq!(*ptr, 123);\n\n    // deallocate `ptr` with associated layout `int_layout`\n    dealloc(ptr, int_layout);\n}",
    "title": "Memory allocation",
    "url": "http://rosettacode.org/wiki/Memory_allocation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Memory layout of a data structure",
    "url": "http://rosettacode.org/wiki/Memory_layout_of_a_data_structure"
  },
  {
    "local_code": "use std::io;\n\n/// Print the menu followed by the prompt\nfn print_both(menu: &[&str], prompt: &str) {\n    // Iterate through array and print index, period, and menu item\n    for (i, item) in menu.iter().enumerate() {\n        println!(\"{}. {}\", i, item);\n    }\n\n    // Print the prompt\n    println!(\"{}\", prompt);\n}\n\n/// Grab the next line of input\nfn next_input() -> Option<usize> {\n    let mut in_s = String::new();\n    if io::stdin().read_line(&mut in_s).is_ok() {\n        in_s.trim().parse().ok()\n    } else {\n        None\n    }\n}\n\nfn select<'a>(menu: &'a [&str], prompt: &str) -> &'a str {\n    if menu.is_empty() {\n        return \"\";\n    }\n\n    // Loop until user inputs a valid menu index\n    loop {\n        print_both(menu, prompt);\n\n        let input = next_input();\n\n        let num = match input {\n            Some(num) => num,\n            None => continue,\n        };\n\n        if num < menu.len() {\n            return menu[num];\n        }\n    }\n}\n\nfn main() {\n    let prompt = \"Choose one.\";\n    let menu = &[\"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\"];\n    println!(\"{}\", select(menu, prompt));\n}\n\n#[test]\nfn test_empty_menu() {\n    let prompt = \"Choose one.\";\n    let menu = &[];\n    assert_eq!(select(menu, prompt), \"\");\n}\n",
    "path": "tasks/menu",
    "remote_code": "\nfn menu_select<'a>(items: &'a [&'a str]) -> &'a str {\n    if items.len() == 0 {\n        return \"\";\n    }\n\n    let stdin = std::io::stdin();\n    let mut buffer = String::new();\n\n    loop {\n        for (i, item) in items.iter().enumerate() {\n            println!(\"{}) {}\", i + 1, item);\n        }\n        print!(\"Pick a number from 1 to {}: \", items.len());\n\n        // Read the user input:\n        stdin.read_line(&mut buffer).unwrap();\n        println!();\n\n        if let Ok(selected_index) = buffer.trim().parse::<usize>() {\n            if 0 < selected_index {\n                if let Some(selected_item) = items.get(selected_index - 1) {\n                    return selected_item;\n                }\n            }\n        }\n\n        // The buffer will contain the old input, so we need to clear it before we can reuse it.\n        buffer.clear();\n    }\n}\n\nfn main() {\n    // Empty list:\n    let selection = menu_select(&[]);\n    println!(\"No choice: {:?}\", selection);\n\n    // List with items:\n    let items = [\n        \"fee fie\",\n        \"huff and puff\",\n        \"mirror mirror\",\n        \"tick tock\",\n    ];\n\n    let selection = menu_select(&items);\n    println!(\"You chose: {}\", selection);\n}\n",
    "title": "Menu",
    "url": "http://rosettacode.org/wiki/Menu"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Merge and aggregate datasets",
    "url": "http://rosettacode.org/wiki/Merge_and_aggregate_datasets"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Mertens function",
    "url": "http://rosettacode.org/wiki/Mertens_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Metallic ratios",
    "url": "http://rosettacode.org/wiki/Metallic_ratios"
  },
  {
    "local_code": "//! Rust supports extensive metaprogramming via macros. Note that rust macros differ from, say, C\n//! preprocessor macros in that they are not mere text substitution (so operator precedence is\n//! preserved and name shadowing is not an issue). Here is an example from [rustbyexample.com] that\n//! implements and tests the `+=`, `-=`, and `*=` operators for Vectors.\n\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:ident, $b:ident, $func:ident, $op:tt) => {\n        assert!(\n            $a.len() == $b.len(),\n            \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n            stringify!($func),\n            ($a.len(),),\n            stringify!($op),\n            ($b.len(),)\n        );\n    };\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => {\n        fn $func<T: $bound<T, Output = T> + Copy>(xs: &mut [T], ys: &[T]) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                // *x = x.$method(*y);\n                *x = $bound::$method(*x, *y);\n            }\n        }\n    };\n}\n\n// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nfn main() {\n    let mut x = vec![2; 3];\n    let a = vec![1, 2, 3];\n    let b = vec![4, 5, 6];\n    let c = vec![7, 8, 9];\n\n    add_assign(&mut x, &a);\n    mul_assign(&mut x, &b);\n    sub_assign(&mut x, &c);\n\n    println!(\"{:?}\", x);\n}\n\nmod test {\n    macro_rules! test {\n        ($func:ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                use std::iter;\n\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        };\n    }\n\n    // Test `add_assign`, `mul_assign` and `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n",
    "path": "tasks/metaprogramming",
    "remote_code": "// dry.rs\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:ident, $b: ident, $func:ident, $op:tt) => (\n        assert!($a.len() == $b.len(),\n                \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n                stringify!($func),\n                ($a.len(),),\n                stringify!($op),\n                ($b.len(),));\n    )\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => (\n        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n                // *x = x.$method(*y);\n            }\n        }\n    )\n}\n\n// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nmod test {\n    use std::iter;\n    macro_rules! test {\n        ($func: ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        }\n    }\n\n    // Test `add_assign`, `mul_assign` and `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}",
    "title": "Metaprogramming",
    "url": "http://rosettacode.org/wiki/Metaprogramming"
  },
  {
    "local_code": "//! Rust has a perfectly good Semaphore type already. It lacks count(), though, so we can't use it\n//! directly.\n\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::sync::mpsc::channel;\nuse std::sync::Arc;\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\npub struct CountingSemaphore {\n    /// Remaining resource count\n    count: AtomicUsize,\n\n    /// How long to sleep if a resource is being contended\n    backoff: Duration,\n}\n\npub struct CountingSemaphoreGuard<'a> {\n    /// A reference to the owning semaphore.\n    sem: &'a CountingSemaphore,\n}\n\nimpl CountingSemaphore {\n    /// Create a semaphore with `max` available resources and a linearly increasing backoff of\n    /// `backoff` (used during spinlock contention).\n    #[must_use]\n    pub fn new(max: usize, backoff: Duration) -> CountingSemaphore {\n        CountingSemaphore {\n            count: AtomicUsize::new(max),\n            backoff,\n        }\n    }\n\n    /// Acquire a resource, returning a RAII `CountingSemaphoreGuard`.\n    pub fn acquire(&self) -> CountingSemaphoreGuard {\n        // Spinlock until remaining resource count is at least 1\n        let mut backoff = self.backoff;\n        loop {\n            // Probably don't need SeqCst here, but it doesn't hurt.\n            let count = self.count.load(SeqCst);\n            // The check for 0 is necessary to make sure we don't go negative, which is why this\n            // must be a compare-and-swap rather than a straight decrement.\n            if count == 0\n                || self\n                    .count\n                    .compare_exchange(count, count - 1, SeqCst, SeqCst)\n                    .is_err()\n            {\n                // Linear backoff a la Servo's spinlock contention.\n                thread::sleep(backoff);\n                backoff += self.backoff;\n            } else {\n                // We successfully acquired the resource.\n                break;\n            }\n        }\n        CountingSemaphoreGuard { sem: self }\n    }\n\n    // Return remaining resource count\n    pub fn count(&self) -> usize {\n        self.count.load(SeqCst)\n    }\n}\n\nimpl<'a> Drop for CountingSemaphoreGuard<'a> {\n    /// When the guard is dropped, a resource is released back to the pool.\n    fn drop(&mut self) {\n        self.sem.count.fetch_add(1, SeqCst);\n    }\n}\n\nfn metered(duration: Duration) {\n    static MAX_COUNT: usize = 4; // Total available resources\n    static NUM_WORKERS: u8 = 10; // Number of workers contending for the resources\n    let backoff = Duration::from_millis(1); // Linear backoff time\n                                            // Create a shared reference to the semaphore\n    let sem = Arc::new(CountingSemaphore::new(MAX_COUNT, backoff));\n    // Create a channel for notifying the main task that the workers are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_WORKERS {\n        let sem = Arc::clone(&sem);\n        let tx = tx.clone();\n        spawn(move || {\n            // Acquire the resource\n            let guard = sem.acquire();\n            let count = sem.count();\n            // Make sure the count is legal\n            assert!(count < MAX_COUNT);\n            println!(\"Worker {} after acquire: count = {}\", i, count);\n            // Sleep for `duration`\n            thread::sleep(duration);\n            // Release the resource\n            drop(guard);\n            // Make sure the count is legal\n            let count = sem.count();\n            assert!(count <= MAX_COUNT);\n            println!(\"Worker {} after release: count = {}\", i, count);\n            // Notify the main task of completion\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // Wait for all the subtasks to finish\n    for _ in 0..NUM_WORKERS {\n        rx.recv().unwrap();\n    }\n}\n\n#[test]\nfn test_metered_concurrency() {\n    // Hold each resource for 1/20 of a second per worker\n    metered(Duration::from_secs(1) / 20);\n}\n\nfn main() {\n    // Hold each resource for 2 seconds per worker\n    metered(Duration::from_secs(2));\n}\n",
    "path": "tasks/metered-concurrency",
    "remote_code": "\n//! Rust has a perfectly good Semaphore type already. It lacks count(), though, so we can't use it\n//! directly.\n\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::sync::mpsc::channel;\nuse std::sync::Arc;\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\npub struct CountingSemaphore {\n    /// Remaining resource count\n    count: AtomicUsize,\n\n    /// How long to sleep if a resource is being contended\n    backoff: Duration,\n}\n\npub struct CountingSemaphoreGuard<'a> {\n    /// A reference to the owning semaphore.\n    sem: &'a CountingSemaphore,\n}\n\nimpl CountingSemaphore {\n    /// Create a semaphore with `max` available resources and a linearly increasing backoff of\n    /// `backoff` (used during spinlock contention).\n    pub fn new(max: usize, backoff: Duration) -> CountingSemaphore {\n        CountingSemaphore {\n            count: AtomicUsize::new(max),\n            backoff,\n        }\n    }\n\n    /// Acquire a resource, returning a RAII CountingSemaphoreGuard.\n    pub fn acquire(&self) -> CountingSemaphoreGuard {\n        // Spinlock until remaining resource count is at least 1\n        let mut backoff = self.backoff;\n        loop {\n            // Probably don't need SeqCst here, but it doesn't hurt.\n            let count = self.count.load(SeqCst);\n            // The check for 0 is necessary to make sure we don't go negative, which is why this\n            // must be a compare-and-swap rather than a straight decrement.\n            if count == 0\n                || self\n                    .count\n                    .compare_exchange(count, count - 1, SeqCst, SeqCst)\n                    .is_err()\n            {\n                // Linear backoff a la Servo's spinlock contention.\n                thread::sleep(backoff);\n                backoff += self.backoff;\n            } else {\n                // We successfully acquired the resource.\n                break;\n            }\n        }\n        CountingSemaphoreGuard { sem: self }\n    }\n\n    // Return remaining resource count\n    pub fn count(&self) -> usize {\n        self.count.load(SeqCst)\n    }\n}\n\nimpl<'a> Drop for CountingSemaphoreGuard<'a> {\n    /// When the guard is dropped, a resource is released back to the pool.\n    fn drop(&mut self) {\n        self.sem.count.fetch_add(1, SeqCst);\n    }\n}\n\nfn metered(duration: Duration) {\n    static MAX_COUNT: usize = 4; // Total available resources\n    static NUM_WORKERS: u8 = 10; // Number of workers contending for the resources\n    let backoff = Duration::from_millis(1); // Linear backoff time\n                                            // Create a shared reference to the semaphore\n    let sem = Arc::new(CountingSemaphore::new(MAX_COUNT, backoff));\n    // Create a channel for notifying the main task that the workers are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_WORKERS {\n        let sem = Arc::clone(&sem);\n        let tx = tx.clone();\n        spawn(move || {\n            // Acquire the resource\n            let guard = sem.acquire();\n            let count = sem.count();\n            // Make sure the count is legal\n            assert!(count < MAX_COUNT);\n            println!(\"Worker {} after acquire: count = {}\", i, count);\n            // Sleep for `duration`\n            thread::sleep(duration);\n            // Release the resource\n            drop(guard);\n            // Make sure the count is legal\n            let count = sem.count();\n            assert!(count <= MAX_COUNT);\n            println!(\"Worker {} after release: count = {}\", i, count);\n            // Notify the main task of completion\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // Wait for all the subtasks to finish\n    for _ in 0..NUM_WORKERS {\n        rx.recv().unwrap();\n    }\n}\n\nfn main() {\n    // Hold each resource for 2 seconds per worker\n    metered(Duration::from_secs(2));\n}\n\n",
    "title": "Metered concurrency",
    "url": "http://rosettacode.org/wiki/Metered_concurrency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Metronome",
    "url": "http://rosettacode.org/wiki/Metronome"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Mian-Chowla sequence",
    "url": "http://rosettacode.org/wiki/Mian-Chowla_sequence"
  },
  {
    "local_code": "#![allow(clippy::unreadable_literal)]\n\nfn middle_three_digits(x: i32) -> Result<String, String> {\n    let s: String = x.abs().to_string();\n    let len = s.len();\n    if len < 3 {\n        Err(\"Too short\".into())\n    } else if len % 2 == 0 {\n        Err(\"Even number of digits\".into())\n    } else {\n        Ok(s[len / 2 - 1..len / 2 + 2].to_owned())\n    }\n}\n\nfn print_result(x: i32) {\n    print!(\"middle_three_digits({}) returned: \", x);\n    match middle_three_digits(x) {\n        Ok(s) => println!(\"Success, {}\", s),\n        Err(s) => println!(\"Failure, {}\", s),\n    }\n}\n\nfn main() {\n    let passing = [\n        123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345,\n    ];\n    let failing = [1, 2, -1, -10, 2002, -2002, 0];\n    for i in &passing {\n        print_result(*i);\n    }\n    for i in &failing {\n        print_result(*i);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::middle_three_digits;\n\n    #[test]\n    fn positive() {\n        assert_eq!(middle_three_digits(123), Ok(\"123\".into()));\n        assert_eq!(middle_three_digits(12345), Ok(\"234\".into()));\n        assert_eq!(middle_three_digits(1234567), Ok(\"345\".into()));\n        assert_eq!(middle_three_digits(987654321), Ok(\"654\".into()));\n        assert_eq!(middle_three_digits(10001), Ok(\"000\".into()));\n        assert_eq!(middle_three_digits(100), Ok(\"100\".into()));\n    }\n\n    #[test]\n    fn negative() {\n        assert_eq!(middle_three_digits(-10001), Ok(\"000\".into()));\n        assert_eq!(middle_three_digits(-123), Ok(\"123\".into()));\n        assert_eq!(middle_three_digits(-100), Ok(\"100\".into()));\n        assert_eq!(middle_three_digits(-12345), Ok(\"234\".into()));\n    }\n\n    #[test]\n    fn failures() {\n        assert_eq!(middle_three_digits(1), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(2), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(-1), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(-10), Err(\"Too short\".into()));\n        assert_eq!(\n            middle_three_digits(2002),\n            Err(\"Even number of digits\".into())\n        );\n        assert_eq!(\n            middle_three_digits(-2002),\n            Err(\"Even number of digits\".into())\n        );\n        assert_eq!(middle_three_digits(0), Err(\"Too short\".into()));\n    }\n}\n",
    "path": "tasks/middle-three-digits",
    "remote_code": "fn middle_three_digits(x: i32) -> Result<String, String> {\n    let s: String = x.abs().to_string();\n    let len = s.len();\n    if len < 3 {\n        Err(\"Too short\".into())\n    } else if len % 2 == 0 {\n        Err(\"Even number of digits\".into())\n    } else {\n        Ok(s[len/2 - 1 .. len/2 + 2].to_owned())\n    }\n}\n\nfn print_result(x: i32) {\n    print!(\"middle_three_digits({}) returned: \", x);\n    match middle_three_digits(x) {\n        Ok(s) => println!(\"Success, {}\", s),\n        Err(s) => println!(\"Failure, {}\", s)\n    }\n}\n\nfn main() {\n    let passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345];\n    let failing = [1, 2, -1, -10, 2002, -2002, 0];\n    for i in passing.iter() {\n        print_result(*i);\n    }\n    for i in failing.iter() {\n        print_result(*i);\n    }\n}",
    "title": "Middle three digits",
    "url": "http://rosettacode.org/wiki/Middle_three_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/* Add these lines to the [dependencies] section of your Cargo.toml file:\nnum = \"0.2.0\"\nrand = \"0.6.5\"\n*/\n \nuse num::bigint::BigInt;\nuse num::bigint::ToBigInt;\n \n \n// The modular_exponentiation() function takes three identical types\n// (which get cast to BigInt), and returns a BigInt:\nfn modular_exponentiation<T: ToBigInt>(n: &T, e: &T, m: &T) -> BigInt {\n    // Convert n, e, and m to BigInt:\n    let n = n.to_bigint().unwrap();\n    let e = e.to_bigint().unwrap();\n    let m = m.to_bigint().unwrap();\n \n    // Sanity check:  Verify that the exponent is not negative:\n    assert!(e >= Zero::zero());\n \n    use num::traits::{Zero, One};\n \n    // As most modular exponentiations do, return 1 if the exponent is 0:\n    if e == Zero::zero() {\n        return One::one()\n    }\n \n    // Now do the modular exponentiation algorithm:\n    let mut result: BigInt = One::one();\n    let mut base = n % &m;\n    let mut exp = e;\n \n    loop {  // Loop until we can return our result.\n        if &exp % 2 == One::one() {\n            result *= &base;\n            result %= &m;\n        }\n \n        if exp == One::one() {\n            return result\n        }\n \n        exp /= 2;\n        base *= base.clone();\n        base %= &m;\n    }\n}\n \n \n// is_prime() checks the passed-in number against many known small primes.\n// If that doesn't determine if the number is prime or not, then the number\n// will be passed to the is_rabin_miller_prime() function:\nfn is_prime<T: ToBigInt>(n: &T) -> bool {\n    let n = n.to_bigint().unwrap();\n    if n.clone() < 2.to_bigint().unwrap() {\n        return false\n    }\n \n    let small_primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n                            47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\n                            103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n                            157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\n                            211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\n                            269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n                            331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\n                            389, 397, 401, 409, 419, 421, 431, 433, 439, 443,\n                            449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n                            509, 521, 523, 541, 547, 557, 563, 569, 571, 577,\n                            587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\n                            643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n                            709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\n                            773, 787, 797, 809, 811, 821, 823, 827, 829, 839,\n                            853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n                            919, 929, 937, 941, 947, 953, 967, 971, 977, 983,\n                            991, 997, 1009, 1013];\n \n    use num::traits::Zero;  // for Zero::zero()\n \n    // Check to see if our number is a small prime (which means it's prime),\n    // or a multiple of a small prime (which means it's not prime):\n    for sp in small_primes {\n        let sp = sp.to_bigint().unwrap();\n \n        if n.clone() == sp {\n            return true\n        } else if n.clone() % sp == Zero::zero() {\n            return false\n        }\n    }\n \n    is_rabin_miller_prime(&n, None)\n}\n \n \n// Note:  \"use bigint::RandBigInt;\"  (which is needed for gen_bigint_range())\n//        fails to work in the Rust playground ( https://play.rust-lang.org ).\n//        Therefore, I'll create my own here:\nfn get_random_bigint(low: &BigInt, high: &BigInt) -> BigInt {\n    if low == high {  // base case\n        return low.clone()\n    }\n \n    let middle = (low.clone() + high) / 2.to_bigint().unwrap();\n \n    let go_low: bool = rand::random();\n \n    if go_low {\n        return get_random_bigint(low, &middle)\n    } else {\n        return get_random_bigint(&middle, high)\n    }\n}\n \n \n// k is the number of times for testing (pass in None to use 5 (the default)).\nfn is_rabin_miller_prime<T: ToBigInt>(n: &T, k: Option<usize>) -> bool {\n    let n = n.to_bigint().unwrap();\n    let k = k.unwrap_or(10);  // number of times for testing (defaults to 10)\n \n    use num::traits::{Zero, One};  // for Zero::zero() and One::one()\n    let zero: BigInt = Zero::zero();\n    let one: BigInt = One::one();\n    let two: BigInt = 2.to_bigint().unwrap();\n \n    // The call to is_prime() should have already checked this,\n    // but check for two, less than two, and multiples of two:\n    if n <= one {\n        return false\n    } else if n == two {\n        return true  // 2 is prime\n    } else if n.clone() % &two == Zero::zero() {\n        return false  // even number (that's not 2) is not prime\n    }\n\n    let mut t: BigInt = zero.clone();\n    let n_minus_one: BigInt = n.clone() - &one;\n    let mut s = n_minus_one.clone();\n    while &s % &two == one {\n        s /= &two;\n        t += &one;\n    }\n \n    // Try k times to test if our number is non-prime:\n    'outer: for _ in 0..k {\n        let a = get_random_bigint(&two, &n_minus_one);\n        let mut v = modular_exponentiation(&a, &s, &n);\n        if v == one {\n            continue 'outer;\n        }\n        let mut i: BigInt = zero.clone();\n        'inner: while &i < &t {\n            v = (v.clone() * &v) % &n;\n            if &v == &n_minus_one {\n                continue 'outer;\n            }\n            i += &one;\n        }\n        return false;\n    }\n    // If we get here, then we have a degree of certainty\n    // that n really is a prime number, so return true:\n    true\n}",
    "title": "Miller–Rabin primality test",
    "url": "http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand; // 0.5.5\nuse rand::Rng;\nuse std::iter::repeat;\n\n#[derive(Debug, Eq, PartialEq, Clone)]\nenum Colour {\n    Black,\n    Red,\n}\nuse Colour::*;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    \n    //Create our deck.\n    let mut deck: Vec<_> = repeat(Black).take(26)\n        .chain(repeat(Red).take(26))\n        .collect();\n    \n    rng.shuffle(&mut deck);\n    \n    let mut black_stack = vec![];\n    let mut red_stack = vec![];\n    let mut discarded = vec![];\n    \n    //Deal our cards.\n    print!(\"Discarding:\");\n    while let (Some(card), Some(next)) = (deck.pop(), deck.pop()) {\n        print!(\" {}\", if card == Black { \"B\" } else { \"R\" });\n        match card {\n            Red => red_stack.push(next),\n            Black => black_stack.push(next),\n        }\n        discarded.push(card);\n    }\n    println!();\n    \n    // Choose how many to swap.\n    let max = red_stack.len().min(black_stack.len());\n    let num = rng.gen_range(1, max);\n    println!(\"Exchanging {} cards\", num);\n    \n    // Actually swap our cards.\n    for _ in 0..num {\n        let red = rng.choose_mut(&mut red_stack).unwrap();\n        let black = rng.choose_mut(&mut black_stack).unwrap();\n        std::mem::swap(red, black);\n    }\n    \n    //Count how many are red and black.\n    let num_black = black_stack.iter()\n        .filter(|&c| c == &Black)\n        .count();\n    let num_red = red_stack.iter()\n        .filter(|&c| c == &Red)\n        .count();\n        \n    println!(\"Number of black cards in black stack: {}\", num_black);\n    println!(\"Number of red cards in red stack: {}\", num_red);\n}",
    "title": "Mind boggling card trick",
    "url": "http://rosettacode.org/wiki/Mind_boggling_card_trick"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse std::io;\nuse std::io::Write;\n\nfn main() {\n\n    use minesweeper::{MineSweeper, GameStatus};\n\n    let mut width = 6;\n    let mut height = 4;\n    let mut mine_perctg = 10;\n    let mut game = MineSweeper::new(width, height, mine_perctg);\n\n    loop {\n        let mut command = String::new();\n\n        println!(\n            \"\\n\\\n             M I N E S W E E P E R\\n\\\n             \\n\\\n             Commands: \\n\\\n             line col            - reveal line,col \\n\\\n             m line col          - mark   line,col \\n\\\n             q                   - quit\\n\\\n             n                   - new game\\n\\\n             n width height perc - new game size and mine percentage\\n\"\n        );\n\n        game.print();\n        print!(\"> \");\n        io::stdout().flush().unwrap();\n        while let Ok(_) = io::stdin().read_line(&mut command) {\n            let mut command_ok = false;\n            {\n                let values: Vec<&str> = command.trim().split(' ').collect();\n                if values.len() == 1 {\n                    if values[0] == \"q\" {\n                        println!(\"Goodbye\");\n                        return;\n                    } else if values[0] == \"n\" {\n                        println!(\"New game\");\n                        game = MineSweeper::new(width, height, mine_perctg);\n                        command_ok = true;\n                    }\n                } else if values.len() == 2 {\n                    if let (Ok(x), Ok(y)) = (\n                        values[0].parse::<usize>(),\n                        values[1].parse::<usize>(),\n                    )\n                    {\n                        game.play(x - 1, y - 1);\n\n                        match game.game_status {\n                            GameStatus::Won => println!(\"You won!\"),\n                            GameStatus::Lost => println!(\"You lost!\"),\n                            _ => (),\n                        }\n                        command_ok = true;\n                    }\n                } else if values.len() == 3 {\n                    if values[0] == \"m\" {\n                        if let (Ok(x), Ok(y)) = (\n                            values[1].parse::<usize>(),\n                            values[2].parse::<usize>(),\n                        )\n                        {\n                            game.mark(x - 1, y - 1);\n                            command_ok = true;\n                        }\n                    }\n                } else if values.len() == 4 {\n                    if values[0] == \"n\" {\n                        if let (Ok(new_width), Ok(new_height), Ok(new_mines_perctg)) =\n                            (\n                                values[1].parse::<usize>(),\n                                values[2].parse::<usize>(),\n                                values[3].parse::<usize>(),\n                            )\n                        {\n                            width = new_width;\n                            height = new_height;\n                            mine_perctg = new_mines_perctg;\n                            game = MineSweeper::new(width, height, mine_perctg);\n                            command_ok = true;\n                        }\n                    }\n                }\n            }\n\n            if command_ok {\n                game.print();\n            } else {\n                println!(\"Invalid command\");\n            }\n\n            print!(\"> \");\n            io::stdout().flush().unwrap();\n            command.clear();\n        }\n    }\n}\n\npub mod minesweeper {\n\n    pub struct MineSweeper {\n        cell: [[Cell; 100]; 100],\n        pub game_status: GameStatus,\n        mines: usize,\n        width: usize,\n        height: usize,\n        revealed_count: usize,\n    }\n\n    #[derive(Copy, Clone)]\n    struct Cell {\n        content: CellContent,\n        mark: Mark,\n        revealed: bool,\n    }\n\n    #[derive(Copy, Clone)]\n    enum CellContent {\n        Empty,\n        Mine,\n        MineNeighbour { count: u8 },\n    }\n\n    #[derive(Copy, Clone)]\n    enum Mark {\n        None,\n        Mine,\n    }\n\n    pub enum GameStatus {\n        InGame,\n        Won,\n        Lost,\n    }\n\n    extern crate rand;\n\n    use std::cmp::max;\n    use std::cmp::min;\n    use self::rand::Rng;\n    use self::CellContent::*;\n    use self::GameStatus::*;\n\n    impl MineSweeper {\n        pub fn new(width: usize, height: usize, percentage_of_mines: usize) -> MineSweeper {\n            let mut game = MineSweeper {\n                cell: [[Cell {\n                    content: Empty,\n                    mark: Mark::None,\n                    revealed: false,\n                }; 100]; 100],\n                game_status: InGame,\n                mines: (width * height * percentage_of_mines) / 100,\n                width: width,\n                height: height,\n                revealed_count: 0,\n            };\n            game.put_mines();\n            game.calc_neighbours();\n            game\n        }\n\n        pub fn play(&mut self, x: usize, y: usize) {\n            match self.game_status {\n                InGame => {\n                    if !self.cell[x][y].revealed {\n                        match self.cell[x][y].content {\n                            Mine => {\n                                self.cell[x][y].revealed = true;\n                                self.revealed_count += 1;\n                                self.game_status = Lost;\n                            }\n                            Empty => {\n                                self.flood_fill_reveal(x, y);\n                                if self.revealed_count + self.mines == self.width * self.height {\n                                    self.game_status = Won;\n                                }\n                            }\n                            MineNeighbour { .. } => {\n                                self.cell[x][y].revealed = true;\n                                self.revealed_count += 1;\n                                if self.revealed_count + self.mines == self.width * self.height {\n                                    self.game_status = Won;\n                                }\n                            }\n                        }\n                    }\n                }\n                _ => println!(\"Game has ended\"),\n            }\n        }\n\n        pub fn mark(&mut self, x: usize, y: usize) {\n            self.cell[x][y].mark = match self.cell[x][y].mark {\n                Mark::None => Mark::Mine,\n                Mark::Mine => Mark::None,\n            }\n        }\n\n        pub fn print(&self) {\n            print!(\"┌\");\n            for _ in 0..self.width {\n                print!(\"─\");\n            }\n            println!(\"┐\");\n            for y in 0..self.height {\n                print!(\"│\");\n                for x in 0..self.width {\n                    self.cell[x][y].print();\n                }\n                println!(\"│\");\n            }\n            print!(\"└\");\n            for _ in 0..self.width {\n                print!(\"─\");\n            }\n            println!(\"┘\");\n        }\n\n        fn put_mines(&mut self) {\n            let mut rng = rand::thread_rng();\n            for _ in 0..self.mines {\n                while let (x, y, true) = (\n                    rng.gen::<usize>() % self.width,\n                    rng.gen::<usize>() % self.height,\n                    true,\n                )\n                {\n                    match self.cell[x][y].content {\n                        Mine => continue,\n                        _ => {\n                            self.cell[x][y].content = Mine;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        fn calc_neighbours(&mut self) {\n            for x in 0..self.width {\n                for y in 0..self.height {\n                    if !self.cell[x][y].is_bomb() {\n                        let mut adjacent_bombs = 0;\n\n                        for i in max(x as isize - 1, 0) as usize..min(x + 2, self.width) {\n                            for j in max(y as isize - 1, 0) as usize..min(y + 2, self.height) {\n                                adjacent_bombs += if self.cell[i][j].is_bomb() { 1 } else { 0 };\n                            }\n                        }\n\n                        if adjacent_bombs == 0 {\n                            self.cell[x][y].content = Empty;\n                        } else {\n                            self.cell[x][y].content = MineNeighbour { count: adjacent_bombs };\n                        }\n                    }\n                }\n            }\n        }\n\n        fn flood_fill_reveal(&mut self, x: usize, y: usize) {\n            let mut stack = Vec::<(usize, usize)>::new();\n            stack.push((x, y));\n\n            while let Some((i, j)) = stack.pop() {\n                if self.cell[i][j].revealed {\n                    continue;\n                }\n                self.cell[i][j].revealed = true;\n                self.revealed_count += 1;\n                if let Empty = self.cell[i][j].content {\n                    for m in max(i as isize - 1, 0) as usize..min(i + 2, self.width) {\n                        for n in max(j as isize - 1, 0) as usize..min(j + 2, self.height) {\n                            if !self.cell[m][n].is_bomb() && !self.cell[m][n].revealed {\n                                stack.push((m, n));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    impl Cell {\n        pub fn print(&self) {\n            print!(\n                \"{}\",\n                if self.revealed {\n                    match self.content {\n                        Empty => ' ',\n                        Mine => '*',\n                        MineNeighbour { count } => char::from(count + b'0'),\n                    }\n                } else {\n                    match self.mark {\n                        Mark::Mine => '?',\n                        Mark::None => '.',\n                    }\n                }\n            );\n        }\n\n        pub fn is_bomb(&self) -> bool {\n            match self.content {\n                Mine => true,\n                _ => false,\n            }\n        }\n    }\n}",
    "title": "Minesweeper game",
    "url": "http://rosettacode.org/wiki/Minesweeper_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minimal steps down to 1",
    "url": "http://rosettacode.org/wiki/Minimal_steps_down_to_1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minimum multiple of m where digital sum equals m",
    "url": "http://rosettacode.org/wiki/Minimum_multiple_of_m_where_digital_sum_equals_m"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minimum positive multiple in base 10 using only 0 and 1",
    "url": "http://rosettacode.org/wiki/Minimum_positive_multiple_in_base_10_using_only_0_and_1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minkowski question-mark function",
    "url": "http://rosettacode.org/wiki/Minkowski_question-mark_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Modified random distribution",
    "url": "http://rosettacode.org/wiki/Modified_random_distribution"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Modular arithmetic",
    "url": "http://rosettacode.org/wiki/Modular_arithmetic"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::ToBigUint;\nuse num::integer::Integer;\nuse num::{BigUint, One};\n\nfn mod_exp<T: Integer + Clone>(mut a: T, mut b: T, m: &T) -> T {\n    let one: T = One::one();\n    let two = one.clone() + one.clone();\n\n    let mut res = one;\n    while !b.is_zero() {\n        if b.is_odd() {\n            res = (res * a.clone()) % m.clone();\n        }\n        a = (a.clone() * a.clone()) % m.clone();\n        b = b.div_floor(&two);\n    }\n\n    res\n}\n\nfn main() {\n    use num::pow;\n\n    let a_str = \"2988348162058574136915891421498819466320163312926952423791023078876139\";\n    let b_str = \"2351399303373464486466122544523690094744975233415544072992656881240319\";\n    let a: BigUint = BigUint::parse_bytes(a_str.as_bytes(), 10).unwrap();\n    let b: BigUint = BigUint::parse_bytes(b_str.as_bytes(), 10).unwrap();\n    let m: BigUint = pow(10.to_biguint().unwrap(), 40);\n    println!(\"{}\", mod_exp(a, b, &m));\n}\n\n#[test]\nfn test_mod_exp() {\n    let tests = [\n        (0, 10, 10, 0),\n        (1, 10, 10, 1),\n        (2, 1000, 2, 0),\n        (2, 10, 2147483647, 1024),\n        (1337, 100, 2147483647, 1398068914),\n        (18, 112994442, 1000000001, 59108659),\n    ];\n\n    for &(a, b, m, expected) in &tests {\n        let a = a.to_biguint().unwrap();\n        let b = b.to_biguint().unwrap();\n        let m = m.to_biguint().unwrap();\n        let ans: BigUint = mod_exp(a, b, &m);\n\n        assert_eq!(ans, expected.to_biguint().unwrap());\n    }\n}\n",
    "path": "tasks/modular-exponentiation",
    "remote_code": "/* Add this line to the [dependencies] section of your Cargo.toml file:\nnum = \"0.2.0\"\n*/\n\n\nuse num::bigint::BigInt;\nuse num::bigint::ToBigInt;\n\n\n// The modular_exponentiation() function takes three identical types\n// (which get cast to BigInt), and returns a BigInt:\nfn modular_exponentiation<T: ToBigInt>(n: &T, e: &T, m: &T) -> BigInt {\n    // Convert n, e, and m to BigInt:\n    let n = n.to_bigint().unwrap();\n    let e = e.to_bigint().unwrap();\n    let m = m.to_bigint().unwrap();\n\n    // Sanity check:  Verify that the exponent is not negative:\n    assert!(e >= Zero::zero());\n\n    use num::traits::{Zero, One};\n\n    // As most modular exponentiations do, return 1 if the exponent is 0:\n    if e == Zero::zero() {\n        return One::one()\n    }\n\n    // Now do the modular exponentiation algorithm:\n    let mut result: BigInt = One::one();\n    let mut base = n % &m;\n    let mut exp = e;\n\n    // Loop until we can return out result:\n    loop {\n        if &exp % 2 == One::one() {\n            result *= &base;\n            result %= &m;\n        }\n\n        if exp == One::one() {\n            return result\n        }\n\n        exp /= 2;\n        base *= base.clone();\n        base %= &m;\n    }\n}",
    "title": "Modular exponentiation",
    "url": "http://rosettacode.org/wiki/Modular_exponentiation"
  },
  {
    "local_code": "fn main() {\n    println!(\"{:?}\", mul_inv(42, 2017));\n}\n\nfn mul_inv(a: i32, b: i32) -> Option<i32> {\n    let (gcd, mut x, _) = egcd(a, b);\n    if gcd != 1 {\n        // No multiplicative inverse exists\n        return None;\n    }\n    if x < 0 {\n        x += b;\n    }\n    Some(x % b)\n}\n\n#[allow(clippy::many_single_char_names)]\nfn egcd(a: i32, b: i32) -> (i32, i32, i32) {\n    if a == 0 {\n        return (b, 0, 1);\n    }\n\n    let (g, y, x) = egcd(b % a, a);\n    (g, x - (b / a) * y, y)\n}\n\n#[test]\nfn test() {\n    assert_eq!(mul_inv(42, 2017), Some(1969));\n}\n",
    "path": "tasks/modular-inverse",
    "remote_code": "fn mod_inv(a: isize, module: isize) -> isize {\n  let mut mn = (module, a);\n  let mut xy = (0, 1);\n  \n  while mn.1 != 0 {\n    xy = (xy.1, xy.0 - (mn.0 / mn.1) * xy.1);\n    mn = (mn.1, mn.0 % mn.1);\n  }\n  \n  while xy.0 < 0 {\n    xy.0 += module;\n  }\n  xy.0\n}\n\nfn main() {\n  println!(\"{}\", mod_inv(42, 2017))\n}",
    "title": "Modular inverse",
    "url": "http://rosettacode.org/wiki/Modular_inverse"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Monads/List monad",
    "url": "http://rosettacode.org/wiki/Monads/List_monad"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Monads/Maybe monad",
    "url": "http://rosettacode.org/wiki/Monads/Maybe_monad"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Monads/Writer monad",
    "url": "http://rosettacode.org/wiki/Monads/Writer_monad"
  },
  {
    "local_code": "use rand::prelude::*;\nuse std::f64::consts::PI;\n\n// `(f32, f32)` may be faster for some RNGs (including `rand::XorShiftRng`),\n// but less accurate.\nfn is_inside_circle((x, y): (f64, f64)) -> bool {\n    x * x + y * y <= 1.0\n}\n\nfn simulate<R: Rng>(rng: &mut R, samples: usize) -> f64 {\n    let count = (0..samples).filter(|_| is_inside_circle(rng.gen())).count();\n    // TODO use cargo bench\n    // to see if a branchless method might be faster\n    (count as f64) / (samples as f64)\n}\n\nfn main() {\n    let mut rng = StdRng::from_entropy();\n\n    println!(\"Real pi: {}\", PI);\n\n    for samples in (3..9).map(|e| 10_usize.pow(e)) {\n        let estimate = 4.0 * simulate(&mut rng, samples);\n        let deviation = 100.0 * (1.0 - estimate / PI).abs();\n        println!(\"{:9}: {:<11} dev: {:.5}%\", samples, estimate, deviation);\n    }\n}\n",
    "path": "tasks/monte-carlo-methods",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\nuse std::f64::consts::PI;\n\n// `(f32, f32)` would be faster for some RNGs (including `rand::thread_rng` on 32-bit platforms\n// and `rand::weak_rng` as of rand v0.4) as `next_u64` combines two `next_u32`s if not natively\n// supported by the RNG.  It would less accurate however.\nfn is_inside_circle((x, y): (f64, f64)) -> bool {\n    x * x + y * y <= 1.0\n}\n\nfn simulate<R: Rng>(rng: &mut R, samples: usize) -> f64 {\n    let mut count = 0;\n    for _ in 0..samples {\n        if is_inside_circle(rng.gen()) {\n            count += 1;\n        }\n    }\n    (count as f64) / (samples as f64)\n}\n\nfn main() {\n    let mut rng = rand::weak_rng();\n\n    println!(\"Real pi: {}\", PI);\n\n    for samples in (3..9).map(|e| 10_usize.pow(e)) {\n        let estimate = 4.0 * simulate(&mut rng, samples);\n        let deviation = 100.0 * (1.0 - estimate / PI).abs();\n        println!(\"{:9}: {:<11} dev: {:.5}%\", samples, estimate, deviation);\n    }\n}",
    "title": "Monte Carlo methods",
    "url": "http://rosettacode.org/wiki/Monte_Carlo_methods"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\nuse rand::Rng;\nuse rand::seq::SliceRandom;\n\n#[derive(Clone, Copy, PartialEq)]\nenum Prize {Goat , Car}\n\nconst GAMES: usize = 3_000_000;\nfn main() {\n    let mut switch_wins = 0;\n    let mut rng = rand::thread_rng();\n    \n    for _ in 0..GAMES {\n        let mut doors = [Prize::Goat; 3];\n        *doors.choose_mut(&mut rng).unwrap() = Prize::Car;\n\n        // You only lose by switching if you pick the car the first time\n        if doors.choose(&mut rng).unwrap() != &Prize::Car {\n            switch_wins += 1;\n        }\n    }\n    println!(\"I played the game {total} times and won {wins} times ({percent}%).\", \n             total   = GAMES, \n             wins    = switch_wins, \n             percent = switch_wins as f64 / GAMES as f64 * 100.0\n    );\n}",
    "title": "Monty Hall problem",
    "url": "http://rosettacode.org/wiki/Monty_Hall_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n//!\n//! morse_code/src/main.rs\n//!\n//! Michael G. Cummings\n//! 2019-08-26\n//!\n//! Since Rust doesn't have build-in audio support text output is used.\n//!\n\nuse std::process;\nuse structopt::StructOpt;\nuse morse_code::{Config, Opt, run};\n\n/// Core of the command-line binary.\n///\n/// By default expects input from stdin and outputs resulting morse code to stdout, but can also\n/// read and/or write to files.\n/// Use `morse_code --help` for more information about options.\nfn main() {\n    let opts = Opt::from_args();\n    let mut config = Config::new(opts).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {}\", err);\n        process::exit(1);\n    });\n    if let Err(err) = run(&mut config) {\n        eprintln!(\"Application error: {}\", err);\n        process::exit(2);\n    }\n}\n",
    "title": "Morse code",
    "url": "http://rosettacode.org/wiki/Morse_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// num-format = \"0.4\"\n\nfn motzkin(n: usize) -> Vec<usize> {\n    let mut m = vec![0; n];\n    m[0] = 1;\n    m[1] = 1;\n    for i in 2..n {\n        m[i] = (m[i - 1] * (2 * i + 1) + m[i - 2] * (3 * i - 3)) / (i + 2);\n    }\n    m\n}\n\nfn main() {\n    use num_format::{Locale, ToFormattedString};\n    let count = 42;\n    let m = motzkin(count);\n    println!(\" n          M(n)             Prime?\");\n    println!(\"-----------------------------------\");\n    for i in 0..count {\n        println!(\n            \"{:2}  {:>23}  {}\",\n            i,\n            m[i].to_formatted_string(&Locale::en),\n            primal::is_prime(m[i] as u64)\n        );\n    }\n}",
    "title": "Motzkin numbers",
    "url": "http://rosettacode.org/wiki/Motzkin_numbers"
  },
  {
    "local_code": "use std::thread;\nuse std::time::Duration;\n\n#[cfg(all(target_os = \"linux\", feature = \"x11\"))]\nfn get_mouse_position() -> (i64, i64) {\n    use std::ffi::CString;\n    use std::ptr;\n    use std::slice;\n\n    use x11::xlib::{self, AnyPropertyType, False, True};\n\n    let display = unsafe { xlib::XOpenDisplay(ptr::null()) };\n    if display.is_null() {\n        panic!(\"Could not open display!\");\n    }\n\n    let active_window = unsafe {\n        let mut type_ = 0;\n        let mut format = 0;\n        let mut n_items = 0;\n        let mut bytes_after = 0;\n        let mut prop = ptr::null_mut();\n\n        let property_name = CString::new(\"_NET_ACTIVE_WINDOW\").unwrap();\n        let property_name_atom = xlib::XInternAtom(display, property_name.as_ptr(), True);\n\n        xlib::XGetWindowProperty(\n            display,\n            xlib::XDefaultRootWindow(display),\n            property_name_atom,\n            0,\n            1,\n            False,\n            AnyPropertyType as u64,\n            &mut type_,\n            &mut format,\n            &mut n_items,\n            &mut bytes_after,\n            &mut prop,\n        );\n        let windows: &[xlib::Window] =\n            slice::from_raw_parts_mut(prop as *mut xlib::Window, n_items as usize);\n        windows[0]\n    };\n\n    let (x, y) = unsafe {\n        let mut root = 0;\n        let mut child = 0;\n        let mut root_x = 0;\n        let mut root_y = 0;\n        let mut win_x = 0;\n        let mut win_y = 0;\n        let mut mask = 0;\n\n        xlib::XQueryPointer(\n            display,\n            active_window,\n            &mut root,\n            &mut child,\n            &mut root_x,\n            &mut root_y,\n            &mut win_x,\n            &mut win_y,\n            &mut mask,\n        );\n\n        (win_x, win_y)\n    };\n\n    unsafe {\n        xlib::XCloseDisplay(display);\n    }\n\n    (x as i64, y as i64)\n}\n\n#[cfg(all(target_os = \"macos\"))]\nfn get_mouse_position() -> (usize, usize) {\n    panic!(\"unsupported platform!\");\n}\n\n#[cfg(all(target_os = \"linux\", not(feature = \"x11\")))]\nfn get_mouse_position() -> (usize, usize) {\n    panic!(\"requires xlib!\");\n}\n\n#[cfg(windows)]\nfn get_mouse_position() -> (i64, i64) {\n    use windows::Win32::{\n        Foundation::POINT,\n        Graphics::Gdi::ScreenToClient,\n        UI::WindowsAndMessaging::{GetCursorPos, GetForegroundWindow},\n    };\n\n    let h = unsafe { GetForegroundWindow() };\n\n    let (x, y) = unsafe {\n        let mut point = POINT::default();\n        GetCursorPos(&mut point);\n        ScreenToClient(h, &mut point);\n        (point.x, point.y)\n    };\n\n    (x as i64, y as i64)\n}\n\nfn main() {\n    loop {\n        let (x, y) = get_mouse_position();\n        thread::sleep(Duration::from_millis(100));\n        println!(\"x: {}, y: {}\", x, y);\n    }\n}\n",
    "path": "tasks/mouse-position",
    "remote_code": "// rustc 0.9 (7613b15 2014-01-08 18:04:43 -0800)\n\nuse std::libc::{BOOL, HANDLE, LONG};\nuse std::ptr::mut_null;\n\ntype HWND = HANDLE;\n\n#[deriving(Eq)]\nstruct POINT {\n    x: LONG,\n    y: LONG\n}\n\n#[link_name = \"user32\"]\nextern \"system\" {\n    fn GetCursorPos(lpPoint:&mut POINT) -> BOOL;\n    fn GetForegroundWindow() -> HWND;\n    fn ScreenToClient(hWnd:HWND, lpPoint:&mut POINT);\n}\n\nfn main() {\n    let mut pt = POINT{x:0, y:0};\n    loop {\n        std::io::timer::sleep(100); // sleep duration in milliseconds\n\n        let pt_prev = pt;\n        unsafe { GetCursorPos(&mut pt) };\n        if pt != pt_prev {\n            let h = unsafe { GetForegroundWindow() };\n            if h == mut_null() { continue }\n\n            let mut pt_client = pt;\n            unsafe { ScreenToClient(h, &mut pt_client) };\n            println!(\"x: {}, y: {}\", pt_client.x, pt_client.y);\n        }\n    }\n}",
    "title": "Mouse position",
    "url": "http://rosettacode.org/wiki/Mouse_position"
  },
  {
    "local_code": "fn main() {\n    let examples = vec![\"broood\", \"bananaaa\", \"hiphophiphop\"];\n    for example in examples {\n        let encoded = encode(example);\n        let decoded = decode(&encoded);\n        println!(\n            \"{} encodes to {:?} decodes to {}\",\n            example, encoded, decoded\n        );\n    }\n}\n\nfn get_symbols() -> Vec<u8> {\n    (b'a'..b'z').collect()\n}\n\nfn encode(input: &str) -> Vec<usize> {\n    input\n        .as_bytes()\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            let i = s.iter().position(|c| c == x).unwrap();\n            let c = s.remove(i);\n            s.insert(0, c);\n            o.push(i);\n            (o, s)\n        })\n        .0\n}\n\nfn decode(input: &[usize]) -> String {\n    input\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            o.push(s[*x]);\n            let c = s.remove(*x);\n            s.insert(0, c);\n            (o, s)\n        })\n        .0\n        .into_iter()\n        .map(|c| c as char)\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::*;\n\n    #[test]\n    fn correct_encode() {\n        let encoded = encode(\"broood\");\n        assert_eq!(encoded, vec![1, 17, 15, 0, 0, 5]);\n    }\n\n    #[test]\n    fn correct_decode() {\n        let decoded = decode(&[1, 17, 15, 0, 0, 5]);\n        assert_eq!(decoded, \"broood\");\n    }\n}\n",
    "path": "tasks/move-to-front",
    "remote_code": "fn main() {\n    let examples = vec![\"broood\", \"bananaaa\", \"hiphophiphop\"];\n    for example in examples {\n        let encoded = encode(example);\n        let decoded = decode(&encoded);\n        println!(\n            \"{} encodes to {:?} decodes to {}\",\n            example, encoded, decoded\n        );\n    }\n}\n\nfn get_symbols() -> Vec<u8> {\n    (b'a'..b'z').collect()\n}\n\nfn encode(input: &str) -> Vec<usize> {\n    input\n        .as_bytes()\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            let i = s.iter().position(|c| c == x).unwrap();\n            let c = s.remove(i);\n            s.insert(0, c);\n            o.push(i);\n            (o, s)\n        })\n        .0\n}\n\nfn decode(input: &[usize]) -> String {\n    input\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            o.push(s[*x]);\n            let c = s.remove(*x);\n            s.insert(0, c);\n            (o, s)\n        })\n        .0\n        .into_iter()\n        .map(|c| c as char)\n        .collect()\n}",
    "title": "Move-to-front algorithm",
    "url": "http://rosettacode.org/wiki/Move-to-front_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n\nfn digits(mut n: u32, dig: &mut [u32]) {\n    for i in 0..dig.len() {\n        dig[i] = n % 10;\n        n /= 10;\n    }\n}\n\nfn evalpoly(x: u64, p: &[u32]) -> u64 {\n    let mut result = 0;\n    for y in p.iter().rev() {\n        result *= x;\n        result += *y as u64;\n    }\n    result\n}\n\nfn max_prime_bases(ndig: u32, maxbase: u32) {\n    let mut maxlen = 0;\n    let mut maxprimebases = Vec::new();\n    let limit = 10u32.pow(ndig);\n    let mut dig = vec![0; ndig as usize];\n    for n in limit / 10..limit {\n        digits(n, &mut dig);\n        let bases: Vec<u32> = (2..=maxbase)\n            .filter(|&x| dig.iter().all(|&y| y < x) && primal::is_prime(evalpoly(x as u64, &dig)))\n            .collect();\n        if bases.len() > maxlen {\n            maxlen = bases.len();\n            maxprimebases.clear();\n        }\n        if bases.len() == maxlen {\n            maxprimebases.push((n, bases));\n        }\n    }\n    println!(\n        \"{} character numeric strings that are prime in maximum bases: {}\",\n        ndig, maxlen\n    );\n    for (n, bases) in maxprimebases {\n        println!(\"{} => {:?}\", n, bases);\n    }\n    println!();\n}\n\nfn main() {\n    for n in 1..=6 {\n        max_prime_bases(n, 36);\n    }\n}",
    "title": "Multi-base primes",
    "url": "http://rosettacode.org/wiki/Multi-base_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multi-dimensional array",
    "url": "http://rosettacode.org/wiki/Multi-dimensional_array"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn multifactorial(n: i32, deg: i32) -> i32 {\n\tif n < 1 {\n\t\t1\n\t} else {\n\t\tn * multifactorial(n - deg, deg)\n\t}\n}\n\nfn main() {\n\tfor i in 1..6 {\n\t\tfor j in 1..11 {\n\t\t\tprint!(\"{} \", multifactorial(j, i));\n\t\t}\n\tprintln!(\"\");\n\t}\n}",
    "title": "Multifactorial",
    "url": "http://rosettacode.org/wiki/Multifactorial"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    let size = 3;\n    \n    // Clone the given element to fill out the vector.\n    let mut v: Vec<String> = vec![String::new(); size];\n    v[0].push('a');\n    println!(\"{:?}\", v);\n    \n    // Run a given closure to create each element.\n    let mut v: Vec<String> = (0..size).map(|i| i.to_string()).collect();\n    v[0].push('a');\n    println!(\"{:?}\", v);\n    \n    // For multiple mutable views of the same thing, use something like Rc and RefCell.\n    let v: Vec<Rc<RefCell<String>>> = vec![Rc::new(RefCell::new(String::new())); size];\n    v[0].borrow_mut().push('a');\n    println!(\"{:?}\", v);\n}",
    "title": "Multiple distinct objects",
    "url": "http://rosettacode.org/wiki/Multiple_distinct_objects"
  },
  {
    "local_code": "use nalgebra::DMatrix;\n/// For a given a set of data vectors in the following format y = {y₁, y₂, ... yn}\n/// and X = {xi₁, xi₂, ... xin}, where i 𝜖 1..k\n///\n/// computes the vector β = {β₁, β₂, ...βk} using ordinary least squares regression\nfn get_coefficients(x: &DMatrix<f64>, y: &DMatrix<f64>) -> DMatrix<f64> {\n    (x.transpose() * x).try_inverse().unwrap() * x.transpose() * y\n}\n\n#[allow(clippy::cast_possible_truncation)]\n#[allow(clippy::cast_possible_wrap)]\nfn main() {\n    let x = vec![\n        1.47_f64, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80,\n        1.83,\n    ];\n\n    let y = vec![\n        52.21_f64, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 63.11, 64.47, 66.28, 68.10,\n        69.92, 72.19, 74.46,\n    ];\n\n    // generate 1, x, and x^2\n    let x = DMatrix::from_fn(x.len(), 3, |row, col| x[row].powi(col as i32));\n    let y = DMatrix::from_vec(y.len(), 1, y);\n    println!(\n        \"β parameters using least squares regression :{}\",\n        get_coefficients(&x, &y)\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assert_approx_eq::assert_approx_eq;\n\n    #[test]\n    fn test_get_coefficients() {\n        let x = DMatrix::from_vec(5, 1, vec![2_f64, 1., 3., 4., 5.]);\n        let y = DMatrix::from_vec(5, 1, vec![1_f64, 2., 3., 4., 5.]);\n        let result = get_coefficients(&x, &y);\n        assert_approx_eq!(result[(0)], 0.9818181818181818);\n\n        let x = DMatrix::from_vec(3, 2, vec![1_f64, 2., 1., 1., 1., 2.]);\n        let y = DMatrix::from_vec(3, 1, vec![3_f64, 4., 5.]);\n        let result = get_coefficients(&x, &y);\n        assert_approx_eq!(result[(0)], 1.);\n        assert_approx_eq!(result[(1)], 2.);\n    }\n}\n",
    "path": "tasks/multiple-regression",
    "remote_code": null,
    "title": "Multiple regression",
    "url": "http://rosettacode.org/wiki/Multiple_regression"
  },
  {
    "local_code": "const LIMIT: i32 = 12;\n\nfn main() {\n    for i in 1..=LIMIT {\n        print!(\"{:3} \", i);\n    }\n    println!();\n\n    for _ in 0..LIMIT {\n        print!(\"----\");\n    }\n    println!(\"+\");\n\n    for i in 1..=LIMIT {\n        for j in 1..=LIMIT {\n            if j < i {\n                print!(\"    \")\n            } else {\n                print!(\"{:3} \", j * i)\n            }\n        }\n        println!(\"| {}\", i);\n    }\n}\n",
    "path": "tasks/multiplication-tables",
    "remote_code": "const LIMIT: i32 = 12;\n\nfn main() {\n    for i in 1..LIMIT+1 {\n        print!(\"{:3}{}\", i, if LIMIT - i == 0 {'\\n'} else {' '})\n    }\n    for i in 0..LIMIT+1 {\n        print!(\"{}\", if LIMIT - i == 0 {\"+\\n\"} else {\"----\"});\n    }\n\n    for i in 1..LIMIT+1 {\n        for j in 1..LIMIT+1 {\n            if j < i {\n                print!(\"    \")\n            } else { \n                print!(\"{:3} \", j * i)\n            }\n        }\n        println!(\"| {}\", i);\n    }\n}",
    "title": "Multiplication tables",
    "url": "http://rosettacode.org/wiki/Multiplication_tables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multiplicative order",
    "url": "http://rosettacode.org/wiki/Multiplicative_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multisplit",
    "url": "http://rosettacode.org/wiki/Multisplit"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut solutions = Vec::new();\n\n    for num in 1..5_000 {\n        let power_sum = num.to_string()\n            .chars()\n            .map(|c| {\n                let digit = c.to_digit(10).unwrap();\n                (digit as f64).powi(digit as i32) as usize\n            })\n            .sum::<usize>();\n\n        if power_sum == num {\n            solutions.push(num);\n        }\n    }\n\n    println!(\"Munchausen numbers below 5_000 : {:?}\", solutions);\n}",
    "title": "Munchausen numbers",
    "url": "http://rosettacode.org/wiki/Munchausen_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{ImageBuffer, Pixel, Rgb};\n\nfn main() {\n    let mut img = ImageBuffer::new(256, 256);\n\n    for x in 0..256 {\n        for y in 0..256 {\n            let pixel = Rgb::from_channels(0, x as u8 ^ y as u8, 0, 0);\n            img.put_pixel(x, y, pixel);\n        }\n    }\n\n    let _ = img.save(\"output.png\");\n}",
    "title": "Munching squares",
    "url": "http://rosettacode.org/wiki/Munching_squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Musical scale",
    "url": "http://rosettacode.org/wiki/Musical_scale"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    sync::{Arc, Mutex},\n    thread,\n    time::Duration,\n};\n\nfn main() {\n    let shared = Arc::new(Mutex::new(String::new()));\n\n    let handle1 = {\n        let value = shared.clone();\n        thread::spawn(move || {\n            for _ in 0..20 {\n                thread::sleep(Duration::from_millis(200));\n                // The guard is valid until the end of the block\n                let mut guard = value.lock().unwrap();\n                guard.push_str(\"A\");\n                println!(\"{}\", guard);\n            }\n        })\n    };\n\n    let handle2 = {\n        let value = shared.clone();\n        thread::spawn(move || {\n            for _ in 0..20 {\n                thread::sleep(Duration::from_millis(300));\n\n                {\n                    // Making the guard scope explicit here\n                    let mut guard = value.lock().unwrap();\n                    guard.push_str(\"B\");\n                    println!(\"{}\", guard);\n                }\n            }\n        })\n    };\n\n    handle1.join().ok();\n    handle2.join().ok();\n    shared.lock().ok().map_or((), |it| println!(\"Done: {}\", it));\n}\n",
    "title": "Mutex",
    "url": "http://rosettacode.org/wiki/Mutex"
  },
  {
    "local_code": "fn f(n: usize) -> usize {\n    match n {\n        0 => 1,\n        _ => n - m(f(n - 1)),\n    }\n}\n\nfn m(n: usize) -> usize {\n    match n {\n        0 => 0,\n        _ => n - f(m(n - 1)),\n    }\n}\n\nfn main() {\n    for i in (0..20).map(f) {\n        print!(\"{} \", i);\n    }\n    println!();\n\n    for i in (0..20).map(m) {\n        print!(\"{} \", i);\n    }\n    println!();\n}\n\n#[test]\nfn test_mutual_recursion() {\n    let f_expected = [\n        1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12,\n    ];\n    let m_expected = [\n        0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12,\n    ];\n    let f_m_zipped = f_expected.iter().zip(m_expected.iter());\n    for (i, (f_expect, m_expect)) in f_m_zipped.enumerate() {\n        assert!(f(i) == *f_expect);\n        assert!(m(i) == *m_expect);\n    }\n}\n",
    "path": "tasks/mutual-recursion",
    "remote_code": "fn f(n: u32) -> u32 {\n    match n {\n        0 => 1,\n        _ => n - m(f(n - 1))\n    }\n}\n\nfn m(n: u32) -> u32 {\n    match n {\n        0 => 0,\n        _ => n - f(m(n - 1))\n    }\n}\n\nfn main() {\n    for i in (0..20).map(f) {\n        print!(\"{} \", i);\n    }\n    println!(\"\");\n\n    for i in (0..20).map(m) {\n        print!(\"{} \", i);\n    }\n    println!(\"\")\n}",
    "title": "Mutual recursion",
    "url": "http://rosettacode.org/wiki/Mutual_recursion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Möbius function",
    "url": "http://rosettacode.org/wiki/M%C3%B6bius_function"
  },
  {
    "local_code": "fn nth(num: i32) -> String {\n    format!(\n        \"{}{}\",\n        num,\n        match num % 10 {\n            1 if num % 100 != 11 => \"st\",\n            2 if num % 100 != 12 => \"nd\",\n            3 if num % 100 != 13 => \"rd\",\n            _ => \"th\",\n        }\n    )\n}\n\nfn main() {\n    let ranges = vec![(0, 26), (250, 266), (1000, 1026)];\n    for &(s, e) in &ranges {\n        println!(\"[{}, {}) :\", s, e);\n        for i in s..e {\n            print!(\"{}, \", nth(i));\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/nth",
    "remote_code": "fn nth(num: isize) -> String {\n    format!(\"{}{}\", num, match (num % 10, num % 100) {\n        (1, 11) | (2, 12) | (3, 13) => \"th\",\n        (1, _) => \"st\",\n        (2, _) => \"nd\",\n        (3, _) => \"rd\",\n        _ => \"th\",\n    })\n}\n\nfn main() {\n    let ranges = [(0, 26), (250, 266), (1000, 1026)];\n    for &(s, e) in &ranges {\n        println!(\"[{}, {}) :\", s, e);\n        for i in s..e {\n            print!(\"{}, \", nth(i));\n        }\n        println!();\n    }\n}",
    "title": "N'th",
    "url": "http://rosettacode.org/wiki/N'th"
  },
  {
    "local_code": "use criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nuse n_queens_problem::{n_queens, semi_parallel_n_queens};\n\nfn benchmark(c: &mut Criterion) {\n    c.bench_function(\"n_queens\", |b| b.iter(|| n_queens(black_box(16))));\n    c.bench_function(\"semi_parallel\", |b| {\n        b.iter(|| semi_parallel_n_queens(black_box(16)))\n    });\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = benchmark);\ncriterion_main!(benches);\nuse std::sync::mpsc::channel;\nuse std::thread::spawn;\nuse std::vec::Vec;\n\n/// Solves n-queens using a depth-first, backtracking solution. Returns the number of solutions for\n/// a given n.\npub fn n_queens(n: i32) -> usize {\n    // Pass off to our helper function.\n    n_queens_helper((1 << n as usize) - 1, 0, 0, 0)\n}\n\n/// The meat of the algorithm is in here, a recursive helper function that actually computes the\n/// answer using a depth-first, backtracking algorithm.\n///\n/// The 30,000 foot overview is as follows:\n///\n/// This function takes only 3 important parameters: three integers which represent the spots on\n/// the current row that are blocked by previous queens.\n///\n/// The \"secret sauce\" here is that we can avoid passing around the board or even the locations of\n/// the previous queens and instead we use this information to infer the conflicts for the next\n/// row.\n///\n/// Once we know the conflicts in our current row we can simply recurse over all of the open spots\n/// and profit.\n///\n/// This implementation is optimized for speed and memory by using integers and bit shifting\n/// instead of arrays for storing the conflicts.\nfn n_queens_helper(all_ones: i32, left_diags: i32, columns: i32, right_diags: i32) -> usize {\n    // all_ones is a special value that simply has all 1s in the first n positions\n    // and 0s elsewhere. We can use it to clear out areas that we don't care about.\n\n    // Our solution count.\n    // This will be updated by the recursive calls to our helper.\n    let mut solutions = 0;\n\n    // We get validSpots with some bit trickery. Effectively, each of the parameters\n    // can be ORed together to create an integer with all the conflicts together,\n    // which we then invert and limit by ANDing with all_ones, our special value\n    // from earlier.\n    let mut valid_spots = !(left_diags | columns | right_diags) & all_ones;\n\n    // Since valid_spots contains 1s in all of the locations that\n    // are conflict-free, we know we have gone through all of\n    // those locations when valid_spots is all 0s, i.e. when it is 0.\n    while valid_spots != 0 {\n        // This is just bit trickery. For reasons involving the weird\n        // behavior of two's complement integers, this creates an integer\n        // which is all 0s except for a single 1 in the position of the\n        // LSB of valid_spots.\n        let spot = -valid_spots & valid_spots;\n\n        // We then XOR that integer with the validSpots to flip it to 0\n        // in valid_spots.\n        valid_spots ^= spot;\n\n        // Make a recursive call. This is where we infer the conflicts\n        // for the next row.\n        solutions += n_queens_helper(\n            all_ones,\n            // We add a conflict in the current spot and then shift left,\n            // which has the desired effect of moving all of the conflicts\n            // that are created by left diagonals to the left one square.\n            (left_diags | spot) << 1,\n            // For columns we simply mark this column as filled by ORing\n            // in the currentSpot.\n            columns | spot,\n            // This is the same as the left_diag shift, except we shift\n            // right because these conflicts are caused by right diagonals.\n            (right_diags | spot) >> 1,\n        );\n    }\n\n    // If columns is all blocked (i.e. if it is all ones) then we\n    // have arrived at a solution because we have placed n queens.\n    solutions + ((columns == all_ones) as usize)\n}\n\n/// This is the same as the regular nQueens except it creates n threads in which to to do the work.\n///\n/// This is much slower for smaller numbers (under 16~17) but outperforms the sequential algorithm\n/// after that.\npub fn semi_parallel_n_queens(n: i32) -> usize {\n    let all_ones = (1 << n as usize) - 1;\n    let (columns, left_diags, right_diags) = (0, 0, 0);\n\n    let mut receivers = Vec::new();\n    let mut valid_spots = !(left_diags | columns | right_diags) & all_ones;\n    while valid_spots != 0 {\n        let (tx, rx) = channel();\n        let spot = -valid_spots & valid_spots;\n        valid_spots ^= spot;\n        receivers.push(rx);\n\n        spawn(move || {\n            tx.send(n_queens_helper(\n                all_ones,\n                (left_diags | spot) << 1,\n                columns | spot,\n                (right_diags | spot) >> 1,\n            ))\n            .unwrap();\n        });\n    }\n\n    receivers.iter().map(|r| r.recv().unwrap()).sum::<usize>() + ((columns == all_ones) as usize)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{n_queens, semi_parallel_n_queens};\n\n    #[test]\n    fn test_n_queens() {\n        let real = vec![1, 1, 0, 0, 2, 10, 4, 40, 92];\n        for num in 0..9i32 {\n            assert_eq!(n_queens(num), real[num as usize]);\n        }\n    }\n\n    #[ignore]\n    #[test]\n    fn test_parallel_n_queens() {\n        let real = vec![1, 1, 0, 0, 2, 10, 4, 40, 92];\n        for num in 0..9i32 {\n            assert_eq!(semi_parallel_n_queens(num), real[num as usize]);\n        }\n    }\n}\nuse n_queens_problem::{n_queens, semi_parallel_n_queens};\n\nfn main() {\n    for num in 0i32..16 {\n        println!(\"Sequential: {}: {}\", num, n_queens(num));\n    }\n    for num in 0i32..16 {\n        println!(\"Parallel: {}: {}\", num, semi_parallel_n_queens(num));\n    }\n}\n",
    "path": "tasks/n-queens-problem",
    "remote_code": "const N: usize = 8;\n\nfn try(mut board: &mut [[bool; N]; N], row: usize, mut count: &mut i64) {\n   if row == N {\n       *count += 1;\n       for r in board.iter() {\n           println!(\"{}\", r.iter().map(|&x| if x {\"x\"} else {\".\"}.to_string()).collect::<Vec<String>>().join(\" \"))\n       }\n       println!(\"\");\n       return\n   }\n   for i in 0..N {\n       let mut ok: bool = true;\n       for j in 0..row {\n           if board[j][i]\n               || i+j >= row && board[j][i+j-row]\n               || i+row < N+j && board[j][i+row-j]\n           { ok = false }\n       }\n       if ok {\n           board[row][i] = true;\n           try(&mut board, row+1, &mut count);\n           board[row][i] = false;\n       }\n   }\n}\n\nfn main() {\n   let mut board: [[bool; N]; N] = [[false; N]; N];\n   let mut count: i64 = 0;\n   try (&mut board, 0, &mut count);\n   println!(\"Found {} solutions\", count)\n}",
    "title": "N-queens problem",
    "url": "http://rosettacode.org/wiki/N-queens_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn find_primes(from: u32, to: u32) -> Vec<u32> {\n    let mut primes: Vec<u32> = Vec::new();\n    for p in from..=to {\n        if is_prime(p) {\n            primes.push(p);\n        }\n    }\n    primes\n}\n\nfn find_nsmooth_numbers(n: u32, count: usize) -> Vec<u128> {\n    let primes = find_primes(2, n);\n    let num_primes = primes.len();\n    let mut result = Vec::with_capacity(count);\n    let mut queue = Vec::with_capacity(num_primes);\n    let mut index = Vec::with_capacity(num_primes);\n    for i in 0..num_primes {\n        index.push(0);\n        queue.push(primes[i] as u128);\n    }\n    result.push(1);\n    for i in 1..count {\n        for p in 0..num_primes {\n            if queue[p] == result[i - 1] {\n                index[p] += 1;\n                queue[p] = result[index[p]] * primes[p] as u128;\n            }\n        }\n        let mut min_index: usize = 0;\n        for p in 1..num_primes {\n            if queue[min_index] > queue[p] {\n                min_index = p;\n            }\n        }\n        result.push(queue[min_index]);\n    }\n    result\n}\n\nfn print_nsmooth_numbers(n: u32, begin: usize, count: usize) {\n    let numbers = find_nsmooth_numbers(n, begin + count);\n    print!(\"{}: {}\", n, &numbers[begin]);\n    for i in 1..count {\n        print!(\", {}\", &numbers[begin + i]);\n    }\n    println!();\n}\n\nfn main() {\n    println!(\"First 25 n-smooth numbers for n = 2 -> 29:\");\n    for n in 2..=29 {\n        if is_prime(n) {\n            print_nsmooth_numbers(n, 0, 25);\n        }\n    }\n    println!();\n    println!(\"3 n-smooth numbers starting from 3000th for n = 3 -> 29:\");\n    for n in 3..=29 {\n        if is_prime(n) {\n            print_nsmooth_numbers(n, 2999, 3);\n        }\n    }\n    println!();\n    println!(\"20 n-smooth numbers starting from 30,000th for n = 503 -> 521:\");\n    for n in 503..=521 {\n        if is_prime(n) {\n            print_nsmooth_numbers(n, 29999, 20);\n        }\n    }\n}",
    "title": "N-smooth numbers",
    "url": "http://rosettacode.org/wiki/N-smooth_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Named parameters",
    "url": "http://rosettacode.org/wiki/Named_parameters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Naming conventions",
    "url": "http://rosettacode.org/wiki/Naming_conventions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io::{stdin, prelude::*};\nfn main() {\n    let src = include_str!(\"main.rs\");\n    let mut input = String::new();\n    stdin()\n        .lock()\n        .read_to_string(&mut input)\n        .expect(\"Could not read from STDIN\");\n    println!(\"{}\", src == input);\n}",
    "title": "Narcissist",
    "url": "http://rosettacode.org/wiki/Narcissist"
  },
  {
    "local_code": "fn is_narcissistic(x: u32) -> bool {\n    let digits: Vec<u32> = x\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap())\n        .collect();\n\n    digits\n        .iter()\n        .map(|d| d.pow(digits.len() as u32))\n        .sum::<u32>()\n        == x\n}\n\nfn main() {\n    let mut counter = 0;\n    let mut i = 0;\n    while counter < 25 {\n        if is_narcissistic(i) {\n            println!(\"{}\", i);\n            counter += 1;\n        }\n        i += 1;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_narcissistic;\n    #[test]\n    fn test_is_narc() {\n        let input = 0;\n        let output = is_narcissistic(input);\n        assert_eq!(output, true);\n\n        let input = 1;\n        let output = is_narcissistic(input);\n        assert_eq!(output, true);\n\n        let input = 153;\n        let output = is_narcissistic(input);\n        assert_eq!(output, true);\n    }\n    #[test]\n    fn test_not_is_narc() {\n        let input = 10;\n        let output = is_narcissistic(input);\n        assert_eq!(output, false);\n\n        let input = 999999999;\n        let output = is_narcissistic(input);\n        assert_eq!(output, false);\n    }\n}\n",
    "path": "tasks/narcissistic-decimal-number",
    "remote_code": "\nfn is_narcissistic(x: u32) -> bool {\n    let digits: Vec<u32> = x\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap())\n        .collect();\n\n    digits\n        .iter()\n        .map(|d| d.pow(digits.len() as u32))\n        .sum::<u32>()\n        == x\n}\n\nfn main() {\n    let mut counter = 0;\n    let mut i = 0;\n    while counter < 25 {\n        if is_narcissistic(i) {\n            println!(\"{}\", i);\n            counter += 1;\n        }\n        i += 1;\n    }\n}\n",
    "title": "Narcissistic decimal number",
    "url": "http://rosettacode.org/wiki/Narcissistic_decimal_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Natural sorting",
    "url": "http://rosettacode.org/wiki/Natural_sorting"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nautical bell",
    "url": "http://rosettacode.org/wiki/Nautical_bell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const DIGITS: [char;62] = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];\n \n\nfn main() {\n  let nums_and_bases: [(i64,i64);5] = [(10,-2),(146,-3),(15,-10),(-6222885,-62),(1488588316238,-62)];\n\n  for (n,b) in nums_and_bases.iter() {\n    let ns = encode_neg_base(*n, *b);\n    println!(\"{} encoded in base {} = {}\", *n, *b, &ns);\n    let nn = decode_neg_base(&ns, *b);\n    println!(\"{} decoded in base {} = {}\\n\", &ns, *b, nn);\n  }\n}\n\nfn decode_neg_base(ns: &str, b: i64) -> i64 {\n    if b < -62 || b > -1 {\n        panic!(\"base must be between -62 and -1 inclusive\")\n    }\n    if ns == \"0\" {\n        return 0\n    }\n    let mut total: i64 = 0;\n    let mut bb: i64 = 1;\n    for c in ns.chars().rev() {\n        total += (DIGITS.iter().position(|&d| d==c).unwrap() as i64) * bb;\n        bb *= b;\n    }\n    return total;\n}\n\nfn encode_neg_base(mut n: i64, b: i64) -> String {\n  if b < -62 || b > -1 {\n    panic!(\"base must be between -62 and -1 inclusive\");\n  }\n  if n == 0 {\n      return \"0\".to_string();\n  }\n  let mut out = String::new();\n  while n != 0 {\n    let mut rem = n % b;\n      n /= b;\n      if rem < 0 {\n          n+=1;\n          rem -= b;\n      }\n      out.push(DIGITS[rem as usize]);\n  }\n  return out.chars().rev().collect();\n}",
    "title": "Negative base numbers",
    "url": "http://rosettacode.org/wiki/Negative_base_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn make_list(sep: &str) -> String {\n    let mut counter = 0;\n    let mut make_item = |label| {\n        counter += 1;\n        format!(\"{}{}{}\", counter, sep, label)\n    };\n    format!(\n        \"{}\\n{}\\n{}\",\n        make_item(\"First\"),\n        make_item(\"Second\"),\n        make_item(\"Third\")\n    )\n}\n\nfn main() {\n    println!(\"{}\", make_list(\". \"))\n}",
    "title": "Nested function",
    "url": "http://rosettacode.org/wiki/Nested_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nested templated data",
    "url": "http://rosettacode.org/wiki/Nested_templated_data"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn next_permutation<T: PartialOrd>(array: &mut [T]) -> bool {\n    let len = array.len();\n    if len < 2 {\n        return false;\n    }\n    let mut i = len - 1;\n    while i > 0 {\n        let j = i;\n        i -= 1;\n        if array[i] < array[j] {\n            let mut k = len - 1;\n            while array[i] >= array[k] {\n                k -= 1;\n            }\n            array.swap(i, k);\n            array[j..len].reverse();\n            return true;\n        }\n    }\n    false\n}\n\nfn next_highest_int(n: u128) -> u128 {\n    use std::iter::FromIterator;\n    let mut chars: Vec<char> = n.to_string().chars().collect();\n    if !next_permutation(&mut chars) {\n        return 0;\n    }    \n    String::from_iter(chars).parse::<u128>().unwrap()\n}\n\nfn main() {\n    for n in &[0, 9, 12, 21, 12453, 738440, 45072010, 95322020, 9589776899767587796600] {\n        println!(\"{} -> {}\", n, next_highest_int(*n));\n    }\n}",
    "title": "Next highest int from digits",
    "url": "http://rosettacode.org/wiki/Next_highest_int_from_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\n    let mut tokens = 12;\n    println!(\"Nim game\");\n    println!(\"Starting with {} tokens.\", tokens);\n    println!(\"\");\n    \n    loop {\n        tokens = p_turn(&tokens);\n        print_remaining(&tokens);\n        tokens = c_turn(&tokens);\n        print_remaining(&tokens);\n        \n        if tokens == 0 {\n            println!(\"Computer wins!\");\n            break;\n        }\n    }\n}\n\nfn p_turn(tokens: &i32) -> i32 {\n    loop {  //try until we get a good number\n        println!(\"How many tokens would you like to take?\");\n        \n        let mut take = String::new();\n        io::stdin().read_line(&mut take)\n            .expect(\"Sorry, I didn't understand that.\");\n        \n        let take: i32 = match take.trim().parse() {\n            Ok(num) => num,\n            Err(_) => {\n                println!(\"Invalid input\");\n                println!(\"\");\n                continue;\n            }\n        };\n        \n        if take > 3 || take < 1 {\n            println!(\"Take must be between 1 and 3.\");\n            println!(\"\");\n            continue;\n        }\n        \n        return tokens - take;\n    }\n}\n\nfn c_turn(tokens: &i32) -> i32 {\n    let take = tokens % 4;\n    \n    println!(\"Computer takes {} tokens.\", take);\n    \n    return tokens - take;\n}\n\nfn print_remaining(tokens: &i32) {\n    println!(\"{} tokens remaining.\", tokens);\n    println!(\"\");\n}\n",
    "title": "Nim game",
    "url": "http://rosettacode.org/wiki/Nim_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-continuous subsequences",
    "url": "http://rosettacode.org/wiki/Non-continuous_subsequences"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn format_with_radix(mut n: u32, radix: u32) -> String {\n    assert!(2 <= radix && radix <= 36);\n\n    let mut result = String::new();\n\n    loop {\n        result.push(std::char::from_digit(n % radix, radix).unwrap());\n        n /= radix;\n        if n == 0 {\n            break;\n        }\n    }\n\n    result.chars().rev().collect()\n}\n\n#[cfg(test)]\n#[test]\nfn test() {\n    for value in 0..100u32 {\n        for radix in 2..=36 {\n            let s = format_with_radix(value, radix);\n            let v = u32::from_str_radix(s.as_str(), radix).unwrap();\n            assert_eq!(value, v);\n        }\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    println!(\"{}\", format_with_radix(0xdeadbeef, 2));\n    println!(\"{}\", format_with_radix(0xdeadbeef, 36));\n    println!(\"{}\", format_with_radix(0xdeadbeef, 16));\n    println!(\"{}\", u32::from_str_radix(\"DeadBeef\", 16)?);\n    Ok(())\n}",
    "title": "Non-decimal radices/Convert",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Convert"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\n        \"Parse from plain decimal: {}\",\n        \"123\".parse::<u32>().unwrap()\n    );\n\n    println!(\n        \"Parse with a given radix (2-36 supported): {}\",\n        u32::from_str_radix(\"deadbeef\", 16).unwrap()\n    );\n}",
    "title": "Non-decimal radices/Input",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Input"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    // To render the number as string, use format! macro instead\n    println!(\"Binary: {:b}\", 0xdeadbeefu32);\n    println!(\"Binary with 0b prefix: {:#b}\", 0xdeadbeefu32);\n    println!(\"Octal: {:o}\", 0xdeadbeefu32);\n    println!(\"Octal with 0o prefix: {:#o}\", 0xdeadbeefu32);\n    println!(\"Decimal: {}\", 0xdeadbeefu32);\n    println!(\"Lowercase hexadecimal: {:x}\", 0xdeadbeefu32);\n    println!(\"Lowercase hexadecimal with 0x prefix: {:#x}\", 0xdeadbeefu32);\n    println!(\"Uppercase hexadecimal: {:X}\", 0xdeadbeefu32);\n    println!(\"Uppercase hexadecimal with 0x prefix: {:#X}\", 0xdeadbeefu32);\n}",
    "title": "Non-decimal radices/Output",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-transitive dice",
    "url": "http://rosettacode.org/wiki/Non-transitive_dice"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct Nonoblock {\n  width: usize,\n  config: Vec<usize>,\n  spaces: Vec<usize>,\n}\n\nimpl Nonoblock {\n  pub fn new(width: usize, config: Vec<usize>) -> Nonoblock {\n    Nonoblock {\n      width: width,\n      config: config,\n      spaces: Vec::new(),\n    }\n  }\n\n  pub fn solve(&mut self) -> Vec<Vec<i32>> {\n    let mut output: Vec<Vec<i32>> = Vec::new();\n    self.spaces = (0..self.config.len()).fold(Vec::new(), |mut s, i| {\n      s.push(match i {\n        0 => 0,\n        _ => 1,\n      });\n      s\n    });\n    if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() <= self.width {\n      'finished: loop {\n        match self.spaces.iter().enumerate().fold((0, vec![0; self.width]), |mut a, (i, s)| {\n            (0..self.config[i]).for_each(|j| a.1[a.0 + j + *s] = 1 + i as i32);\n            return (a.0 + self.config[i] + *s, a.1);\n          }) {\n          (_, out) => output.push(out),\n        }\n        let mut i: usize = 1;\n        'calc: loop {\n          let len = self.spaces.len();\n          if i > len {\n            break 'finished;\n          } else {\n            self.spaces[len - i] += 1\n          }\n          if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() > self.width {\n            self.spaces[len - i] = 1;\n            i += 1;\n          } else {\n            break 'calc;\n          }\n        }\n      }\n    }\n    output\n  }\n}\n\nfn main() {\n  let mut blocks = [\n    Nonoblock::new(5, vec![2, 1]),\n    Nonoblock::new(5, vec![]),\n    Nonoblock::new(10, vec![8]),\n    Nonoblock::new(15, vec![2, 3, 2, 3]),\n    Nonoblock::new(5, vec![2, 3]),\n  ];\n\n  for block in blocks.iter_mut() {\n    println!(\"{} cells and {:?} blocks\", block.width, block.config);\n    println!(\"{}\",(0..block.width).fold(String::from(\"=\"), |a, _| a + \"==\"));\n    let solutions = block.solve();\n    if solutions.len() > 0 {\n      for solution in solutions.iter() {\n        println!(\"{}\", solution.iter().fold(String::from(\"|\"), |s, f| s + &match f {\n          i if *i > 0 => (('A' as u8 + ((*i - 1) as u8) % 26) as char).to_string(),\n          _ => String::from(\"_\"),\n        }+ \"|\"));\n      }\n    } else {\n      println!(\"No solutions. \");\n    }\n    println!();\n  }\n}",
    "title": "Nonoblock",
    "url": "http://rosettacode.org/wiki/Nonoblock"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nonogram solver",
    "url": "http://rosettacode.org/wiki/Nonogram_solver"
  },
  {
    "local_code": "const EPSILON: f64 = 1e-10;\n\nfn nth_root(x: f64, n: f64) -> f64 {\n    let mut x0: f64 = x;\n    loop {\n        let delta = (x / x0.powf(n - 1.0) - x0) / n;\n        x0 += delta;\n        if delta.abs() < EPSILON {\n            return x0;\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", nth_root(8.0, 3.0));\n    println!(\"{}\", nth_root(4.0, 2.0));\n    println!(\"{}\", nth_root(169.0, 2.0));\n    println!(\"{}\", nth_root(81.0, 4.0));\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use self::rand::distributions::Uniform;\n    use self::rand::Rng;\n    use super::{nth_root, EPSILON};\n\n    #[test]\n    fn check_nth_root() {\n        let mut rng = rand::thread_rng();\n        let range = Uniform::new(1.0, 1e5);\n        for _ in 1..1000 {\n            let x = rng.sample(range);\n            let n = rng.sample(range);\n            assert!((nth_root(x, n) - x.powf(n.recip())).abs() < EPSILON)\n        }\n    }\n}\n",
    "path": "tasks/nth-root",
    "remote_code": "// 20210212 Rust programming solution\n\nfn nthRoot(n: f64, A: f64) -> f64 {\n\n   let      p  =  1e-9_f64 ;\n   let mut x0  =     A / n ;\n\n   loop {\n      let mut x1 = ( (n-1.0) * x0 + A / f64::powf(x0, n-1.0) ) / n;\n      if (x1-x0).abs() < (x0*p).abs() { return x1 };\n      x0 = x1\n   }\n}\n\nfn main() {\n   println!(\"{}\", nthRoot(3. , 8. ));\n}",
    "title": "Nth root",
    "url": "http://rosettacode.org/wiki/Nth_root"
  },
  {
    "local_code": "// If an option may return null - or nothing - in Rust, it's wrapped\n// in an Optional which may return either the type of object specified\n// in <> or None. We can check this using .is_some() and .is_none() on\n// the Option.\n\nfn check_number(num: &Option<u8>) {\n    if num.is_none() {\n        println!(\"Number is: None\");\n    } else {\n        println!(\"Number is: {}\", num.unwrap());\n    }\n}\n\nfn main() {\n    let mut possible_number: Option<u8> = None;\n    check_number(&possible_number);\n\n    possible_number = Some(31);\n    check_number(&possible_number);\n}\n",
    "path": "tasks/null-object",
    "remote_code": "// If an option may return null - or nothing - in Rust, it's wrapped\n// in an Optional which may return either the type of object specified\n// in <> or None. We can check this using .is_some() and .is_none() on\n// the Option.\n\nfn check_number(num: &Option<u8>) {\n    if num.is_none() {\n        println!(\"Number is: None\");\n    } else {\n        println!(\"Number is: {}\", num.unwrap());\n    }\n}\n\nfn main() {\n    let mut possible_number: Option<u8> = None;\n    check_number(&possible_number);\n\n    possible_number = Some(31);\n    check_number(&possible_number);\n}",
    "title": "Null object",
    "url": "http://rosettacode.org/wiki/Null_object"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io::{self, Write, stdout};\n\nconst SMALL: &[&str] = &[\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\",\n    \"nineteen\",\n];\n\nconst TENS: &[&str] = &[\n    \"PANIC\", \"PANIC\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\",\n];\n\nconst MAGNITUDE: &[&str] = &[\n    \"PANIC\", \"thousand\", \"million\", \"billion\", \"trillion\", \"quadrillion\", \"quintillion\",\n];\n\nfn wordify<W: Write>(w: &mut W, mut number: i64) -> Result<(), io::Error> {\n    if number == 0 {\n        return write!(w, \"zero\");\n    }\n    if number < 0 {\n        write!(w, \"negative \")?;\n        number = -number;\n    }\n    while number != 0 {\n        if number < 20 {\n            write!(w, \"{}\", SMALL[number as usize])?;\n            break;\n        } else if number < 100 {\n            write!(w, \"{}\", TENS[number as usize / 10])?;\n            number %= 10;\n            if number != 0 {\n                write!(w, \"-\")?;\n            }\n        } else if number < 1_000 {\n            write!(w, \"{} hundred\", SMALL[number as usize / 100])?;\n            number %= 100;\n            if number != 0 {\n                write!(w, \" and \")?;\n            }\n        } else {\n            let mut top = number;\n            let mut magnitude = 0i64;\n            let mut magnitude_pow = 1i64;\n            while top >= 1_000 {\n                top /= 1_000;\n                magnitude += 1;\n                magnitude_pow *= 1_000;\n            }\n            wordify(w, top)?;\n            number %= magnitude_pow;\n            if number == 0 {\n                write!(w, \" {}\", MAGNITUDE[magnitude as usize])?;\n            } else if number > 100 {\n                write!(w, \" {}, \", MAGNITUDE[magnitude as usize])?;\n            } else {\n                write!(w, \" {} and \", MAGNITUDE[magnitude as usize])?;\n            }\n        }\n    }\n    Ok(())\n}\n\nfn main() {\n    let stdout = stdout();\n    let mut stdout = stdout.lock();\n    for &n in &[12, 1048576, 9_000_000_000_000_000_000, -2, 0, 5_000_000_000_000_000_001, -555_555_555_555] {\n        wordify(&mut stdout, n).unwrap();\n        write!(&mut stdout, \"\\n\").unwrap();\n    }\n}",
    "title": "Number names",
    "url": "http://rosettacode.org/wiki/Number_names"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::prelude::*;\nuse std::io::stdin;\n\nfn is_sorted(seq: &[impl PartialOrd]) -> bool {\n    if seq.len() < 2 {\n        return true;\n    }\n    // Look for any instance where the previous number is larger than the following\n    !seq.iter()\n        .zip(seq[1..].iter())\n        .any(|(prev, foll)| prev > foll)\n}\n\nfn main() {\n    println!(\n        \"Number reversal game:\n    Given a jumbled list of the numbers 1 to 9, put the numbers in order.\n    Each attempt you can reverse up to n digits starting from the left.\n    The score is the count of the reversals needed to attain the ascending order.\"\n    );\n    let mut rng = thread_rng();\n\n    let mut sequence: Vec<u8> = (1..10).collect();\n    while is_sorted(&sequence) {\n        sequence.shuffle(&mut rng);\n    }\n\n    let mut attempt = 1;\n    while !is_sorted(&sequence) {\n        println!(\n            \"Attempt {}: {:?} - How many numbers do you want to flip?\",\n            attempt, sequence\n        );\n        let flip = {\n            let mut input = String::new();\n            stdin().read_line(&mut input).unwrap();\n            input.trim().parse().unwrap()\n        };\n        sequence[..flip].reverse();\n        attempt += 1;\n    }\n    println!(\n        \"Congrats! It took you {} attempts to sort the sequence.\",\n        attempt - 1 // Remove additionally counted attempt\n    );\n}",
    "title": "Number reversal game",
    "url": "http://rosettacode.org/wiki/Number_reversal_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numbers which are not the sum of distinct squares",
    "url": "http://rosettacode.org/wiki/Numbers_which_are_not_the_sum_of_distinct_squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numbers with equal rises and falls",
    "url": "http://rosettacode.org/wiki/Numbers_with_equal_rises_and_falls"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numeric error propagation",
    "url": "http://rosettacode.org/wiki/Numeric_error_propagation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numerical and alphabetical suffixes",
    "url": "http://rosettacode.org/wiki/Numerical_and_alphabetical_suffixes"
  },
  {
    "local_code": "//! This is a partial solution and only implements trapezium integration.\n\nfn trapezium_integral<F>(f: F, range: &std::ops::Range<f64>, n_steps: u32) -> f64\nwhere\n    F: Fn(f64) -> f64,\n{\n    let step_size = (range.end - range.start) / f64::from(n_steps);\n\n    let mut integral = (f(range.start) + f(range.end)) / 2.;\n    let mut pos = range.start + step_size;\n    while pos < range.end {\n        integral += f(pos);\n        pos += step_size;\n    }\n    integral * step_size\n}\n\nfn main() {\n    println!(\"{}\", trapezium_integral(|x| x.powi(3), &(0.0..1.0), 100));\n    println!(\"{}\", trapezium_integral(|x| 1.0 / x, &(1.0..100.0), 1000));\n    println!(\"{}\", trapezium_integral(|x| x, &(0.0..5000.0), 5_000_000));\n    println!(\"{}\", trapezium_integral(|x| x, &(0.0..6000.0), 6_000_000));\n}\n",
    "path": "tasks/numerical-integration",
    "remote_code": "fn integral<F>(f: F, range: std::ops::Range<f64>, n_steps: u32) -> f64\n    where F: Fn(f64) -> f64\n{\n    let step_size = (range.end - range.start)/n_steps as f64;\n\n    let mut integral = (f(range.start) + f(range.end))/2.;\n    let mut pos = range.start + step_size;\n    while pos < range.end {\n        integral += f(pos);\n        pos += step_size;\n    }\n    integral * step_size\n}\n\nfn main() {\n    println!(\"{}\", integral(|x| x.powi(3), 0.0..1.0, 100));\n    println!(\"{}\", integral(|x| 1.0/x, 1.0..100.0, 1000));\n    println!(\"{}\", integral(|x| x, 0.0..5000.0, 5_000_000));\n    println!(\"{}\", integral(|x| x, 0.0..6000.0, 6_000_000));\n}",
    "title": "Numerical integration",
    "url": "http://rosettacode.org/wiki/Numerical_integration"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numerical integration/Gauss-Legendre Quadrature",
    "url": "http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "OLE automation",
    "url": "http://rosettacode.org/wiki/OLE_automation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt;\n\nuse bincode::{deserialize, serialize};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nenum Animal {\n    Dog { name: String, color: String },\n    Bird { name: String, wingspan: u8 },\n}\n\nimpl fmt::Display for Animal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Animal::Dog { name, color } => write!(f, \"{} is a dog with {} fur\", name, color),\n            Animal::Bird { name, wingspan } => {\n                write!(f, \"{} is a bird with a wingspan of {}\", name, wingspan)\n            }\n        }\n    }\n}\n\nfn main() -> bincode::Result<()> {\n    let animals = vec![\n        Animal::Dog {\n            name: \"Rover\".into(),\n            color: \"brown\".into(),\n        },\n        Animal::Bird {\n            name: \"Tweety\".into(),\n            wingspan: 3,\n        },\n    ];\n\n    for animal in &animals {\n        println!(\"{}\", animal);\n    }\n\n    let serialized = serialize(&animals)?;\n\n    println!(\"Serialized into {} bytes\", serialized.len());\n\n    let deserialized: Vec<Animal> = deserialize(&serialized)?;\n\n    println!(\"{:#?}\", deserialized);\n\n    Ok(())\n}",
    "title": "Object serialization",
    "url": "http://rosettacode.org/wiki/Object_serialization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Odd word problem",
    "url": "http://rosettacode.org/wiki/Odd_word_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\nuse std::process;\nuse std::collections::HashMap;\n\nfn main() {\n\n\tlet units: HashMap<&str, f32> = [(\"arshin\",0.7112),(\"centimeter\",0.01),(\"diuym\",0.0254),(\"fut\",0.3048),(\"kilometer\",1000.0),(\"liniya\",0.00254),(\"meter\",1.0),(\"milia\",7467.6),(\"piad\",0.1778),(\"sazhen\",2.1336),(\"tochka\",0.000254),(\"vershok\",0.04445),(\"versta\",1066.8)].iter().cloned().collect();\n\n\tlet args: Vec<String> = env::args().collect();\n\tif args.len() < 3 {\n\t\teprintln!(\"A correct use is oldrus [amount] [unit].\");\n\t\tprocess::exit(1);\n\t};\n\n\tlet length_float;\n\tlength_float = match args[1].parse::<f32>() {\n\t\tOk(length_float) =>  length_float,\n\t\tErr(..) => 1 as f32,\n\t};\n\n\tlet unit: &str = &args[2];\n\tif ! units.contains_key(unit) {\n\t\tlet mut keys: Vec<&str> = Vec::new();\n\t\tfor i in units.keys() {\n\t\t\tkeys.push(i)\n\t\t};\n\t\teprintln!(\"The correct units are: {}.\", keys.join(\", \"));\n\t\tprocess::exit(1);\n\t};\n\n\tprintln!(\"{} {} to:\", length_float, unit);\n\tfor (lunit, length) in &units {\n\t\tprintln!(\"\t{}: {:?}\", lunit,  length_float * units.get(unit).unwrap() / length);\n\t};\n\n\n}\n",
    "title": "Old Russian measure of length",
    "url": "http://rosettacode.org/wiki/Old_Russian_measure_of_length"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "enum Action {Once, Every, Die}\nuse Action::*;\n\nfn main() {\n    let animals = [ (\"horse\" , Die  , \"She's dead, of course!\")\n                  , (\"donkey\", Once , \"It was rather wonky. To swallow a donkey.\")\n                  , (\"cow\"   , Once , \"I don't know how. To swallow a cow.\")\n                  , (\"goat\"  , Once , \"She just opened her throat. To swallow a goat.\")\n                  , (\"pig\"   , Once , \"Her mouth was so big. To swallow a pig.\")\n                  , (\"dog\"   , Once , \"What a hog. To swallow a dog.\")\n                  , (\"cat\"   , Once , \"Fancy that. To swallow a cat.\")\n                  , (\"bird\"  , Once , \"Quite absurd. To swallow a bird.\")\n                  , (\"spider\", Once , \"That wriggled and jiggled and tickled inside her.\")\n                  , (\"fly\"   , Every, \"I don't know why she swallowed the fly.\")\n                  ];\n\n    for (i, a) in animals.iter().enumerate().rev() {\n        println!(\"There was an old lady who swallowed a {}\\n{}\", a.0, a.2);\n\n        if let Die = a.1 {break}\n\n        for (swallowed, to_catch) in animals[i..].iter().zip(&animals[i+1..]) {\n            println!(\"She swallowed the {} to catch the {}.\", swallowed.0, to_catch.0);\n\n            if let Every = to_catch.1 {\n                println!(\"{}\", to_catch.2);\n            }\n        }\n\n        println!(\"Perhaps she'll die.\\n\");\n    }\n}",
    "title": "Old lady swallowed a fly",
    "url": "http://rosettacode.org/wiki/Old_lady_swallowed_a_fly"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\n\nfn one_of_n<R: Rng>(rng: &mut R, n: usize) -> usize {\n    (1..n).fold(0, |keep, cand| {\n        // Note that this will break if n is larger than u32::MAX\n        if rng.gen_range(0, cand as u32 + 1) == 0 {\n            cand\n        } else {\n            keep\n        }\n    })\n}\n\nfn main() {\n    const LINES: usize = 10;\n\n    let mut dist = [0; LINES];\n    let mut rng = thread_rng();\n\n    for _ in 0..1_000_000 {\n        let num = one_of_n(&mut rng, LINES);\n        dist[num] += 1;\n    }\n\n    println!(\"{:?}\", dist);\n}\n",
    "path": "tasks/one-of-n-lines-in-a-file",
    "remote_code": "extern crate rand;\n\nuse rand::{Rng, thread_rng};\n\nfn one_of_n<R: Rng>(rng: &mut R, n: usize) -> usize {\n    (1..n).fold(0, |keep, cand| {\n        // Note that this will break if n is larger than u32::MAX\n        if rng.gen_weighted_bool(cand as u32 + 1) {\n            cand\n        } else {\n            keep\n        }\n    })\n}\n\nfn main() {\n    const LINES: usize = 10;\n\n    let mut dist = [0; LINES];\n    let mut rng = thread_rng();\n\n    for _ in 0..1_000_000 {\n        let num = one_of_n(&mut rng, LINES);\n        dist[num] += 1;\n    }\n\n    println!(\"{:?}\", dist);\n}\n",
    "title": "One of n lines in a file",
    "url": "http://rosettacode.org/wiki/One_of_n_lines_in_a_file"
  },
  {
    "local_code": "const MAX_GENERATION: usize = 10;\nconst CELLS_LENGTH: usize = 20;\n\nfn get_new_state(windowed: &[bool]) -> bool {\n    match windowed {\n        [false, true, true] | [true, true, false] => true,\n        _ => false,\n    }\n}\n\nfn next_gen(cell: &mut [bool]) {\n    let mut v = Vec::with_capacity(cell.len());\n    v.push(cell[0]);\n    for i in cell.windows(3) {\n        v.push(get_new_state(i));\n    }\n    v.push(cell[cell.len() - 1]);\n    cell.copy_from_slice(&v);\n}\n\nfn print_cell(cell: &[bool]) {\n    for v in cell {\n        print!(\"{} \", if *v { '#' } else { ' ' });\n    }\n    println!();\n}\n\nfn main() {\n    let mut cell: [bool; CELLS_LENGTH] = rand::random();\n\n    for i in 1..=MAX_GENERATION {\n        print!(\"Gen {:2}: \", i);\n        print_cell(&cell);\n        next_gen(&mut cell);\n    }\n}\n",
    "path": "tasks/one-dimensional-cellular-automata",
    "remote_code": "fn get_new_state(windowed: &[bool]) -> bool {\n    match windowed {\n        [false, true, true] | [true, true, false] => true,\n        _ => false\n    }\n}\n\nfn next_gen(cell: &mut [bool]) {\n    let mut v = Vec::with_capacity(cell.len());\n    v.push(cell[0]);\n    for i in cell.windows(3) {\n        v.push(get_new_state(i));\n    }\n    v.push(cell[cell.len() - 1]);\n    cell.copy_from_slice(&v);\n}\n\nfn print_cell(cell: &[bool]) {\n    for v in cell {\n        print!(\"{} \", if *v {'#'} else {' '});\n    }\n    println!();\n}\n\nfn main() {\n\n    const MAX_GENERATION: usize = 10;\n    const CELLS_LENGTH: usize = 30;\n\n    let mut cell: [bool; CELLS_LENGTH] = rand::random();\n\n    for i in 1..=MAX_GENERATION {\n        print!(\"Gen {:2}: \", i);\n        print_cell(&cell);\n        next_gen(&mut cell);\n    }\n}\n",
    "title": "One-dimensional cellular automata",
    "url": "http://rosettacode.org/wiki/One-dimensional_cellular_automata"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "One-time pad",
    "url": "http://rosettacode.org/wiki/One-time_pad"
  },
  {
    "local_code": "//! This example uses the `glium` library, a high level, safe wrapper for OpenGL.\n//!\n//! It is based off the example in the [official tutorial].\n//!\n//! [official tutorial]: https://github.com/glium/glium/tree/master/book\n\nuse glium::glutin::{\n    event::{Event, WindowEvent},\n    event_loop::{ControlFlow, EventLoop},\n    window::WindowBuilder,\n    ContextBuilder,\n};\nuse glium::{implement_vertex, Display, Surface};\n\n/// Define a struct to store vertices. This struct will be used by `glium` directly.\n#[derive(Copy, Clone)]\nstruct Vertex {\n    position: [f32; 2],\n}\n\nimplement_vertex!(Vertex, position);\n\nfn main() {\n    let event_loop = EventLoop::new();\n    let window_builder = WindowBuilder::new();\n    let context_builder = ContextBuilder::new();\n    let display = Display::new(window_builder, context_builder, &event_loop).unwrap();\n\n    let vertex1 = Vertex {\n        position: [0.0, 0.0],\n    };\n    let vertex2 = Vertex {\n        position: [0.5, 0.0],\n    };\n    let vertex3 = Vertex {\n        position: [0.0, 0.5],\n    };\n    let shape = vec![vertex1, vertex2, vertex3];\n\n    let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();\n    let indices = glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList);\n\n    // Define the shaders.\n    let vertex_shader_src = r#\"\n        #version 140\n\n        in vec2 position;\n        out vec2 a_color;\n\n        void main() {\n            a_color = position;\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    \"#;\n\n    let fragment_shader_src = r#\"\n        #version 140\n\n        in vec2 a_color;\n        out vec4 color;\n\n        void main() {\n            color = vec4(a_color, 0.0, 1.0);\n        }\n    \"#;\n\n    let program =\n        glium::Program::from_source(&display, vertex_shader_src, fragment_shader_src, None)\n            .unwrap();\n\n    let draw = move || {\n        let mut target = display.draw();\n        target.clear_color(0.3, 0.3, 0.3, 0.0);\n        target\n            .draw(\n                &vertex_buffer,\n                &indices,\n                &program,\n                &glium::uniforms::EmptyUniforms,\n                &Default::default(),\n            )\n            .unwrap();\n        target.finish().unwrap();\n    };\n\n    // Finally, draw the triangle!\n    draw();\n\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = match event {\n            Event::WindowEvent { event, .. } => match event {\n                WindowEvent::CloseRequested => ControlFlow::Exit,\n                WindowEvent::Resized(..) => {\n                    draw();\n                    ControlFlow::Poll\n                }\n                _ => ControlFlow::Poll,\n            },\n            Event::RedrawRequested(..) => {\n                draw();\n                ControlFlow::Poll\n            }\n            _ => ControlFlow::Poll,\n        }\n    });\n}\n",
    "path": "tasks/opengl",
    "remote_code": "use glow::*;\nuse glutin::event::*;\nuse glutin::event_loop::{ControlFlow, EventLoop};\nuse std::os::raw::c_uint;\n\nconst VERTEX: &str = \"#version 410\nconst vec2 verts[3] = vec2[3](\n    vec2(0.5f, 1.0f),\n    vec2(0.0f, 0.0f),\n    vec2(1.0f, 0.0f)\n);\nout vec2 vert;\nvoid main() {\n    vert = verts[gl_VertexID];\n    gl_Position = vec4(vert - 0.5, 0.0, 1.0);\n}\";\n\nconst FRAGMENT: &str = \"#version 410\nprecision mediump float;\nin vec2 vert;\nout vec4 color;\nvoid main() {\n    color = vec4(vert, 0.5, 1.0);\n}\";\n\nunsafe fn create_program(gl: &Context, vert: &str, frag: &str) -> c_uint {\n    let program = gl.create_program().expect(\"Cannot create program\");\n    let shader_sources = [(glow::VERTEX_SHADER, vert), (glow::FRAGMENT_SHADER, frag)];\n\n    let mut shaders = Vec::new();\n    for (shader_type, shader_source) in shader_sources.iter() {\n        let shader = gl\n            .create_shader(*shader_type)\n            .expect(\"Cannot create shader\");\n        gl.shader_source(shader, shader_source);\n        gl.compile_shader(shader);\n        if !gl.get_shader_compile_status(shader) {\n            panic!(gl.get_shader_info_log(shader));\n        }\n        gl.attach_shader(program, shader);\n        shaders.push(shader);\n    }\n\n    gl.link_program(program);\n    if !gl.get_program_link_status(program) {\n        panic!(gl.get_program_info_log(program));\n    }\n\n    for shader in shaders {\n        gl.detach_shader(program, shader);\n        gl.delete_shader(shader);\n    }\n    program\n}\n\nfn main() {\n    let (gl, event_loop, window) = unsafe {\n        let el = EventLoop::new();\n        let wb = glutin::window::WindowBuilder::new()\n            .with_title(\"Hello triangle!\")\n            .with_inner_size(glutin::dpi::LogicalSize::new(1024.0, 768.0));\n        let windowed_context = glutin::ContextBuilder::new()\n            .with_vsync(true)\n            .build_windowed(wb, &el)\n            .unwrap();\n        let windowed_context = windowed_context.make_current().unwrap();\n        let context = glow::Context::from_loader_function(|s| {\n            windowed_context.get_proc_address(s) as *const _\n        });\n        (context, el, windowed_context)\n    };\n\n    let (program, vab) = unsafe {\n        let vertex_array = gl\n            .create_vertex_array()\n            .expect(\"Cannot create vertex array\");\n        gl.bind_vertex_array(Some(vertex_array));\n\n        let program = create_program(&gl, VERTEX, FRAGMENT);\n        gl.use_program(Some(program));\n\n        (program, vertex_array)\n    };\n\n    event_loop.run(move |ev, _, flow| match ev {\n        Event::WindowEvent {\n            event: WindowEvent::CloseRequested, ..\n        } => {\n            unsafe {\n                gl.delete_program(program);\n                gl.delete_vertex_array(vab);\n            }\n            *flow = ControlFlow::Exit;\n        }\n        Event::WindowEvent {\n            event: WindowEvent::Resized(size), ..\n        } => {\n            unsafe {\n                gl.viewport(0, 0, size.width as i32, size.height as i32);\n            }\n            window.resize(size);\n        }\n        Event::RedrawRequested(_) => unsafe {\n            gl.clear_color(0.1, 0.2, 0.3, 1.0);\n            gl.clear(glow::COLOR_BUFFER_BIT);\n            gl.draw_arrays(glow::TRIANGLES, 0, 3);\n            window.swap_buffers().unwrap();\n        },\n        _ => {}\n    });\n}",
    "title": "OpenGL",
    "url": "http://rosettacode.org/wiki/OpenGL"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "OpenWebNet password",
    "url": "http://rosettacode.org/wiki/OpenWebNet_password"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Operator precedence",
    "url": "http://rosettacode.org/wiki/Operator_precedence"
  },
  {
    "local_code": "use std::cmp::Ordering;\n\npub struct Table {\n    rows: Vec<Vec<String>>,\n    ordering_function: fn(&str, &str) -> Ordering,\n    ordering_column: usize,\n    reverse: bool,\n}\n\nimpl Table {\n    pub fn new(rows: Vec<Vec<String>>) -> Table {\n        Table {\n            rows,\n            ordering_column: 0,\n            reverse: false,\n            ordering_function: |str1, str2| str1.cmp(str2),\n        }\n    }\n}\n\nimpl Table {\n    pub fn with_ordering_column(&mut self, ordering_column: usize) -> &mut Table {\n        self.ordering_column = ordering_column;\n        self\n    }\n\n    pub fn with_reverse(&mut self, reverse: bool) -> &mut Table {\n        self.reverse = reverse;\n        self\n    }\n\n    pub fn with_ordering_fun(&mut self, compare: fn(&str, &str) -> Ordering) -> &mut Table {\n        self.ordering_function = compare;\n        self\n    }\n\n    pub fn sort(&mut self) {\n        let fun = &mut self.ordering_function;\n        let idx = self.ordering_column;\n        if self.reverse {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]).reverse());\n        } else {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]));\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::Table;\n\n    fn generate_test_table() -> Table {\n        Table::new(vec![\n            vec![\"0\".to_string(), \"fff\".to_string()],\n            vec![\"2\".to_string(), \"aab\".to_string()],\n            vec![\"1\".to_string(), \"ccc\".to_string()],\n        ])\n    }\n\n    #[test]\n    fn test_simple_sort() {\n        let mut table = generate_test_table();\n        table.sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"0\".to_string(), \"fff\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"2\".to_string(), \"aab\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_ordering_column() {\n        let mut table = generate_test_table();\n        table.with_ordering_column(1).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_with_reverse() {\n        let mut table = generate_test_table();\n        table.with_reverse(true).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_custom_ordering_fun() {\n        let mut table = generate_test_table();\n        // Simple ordering function that reverses stuff.\n        // Should operate like the test before.\n        table.with_ordering_fun(|x, y| x.cmp(y).reverse()).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_everything_together() {\n        let mut table = generate_test_table();\n        // Using the reversing cmp function, then reverse (= don't do anything)\n        // then sort from column 1.\n        table\n            .with_ordering_fun(|x, y| x.cmp(y).reverse())\n            .with_reverse(true)\n            .with_ordering_column(1)\n            .sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n}\n",
    "path": "tasks/optional-parameters",
    "remote_code": "use std::cmp::Ordering;\n\nstruct Table {\n    rows: Vec<Vec<String>>,\n    ordering_function: fn(&str, &str) -> Ordering,\n    ordering_column: usize,\n    reverse: bool,\n}\n\nimpl Table {\n    fn new(rows: Vec<Vec<String>>) -> Table {\n        Table {\n            rows: rows,\n            ordering_column: 0,\n            reverse: false,\n            ordering_function: |str1, str2| str1.cmp(str2),\n        }\n    }\n}\n\nimpl Table {\n    fn with_ordering_column(&mut self, ordering_column: usize) -> &mut Table {\n        self.ordering_column = ordering_column;\n        self\n    }\n\n    fn with_reverse(&mut self, reverse: bool) -> &mut Table {\n        self.reverse = reverse;\n        self\n    }\n\n    fn with_ordering_fun(&mut self, compare: fn(&str, &str) -> Ordering) -> &mut Table {\n        self.ordering_function = compare;\n        self\n    }\n\n    fn sort(&mut self) {\n        let fun = &mut self.ordering_function;\n        let idx = self.ordering_column;\n        if self.reverse {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]).reverse());\n        } else {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]));\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::Table;\n\n    fn generate_test_table() -> Table {\n        Table::new(vec![\n            vec![\"0\".to_string(), \"fff\".to_string()],\n            vec![\"2\".to_string(), \"aab\".to_string()],\n            vec![\"1\".to_string(), \"ccc\".to_string()],\n        ])\n    }\n\n    #[test]\n    fn test_simple_sort() {\n        let mut table = generate_test_table();\n        table.sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"0\".to_string(), \"fff\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"2\".to_string(), \"aab\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_ordering_column() {\n        let mut table = generate_test_table();\n        table.with_ordering_column(1).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_with_reverse() {\n        let mut table = generate_test_table();\n        table.with_reverse(true).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_custom_ordering_fun() {\n        let mut table = generate_test_table();\n        // Simple ordering function that reverses stuff.\n        // Should operate like the test before.\n        table.with_ordering_fun(|x, y| x.cmp(y).reverse()).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_everything_together() {\n        let mut table = generate_test_table();\n        // Using the reversing cmp function, then reverse (= don't do anything)\n        // then sort from column 1.\n        table\n            .with_ordering_fun(|x, y| x.cmp(y).reverse())\n            .with_reverse(true)\n            .with_ordering_column(1)\n            .sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n}\n",
    "title": "Optional parameters",
    "url": "http://rosettacode.org/wiki/Optional_parameters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Order by pair comparisons",
    "url": "http://rosettacode.org/wiki/Order_by_pair_comparisons"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Order disjoint list items",
    "url": "http://rosettacode.org/wiki/Order_disjoint_list_items"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "vec![1, 2, 1, 3, 2] < vec![1, 2, 0, 4, 4, 0, 0, 0]",
    "title": "Order two numerical lists",
    "url": "http://rosettacode.org/wiki/Order_two_numerical_lists"
  },
  {
    "local_code": "use itertools::Itertools;\n\ntype NArray = Vec<Vec<Vec<usize>>>;\n\nfn generate_partitions(args: &[usize]) -> NArray {\n    // calculate the sum of all partitions\n    let max = args.iter().sum();\n\n    // generate combinations with the given lengths\n    // for each partition\n    let c = args.iter().fold(vec![], |mut acc, arg| {\n        acc.push((1..=max).combinations(*arg).collect::<Vec<_>>());\n        acc\n    });\n\n    // create a cartesian product of all individual combinations\n    // filter/keep only where all the elements are there and exactly once\n    c.iter()\n        .map(|i| i.iter().cloned())\n        .multi_cartesian_product()\n        .unique()\n        .filter(|x| x.iter().cloned().flatten().unique().count() == max)\n        .collect::<Vec<_>>()\n}\n\n#[allow(clippy::ptr_arg)]\nfn print_partitions(result: &NArray) {\n    println!(\"Partitions:\");\n    for partition in result {\n        println!(\"{:?}\", partition);\n    }\n}\nfn main() {\n    print_partitions(generate_partitions(&[2, 0, 2]).as_ref());\n    print_partitions(generate_partitions(&[1, 1, 1]).as_ref());\n    print_partitions(generate_partitions(&[2, 3]).as_ref());\n    print_partitions(generate_partitions(&[0]).as_ref());\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_partitions() {\n        itertools::assert_equal(generate_partitions(&[0]), vec![vec![vec![]]]);\n        itertools::assert_equal(\n            generate_partitions(&[2, 0, 2]),\n            vec![\n                vec![vec![1, 2], vec![], vec![3, 4]],\n                vec![vec![1, 3], vec![], vec![2, 4]],\n                vec![vec![1, 4], vec![], vec![2, 3]],\n                vec![vec![2, 3], vec![], vec![1, 4]],\n                vec![vec![2, 4], vec![], vec![1, 3]],\n                vec![vec![3, 4], vec![], vec![1, 2]],\n            ],\n        );\n\n        itertools::assert_equal(\n            generate_partitions(&[1, 1, 1]),\n            vec![\n                vec![vec![1], vec![2], vec![3]],\n                vec![vec![1], vec![3], vec![2]],\n                vec![vec![2], vec![1], vec![3]],\n                vec![vec![2], vec![3], vec![1]],\n                vec![vec![3], vec![1], vec![2]],\n                vec![vec![3], vec![2], vec![1]],\n            ],\n        );\n    }\n}\n",
    "path": "tasks/ordered-partitions",
    "remote_code": "\nuse itertools::Itertools;\n\ntype NArray = Vec<Vec<Vec<usize>>>;\n\nfn generate_partitions(args: &[usize]) -> NArray {\n    // calculate the sum of all partitions\n    let max = args.iter().sum();\n\n    // generate combinations with the given lengths\n    // for each partition\n    let c = args.iter().fold(vec![], |mut acc, arg| {\n        acc.push((1..=max).combinations(*arg).collect::<Vec<_>>());\n        acc\n    });\n\n    // create a cartesian product of all individual combinations\n    // filter/keep only where all the elements are there and exactly once\n    c.iter()\n        .map(|i| i.iter().cloned())\n        .multi_cartesian_product()\n        .unique()\n        .filter(|x| x.iter().cloned().flatten().unique().count() == max)\n        .collect::<Vec<_>>()\n}\n\n#[allow(clippy::clippy::ptr_arg)]\nfn print_partitions(result: &NArray) {\n    println!(\"Partitions:\");\n    for partition in result {\n        println!(\"{:?}\", partition);\n    }\n}\nfn main() {\n    print_partitions(generate_partitions(&[2, 0, 2]).as_ref());\n    print_partitions(generate_partitions(&[1, 1, 1]).as_ref());\n    print_partitions(generate_partitions(&[2, 3]).as_ref());\n    print_partitions(generate_partitions(&[0]).as_ref());\n}\n",
    "title": "Ordered partitions",
    "url": "http://rosettacode.org/wiki/Ordered_partitions"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn is_ordered(s: &str) -> bool {\n    let mut prev = '\\x00';\n    for c in s.chars() {\n        if c < prev {\n            return false;\n        }\n        prev = c;\n    }\n\n    true\n}\n\nfn find_longest_ordered_words(dict: Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut longest_length = 0;\n\n    for s in dict {\n        if is_ordered(&s) {\n            let n = s.len();\n            if n > longest_length {\n                longest_length = n;\n                result.truncate(0);\n            }\n            if n == longest_length {\n                result.push(s.to_owned());\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let lines = BufReader::new(File::open(\"unixdict.txt\").unwrap())\n        .lines()\n        .map(|l| l.unwrap())\n        .collect();\n\n    let longest_ordered = find_longest_ordered_words(lines);\n\n    for s in &longest_ordered {\n        println!(\"{}\", s);\n    }\n}\n",
    "path": "tasks/ordered-words",
    "remote_code": "const FILE: &'static str = include_str!(\"./unixdict.txt\");\n\nfn is_ordered(s: &str) -> bool {\n    let mut prev = '\\x00';\n    for c in s.to_lowercase().chars() {\n        if c < prev {\n            return false;\n        }\n        prev = c;\n    }\n\n    return true;\n}\n\nfn find_longest_ordered_words(dict: Vec<&str>) -> Vec<&str> {\n    let mut result = Vec::new();\n    let mut longest_length = 0;\n\n    for s in dict.into_iter() {\n        if is_ordered(&s) {\n            let n = s.len();\n            if n > longest_length {\n                longest_length = n;\n                result.truncate(0);\n            }\n            if n == longest_length {\n                result.push(s);\n            }\n        }\n    }\n\n    return result;\n}\n\nfn main() {\n    let lines = FILE.lines().collect();\n\n    let longest_ordered = find_longest_ordered_words(lines);\n\n    for s in longest_ordered.iter() {\n        println!(\"{}\", s.to_string());\n    }\n}",
    "title": "Ordered words",
    "url": "http://rosettacode.org/wiki/Ordered_words"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "P-Adic numbers, basic",
    "url": "http://rosettacode.org/wiki/P-Adic_numbers,_basic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "P-Adic square roots",
    "url": "http://rosettacode.org/wiki/P-Adic_square_roots"
  },
  {
    "local_code": "use std::iter;\n\n#[rustfmt::skip]\nconst PVALUES:[f64;50] = [\n4.533_744e-01, 7.296_024e-01, 9.936_026e-02, 9.079_658e-02, 1.801_962e-01,\n8.752_257e-01, 2.922_222e-01, 9.115_421e-01, 4.355_806e-01, 5.324_867e-01,\n4.926_798e-01, 5.802_978e-01, 3.485_442e-01, 7.883_130e-01, 2.729_308e-01,\n8.502_518e-01, 4.268_138e-01, 6.442_008e-01, 3.030_266e-01, 5.001_555e-02,\n3.194_810e-01, 7.892_933e-01, 9.991_834e-01, 1.745_691e-01, 9.037_516e-01,\n1.198_578e-01, 3.966_083e-01, 1.403_837e-02, 7.328_671e-01, 6.793_476e-02,\n4.040_730e-03, 3.033_349e-04, 1.125_147e-02, 2.375_072e-02, 5.818_542e-04,\n3.075_482e-04, 8.251_272e-03, 1.356_534e-03, 1.360_696e-02, 3.764_588e-04,\n1.801_145e-05, 2.504_456e-07, 3.310_253e-02, 9.427_839e-03, 8.791_153e-04,\n2.177_831e-04, 9.693_054e-04, 6.610_250e-05, 2.900_813e-02, 5.735_490e-03\n];\n\n#[derive(Debug)]\nenum CorrectionType {\n    BenjaminiHochberg,\n    BenjaminiYekutieli,\n    Bonferroni,\n    Hochberg,\n    Holm,\n    Hommel,\n    Sidak,\n}\n\nenum SortDirection {\n    Increasing,\n    Decreasing,\n}\n\n/// orders **input** vector by value and multiplies with **multiplier** vector\n/// Finally returns the multiplied values in the original order of **input**\nfn ordered_multiply(input: &[f64], multiplier: &[f64], direction: &SortDirection) -> Vec<f64> {\n    let order_by_value = match direction {\n        SortDirection::Increasing => {\n            |a: &(f64, usize), b: &(f64, usize)| b.0.partial_cmp(&a.0).unwrap()\n        }\n        SortDirection::Decreasing => {\n            |a: &(f64, usize), b: &(f64, usize)| a.0.partial_cmp(&b.0).unwrap()\n        }\n    };\n\n    let cmp_minmax = match direction {\n        SortDirection::Increasing => |a: f64, b: f64| a.gt(&b),\n        SortDirection::Decreasing => |a: f64, b: f64| a.lt(&b),\n    };\n\n    // add original order index\n    let mut input_indexed = input\n        .iter()\n        .enumerate()\n        .map(|(idx, &p_value)| (p_value, idx))\n        .collect::<Vec<_>>();\n\n    // order by value desc/asc\n    input_indexed.sort_unstable_by(order_by_value);\n\n    // do the multiplication in place, clamp it at 1.0,\n    // keep the original index in place\n    for i in 0..input_indexed.len() {\n        input_indexed[i] = (\n            f64::min(1.0, input_indexed[i].0 * multiplier[i]),\n            input_indexed[i].1,\n        );\n    }\n\n    // make vector strictly monotonous increasing/decreasing in place\n    for i in 1..input_indexed.len() {\n        if cmp_minmax(input_indexed[i].0, input_indexed[i - 1].0) {\n            input_indexed[i] = (input_indexed[i - 1].0, input_indexed[i].1);\n        }\n    }\n\n    // re-sort back to original order\n    input_indexed.sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.1.cmp(&b.1));\n\n    // remove ordering index\n    let (resorted, _): (Vec<_>, Vec<_>) = input_indexed.iter().cloned().unzip();\n    resorted\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn hommel(input: &[f64]) -> Vec<f64> {\n    // using algorith described:\n    // http://stat.wharton.upenn.edu/~steele/Courses/956/ResourceDetails/MultipleComparision/Writght92.pdf\n\n    // add original order index\n    let mut input_indexed = input\n        .iter()\n        .enumerate()\n        .map(|(idx, &p_value)| (p_value, idx))\n        .collect::<Vec<_>>();\n\n    // order by value asc\n    input_indexed\n        .sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.0.partial_cmp(&b.0).unwrap());\n\n    let (p_values, order): (Vec<_>, Vec<_>) = input_indexed.iter().cloned().unzip();\n\n    let n = input.len();\n\n    // initial minimal n*p/i values\n    // get the smalles of these values\n    let min_result = (0..n)\n        .map(|i| ((p_values[i] * n as f64) / (i + 1) as f64))\n        .fold(1. / 0. /* -inf */, f64::min);\n\n    // // initialize result vector with minimal values\n    let mut result = iter::repeat(min_result).take(n).collect::<Vec<_>>();\n\n    for m in (2..n).rev() {\n        let cmin: f64;\n        let m_as_float = m as f64;\n        let mut a = p_values.clone();\n        // println!(\"\\nn: {}\", m);\n        {\n            // split p-values into two group\n            let (_, second) = p_values.split_at(n - m + 1);\n\n            // calculate minumum of m*p/i for this second group\n            cmin = second\n                .iter()\n                .zip(2..=m)\n                .map(|(p, i)| (m_as_float * p) / i as f64)\n                .fold(1. / 0. /* inf */, f64::min);\n        }\n\n        // replace p values if p<cmin in the second group\n        ((n - m + 1)..n).for_each(|i| a[i] = a[i].max(cmin));\n\n        // replace p values if min(cmin, m*p) > p\n        (0..=(n - m)).for_each(|i| a[i] = a[i].max(f64::min(cmin, m_as_float * p_values[i])));\n\n        // store in the result vector if any adjusted p is higher than the current one\n        (0..n).for_each(|i| result[i] = result[i].max(a[i]));\n    }\n\n    // re-sort into the original order\n    let mut result = result\n        .into_iter()\n        .zip(order.into_iter())\n        .map(|(p, idx)| (p, idx))\n        .collect::<Vec<_>>();\n    result.sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.1.cmp(&b.1));\n    let (result, _): (Vec<_>, Vec<_>) = result.iter().cloned().unzip();\n    result\n}\n#[allow(clippy::cast_precision_loss)]\nfn p_value_correction(p_values: &[f64], ctype: &CorrectionType) -> Vec<f64> {\n    let p_vec = p_values.to_vec();\n    if p_values.is_empty() {\n        return p_vec;\n    }\n\n    let fsize = p_values.len() as f64;\n\n    match ctype {\n        CorrectionType::BenjaminiHochberg => {\n            let multiplier = (0..p_values.len())\n                .map(|index| fsize / (fsize - index as f64))\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::BenjaminiYekutieli => {\n            let q: f64 = (1..=p_values.len()).map(|index| 1. / index as f64).sum();\n            let multiplier = (0..p_values.len())\n                .map(|index| q * fsize / (fsize - index as f64))\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::Bonferroni => p_vec\n            .iter()\n            .map(|p| f64::min(p * fsize, 1.0))\n            .collect::<Vec<_>>(),\n        CorrectionType::Hochberg => {\n            let multiplier = (0..p_values.len())\n                .map(|index| 1. + index as f64)\n                .collect::<Vec<_>>();\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::Holm => {\n            let multiplier = (0..p_values.len())\n                .map(|index| fsize - index as f64)\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Decreasing)\n        }\n        CorrectionType::Sidak => p_vec\n            .iter()\n            .map(|x| 1. - (1. - x).powf(fsize))\n            .collect::<Vec<_>>(),\n        CorrectionType::Hommel => hommel(&p_vec),\n    }\n}\n\n// prints array into a nice table, max 5 floats/row\nfn array_to_string(a: &[f64]) -> String {\n    a.chunks(5)\n        .enumerate()\n        .map(|(index, e)| {\n            format!(\n                \"[{:>2}]: {}\",\n                index * 5,\n                e.iter()\n                    .map(|x| format!(\"{:>1.10}\", x))\n                    .collect::<Vec<_>>()\n                    .join(\", \")\n            )\n        })\n        .collect::<Vec<_>>()\n        .join(\"\\n\")\n}\nfn main() {\n    let ctypes = [\n        CorrectionType::BenjaminiHochberg,\n        CorrectionType::BenjaminiYekutieli,\n        CorrectionType::Bonferroni,\n        CorrectionType::Hochberg,\n        CorrectionType::Holm,\n        CorrectionType::Sidak,\n        CorrectionType::Hommel,\n    ];\n\n    for ctype in &ctypes {\n        println!(\"\\n{:?}:\", ctype);\n        println!(\"{}\", array_to_string(&p_value_correction(&PVALUES, ctype)));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assert_approx_eq::assert_approx_eq;\n\n    #[test]\n    fn test_p_value_correction_benjamini_hochberg() {\n        let result = p_value_correction(\n            &[0.001, 0.004, 0.009, 0.007],\n            &CorrectionType::BenjaminiHochberg,\n        );\n\n        assert_approx_eq!(result[0], 0.004);\n        assert_approx_eq!(result[1], 0.008);\n        assert_approx_eq!(result[2], 0.009);\n        assert_approx_eq!(result[3], 0.009);\n    }\n\n    #[test]\n    fn test_p_value_correction_benjamini_yekutieli() {\n        let result = p_value_correction(\n            &[0.001, 0.004, 0.009, 0.007],\n            &CorrectionType::BenjaminiYekutieli,\n        );\n\n        assert_approx_eq!(result[0], 0.008333333);\n        assert_approx_eq!(result[1], 0.016666667);\n        assert_approx_eq!(result[2], 0.018750000);\n        assert_approx_eq!(result[3], 0.018750000);\n    }\n\n    #[test]\n    fn test_p_value_correction_bonferroni() {\n        let result = p_value_correction(&[0.001, 0.004, 0.009, 0.007], &CorrectionType::Bonferroni);\n\n        assert_approx_eq!(result[0], 0.004);\n        assert_approx_eq!(result[1], 0.016);\n        assert_approx_eq!(result[2], 0.036);\n        assert_approx_eq!(result[3], 0.028);\n    }\n\n    #[test]\n    fn test_p_value_correction_hochberg() {\n        let result = p_value_correction(&[0.001, 0.004, 0.009, 0.007], &CorrectionType::Hochberg);\n\n        assert_approx_eq!(result[0], 0.004);\n        assert_approx_eq!(result[1], 0.009);\n        assert_approx_eq!(result[2], 0.009);\n        assert_approx_eq!(result[3], 0.009);\n    }\n\n    #[test]\n    fn test_p_value_correction_holm() {\n        let result = p_value_correction(&[0.001, 0.004, 0.009, 0.007], &CorrectionType::Holm);\n\n        assert_approx_eq!(result[0], 0.004);\n        assert_approx_eq!(result[1], 0.012);\n        assert_approx_eq!(result[2], 0.014);\n        assert_approx_eq!(result[3], 0.014);\n    }\n\n    #[test]\n    fn test_p_value_correction_sidak() {\n        let result = p_value_correction(&[0.001, 0.004, 0.009, 0.007], &CorrectionType::Sidak);\n\n        assert_approx_eq!(result[0], 0.003994003998999962);\n        assert_approx_eq!(result[1], 0.015904255744000007);\n        assert_approx_eq!(result[2], 0.03551690943899999);\n        assert_approx_eq!(result[3], 0.02770736959900011);\n    }\n    #[test]\n    fn test_p_value_correction_hommel() {\n        let result = p_value_correction(&[0.001, 0.004, 0.009, 0.007], &CorrectionType::Hommel);\n\n        assert_approx_eq!(result[0], 0.004);\n        assert_approx_eq!(result[1], 0.009);\n        assert_approx_eq!(result[2], 0.009);\n        assert_approx_eq!(result[3], 0.009);\n    }\n}\n",
    "path": "tasks/p-value-correction",
    "remote_code": "\nuse std::iter;\n\n#[rustfmt::skip]\nconst PVALUES:[f64;50] = [\n4.533_744e-01, 7.296_024e-01, 9.936_026e-02, 9.079_658e-02, 1.801_962e-01,\n8.752_257e-01, 2.922_222e-01, 9.115_421e-01, 4.355_806e-01, 5.324_867e-01,\n4.926_798e-01, 5.802_978e-01, 3.485_442e-01, 7.883_130e-01, 2.729_308e-01,\n8.502_518e-01, 4.268_138e-01, 6.442_008e-01, 3.030_266e-01, 5.001_555e-02,\n3.194_810e-01, 7.892_933e-01, 9.991_834e-01, 1.745_691e-01, 9.037_516e-01,\n1.198_578e-01, 3.966_083e-01, 1.403_837e-02, 7.328_671e-01, 6.793_476e-02,\n4.040_730e-03, 3.033_349e-04, 1.125_147e-02, 2.375_072e-02, 5.818_542e-04,\n3.075_482e-04, 8.251_272e-03, 1.356_534e-03, 1.360_696e-02, 3.764_588e-04,\n1.801_145e-05, 2.504_456e-07, 3.310_253e-02, 9.427_839e-03, 8.791_153e-04,\n2.177_831e-04, 9.693_054e-04, 6.610_250e-05, 2.900_813e-02, 5.735_490e-03\n];\n\n#[derive(Debug)]\nenum CorrectionType {\n    BenjaminiHochberg,\n    BenjaminiYekutieli,\n    Bonferroni,\n    Hochberg,\n    Holm,\n    Hommel,\n    Sidak,\n}\n\nenum SortDirection {\n    Increasing,\n    Decreasing,\n}\n\n/// orders **input** vector by value and multiplies with **multiplier** vector\n/// Finally returns the multiplied values in the original order of **input**\nfn ordered_multiply(input: &[f64], multiplier: &[f64], direction: &SortDirection) -> Vec<f64> {\n    let order_by_value = match direction {\n        SortDirection::Increasing => {\n            |a: &(f64, usize), b: &(f64, usize)| b.0.partial_cmp(&a.0).unwrap()\n        }\n        SortDirection::Decreasing => {\n            |a: &(f64, usize), b: &(f64, usize)| a.0.partial_cmp(&b.0).unwrap()\n        }\n    };\n\n    let cmp_minmax = match direction {\n        SortDirection::Increasing => |a: f64, b: f64| a.gt(&b),\n        SortDirection::Decreasing => |a: f64, b: f64| a.lt(&b),\n    };\n\n    // add original order index\n    let mut input_indexed = input\n        .iter()\n        .enumerate()\n        .map(|(idx, &p_value)| (p_value, idx))\n        .collect::<Vec<_>>();\n\n    // order by value desc/asc\n    input_indexed.sort_unstable_by(order_by_value);\n\n    // do the multiplication in place, clamp it at 1.0,\n    // keep the original index in place\n    for i in 0..input_indexed.len() {\n        input_indexed[i] = (\n            f64::min(1.0, input_indexed[i].0 * multiplier[i]),\n            input_indexed[i].1,\n        );\n    }\n\n    // make vector strictly monotonous increasing/decreasing in place\n    for i in 1..input_indexed.len() {\n        if cmp_minmax(input_indexed[i].0, input_indexed[i - 1].0) {\n            input_indexed[i] = (input_indexed[i - 1].0, input_indexed[i].1);\n        }\n    }\n\n    // re-sort back to original order\n    input_indexed.sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.1.cmp(&b.1));\n\n    // remove ordering index\n    let (resorted, _): (Vec<_>, Vec<_>) = input_indexed.iter().cloned().unzip();\n    resorted\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn hommel(input: &[f64]) -> Vec<f64> {\n    // using algorith described:\n    // http://stat.wharton.upenn.edu/~steele/Courses/956/ResourceDetails/MultipleComparision/Writght92.pdf\n\n    // add original order index\n    let mut input_indexed = input\n        .iter()\n        .enumerate()\n        .map(|(idx, &p_value)| (p_value, idx))\n        .collect::<Vec<_>>();\n\n    // order by value asc\n    input_indexed\n        .sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.0.partial_cmp(&b.0).unwrap());\n\n    let (p_values, order): (Vec<_>, Vec<_>) = input_indexed.iter().cloned().unzip();\n\n    let n = input.len();\n\n    // initial minimal n*p/i values\n    // get the smalles of these values\n    let min_result = (0..n)\n        .map(|i| ((p_values[i] * n as f64) / (i + 1) as f64))\n        .fold(1. / 0. /* -inf */, f64::min);\n\n    // // initialize result vector with minimal values\n    let mut result = iter::repeat(min_result).take(n).collect::<Vec<_>>();\n\n    for m in (2..n).rev() {\n        let cmin: f64;\n        let m_as_float = m as f64;\n        let mut a = p_values.clone();\n        // println!(\"\\nn: {}\", m);\n        {\n            // split p-values into two group\n            let (_, second) = p_values.split_at(n - m + 1);\n\n            // calculate minumum of m*p/i for this second group\n            cmin = second\n                .iter()\n                .zip(2..=m)\n                .map(|(p, i)| (m_as_float * p) / i as f64)\n                .fold(1. / 0. /* inf */, f64::min);\n        }\n\n        // replace p values if p<cmin in the second group\n        ((n - m + 1)..n).for_each(|i| a[i] = a[i].max(cmin));\n\n        // replace p values if min(cmin, m*p) > p\n        (0..=(n - m)).for_each(|i| a[i] = a[i].max(f64::min(cmin, m_as_float * p_values[i])));\n\n        // store in the result vector if any adjusted p is higher than the current one\n        (0..n).for_each(|i| result[i] = result[i].max(a[i]));\n    }\n\n    // re-sort into the original order\n    let mut result = result\n        .into_iter()\n        .zip(order.into_iter())\n        .map(|(p, idx)| (p, idx))\n        .collect::<Vec<_>>();\n    result.sort_unstable_by(|a: &(f64, usize), b: &(f64, usize)| a.1.cmp(&b.1));\n    let (result, _): (Vec<_>, Vec<_>) = result.iter().cloned().unzip();\n    result\n}\n#[allow(clippy::cast_precision_loss)]\nfn p_value_correction(p_values: &[f64], ctype: &CorrectionType) -> Vec<f64> {\n    let p_vec = p_values.to_vec();\n    if p_values.is_empty() {\n        return p_vec;\n    }\n\n    let fsize = p_values.len() as f64;\n\n    match ctype {\n        CorrectionType::BenjaminiHochberg => {\n            let multiplier = (0..p_values.len())\n                .map(|index| fsize / (fsize - index as f64))\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::BenjaminiYekutieli => {\n            let q: f64 = (1..=p_values.len()).map(|index| 1. / index as f64).sum();\n            let multiplier = (0..p_values.len())\n                .map(|index| q * fsize / (fsize - index as f64))\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::Bonferroni => p_vec\n            .iter()\n            .map(|p| f64::min(p * fsize, 1.0))\n            .collect::<Vec<_>>(),\n        CorrectionType::Hochberg => {\n            let multiplier = (0..p_values.len())\n                .map(|index| 1. + index as f64)\n                .collect::<Vec<_>>();\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Increasing)\n        }\n        CorrectionType::Holm => {\n            let multiplier = (0..p_values.len())\n                .map(|index| fsize - index as f64)\n                .collect::<Vec<_>>();\n\n            ordered_multiply(&p_vec, &multiplier, &SortDirection::Decreasing)\n        }\n        CorrectionType::Sidak => p_vec\n            .iter()\n            .map(|x| 1. - (1. - x).powf(fsize))\n            .collect::<Vec<_>>(),\n        CorrectionType::Hommel => hommel(&p_vec),\n    }\n}\n\n// prints array into a nice table, max 5 floats/row\nfn array_to_string(a: &[f64]) -> String {\n    a.chunks(5)\n        .enumerate()\n        .map(|(index, e)| {\n            format!(\n                \"[{:>2}]: {}\",\n                index * 5,\n                e.iter()\n                    .map(|x| format!(\"{:>1.10}\", x))\n                    .collect::<Vec<_>>()\n                    .join(\", \")\n            )\n        })\n        .collect::<Vec<_>>()\n        .join(\"\\n\")\n}\nfn main() {\n    let ctypes = [\n        CorrectionType::BenjaminiHochberg,\n        CorrectionType::BenjaminiYekutieli,\n        CorrectionType::Bonferroni,\n        CorrectionType::Hochberg,\n        CorrectionType::Holm,\n        CorrectionType::Sidak,\n        CorrectionType::Hommel,\n    ];\n\n    for ctype in &ctypes {\n        println!(\"\\n{:?}:\", ctype);\n        println!(\"{}\", array_to_string(&p_value_correction(&PVALUES, ctype)));\n    }\n}\n",
    "title": "P-value correction",
    "url": "http://rosettacode.org/wiki/P-value_correction"
  },
  {
    "local_code": "fn padovan(n: u64, x: u64) -> u64 {\n    if n < 2 {\n        return 0;\n    }\n\n    match n {\n        2 if x <= n + 1 => 1,\n        2 => padovan(n, x - 2) + padovan(n, x - 3),\n        _ if x <= n + 1 => padovan(n - 1, x),\n        _ => ((x - n - 1)..(x - 1)).fold(0, |acc, value| acc + padovan(n, value)),\n    }\n}\nfn main() {\n    (2..=8).for_each(|n| {\n        print!(\"\\nN={}: \", n);\n        (1..=15).for_each(|x| print!(\"{},\", padovan(n, x)))\n    });\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_padovan() {\n        assert_eq!(padovan(1, 1), 0);\n        assert_eq!(padovan(2, 1), 1);\n        assert_eq!(padovan(2, 4), 2);\n        assert_eq!(padovan(6, 11), 51);\n        assert_eq!(padovan(8, 15), 362);\n    }\n}\n",
    "path": "tasks/padovan-n-step-number-sequences",
    "remote_code": "\nfn padovan(n: u64, x: u64) -> u64 {\n    if n < 2 {\n        return 0;\n    }\n\n    match n {\n        2 if x <= n + 1 => 1,\n        2 => padovan(n, x - 2) + padovan(n, x - 3),\n        _ if x <= n + 1 => padovan(n - 1, x),\n        _ => ((x - n - 1)..(x - 1)).fold(0, |acc, value| acc + padovan(n, value)),\n    }\n}\nfn main() {\n    (2..=8).for_each(|n| {\n        print!(\"\\nN={}: \", n);\n        (1..=15).for_each(|x| print!(\"{},\", padovan(n, x)))\n    });\n}\n\n",
    "title": "Padovan n-step number sequences",
    "url": "http://rosettacode.org/wiki/Padovan_n-step_number_sequences"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn padovan_recur() -> impl std::iter::Iterator<Item = usize> {\n    let mut p = vec![1, 1, 1];\n    let mut n = 0;\n    std::iter::from_fn(move || {\n        let pn = if n < 3 { p[n] } else { p[0] + p[1] };\n        p[0] = p[1];\n        p[1] = p[2];\n        p[2] = pn;\n        n += 1;\n        Some(pn)\n    })\n}\n\nfn padovan_floor() -> impl std::iter::Iterator<Item = usize> {\n    const P: f64 = 1.324717957244746025960908854;\n    const S: f64 = 1.0453567932525329623;\n    (0..).map(|x| (P.powf((x - 1) as f64) / S + 0.5).floor() as usize)\n}\n\nfn padovan_lsystem() -> impl std::iter::Iterator<Item = String> {\n    let mut str = String::from(\"A\");\n    std::iter::from_fn(move || {\n        let result = str.clone();\n        let mut next = String::new();\n        for ch in str.chars() {\n            match ch {\n                'A' => next.push('B'),\n                'B' => next.push('C'),\n                _ => next.push_str(\"AB\"),\n            }\n        }\n        str = next;\n        Some(result)\n    })\n}\n\nfn main() {\n    println!(\"First 20 terms of the Padovan sequence:\");\n    for p in padovan_recur().take(20) {\n        print!(\"{} \", p);\n    }\n    println!();\n\n    println!(\n        \"\\nRecurrence and floor functions agree for first 64 terms? {}\",\n        padovan_recur().take(64).eq(padovan_floor().take(64))\n    );\n\n    println!(\"\\nFirst 10 strings produced from the L-system:\");\n    for p in padovan_lsystem().take(10) {\n        print!(\"{} \", p);\n    }\n    println!();\n\n    println!(\n        \"\\nLength of first 32 strings produced from the L-system = Padovan sequence? {}\",\n        padovan_lsystem()\n            .map(|x| x.len())\n            .take(32)\n            .eq(padovan_recur().take(32))\n    );\n}",
    "title": "Padovan sequence",
    "url": "http://rosettacode.org/wiki/Padovan_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// chrono = \"0.4\"\n\nfn is_palindrome(s: &str) -> bool {\n    s.chars().rev().eq(s.chars())\n}\n\nfn main() {\n    let mut date = chrono::Utc::today();\n    let mut count = 0;\n    while count < 15 {\n        if is_palindrome(&date.format(\"%Y%m%d\").to_string()) {\n            println!(\"{}\", date.format(\"%F\"));\n            count += 1;\n        }\n        date = date.succ();\n    }\n}",
    "title": "Palindrome dates",
    "url": "http://rosettacode.org/wiki/Palindrome_dates"
  },
  {
    "local_code": "/// Returns true if the string is a palindrome\nfn palindrome(string: &str) -> bool {\n    // The first part of the string\n    let forward = string.chars().take(string.len() / 2);\n\n    // The second part of the string in reverse order\n    let reverse = string.chars().rev().take(string.len() / 2);\n\n    // We group the two parts of the string in tuples\n    let mut both_directions = forward.zip(reverse);\n\n    // The word is a palindrome if each tuple contains two times\n    // the same character\n    both_directions.all(|(a, b)| a == b)\n}\n\nfn main() {\n    let test_strings = [\"nope\", \"eevee\", \"lalala\", \"rust\", \"lalalal\"];\n    for &string in &test_strings {\n        println!(\"{}: {}\", string, palindrome(string));\n    }\n}\n\n#[test]\nfn test_palindromes() {\n    let palindromes = [\"eevee\", \"lalalal\", \"オオオオ\", \"\", \"anna\"];\n    let non_palindromes = [\"nope\", \"lalala\", \"car\", \"rain\", \"house\", \"computer\", \"rust\"];\n\n    assert!(palindromes.iter().all(|&s| palindrome(s)));\n    assert!(non_palindromes.iter().all(|&s| !palindrome(s)));\n}\n",
    "path": "tasks/palindrome-detection",
    "remote_code": "fn is_palindrome(string: &str) -> bool {\n    let half_len = string.len() / 2;\n    string\n        .chars()\n        .take(half_len)\n        .eq(string.chars().rev().take(half_len))\n}\n\nmacro_rules! test {\n    ( $( $x:tt ),* ) => { $( println!(\"'{}': {}\", $x, is_palindrome($x)); )* };\n}\n\nfn main() {\n    test!(\n        \"\",\n        \"a\",\n        \"ada\",\n        \"adad\",\n        \"ingirumimusnocteetconsumimurigni\",\n        \"人人為我,我為人人\",\n        \"Я иду с мечем, судия\",\n        \"아들딸들아\",\n        \"The quick brown fox\"\n    );\n}",
    "title": "Palindrome detection",
    "url": "http://rosettacode.org/wiki/Palindrome_detection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn palindromicgapfuls(digit: u64, count: u64, keep: usize) -> Vec<u64> {\n  let mut palcnt = 0u64;               // count of gapful palindromes\n  let to_skip = count - keep as u64;   // count of unwanted values to skip\n  let mut gapfuls: Vec<u64> = vec![];  // array of palindromic gapfuls\n  let nn = digit * 11;                 // digit gapful divisor: 11, 22,...88, 99\n  let (mut power, mut base) = (1, 1u64);\n  loop { power += 1;\n    if power & 1 == 0 { base *= 10 };  // value of middle digit position: 10..\n    let base11  = base * 11;           // value of middle two digits positions: 110..\n    let this_lo = base * digit;        // starting half for this digit: 10.. to  90..\n    let next_lo = base * (digit + 1);  // starting half for next digit: 20.. to 100..\n    for front_half in (this_lo..next_lo-1).step_by(10) { // d_00; d_10; d_20; ...\n      let (mut left_half, mut basep) = (front_half.to_string(), 0);\n      let right_half = left_half.chars().rev().collect::<String>();\n      if power & 1 == 1 { basep = base11; left_half.push_str(&right_half) }\n      else              { basep = base;   left_half.pop(); left_half.push_str(&right_half) };\n      let mut palindrome = left_half.parse::<u64>().unwrap();\n      for _ in 0..10 {\n        if palindrome % nn == 0 { palcnt += 1; if palcnt > to_skip { gapfuls.push(palindrome) } };\n        palindrome += basep;\n      } \n      if gapfuls.len() >= keep { return gapfuls[0..keep].to_vec() };\n    }\n  }\n}\n\nfn main() {\n  let t = std::time::Instant::now();  \n  \n  let (count, keep) = (20, 20);\n  println!(\"First 20 palindromic gapful numbers ending with:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  let (count, keep) = (100, 15);\n  println!(\"\\nLast 15 of first 100 palindromic gapful numbers ending in:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  let (count, keep) = (1_000, 10);\n  println!(\"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  let (count, keep) = (100_000, 1);\n  println!(\"\\n100,000th palindromic gapful number ending with:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  let (count, keep) = (1_000_000, 1);\n  println!(\"\\n1,000,000th palindromic gapful number ending with:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  let (count, keep) = (10_000_000, 1);\n  println!(\"\\n10,000,000th palindromic gapful number ending with:\");\n  for digit in 1..10 { println!(\"{} : {:?}\", digit, palindromicgapfuls(digit, count, keep)); }  \n  \n  println!(\"{:?}\", t.elapsed())\n}",
    "title": "Palindromic gapful numbers",
    "url": "http://rosettacode.org/wiki/Palindromic_gapful_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pancake numbers",
    "url": "http://rosettacode.org/wiki/Pancake_numbers"
  },
  {
    "local_code": "use criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nuse pangram_checker::{is_pangram_via_bitmask, is_pangram_via_hashset, is_pangram_via_sort};\n\nstatic PANGRAM: &str = \"The quick brown fox jumps over the lazy dog\";\n\nfn benchmark(c: &mut Criterion) {\n    c.bench_function(\"sort\", |b| {\n        b.iter(|| is_pangram_via_sort(black_box(PANGRAM)))\n    });\n    c.bench_function(\"bitmask\", |b| {\n        b.iter(|| is_pangram_via_bitmask(black_box(PANGRAM)))\n    });\n    c.bench_function(\"hashset\", |b| {\n        b.iter(|| is_pangram_via_hashset(black_box(PANGRAM)))\n    });\n}\n\ncriterion_group!(benches, benchmark);\ncriterion_main!(benches);\nuse std::collections::HashSet;\n\npub fn is_pangram_via_bitmask(s: &str) -> bool {\n    // Create a mask of set bits and convert to false as we find characters.\n    let mut mask = (1 << 26) - 1;\n\n    for chr in s.chars() {\n        let val = chr as u32 & !0x20; /* 0x20 converts lowercase to upper */\n        if val <= 'Z' as u32 && val >= 'A' as u32 {\n            mask &= !(1 << (val - 'A' as u32));\n        }\n    }\n\n    mask == 0\n}\n\npub fn is_pangram_via_hashset(s: &str) -> bool {\n    // Insert lowercase letters into a HashSet, then check if we have at least 26.\n    let letters = s\n        .chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| ('a'..='z').contains(&chr))\n        .fold(HashSet::new(), |mut letters, chr| {\n            letters.insert(chr);\n            letters\n        });\n\n    letters.len() == 26\n}\n\npub fn is_pangram_via_sort(s: &str) -> bool {\n    // Copy chars into a vector, convert to lowercase, sort, and remove duplicates.\n    let mut chars: Vec<char> = s\n        .chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| ('a'..='z').contains(&chr))\n        .collect();\n\n    chars.sort_unstable();\n    chars.dedup();\n\n    chars.len() == 26\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sort() {\n        assert!(is_pangram_via_sort(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_sort(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n\n    #[test]\n    fn test_bitmask() {\n        assert!(is_pangram_via_bitmask(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_bitmask(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n\n    #[test]\n    fn test_hashset() {\n        assert!(is_pangram_via_hashset(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_hashset(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n}\nuse std::collections::HashSet;\n\n/// Returns true if the sentence uses all 26 letters in the English\n/// alphabet at least once.\nfn is_pangram(sentence: &str) -> bool {\n    sentence\n        .chars()\n        .map(|c| c.to_lowercase().next().unwrap())\n        .filter(|&c| ('a'..='z').contains(&c))\n        .collect::<HashSet<char>>()\n        .len()\n        == 26\n}\n\nfn main() {\n    let test_sentences = [\n        \"The quick brown fox jumps over the lazy dog.\",\n        \"The quick brown frog jumps over the lazy dog.\",\n    ];\n    for &sentence in &test_sentences {\n        println!(\n            \"\\\"{}\\\" {} a pangram\",\n            sentence,\n            if is_pangram(sentence) { \"is\" } else { \"is not\" }\n        );\n    }\n}\n\n#[test]\nfn test_empty() {\n    assert_eq!(is_pangram(\"\"), false);\n}\n\n#[test]\nfn test_one_letter() {\n    assert_eq!(is_pangram(\"A\"), false);\n}\n\n#[test]\nfn test_pangram() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox jumps over the lazy dog\"),\n        true\n    );\n}\n\n#[test]\nfn test_non_pangram() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox jumps over the lurking dog\"),\n        false\n    );\n}\n\n#[test]\nfn test_pangram_unicode() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox (狐狸) jumps over the lazy dog\"),\n        true\n    );\n}\n\n#[test]\nfn test_non_pangram_unicode() {\n    assert_eq!(\n        is_pangram(\"The quick brown 狐狸 jumps over the lazy dog\"),\n        false\n    );\n}\nuse pangram_checker::{is_pangram_via_bitmask, is_pangram_via_hashset, is_pangram_via_sort};\n\nfn main() {\n    let examples = [\n        \"The quick brown fox jumps over the lazy dog\",\n        \"The quick white cat jumps over the lazy dog\",\n    ];\n\n    for &text in &examples {\n        let is_pangram_sort = is_pangram_via_sort(text);\n        println!(\"Is \\\"{}\\\" a pangram via sort? - {}\", text, is_pangram_sort);\n\n        let is_pangram_bitmask = is_pangram_via_bitmask(text);\n        println!(\n            \"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n            text, is_pangram_bitmask\n        );\n\n        let is_pangram_hashset = is_pangram_via_hashset(text);\n        println!(\n            \"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n            text, is_pangram_hashset\n        );\n    }\n}\n",
    "path": "tasks/pangram-checker",
    "remote_code": "#![feature(test)]\n\nextern crate test;\n\nuse std::collections::HashSet;\n\npub fn is_pangram_via_bitmask(s: &str) -> bool {\n\n    // Create a mask of set bits and convert to false as we find characters.\n    let mut mask = (1 << 26) - 1;\n\n    for chr in s.chars() {\n        let val = chr as u32 & !0x20; /* 0x20 converts lowercase to upper */\n        if val <= 'Z' as u32 && val >= 'A' as u32 {\n            mask = mask & !(1 << (val - 'A' as u32));\n        }\n    }\n\n    mask == 0\n}\n\npub fn is_pangram_via_hashset(s: &str) -> bool {\n\n    // Insert lowercase letters into a HashSet, then check if we have at least 26.\n    let letters = s.chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .fold(HashSet::new(), |mut letters, chr| {\n            letters.insert(chr);\n            letters\n        });\n\n    letters.len() == 26\n}\n\npub fn is_pangram_via_sort(s: &str) -> bool {\n\n    // Copy chars into a vector, convert to lowercase, sort, and remove duplicates.\n    let mut chars: Vec<char> = s.chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .collect();\n\n    chars.sort();\n    chars.dedup();\n\n    chars.len() == 26\n}\n\nfn main() {\n\n    let examples = [\"The quick brown fox jumps over the lazy dog\",\n                    \"The quick white cat jumps over the lazy dog\"];\n\n    for &text in examples.iter() {\n        let is_pangram_sort = is_pangram_via_sort(text);\n        println!(\"Is \\\"{}\\\" a pangram via sort? - {}\", text, is_pangram_sort);\n\n        let is_pangram_bitmask = is_pangram_via_bitmask(text);\n        println!(\"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n                 text,\n                 is_pangram_bitmask);\n\n        let is_pangram_hashset = is_pangram_via_hashset(text);\n        println!(\"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n                 text,\n                 is_pangram_hashset);\n    }\n}",
    "title": "Pangram checker",
    "url": "http://rosettacode.org/wiki/Pangram_checker"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Paraffins",
    "url": "http://rosettacode.org/wiki/Paraffins"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rust-crypto = \"0.2.36\"\n// num_cpus = \"1.7.0\"\n// hex = \"0.2.0\"\n\nextern crate crypto;\nextern crate num_cpus;\nextern crate hex;\n\nuse std::thread;\nuse std::cmp::min;\nuse crypto::sha2::Sha256;\nuse crypto::digest::Digest;\nuse hex::{FromHex, ToHex};\n\nfn main() {\n    let hashes = vec![\n        decode(\"1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad\"),\n        decode(\"3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b\"),\n        decode(\"74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f\"),\n    ];\n\n    let mut threads = Vec::new();\n    let mut ranges = distribute_work();\n\n    while let Some(range) = ranges.pop() {\n        let hashes = hashes.clone();\n        threads.push(thread::spawn(\n            move || search(range.0, range.1, hashes.clone()),\n        ));\n    }\n\n    while let Some(t) = threads.pop() {\n        t.join().ok();\n    }\n}\n\nfn search(from: [u8; 5], to: [u8; 5], hashes: Vec<[u8; 256 / 8]>) {\n\n    let mut password = from.clone();\n\n    while password <= to {\n        let mut sha256 = Sha256::new();\n        sha256.input(&password);\n        let mut result = [0u8; 256 / 8];\n        sha256.result(&mut result);\n\n        for hash in hashes.iter() {\n            if *hash == result {\n                println!(\n                    \"{}{}{}{}{} {}\",\n                    password[0] as char,\n                    password[1] as char,\n                    password[2] as char,\n                    password[3] as char,\n                    password[4] as char,\n                    hash.to_hex()\n                );\n            }\n        }\n\n        password = next(&password);\n    }\n\n}\n\nfn next(password: &[u8; 5]) -> [u8; 5] {\n    let mut result = password.clone();\n    for i in (0..result.len()).rev() {\n        if result[i] == b'z' {\n            if i == 0 {\n                result[i] = b'z' + 1;\n            } else {\n                result[i] = b'a';\n            }\n        } else {\n            result[i] += 1;\n            break;\n        }\n    }\n    result.clone()\n}\n\nfn distribute_work() -> Vec<([u8; 5], [u8; 5])> {\n    let mut ranges = Vec::new();\n    let num_cpus = min(num_cpus::get(), 26) as u8;\n\n    let div = 25 / num_cpus;\n    let mut remainder = 25 % num_cpus;\n    let mut from = b'a';\n    while from < b'z' {\n\n        let to = from + div +\n            if remainder > 0 {\n                remainder -= 1;\n                1\n            } else {\n                0\n            };\n\n        ranges.push((\n            [from, from, from, from, from + 1].clone(),\n            [to, to, to, to, to].clone(),\n        ));\n\n        from = to;\n    }\n    ranges[0].0[4] = b'a';\n\n    ranges.clone()\n}\n\nfn decode(string: &str) -> [u8; 256 / 8] {\n    let mut result = [0; 256 / 8];\n    let vec = Vec::from_hex(string).unwrap();\n    for i in 0..result.len() {\n        result[i] = vec[i];\n    }\n    result.clone()\n}",
    "title": "Parallel brute force",
    "url": "http://rosettacode.org/wiki/Parallel_brute_force"
  },
  {
    "local_code": "//! This solution uses [rayon](https://github.com/rayon-rs/rayon), a data-parallelism library.\n//! Since Rust guarantees that a program has no data races, adding parallelism to a sequential\n//! computation is as easy as importing the rayon traits and calling the `par_iter()` method.\n\nextern crate rayon;\n\nextern crate prime_decomposition;\n\nuse rayon::prelude::*;\n\n/// Returns the largest minimal factor of the numbers in a slice\npub fn largest_min_factor(numbers: &[usize]) -> usize {\n    numbers\n        .par_iter()\n        .map(|n| {\n            // `factor` returns a sorted vector, so we just take the first element.\n            prime_decomposition::factor(*n)[0]\n        })\n        .max()\n        .unwrap()\n}\n\nfn main() {\n    let numbers = &[\n        1_122_725, 1_125_827, 1_122_725, 1_152_800, 1_157_978, 1_099_726,\n    ];\n    let max = largest_min_factor(numbers);\n    println!(\"The largest minimal factor is {}\", max);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::largest_min_factor;\n\n    #[test]\n    fn test_basic() {\n        let numbers = &[25, 80, 256, 55, 18, 19];\n        assert_eq!(largest_min_factor(numbers), 19);\n    }\n}\n",
    "path": "tasks/parallel-calculations",
    "remote_code": "\n//! This solution uses [rayon](https://github.com/rayon-rs/rayon), a data-parallelism library.\n//! Since Rust guarantees that a program has no data races, adding parallelism to a sequential\n//! computation is as easy as importing the rayon traits and calling the `par_iter()` method.\n\nextern crate rayon;\n\nextern crate prime_decomposition;\n\nuse rayon::prelude::*;\n\n/// Returns the largest minimal factor of the numbers in a slice\npub fn largest_min_factor(numbers: &[usize]) -> usize {\n    numbers\n        .par_iter()\n        .map(|n| {\n            // `factor` returns a sorted vector, so we just take the first element.\n            prime_decomposition::factor(*n)[0]\n        })\n        .max()\n        .unwrap()\n}\n\nfn main() {\n    let numbers = &[\n        1_122_725, 1_125_827, 1_122_725, 1_152_800, 1_157_978, 1_099_726,\n    ];\n    let max = largest_min_factor(numbers);\n    println!(\"The largest minimal factor is {}\", max);\n}\n",
    "title": "Parallel calculations",
    "url": "http://rosettacode.org/wiki/Parallel_calculations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parameterized SQL statement",
    "url": "http://rosettacode.org/wiki/Parameterized_SQL_statement"
  },
  {
    "local_code": "struct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\nimpl<T> TreeNode<T> {\n    fn my_map<U, F>(&self, f: &F) -> TreeNode<U>\n    where\n        F: Fn(&T) -> U,\n    {\n        TreeNode {\n            value: f(&self.value),\n            left: self.left.as_ref().map(|n| Box::new(n.my_map(f))),\n            right: self.right.as_ref().map(|n| Box::new(n.my_map(f))),\n        }\n    }\n}\n\nfn main() {\n    let root = TreeNode {\n        value: 3,\n        left: Some(Box::new(TreeNode {\n            value: 55,\n            left: None,\n            right: None,\n        })),\n        right: Some(Box::new(TreeNode {\n            value: 234,\n            left: Some(Box::new(TreeNode {\n                value: 0,\n                left: None,\n                right: None,\n            })),\n            right: None,\n        })),\n    };\n    root.my_map(&|x| println!(\"{}\", x));\n    println!(\"---------------\");\n    let new_root = root.my_map(&|x| f64::from(*x) * 333.333);\n    new_root.my_map(&|x| println!(\"{}\", x));\n}\n",
    "path": "tasks/parametric-polymorphism",
    "remote_code": "struct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\nimpl <T> TreeNode<T> {\n    fn my_map<U,F>(&self, f: &F) -> TreeNode<U> where\n            F: Fn(&T) -> U {\n        TreeNode {\n            value: f(&self.value),\n            left: match self.left {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n            right: match self.right {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n        }\n    }\n}\n\nfn main() {\n    let root = TreeNode {\n        value: 3,\n        left: Some(Box::new(TreeNode {\n            value: 55,\n            left: None,\n            right: None,\n        })),\n        right: Some(Box::new(TreeNode {\n            value: 234,\n            left: Some(Box::new(TreeNode {\n                value: 0,\n                left: None,\n                right: None,\n            })),\n            right: None,\n        })),\n    };\n    root.my_map(&|x| { println!(\"{}\" , x)});\n    println!(\"---------------\");\n    let new_root = root.my_map(&|x| *x as f64 * 333.333f64);\n    new_root.my_map(&|x| { println!(\"{}\" , x) });\n}",
    "title": "Parametric polymorphism",
    "url": "http://rosettacode.org/wiki/Parametric_polymorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    net::{IpAddr, SocketAddr},\n    str::FromStr,\n};\n\n#[derive(Clone, Debug)]\nstruct Addr {\n    addr: IpAddr,\n    port: Option<u16>,\n}\n\nimpl std::fmt::Display for Addr {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let ipv = if self.addr.is_ipv4() { \"4\" } else { \"6\" };\n\n        let hex = match self.addr {\n            IpAddr::V4(addr) => u32::from(addr) as u128,\n            IpAddr::V6(addr) => u128::from(addr),\n        };\n\n        match self.port {\n            Some(p) => write!(\n                f,\n                \"address: {}, port: {}, hex: {:x} (IPv{})\",\n                self.addr, p, hex, ipv\n            ),\n\n            None => write!(\n                f,\n                \"address: {}, port: N/A, hex: {:x} (IPv{}) \",\n                self.addr, hex, ipv\n            ),\n        }\n    }\n}\n\nimpl FromStr for Addr {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if let Ok(addr) = s.parse::<IpAddr>() {\n            Ok(Self { addr, port: None })\n        } else if let Ok(sock) = s.parse::<SocketAddr>() {\n            Ok(Self {\n                addr: sock.ip(),\n                port: Some(sock.port()),\n            })\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn print_addr(s: &str) {\n    match s.parse::<Addr>() {\n        Ok(addr) => println!(\"{}: {}\", s, addr),\n        _ => println!(\"{} not a valid address\", s),\n    }\n}\n\nfn main() {\n    [\n        \"127.0.0.1\",\n        \"127.0.0.1:80\",\n        \"::1\",\n        \"[::1]:80\",\n        \"2605:2700:0:3::4713:93e3\",\n        \"[2605:2700:0:3::4713:93e3]:80\",\n    ]\n    .iter()\n    .cloned()\n    .for_each(print_addr);\n}",
    "title": "Parse an IP Address",
    "url": "http://rosettacode.org/wiki/Parse_an_IP_Address"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn rpn(text: &str) -> f64 {\n    let tokens = text.split_whitespace();\n    let mut stack: Vec<f64> = vec![];\n    println!(\"input operation stack\");\n\n    for token in tokens {\n        print!(\"{:^5} \", token);\n        match token.parse() {\n            Ok(num) => {\n                stack.push(num);\n                println!(\"push      {:?}\", stack);\n            }\n            Err(_) => {\n                match token {\n                    \"+\" => {\n                        let b = stack.pop().expect(\"missing first operand\");\n                        let a = stack.pop().expect(\"missing second operand\");\n                        stack.push(a + b);\n                    }\n                    \"-\" => {\n                        let b = stack.pop().expect(\"missing first operand\");\n                        let a = stack.pop().expect(\"missing second operand\");\n                        stack.push(a - b);\n                    }\n                    \"*\" => {\n                        let b = stack.pop().expect(\"missing first operand\");\n                        let a = stack.pop().expect(\"missing second operand\");\n                        stack.push(a * b);\n                    }\n                    \"/\" => {\n                        let b = stack.pop().expect(\"missing first operand\");\n                        let a = stack.pop().expect(\"missing second operand\");\n                        stack.push(a / b);\n                    }\n                    \"^\" => {\n                        let b = stack.pop().expect(\"missing first operand\");\n                        let a = stack.pop().expect(\"missing second operand\");\n                        stack.push(a.powf(b));\n                    }\n                    _ => panic!(\"unknown operator {}\", token),\n                }\n                println!(\"calculate {:?}\", stack);\n            }\n        }\n    }\n\n    stack.pop().unwrap_or(0.0)\n}\n\nfn main() {\n    let text = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n\n    println!(\"\\nresult: {}\", rpn(text));\n}",
    "title": "Parsing/RPN calculator algorithm",
    "url": "http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parsing/RPN to infix conversion",
    "url": "http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "type Number = f64;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Operator {\n    token: char,\n    operation: fn(Number, Number) -> Number,\n    precedence: u8,\n    is_left_associative: bool,\n}\n\n#[derive(Debug, Clone, PartialEq)]\nenum Token {\n    Digit(Number),\n    Operator(Operator),\n    LeftParen,\n    RightParen,\n}\n\nimpl Operator {\n    fn new_token(\n        token: char,\n        precedence: u8,\n        is_left_associative: bool,\n        operation: fn(Number, Number) -> Number,\n    ) -> Token {\n        Token::Operator(Operator {\n            token: token,\n            operation: operation,\n            precedence: precedence,\n            is_left_associative,\n        })\n    }\n\n    fn apply(&self, x: Number, y: Number) -> Number {\n        (self.operation)(x, y)\n    }\n}\n\ntrait Stack<T> {\n    fn top(&self) -> Option<T>;\n}\n\nimpl<T: Clone> Stack<T> for Vec<T> {\n    fn top(&self) -> Option<T> {\n        if self.is_empty() {\n            return None;\n        }\n        self.last().cloned()\n    }\n}\nfn lex_token(input: char) -> Result<Token, char> {\n    let ret = match input {\n        '0'...'9' => Token::Digit(input.to_digit(10).unwrap() as Number),\n        '+' => Operator::new_token('+', 1, true, |x, y| x + y),\n        '-' => Operator::new_token('-', 1, true, |x, y| x - y),\n        '*' => Operator::new_token('*', 2, true, |x, y| x * y),\n        '/' => Operator::new_token('/', 2, true, |x, y| x / y),\n        '^' => Operator::new_token('^', 3, false, |x, y| x.powf(y)),\n        '(' => Token::LeftParen,\n        ')' => Token::RightParen,\n        _ => return Err(input),\n    };\n    Ok(ret)\n}\n\nfn lex(input: String) -> Result<Vec<Token>, char> {\n    input\n        .chars()\n        .filter(|c| !c.is_whitespace())\n        .map(lex_token)\n        .collect()\n}\n\nfn tilt_until(operators: &mut Vec<Token>, output: &mut Vec<Token>, stop: Token) -> bool {\n    while let Some(token) = operators.pop() {\n        if token == stop {\n            return true;\n        }\n        output.push(token)\n    }\n    false\n}\n\nfn shunting_yard(tokens: Vec<Token>) -> Result<Vec<Token>, String> {\n    let mut output: Vec<Token> = Vec::new();\n    let mut operators: Vec<Token> = Vec::new();\n\n    for token in tokens {\n        match token {\n            Token::Digit(_) => output.push(token),\n            Token::LeftParen => operators.push(token),\n            Token::Operator(operator) => {\n                while let Some(top) = operators.top() {\n                    match top {\n                        Token::LeftParen => break,\n                        Token::Operator(top_op) => {\n                            let p = top_op.precedence;\n                            let q = operator.precedence;\n                            if (p > q) || (p == q && operator.is_left_associative) {\n                                output.push(operators.pop().unwrap());\n                            } else {\n                                break;\n                            }\n                        }\n                        _ => unreachable!(\"{:?} must not be on operator stack\", token),\n                    }\n                }\n                operators.push(token);\n            }\n            Token::RightParen => {\n                if !tilt_until(&mut operators, &mut output, Token::LeftParen) {\n                    return Err(String::from(\"Mismatched ')'\"));\n                }\n            }\n        }\n    }\n\n    if tilt_until(&mut operators, &mut output, Token::LeftParen) {\n        return Err(String::from(\"Mismatched '('\"));\n    }\n\n    assert!(operators.is_empty());\n    Ok(output)\n}\n\nfn calculate(postfix_tokens: Vec<Token>) -> Result<Number, String> {\n    let mut stack = Vec::new();\n\n    for token in postfix_tokens {\n        match token {\n            Token::Digit(number) => stack.push(number),\n            Token::Operator(operator) => {\n                if let Some(y) = stack.pop() {\n                    if let Some(x) = stack.pop() {\n                        stack.push(operator.apply(x, y));\n                        continue;\n                    }\n                }\n                return Err(format!(\"Missing operand for operator '{}'\", operator.token));\n            }\n            _ => unreachable!(\"Unexpected token {:?} during calculation\", token),\n        }\n    }\n\n    assert!(stack.len() == 1);\n    Ok(stack.pop().unwrap())\n}\n\nfn run(input: String) -> Result<Number, String> {\n    let tokens = match lex(input) {\n        Ok(tokens) => tokens,\n        Err(c) => return Err(format!(\"Invalid character: {}\", c)),\n    };\n    let postfix_tokens = match shunting_yard(tokens) {\n        Ok(tokens) => tokens,\n        Err(message) => return Err(message),\n    };\n\n    calculate(postfix_tokens)\n}",
    "title": "Parsing/Shunting-yard algorithm",
    "url": "http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Partial function application",
    "url": "http://rosettacode.org/wiki/Partial_function_application"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Particle fountain",
    "url": "http://rosettacode.org/wiki/Particle_fountain"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// main.rs\nmod bit_array;\nmod prime_sieve;\n\nuse prime_sieve::PrimeSieve;\n\nfn find_prime_partition(\n    sieve: &PrimeSieve,\n    number: usize,\n    count: usize,\n    min_prime: usize,\n    primes: &mut Vec<usize>,\n    index: usize,\n) -> bool {\n    if count == 1 {\n        if number >= min_prime && sieve.is_prime(number) {\n            primes[index] = number;\n            return true;\n        }\n        return false;\n    }\n    for p in min_prime..number {\n        if sieve.is_prime(p)\n            && find_prime_partition(sieve, number - p, count - 1, p + 1, primes, index + 1)\n        {\n            primes[index] = p;\n            return true;\n        }\n    }\n    false\n}\n\nfn print_prime_partition(sieve: &PrimeSieve, number: usize, count: usize) {\n    let mut primes = vec![0; count];\n    if !find_prime_partition(sieve, number, count, 2, &mut primes, 0) {\n        println!(\"{} cannot be partitioned into {} primes.\", number, count);\n    } else {\n        print!(\"{} = {}\", number, primes[0]);\n        for i in 1..count {\n            print!(\" + {}\", primes[i]);\n        }\n        println!();\n    }\n}\n\nfn main() {\n    let s = PrimeSieve::new(100000);\n    print_prime_partition(&s, 99809, 1);\n    print_prime_partition(&s, 18, 2);\n    print_prime_partition(&s, 19, 3);\n    print_prime_partition(&s, 20, 4);\n    print_prime_partition(&s, 2017, 24);\n    print_prime_partition(&s, 22699, 1);\n    print_prime_partition(&s, 22699, 2);\n    print_prime_partition(&s, 22699, 3);\n    print_prime_partition(&s, 22699, 4);\n    print_prime_partition(&s, 40355, 3);\n}",
    "title": "Partition an integer x into n primes",
    "url": "http://rosettacode.org/wiki/Partition_an_integer_x_into_n_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.11\"\n\nuse rug::Integer;\n\nfn partitions(n: usize) -> Integer {\n    let mut p = Vec::with_capacity(n + 1);\n    p.push(Integer::from(1));\n    for i in 1..=n {\n        let mut num = Integer::from(0);\n        let mut k = 1;\n        loop {\n            let mut j = (k * (3 * k - 1)) / 2;\n            if j > i {\n                break;\n            }\n            if (k & 1) == 1 {\n                num += &p[i - j];\n            } else {\n                num -= &p[i - j];\n            }\n            j += k;\n            if j > i {\n                break;\n            }\n            if (k & 1) == 1 {\n                num += &p[i - j];\n            } else {\n                num -= &p[i - j];\n            }\n            k += 1;\n        }\n        p.push(num);\n    }\n    p[n].clone()\n}\n\nfn main() {\n    use std::time::Instant;\n    let n = 6666;\n    let now = Instant::now();\n    let result = partitions(n);\n    let time = now.elapsed();\n    println!(\"P({}) = {}\", n, result);\n    println!(\"elapsed time: {} microseconds\", time.as_micros());\n}",
    "title": "Partition function P",
    "url": "http://rosettacode.org/wiki/Partition_function_P"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pascal matrix generation",
    "url": "http://rosettacode.org/wiki/Pascal_matrix_generation"
  },
  {
    "local_code": "fn pascaltriangle(rows: usize) -> Vec<Vec<usize>> {\n    let mut all_rows = Vec::with_capacity(rows);\n\n    for row in 0..rows {\n        let mut row_vals = Vec::with_capacity(row + 1);\n        let mut value = 1;\n\n        for col in 0..row + 1 {\n            row_vals.push(value);\n            value = value * (row - col) / (col + 1)\n        }\n\n        all_rows.push(row_vals);\n    }\n\n    all_rows\n}\n\nfn printpascal(rows: &[Vec<usize>]) {\n    for (i, row) in rows.iter().enumerate() {\n        for _ in 0..(rows.len() - i) {\n            print!(\" \");\n        }\n\n        for col in row.iter() {\n            print!(\"{} \", col);\n        }\n\n        println!();\n    }\n}\n\nfn main() {\n    printpascal(&pascaltriangle(5));\n}\n\n#[test]\nfn test_triangle() {\n    assert_eq!(\n        pascaltriangle(5),\n        vec![\n            vec![1],\n            vec![1, 1],\n            vec![1, 2, 1],\n            vec![1, 3, 3, 1],\n            vec![1, 4, 6, 4, 1],\n        ]\n    );\n}\n",
    "path": "tasks/pascals-triangle",
    "remote_code": "\nfn pascal_triangle(n: u64)\n{\n\n  for i in 0..n {\n    let mut c = 1;\n    for _j in 1..2*(n-1-i)+1 {\n      print!(\" \");\n    }\n    for k in 0..i+1 {\n      print!(\"{:2} \", c);\n      c = c * (i-k)/(k+1);\n    }\n    println!();\n  }\n}\n",
    "title": "Pascal's triangle",
    "url": "http://rosettacode.org/wiki/Pascal's_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pascal's triangle/Puzzle",
    "url": "http://rosettacode.org/wiki/Pascal's_triangle/Puzzle"
  },
  {
    "local_code": "use rand::distributions::Alphanumeric;\nuse rand::prelude::IteratorRandom;\nuse rand::{thread_rng, Rng};\nuse std::iter;\nuse std::process;\nuse structopt::StructOpt;\nconst OTHER_VALUES: &str = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n\n// the core logic that creates our password\nfn generate_password(length: u8) -> String {\n    // cache thread_rng for better performance\n    let mut rng = thread_rng();\n    // the Alphanumeric struct provides 3/4\n    // of the characters for passwords\n    // so we can sample from it\n    let mut base_password: Vec<char> = iter::repeat(())\n        .map(|()| rng.sample(Alphanumeric))\n        .take(length as usize)\n        .collect();\n    let mut end_range = 10;\n    // if the user supplies a password length less than 10\n    // we need to adjust the random sample range\n    if length < end_range {\n        end_range = length;\n    }\n    // create a random count of how many other characters to add\n    let mut to_add = rng.gen_range(1, end_range as usize);\n    loop {\n        // create an iterator of required other characters\n        let special = OTHER_VALUES.chars().choose(&mut rng).unwrap();\n        to_add -= 1;\n        base_password[to_add] = special;\n        if to_add == 0 {\n            break;\n        }\n    }\n    base_password.iter().collect()\n}\n\n#[derive(StructOpt, Debug)]\n#[structopt(name = \"password-generator\", about = \"A simple password generator.\")]\nstruct Opt {\n    // make it SECURE by default\n    // https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n    /// The password length\n    #[structopt(default_value = \"160\")]\n    length: u8,\n    /// How many passwords to generate\n    #[structopt(default_value = \"1\")]\n    count: u8,\n}\n\nfn main() {\n    // instantiate the options and use them as\n    // arguments to our password generator\n    let opt = Opt::from_args();\n    const MINIMUM_LENGTH: u8 = 30;\n    if opt.length < MINIMUM_LENGTH {\n        eprintln!(\n            \"Please provide a password length greater than or equal to {}\",\n            MINIMUM_LENGTH\n        );\n        process::exit(1);\n    }\n    for index in 0..opt.count {\n        let password = generate_password(opt.length);\n        // do not print a newline after the last password\n        match index + 1 == opt.count {\n            true => print!(\"{}\", password),\n            _ => println!(\"{}\", password),\n        };\n    }\n}\n\n// keep it within this file for convenience\n#[cfg(test)]\nmod tests {\n    use super::generate_password;\n    use super::OTHER_VALUES;\n\n    // test our core password logic according to the rules described in the wiki\n    #[test]\n    fn generate_password_customizes_length() {\n        let a_password = generate_password(50);\n        assert_eq!(a_password.len(), 50);\n    }\n\n    #[test]\n    fn generate_password_has_numerals() {\n        assert!(generate_password(50).chars().any(|c| c.is_ascii_digit()));\n    }\n\n    #[test]\n    fn generate_password_has_upper_and_lowercase_characters() {\n        let password = generate_password(50);\n        // the following line only prints when this test fails\n        // you can see it printed by running `cargo test -- --nocapture`\n        println!(\"{}\", password);\n        assert!(password.chars().any(|c| c.is_ascii_lowercase()));\n        assert!(generate_password(50)\n            .chars()\n            .any(|c| c.is_ascii_uppercase()));\n    }\n\n    #[test]\n    fn generate_password_has_other_characters() {\n        let password = generate_password(10);\n        println!(\"{}\", password);\n        assert!(password.chars().any(|c| OTHER_VALUES.contains(c)));\n    }\n}\nuse std::process::Command;\n// files in tests/ directory are integration tests\n#[test]\n// add test to verify we cannot generate a password < 30 characters\nfn validate_password_length() {\n    let output = Command::new(\"cargo\")\n        .args(&[\"run\", \"--release\", \"--quiet\", \"0\"])\n        .output()\n        .expect(\"could not run cargo\");\n    let output = String::from_utf8_lossy(&output.stderr);\n    assert_eq!(\n        \"Please provide a password length greater than or equal to 30\",\n        output.trim()\n    );\n}\n",
    "path": "tasks/password-generator",
    "remote_code": "\nuse rand::distributions::Alphanumeric;\nuse rand::prelude::IteratorRandom;\nuse rand::{thread_rng, Rng};\nuse std::iter;\nuse std::process;\nuse structopt::StructOpt;\nconst OTHER_VALUES: &str = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n\n// the core logic that creates our password\nfn generate_password(length: u8) -> String {\n    // cache thread_rng for better performance\n    let mut rng = thread_rng();\n    // the Alphanumeric struct provides 3/4\n    // of the characters for passwords\n    // so we can sample from it\n    let mut base_password: Vec<char> = iter::repeat(())\n        .map(|()| rng.sample(Alphanumeric))\n        .take(length as usize)\n        .collect();\n    let mut end_range = 10;\n    // if the user supplies a password length less than 10\n    // we need to adjust the random sample range\n    if length < end_range {\n        end_range = length;\n    }\n    // create a random count of how many other characters to add\n    let mut to_add = rng.gen_range(1, end_range as usize);\n    loop {\n        // create an iterator of required other characters\n        let special = OTHER_VALUES.chars().choose(&mut rng).unwrap();\n        to_add -= 1;\n        base_password[to_add] = special;\n        if to_add == 0 {\n            break;\n        }\n    }\n    base_password.iter().collect()\n}\n\n#[derive(StructOpt, Debug)]\n#[structopt(name = \"password-generator\", about = \"A simple password generator.\")]\nstruct Opt {\n    // make it SECURE by default\n    // https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n    /// The password length\n    #[structopt(default_value = \"160\")]\n    length: u8,\n    /// How many passwords to generate\n    #[structopt(default_value = \"1\")]\n    count: u8,\n}\n\nfn main() {\n    // instantiate the options and use them as\n    // arguments to our password generator\n    let opt = Opt::from_args();\n    const MINIMUM_LENGTH: u8 = 30;\n    if opt.length < MINIMUM_LENGTH {\n        eprintln!(\n            \"Please provide a password length greater than or equal to {}\",\n            MINIMUM_LENGTH\n        );\n        process::exit(1);\n    }\n    for index in 0..opt.count {\n        let password = generate_password(opt.length);\n        // do not print a newline after the last password\n        match index + 1 == opt.count {\n            true => print!(\"{}\", password),\n            _ => println!(\"{}\", password),\n        };\n    }\n}\n",
    "title": "Password generator",
    "url": "http://rosettacode.org/wiki/Password_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pathological floating point problems",
    "url": "http://rosettacode.org/wiki/Pathological_floating_point_problems"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Peaceful chess queen armies",
    "url": "http://rosettacode.org/wiki/Peaceful_chess_queen_armies"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nuse svg::node::element::path::Data;\nuse svg::node::element::Path;\n\nstruct PeanoCurve {\n    current_x: f64,\n    current_y: f64,\n    current_angle: i32,\n    line_length: f64,\n}\n\nimpl PeanoCurve {\n    fn new(x: f64, y: f64, length: f64, angle: i32) -> PeanoCurve {\n        PeanoCurve {\n            current_x: x,\n            current_y: y,\n            current_angle: angle,\n            line_length: length,\n        }\n    }\n    fn rewrite(order: usize) -> String {\n        let mut str = String::from(\"L\");\n        for _ in 0..order {\n            let mut tmp = String::new();\n            for ch in str.chars() {\n                match ch {\n                    'L' => tmp.push_str(\"LFRFL-F-RFLFR+F+LFRFL\"),\n                    'R' => tmp.push_str(\"RFLFR+F+LFRFL-F-RFLFR\"),\n                    _ => tmp.push(ch),\n                }\n            }\n            str = tmp;\n        }\n        str\n    }\n    fn execute(&mut self, order: usize) -> Path {\n        let mut data = Data::new().move_to((self.current_x, self.current_y));\n        for ch in PeanoCurve::rewrite(order).chars() {\n            match ch {\n                'F' => data = self.draw_line(data),\n                '+' => self.turn(90),\n                '-' => self.turn(-90),\n                _ => {}\n            }\n        }\n        Path::new()\n            .set(\"fill\", \"none\")\n            .set(\"stroke\", \"black\")\n            .set(\"stroke-width\", \"1\")\n            .set(\"d\", data)\n    }\n    fn draw_line(&mut self, data: Data) -> Data {\n        let theta = (self.current_angle as f64).to_radians();\n        self.current_x += self.line_length * theta.cos();\n        self.current_y += self.line_length * theta.sin();\n        data.line_to((self.current_x, self.current_y))\n    }\n    fn turn(&mut self, angle: i32) {\n        self.current_angle = (self.current_angle + angle) % 360;\n    }\n    fn save(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n        use svg::node::element::Rectangle;\n        let rect = Rectangle::new()\n            .set(\"width\", \"100%\")\n            .set(\"height\", \"100%\")\n            .set(\"fill\", \"white\");\n        let mut p = PeanoCurve::new(8.0, 8.0, 8.0, 90);\n        let document = svg::Document::new()\n            .set(\"width\", size)\n            .set(\"height\", size)\n            .add(rect)\n            .add(p.execute(order));\n        svg::save(file, &document)\n    }\n}\n\nfn main() {\n    PeanoCurve::save(\"peano_curve.svg\", 656, 4).unwrap();\n}",
    "title": "Peano curve",
    "url": "http://rosettacode.org/wiki/Peano_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pell numbers",
    "url": "http://rosettacode.org/wiki/Pell_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse num_bigint::{ToBigInt, BigInt};\nuse num_traits::{Zero, One};\n//use std::mem::replace in the loop if you want this to be more efficient\n\nfn main() {\n    test(61u64);\n    test(109u64);\n    test(181u64);\n    test(277u64);\n}\n\nstruct Pair {\n    v1: BigInt,\n    v2: BigInt,\n}\n\nimpl Pair {\n    pub fn make_pair(a: &BigInt, b: &BigInt) -> Pair {\n        Pair {\n            v1: a.clone(),\n            v2: b.clone(),\n        }\n    }\n\n}\n\nfn solve_pell(n: u64) -> Pair{\n    let x: BigInt = ((n as f64).sqrt()).to_bigint().unwrap();\n    if x.clone() * x.clone() == n.to_bigint().unwrap() {\n        Pair::make_pair(&One::one(), &Zero::zero())\n    } else {\n        let mut y: BigInt = x.clone();\n        let mut z: BigInt = One::one();\n        let mut r: BigInt = ( &z + &z) * x.clone();\n        let mut e: Pair = Pair::make_pair(&One::one(), &Zero::zero());\n        let mut f: Pair = Pair::make_pair(&Zero::zero() ,&One::one());\n        let mut a: BigInt = Zero::zero();\n        let mut b: BigInt = Zero::zero();\n        while &a * &a - n * &b * &b != One::one() {\n            //println!(\"{}  {}  {}\", y, z, r);\n            y = &r * &z - &y;\n            z = (n - &y * &y) / &z;\n            r = (&x + &y) / &z;\n\n            e = Pair::make_pair(&e.v2, &(&r * &e.v2 + &e.v1));\n            f = Pair::make_pair(&f.v2, &(&r * &f.v2 + &f.v1));\n            a = &e.v2 + &x * &f.v2;\n            b = f.v2.clone();\n        }\n        let pa = &a;\n        let pb = &b;\n        Pair::make_pair(&pa.clone(), &pb.clone())\n    }\n}\n\nfn test(n: u64) {\n    let r: Pair = solve_pell(n);\n    println!(\"x^2 - {} * y^2 = 1 for x = {} and y = {}\", n, r.v1, r.v2);\n}\n",
    "title": "Pell's equation",
    "url": "http://rosettacode.org/wiki/Pell's_equation"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io::{stdin, stdout, Write};\nuse std::thread;\nuse std::time::Duration;\n\nuse rand::Rng;\n\nfn toss_coin<R: Rng>(rng: &mut R, print: bool) -> char {\n    let c = if rng.gen() { 'H' } else { 'T' };\n    if print {\n        print!(\"{}\", c);\n        stdout().flush().expect(\"Could not flush stdout\");\n    }\n    c\n}\n\nfn gen_sequence<R: Rng>(rng: &mut R, seed: Option<&str>) -> String {\n    let mut seq = String::new();\n    match seed {\n        Some(s) => {\n            let mut iter = s.chars();\n            let c0 = iter.next().unwrap();\n            let next = if c0 == 'H' { 'T' } else { 'H' };\n            seq.push(next);\n            seq.push(c0);\n            seq.push(iter.next().unwrap());\n        }\n        None => {\n            for _ in 0..3 {\n                seq.push(toss_coin(rng, false))\n            }\n        }\n    }\n    seq\n}\n\nfn read_sequence(used_seq: Option<&str>) -> String {\n    let mut seq = String::new();\n    loop {\n        seq.clear();\n        println!(\"Please, enter sequence of 3 coins: H (heads) or T (tails): \");\n        stdin().read_line(&mut seq).expect(\"failed to read line\");\n        seq = seq.trim().to_uppercase();\n        // do the cheapest test first\n        if seq.len() == 3\n            && seq.chars().all(|c| c == 'H' || c == 'T')\n            && seq != used_seq.unwrap_or(\"\")\n        {\n            return seq;\n        }\n\n        println!(\"Please enter correct sequence!\");\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"--Penney's game--\");\n    loop {\n        let useq: String;\n        let aiseq: String;\n        if rng.gen::<bool>() {\n            println!(\"You choose first!\");\n            useq = read_sequence(None);\n            println!(\"Your sequence: {}\", useq);\n            aiseq = gen_sequence(&mut rng, Some(&useq));\n            println!(\"My sequence: {}\", aiseq);\n        } else {\n            println!(\"I choose first!\");\n            aiseq = gen_sequence(&mut rng, None);\n            println!(\"My sequence: {}\", aiseq);\n            useq = read_sequence(Some(&aiseq));\n            println!(\"Your sequence: {}\", useq);\n        }\n        println!(\"Tossing coins...\");\n        let mut coins = String::new();\n        for _ in 0..2 {\n            // toss first 2 coins\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n        }\n        loop {\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n            if coins.contains(&useq) {\n                println!(\"\\nYou win!\");\n                break;\n            }\n            if coins.contains(&aiseq) {\n                println!(\"\\nI win!\");\n                break;\n            }\n        }\n\n        println!(\" Play again? 'Y' to play, 'Q' to exit.\");\n        let mut input = String::new();\n        stdin().read_line(&mut input).expect(\"failed to read line\");\n        match input.trim_start().chars().next().unwrap() {\n            'Y' | 'y' => continue,\n            _ => break,\n        }\n    }\n}\n",
    "path": "tasks/penneys-game",
    "remote_code": "\nextern crate rand;\n\nuse std::io::{stdin, stdout, Write};\nuse std::thread;\nuse std::time::Duration;\n\nuse rand::Rng;\n\nfn toss_coin<R: Rng>(rng: &mut R, print: bool) -> char {\n    let c = if rng.gen() { 'H' } else { 'T' };\n    if print {\n        print!(\"{}\", c);\n        stdout().flush().expect(\"Could not flush stdout\");\n    }\n    c\n}\n\nfn gen_sequence<R: Rng>(rng: &mut R, seed: Option<&str>) -> String {\n    let mut seq = String::new();\n    match seed {\n        Some(s) => {\n            let mut iter = s.chars();\n            let c0 = iter.next().unwrap();\n            let next = if c0 == 'H' { 'T' } else { 'H' };\n            seq.push(next);\n            seq.push(c0);\n            seq.push(iter.next().unwrap());\n        }\n        None => {\n            for _ in 0..3 {\n                seq.push(toss_coin(rng, false))\n            }\n        }\n    }\n    seq\n}\n\nfn read_sequence(used_seq: Option<&str>) -> String {\n    let mut seq = String::new();\n    loop {\n        seq.clear();\n        println!(\"Please, enter sequence of 3 coins: H (heads) or T (tails): \");\n        stdin().read_line(&mut seq).expect(\"failed to read line\");\n        seq = seq.trim().to_uppercase();\n        // do the cheapest test first\n        if seq.len() == 3\n            && seq.chars().all(|c| c == 'H' || c == 'T')\n            && seq != used_seq.unwrap_or(\"\")\n        {\n            return seq;\n        }\n\n        println!(\"Please enter correct sequence!\");\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"--Penney's game--\");\n    loop {\n        let useq: String;\n        let aiseq: String;\n        if rng.gen::<bool>() {\n            println!(\"You choose first!\");\n            useq = read_sequence(None);\n            println!(\"Your sequence: {}\", useq);\n            aiseq = gen_sequence(&mut rng, Some(&useq));\n            println!(\"My sequence: {}\", aiseq);\n        } else {\n            println!(\"I choose first!\");\n            aiseq = gen_sequence(&mut rng, None);\n            println!(\"My sequence: {}\", aiseq);\n            useq = read_sequence(Some(&aiseq));\n            println!(\"Your sequence: {}\", useq);\n        }\n        println!(\"Tossing coins...\");\n        let mut coins = String::new();\n        for _ in 0..2 {\n            // toss first 2 coins\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n        }\n        loop {\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n            if coins.contains(&useq) {\n                println!(\"\\nYou win!\");\n                break;\n            }\n            if coins.contains(&aiseq) {\n                println!(\"\\nI win!\");\n                break;\n            }\n        }\n\n        println!(\" Play again? 'Y' to play, 'Q' to exit.\");\n        let mut input = String::new();\n        stdin().read_line(&mut input).expect(\"failed to read line\");\n        match input.trim_start().chars().next().unwrap() {\n            'Y' | 'y' => continue,\n            _ => break,\n        }\n    }\n}\n\n",
    "title": "Penney's game",
    "url": "http://rosettacode.org/wiki/Penney's_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pentagram",
    "url": "http://rosettacode.org/wiki/Pentagram"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pentomino tiling",
    "url": "http://rosettacode.org/wiki/Pentomino_tiling"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{GenericImageView, Rgba};\n\nfn diff_rgba3(rgba1 : Rgba<u8>, rgba2 : Rgba<u8>) -> i32 {\n    (rgba1[0] as i32 - rgba2[0] as i32).abs()\n    + (rgba1[1] as i32 - rgba2[1] as i32).abs()\n    + (rgba1[2] as i32 - rgba2[2] as i32).abs()\n}\n\nfn main() {\n    let img1 = image::open(\"Lenna100.jpg\").unwrap();\n    let img2 = image::open(\"Lenna50.jpg\").unwrap();\n    let mut accum = 0;\n    let zipper = img1.pixels().zip(img2.pixels());\n    for (pixel1, pixel2) in zipper {\n        accum += diff_rgba3(pixel1.2, pixel2.2);\n    }\n    println!(\"Percent difference {}\", accum as f64 * 100.0/ (255.0 * 3.0 * (img1.width() * img1.height()) as f64));\n}",
    "title": "Percentage difference between images",
    "url": "http://rosettacode.org/wiki/Percentage_difference_between_images"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Bond percolation",
    "url": "http://rosettacode.org/wiki/Percolation/Bond_percolation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Mean cluster density",
    "url": "http://rosettacode.org/wiki/Percolation/Mean_cluster_density"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Mean run density",
    "url": "http://rosettacode.org/wiki/Percolation/Mean_run_density"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Site percolation",
    "url": "http://rosettacode.org/wiki/Percolation/Site_percolation"
  },
  {
    "local_code": "fn perfect_number(n: usize) -> bool {\n    (1..=(n / 2)).filter(|&i| n % i == 0).sum::<usize>() == n\n}\n\nfn main() {\n    for n in (2..10_000).filter(|&n| perfect_number(n)) {\n        println!(\"{}\", n);\n    }\n}\n\n#[test]\nfn test_first_four() {\n    let nums = (2..10_000)\n        .filter(|&n| perfect_number(n))\n        .collect::<Vec<usize>>();\n    assert_eq!(nums, [6, 28, 496, 8128]);\n}\n\n#[test]\nfn test_high_number() {\n    assert!(perfect_number(33550336));\n}\n",
    "path": "tasks/perfect-numbers",
    "remote_code": "\nfn main ( ) {\n\tfn factor_sum(n: i32) -> i32 {\n\t    let mut v = Vec::new(); //create new empty array\n\t    for  x in 1..n-1 {      //test vaules 1 to n-1\n\t    \tif n%x == 0 {   //if current x is a factor of n\n\t    \t\tv.push(x);      //add x to the array\n\t    \t}\n\t    }\n    let mut sum = v.iter().sum(); //iterate over array and sum it up \n    return sum;\n    }\n    \n    fn perfect_nums(n: i32) {\n    \tfor x in 2..n {       //test numbers from 1-n\n    \t\tif factor_sum(x) == x {//call factor_sum on each value of x, if return value is = x\n    \t\t\tprintln!(\"{} is a perfect number.\", x); //print value of x \n    \t\t}\n    \t}\n    }\n    perfect_nums(10000);\n}\n",
    "title": "Perfect numbers",
    "url": "http://rosettacode.org/wiki/Perfect_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate itertools;\n\nfn shuffle<T>(mut deck: Vec<T>) -> Vec<T> {\n    let index = deck.len() / 2;\n    let right_half = deck.split_off(index);\n    itertools::interleave(deck, right_half).collect()\n}\n\nfn main() {\n    for &size in &[8, 24, 52, 100, 1020, 1024, 10_000] {\n        let original_deck: Vec<_> = (0..size).collect();\n        let mut deck = original_deck.clone();\n        let mut iterations = 0;\n        loop {\n            deck = shuffle(deck);\n            iterations += 1;\n            if deck == original_deck {\n                break;\n            }\n        }\n        println!(\"{: >5}: {: >4}\", size, iterations);\n    }\n}",
    "title": "Perfect shuffle",
    "url": "http://rosettacode.org/wiki/Perfect_shuffle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Perfect totient numbers",
    "url": "http://rosettacode.org/wiki/Perfect_totient_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Periodic table",
    "url": "http://rosettacode.org/wiki/Periodic_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Peripheral drift illusion",
    "url": "http://rosettacode.org/wiki/Peripheral_drift_illusion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n\tprintln!(\"{}\", noise(3.14, 42.0, 7.0));\n}\n\nfn noise(x: f64, y: f64, z: f64) -> f64 {\n\tlet x0 = x.floor() as usize & 255;\n\tlet y0 = y.floor() as usize & 255;\n\tlet z0 = z.floor() as usize & 255;\n\t\n\tlet x = x - x.floor();\n\tlet y = y - y.floor();\n\tlet z = z - z.floor();\n\t\n\tlet u = fade(x);\n\tlet v = fade(y);\n\tlet w = fade(z);\n\t\n\tlet a = P[x0] + y0;\n\tlet aa = P[a] + z0;\n\tlet ab = P[a + 1] + z0;\n\tlet b = P[x0 + 1] + y0;\n\tlet ba = P[b] + z0;\n\tlet bb = P[b + 1] + z0;\n\t\n\treturn lerp(w,\n\t\tlerp(v, lerp(u, grad(P[aa], x    , y    , z),\n\t\t\t\tgrad(P[ba], x-1.0, y    , z)),\n\t\t\tlerp(u, grad(P[ab], x    , y-1.0, z),\n                                grad(P[bb], x-1.0, y-1.0, z))),\n\t\tlerp(v, lerp(u, grad(P[aa+1], x    , y    , z-1.0),\n                                grad(P[ba+1], x-1.0, y    , z-1.0)),\n                        lerp(u, grad(P[ab+1], x    , y-1.0, z-1.0),\n                                grad(P[bb+1], x-1.0, y-1.0, z-1.0))));\n}\n\nfn fade(t: f64) -> f64 {\n\tt * t * t * ( t * (t * 6.0 - 15.0) + 10.0)\n}\n\nfn lerp(t: f64, a: f64, b: f64) -> f64 {\n\ta + t * (b - a)\n}\n\nfn grad(hash: usize, x: f64, y: f64, z: f64) -> f64 {\n\tlet h = hash & 15;\n\tlet u = if h < 8 { x } else { y };\n\tlet v = if h < 4 { y } else { if h == 12 || h == 14 { x } else { z } };\n\t\n\treturn if h&1 == 0 { u } else { -u } + if h&2 == 0 { v } else { -v };\n}\n\nstatic P: [usize; 512] = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,\n\t7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,\n\t75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\n\t174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,\n\t231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,\n\t143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,\n\t123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,\n\t28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167,\n\t43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,\n\t246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,\n\t14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127,\n\t4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,\n\t180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69\n\t,142,8,99,37,240,21,10,23,190, 6,148,247,120,234,75,0,26,197,62,94,252,219,\n\t203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,\n\t74,165,71,134,139,48,27,166, 77,146,158,231,83,111,229,122,60,211,133,230,\n\t220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,\n\t76,132,187,208, 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,\n\t173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,\n\t207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,\n\t44,154,163, 70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,\n\t110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,\n\t210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, 49,192,214, 31,\n\t181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,\n\t93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];",
    "title": "Perlin noise",
    "url": "http://rosettacode.org/wiki/Perlin_noise"
  },
  {
    "local_code": "fn main() {\n    let treatment = vec![85, 88, 75, 66, 25, 29, 83, 39, 97];\n    let control = vec![68, 41, 10, 49, 16, 65, 32, 92, 28, 98];\n\n    let mut data_set = control.clone();\n    data_set.extend_from_slice(&treatment);\n\n    let greater = combinations(treatment.iter().sum(), treatment.len() as i64, &data_set) as f64;\n    let lesser = combinations(control.iter().sum(), control.len() as i64, &data_set) as f64;\n    let total = binomial(data_set.len() as i64, treatment.len() as i64) as f64;\n\n    println!(\"<= : {}%\", (lesser / total * 100.0));\n    println!(\" > : {}%\", (greater / total * 100.0));\n}\n\nfn factorial(x: i64) -> i64 {\n    let mut product = 1;\n    for a in 1..(x + 1) {\n        product *= a;\n    }\n    product\n}\n\nfn binomial(n: i64, k: i64) -> i64 {\n    let numerator = factorial(n);\n    let denominator = factorial(k) * factorial(n - k);\n    numerator / denominator\n}\n\nfn combinations(total: i64, number: i64, data: &[i64]) -> i64 {\n    if total < 0 {\n        return binomial(data.len() as i64, number);\n    }\n\n    if number == 0 {\n        return 0;\n    }\n\n    if number > data.len() as i64 {\n        return 0;\n    }\n\n    if number == data.len() as i64 {\n        if total < data.iter().sum() {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    let tail = &data[1..];\n    combinations(total - data[0], number - 1, tail) + combinations(total, number, tail)\n}\n\n#[cfg(test)]\nmod test {\n    use self::super::*;\n\n    #[test]\n    fn test_factorial() {\n        assert_eq!(factorial(5), 120);\n        assert_eq!(factorial(8), 40320);\n    }\n\n    #[test]\n    //Test 64-bit values\n    fn test_large_factorial() {\n        assert_eq!(factorial(13), 6227020800);\n        assert_eq!(factorial(20), 2432902008176640000);\n    }\n\n    #[test]\n    fn test_binomial() {\n        assert_eq!(binomial(4, 3), 4);\n        assert_eq!(binomial(8, 5), 56);\n        assert_eq!(binomial(10, 7), 120);\n    }\n\n    #[test]\n    //Test 64-bit values\n    fn test_large_binomial() {\n        assert_eq!(binomial(12, 5), 792);\n        assert_eq!(binomial(15, 5), 3003);\n        assert_eq!(binomial(18, 3), 816);\n    }\n}\n",
    "path": "tasks/permutation-test",
    "remote_code": "\nfn main() {\n    let treatment = vec![85, 88, 75, 66, 25, 29, 83, 39, 97];\n    let control = vec![68, 41, 10, 49, 16, 65, 32, 92, 28, 98];\n\n    let mut data_set = control.clone();\n    data_set.extend_from_slice(&treatment);\n\n    let greater = combinations(treatment.iter().sum(), treatment.len() as i64, &data_set) as f64;\n    let lesser = combinations(control.iter().sum(), control.len() as i64, &data_set) as f64;\n    let total = binomial(data_set.len() as i64, treatment.len() as i64) as f64;\n\n    println!(\"<= : {}%\", (lesser / total * 100.0));\n    println!(\" > : {}%\", (greater / total * 100.0));\n}\n\nfn factorial(x: i64) -> i64 {\n    let mut product = 1;\n    for a in 1..(x + 1) {\n        product *= a;\n    }\n    product\n}\n\nfn binomial(n: i64, k: i64) -> i64 {\n    let numerator = factorial(n);\n    let denominator = factorial(k) * factorial(n - k);\n    numerator / denominator\n}\n\nfn combinations(total: i64, number: i64, data: &[i64]) -> i64 {\n    if total < 0 {\n        return binomial(data.len() as i64, number);\n    }\n\n    if number == 0 {\n        return 0;\n    }\n\n    if number > data.len() as i64 {\n        return 0;\n    }\n\n    if number == data.len() as i64 {\n        if total < data.iter().sum() {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    let tail = &data[1..];\n    combinations(total - data[0], number - 1, &tail) + combinations(total, number, &tail)\n}\n",
    "title": "Permutation test",
    "url": "http://rosettacode.org/wiki/Permutation_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub fn permutations(size: usize) -> Permutations {\n    Permutations { idxs: (0..size).collect(), swaps: vec![0; size], i: 0 }\n}\n\npub struct Permutations {\n    idxs: Vec<usize>,\n    swaps: Vec<usize>,\n    i: usize,\n}\n\nimpl Iterator for Permutations {\n    type Item = Vec<usize>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.i > 0 {\n            loop {\n                if self.i >= self.swaps.len() { return None; }\n                if self.swaps[self.i] < self.i { break; }\n                self.swaps[self.i] = 0;\n                self.i += 1;\n            }\n            self.idxs.swap(self.i, (self.i & 1) * self.swaps[self.i]);\n            self.swaps[self.i] += 1;\n        }\n        self.i = 1;\n        Some(self.idxs.clone())\n    }\n}\n\nfn main() {\n    let perms = permutations(3).collect::<Vec<_>>();\n    assert_eq!(perms, vec![\n        vec![0, 1, 2],\n        vec![1, 0, 2],\n        vec![2, 0, 1],\n        vec![0, 2, 1],\n        vec![1, 2, 0],\n        vec![2, 1, 0],\n    ]);\n}",
    "title": "Permutations",
    "url": "http://rosettacode.org/wiki/Permutations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Implementation of Heap's algorithm.\n// See https://en.wikipedia.org/wiki/Heap%27s_algorithm#Details_of_the_algorithm\nfn generate<T, F>(a: &mut [T], output: F)\nwhere\n    F: Fn(&[T], isize),\n{\n    let n = a.len();\n    let mut c = vec![0; n];\n    let mut i = 1;\n    let mut sign = 1;\n    output(a, sign);\n    while i < n {\n        if c[i] < i {\n            if (i & 1) == 0 {\n                a.swap(0, i);\n            } else {\n                a.swap(c[i], i);\n            }\n            sign = -sign;\n            output(a, sign);\n            c[i] += 1;\n            i = 1;\n        } else {\n            c[i] = 0;\n            i += 1;\n        }\n    }\n}\n\nfn print_permutation<T: std::fmt::Debug>(a: &[T], sign: isize) {\n    println!(\"{:?} {}\", a, sign);\n}\n\nfn main() {\n    println!(\"Permutations and signs for three items:\");\n    let mut a = vec![0, 1, 2];\n    generate(&mut a, print_permutation);\n\n    println!(\"\\nPermutations and signs for four items:\");\n    let mut b = vec![0, 1, 2, 3];\n    generate(&mut b, print_permutation);\n}",
    "title": "Permutations by swapping",
    "url": "http://rosettacode.org/wiki/Permutations_by_swapping"
  },
  {
    "local_code": "struct PermutationIterator<'a, T: 'a> {\n    universe: &'a [T],\n    size: usize,\n    prev: Option<Vec<usize>>,\n}\n\nfn permutations<T>(universe: &[T], size: usize) -> PermutationIterator<T> {\n    PermutationIterator {\n        universe,\n        size,\n        prev: None,\n    }\n}\n\nfn map<T>(values: &[T], ixs: &[usize]) -> Vec<T>\nwhere\n    T: Clone,\n{\n    ixs.iter().map(|&i| values[i].clone()).collect()\n}\n\nimpl<'a, T> Iterator for PermutationIterator<'a, T>\nwhere\n    T: Clone,\n{\n    type Item = Vec<T>;\n\n    fn next(&mut self) -> Option<Vec<T>> {\n        let n = self.universe.len();\n\n        if n == 0 {\n            return None;\n        }\n\n        match self.prev {\n            None => {\n                let zeroes: Vec<usize> = std::iter::repeat(0).take(self.size).collect();\n                let result = Some(map(self.universe, &zeroes[..]));\n                self.prev = Some(zeroes);\n                result\n            }\n            Some(ref mut indexes) => match indexes.iter().position(|&i| i + 1 < n) {\n                None => None,\n                Some(position) => {\n                    for index in indexes.iter_mut().take(position) {\n                        *index = 0;\n                    }\n                    indexes[position] += 1;\n                    Some(map(self.universe, &indexes[..]))\n                }\n            },\n        }\n    }\n}\n\nfn main() {\n    let universe = [\"Annie\", \"Barbie\"];\n    for p in permutations(&universe[..], 3) {\n        for element in &p {\n            print!(\"{} \", element);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::permutations;\n\n    #[test]\n    fn test_len() {\n        let universe = [1, 132, 323];\n        assert!(permutations(&universe[..], 4).count() == 81);\n    }\n}\n",
    "path": "tasks/permutations-with-repetitions",
    "remote_code": "\nstruct PermutationIterator<'a, T: 'a> {\n    universe: &'a [T],\n    size: usize,\n    prev: Option<Vec<usize>>,\n}\n\nfn permutations<T>(universe: &[T], size: usize) -> PermutationIterator<T> {\n    PermutationIterator {\n        universe,\n        size,\n        prev: None,\n    }\n}\n\nfn map<T>(values: &[T], ixs: &[usize]) -> Vec<T>\nwhere\n    T: Clone,\n{\n    ixs.iter().map(|&i| values[i].clone()).collect()\n}\n\nimpl<'a, T> Iterator for PermutationIterator<'a, T>\nwhere\n    T: Clone,\n{\n    type Item = Vec<T>;\n\n    fn next(&mut self) -> Option<Vec<T>> {\n        let n = self.universe.len();\n\n        if n == 0 {\n            return None;\n        }\n\n        match self.prev {\n            None => {\n                let zeroes: Vec<usize> = std::iter::repeat(0).take(self.size).collect();\n                let result = Some(map(self.universe, &zeroes[..]));\n                self.prev = Some(zeroes);\n                result\n            }\n            Some(ref mut indexes) => match indexes.iter().position(|&i| i + 1 < n) {\n                None => None,\n                Some(position) => {\n                    for index in indexes.iter_mut().take(position) {\n                        *index = 0;\n                    }\n                    indexes[position] += 1;\n                    Some(map(self.universe, &indexes[..]))\n                }\n            },\n        }\n    }\n}\n\nfn main() {\n    let universe = [\"Annie\", \"Barbie\"];\n    for p in permutations(&universe[..], 3) {\n        for element in &p {\n            print!(\"{} \", element);\n        }\n        println!();\n    }\n}\n\n",
    "title": "Permutations with repetitions",
    "url": "http://rosettacode.org/wiki/Permutations_with_repetitions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Permutations/Derangements",
    "url": "http://rosettacode.org/wiki/Permutations/Derangements"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Permutations/Rank of a permutation",
    "url": "http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation"
  },
  {
    "local_code": "extern crate aks_test_for_primes;\n\nuse std::iter::Filter;\nuse std::ops::RangeFrom;\n\nuse aks_test_for_primes::is_prime;\n\nfn main() {\n    for i in pernicious().take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    for i in (888_888_877u64..888_888_888).filter(is_pernicious) {\n        print!(\"{} \", i);\n    }\n}\n\nfn pernicious() -> Filter<RangeFrom<u64>, fn(&u64) -> bool> {\n    (0u64..).filter(is_pernicious as fn(&u64) -> bool)\n}\n\nfn is_pernicious(n: &u64) -> bool {\n    is_prime(n.count_ones())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{is_pernicious, pernicious};\n\n    #[test]\n    fn pernicious_iter() {\n        let exp = &[\n            3u64, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33,\n            34, 35, 36,\n        ];\n        for (act, &exp) in pernicious().take(30).zip(exp.iter()) {\n            assert_eq!(act, exp);\n        }\n    }\n\n    #[test]\n    fn is_pernicious_range() {\n        let exp = &[\n            888888877u64,\n            888888878,\n            888888880,\n            888888883,\n            888888885,\n            888888886,\n        ];\n        for (act, &exp) in (888_888_877u64..888_888_888)\n            .filter(is_pernicious)\n            .zip(exp.iter())\n        {\n            assert_eq!(act, exp);\n        }\n    }\n}\n",
    "path": "tasks/pernicious-numbers",
    "remote_code": "\nextern crate aks_test_for_primes;\n\nuse std::iter::Filter;\nuse std::ops::RangeFrom;\n\nuse aks_test_for_primes::is_prime;\n\nfn main() {\n    for i in pernicious().take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    for i in (888_888_877u64..888_888_888).filter(is_pernicious) {\n        print!(\"{} \", i);\n    }\n}\n\nfn pernicious() -> Filter<RangeFrom<u64>, fn(&u64) -> bool> {\n    (0u64..).filter(is_pernicious as fn(&u64) -> bool)\n}\n\nfn is_pernicious(n: &u64) -> bool {\n    is_prime(n.count_ones())\n}\n",
    "title": "Pernicious numbers",
    "url": "http://rosettacode.org/wiki/Pernicious_numbers"
  },
  {
    "local_code": "pub fn reverse_string(string: &str) -> String {\n    string.chars().rev().collect::<String>()\n}\n\npub fn reverse_words(string: &str) -> String {\n    string\n        .split_whitespace()\n        .map(|x| x.chars().rev().collect::<String>())\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\npub fn reverse_word_order(string: &str) -> String {\n    string\n        .split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(reverse_string(string), \"lasrever esarhp edoc attesor\");\n    }\n\n    #[test]\n    fn test_reverse_words() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(reverse_words(string), \"attesor edoc esarhp lasrever\");\n    }\n\n    #[test]\n    fn test_reverse_word_order() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(reverse_word_order(string), \"reversal phrase code rosetta\");\n    }\n}\n",
    "path": "tasks/phrase-reversals",
    "remote_code": "fn reverse_string(string: &str) -> String {\n    string.chars().rev().collect::<String>()\n}\n\nfn reverse_words(string: &str) -> String {\n    string\n        .split_whitespace()\n        .map(|x| x.chars().rev().collect::<String>())\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn reverse_word_order(string: &str) -> String {\n    string\n        .split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_string(string.clone()),\n            \"lasrever esarhp edoc attesor\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_words() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_words(string.clone()),\n            \"attesor edoc esarhp lasrever\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_word_order() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_word_order(string.clone()),\n            \"reversal phrase code rosetta\"\n        );\n    }\n}\n",
    "title": "Phrase reversals",
    "url": "http://rosettacode.org/wiki/Phrase_reversals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use num_bigint::BigInt;\n\nfn main() {\n    calc_pi();\n}\n\nfn calc_pi() {\n    let mut q = BigInt::from(1);\n    let mut r = BigInt::from(0);\n    let mut t = BigInt::from(1);\n    let mut k = BigInt::from(1);\n    let mut n = BigInt::from(3);\n    let mut l = BigInt::from(3);\n    let mut first = true;\n    loop {\n        if &q * 4 + &r - &t < &n * &t {\n            print!(\"{}\", n);\n            if first {\n                print!(\".\");\n                first = false;\n            }\n            let nr = (&r - &n * &t) * 10;\n            n = (&q * 3 + &r) * 10 / &t - &n * 10;\n            q *= 10;\n            r = nr;\n        } else {\n            let nr = (&q * 2 + &r) * &l;\n            let nn = (&q * &k * 7 + 2 + &r * &l) / (&t * &l);\n            q *= &k;\n            t *= &l;\n            l += 2;\n            k += 1;\n            n = nn;\n            r = nr;\n        }\n    }\n}",
    "title": "Pi",
    "url": "http://rosettacode.org/wiki/Pi"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\n\nfn pick_random_e(a: &[u8]) -> u8 {\n    // thread-local random number generator\n    let mut rng = thread_rng();\n\n    let ri = rng.gen_range(0, a.len());\n\n    a[ri]\n}\n\nfn main() {\n    let xs: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    println!(\"{}\", pick_random_e(&xs));\n}\n\n#[test]\nfn test_pick_random_e() {\n    let xs: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    let picked = pick_random_e(&xs);\n\n    assert!(xs.contains(&picked));\n}\n",
    "path": "tasks/pick-random-element",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let array = [5,1,2,5,6,7,8,1,2,4,5];\n    let mut rng = rand::thread_rng();\n    \n    println!(\"{}\", rng.choose(&array).unwrap());\n}",
    "title": "Pick random element",
    "url": "http://rosettacode.org/wiki/Pick_random_element"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pierpont primes",
    "url": "http://rosettacode.org/wiki/Pierpont_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::prelude::*;\n\nfn main() {\n    println!(\"Beginning game of Pig...\");\n\n    let mut players = vec![\n        Player::new(String::from(\"PLAYER (1) ONE\")),\n        Player::new(String::from(\"PLAYER (2) TWO\")),\n    ];\n\n    'game: loop {\n        for player in players.iter_mut() {\n            if player.cont() {\n                println!(\"\\n# {} has {:?} Score\", player.name, player.score);\n                player.resolve();\n            } else {\n                println!(\"\\n{} wins!\", player.name);\n                break 'game;\n            }\n        }\n    }\n\n    println!(\"Thanks for playing!\");\n}\n\ntype DiceRoll = u32;\ntype Score = u32;\ntype Name = String;\n\nenum Action {\n    Roll,\n    Hold,\n}\n\n#[derive(PartialEq)]\nenum TurnStatus {\n    Continue,\n    End,\n}\n\nstruct Player {\n    name: Name,\n    score: Score,\n    status: TurnStatus,\n}\n\nimpl Player {\n    fn new(name: Name) -> Player {\n        Player {\n            name,\n            score: 0,\n            status: TurnStatus::Continue,\n        }\n    }\n\n    fn roll() -> DiceRoll {\n        // Simple 1d6 dice.\n        let sides = rand::distributions::Uniform::new(1, 6);\n        rand::thread_rng().sample(sides)\n    }\n\n    fn action() -> Action {\n        // Closure to determine userinput as action.\n        let command = || -> Option<char> {\n            let mut cmd: String = String::new();\n            match std::io::stdin().read_line(&mut cmd) {\n                Ok(c) => c.to_string(),\n                Err(err) => panic!(\"Error: {}\", err),\n            };\n\n            cmd.to_lowercase().trim().chars().next()\n        };\n\n        'user_in: loop {\n            match command() {\n                Some('r') => break 'user_in Action::Roll,\n                Some('h') => break 'user_in Action::Hold,\n                Some(invalid) => println!(\"{} is not a valid command!\", invalid),\n                None => println!(\"Please input a command!\"),\n            }\n        }\n    }\n\n    fn turn(&mut self) -> Score {\n        let one = |die: DiceRoll| {\n            println!(\"[DICE] Dice result is: {:3}!\", die);\n            println!(\"[DUMP] Dumping Score! Sorry!\");\n            println!(\"###### ENDING TURN ######\");\n        };\n\n        let two_to_six = |die: DiceRoll, score: Score, player_score: Score| {\n            println!(\"[DICE] Dice result is: {:3}!\", die);\n            println!(\"[ROLL] Total    Score: {:3}!\", (score + die));\n            println!(\"[HOLD] Possible Score: {:3}!\", (score + die + player_score));\n        };\n\n        let mut score: Score = 0;\n        'player: loop {\n            println!(\"# {}'s Turn\", self.name);\n            println!(\"######  [R]oll   ######\\n######  --OR--   ######\\n######  [H]old   ######\");\n\n            match Player::action() {\n                Action::Roll => match Player::roll() {\n                    0 | 7..=u32::MAX => panic!(\"outside dice bounds!\"),\n                    die @ 1 => {\n                        one(die);\n                        self.status = TurnStatus::End;\n                        break 'player 0;\n                    }\n                    die @ 2..=6 => {\n                        two_to_six(die, score, self.score);\n                        self.status = TurnStatus::Continue;\n                        score += die\n                    }\n                },\n                Action::Hold => {\n                    self.status = TurnStatus::End;\n                    break 'player score;\n                }\n            }\n        }\n    }\n\n    fn resolve(&mut self) {\n        self.score += self.turn()\n    }\n\n    fn cont(&self) -> bool {\n        self.score <= 100 || self.status == TurnStatus::Continue\n    }\n}",
    "title": "Pig the dice game",
    "url": "http://rosettacode.org/wiki/Pig_the_dice_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pig the dice game/Player",
    "url": "http://rosettacode.org/wiki/Pig_the_dice_game/Player"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pinstripe/Display",
    "url": "http://rosettacode.org/wiki/Pinstripe/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pinstripe/Printer",
    "url": "http://rosettacode.org/wiki/Pinstripe/Printer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pisano period",
    "url": "http://rosettacode.org/wiki/Pisano_period"
  },
  {
    "local_code": "use image::ColorType;\nuse std::path::Path;\n\n// Framebuffer dimensions\nconst WIDTH: usize = 640;\nconst HEIGHT: usize = 480;\n\n/// Formula for plasma at any particular address\nfn plasma_pixel(x: f64, y: f64) -> f64 {\n    ((x / 16.0).sin()\n        + (y / 8.0).sin()\n        + ((x + y) / 16.0).sin()\n        + ((x * x + y * y).sqrt() / 8.0).sin()\n        + 4.0)\n        / 8.0\n}\n\n/// Precalculate plasma field lookup-table for performance\nfn create_plasma_lut() -> Vec<f64> {\n    let mut plasma: Vec<f64> = vec![0.0; WIDTH * HEIGHT];\n    for y in 0..HEIGHT {\n        for x in 0..WIDTH {\n            plasma[(y * WIDTH) + x] = plasma_pixel(x as f64, y as f64);\n        }\n    }\n    plasma\n}\n\n/// Convert from HSV float(1.0,1.0,1.0) to RGB u8 tuple (255,255,255).\n/// From https://crates.io/crates/palette 0.5.0 rgb.rs, simplified for example\nfn hsv_to_rgb(hue: f64, saturation: f64, value: f64) -> (u8, u8, u8) {\n    let c = value * saturation;\n    let h = hue * 6.0;\n    let x = c * (1.0 - (h % 2.0 - 1.0).abs());\n    let m = value - c;\n    let (red, green, blue) = match (h % 6.0).floor() as u32 {\n        0 => (c, x, 0.0),\n        1 => (x, c, 0.0),\n        2 => (0.0, c, x),\n        3 => (0.0, x, c),\n        4 => (x, 0.0, c),\n        _ => (c, 0.0, x),\n    };\n    // Convert back to RGB (where components are integers from 0 to 255)\n    (\n        ((red + m) * 255.0).round() as u8,\n        ((green + m) * 255.0).round() as u8,\n        ((blue + m) * 255.0).round() as u8,\n    )\n}\nfn main() {\n    // The bitmap/framebuffer for our application. 3 u8 elements per output pixel\n    let mut framebuffer: Vec<u8> = vec![0; WIDTH * HEIGHT * 3];\n    // Generate a lookup table so we don't do too much math for every pixel.\n    // Do it in a function so that the local one can be immutable.\n    let plasma_lookup_table = create_plasma_lut();\n    // For each (r,g,b) pixel in our output buffer\n    for (index, rgb) in framebuffer.chunks_mut(3).enumerate() {\n        // Lookup the precalculated plasma value\n        let hue_lookup = plasma_lookup_table[index] % 1.0;\n        let (red, green, blue) = hsv_to_rgb(hue_lookup, 1.0, 1.0);\n        rgb[0] = red;\n        rgb[1] = green;\n        rgb[2] = blue;\n    }\n    // Save our plasma image to out.png\n    let output_path = Path::new(\"out.png\");\n    match image::save_buffer(\n        output_path,\n        framebuffer.as_slice(),\n        WIDTH as u32,\n        HEIGHT as u32,\n        ColorType::Rgb8,\n    ) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n",
    "path": "tasks/plasma-effect",
    "remote_code": "\nextern crate image;\n\nuse image::ColorType;\nuse std::path::Path;\n\n// Framebuffer dimensions\nconst WIDTH: usize = 640;\nconst HEIGHT: usize = 480;\n\n/// Formula for plasma at any particular address\nfn plasma_pixel(x: f64, y: f64) -> f64 {\n    ((x / 16.0).sin()\n        + (y / 8.0).sin()\n        + ((x + y) / 16.0).sin()\n        + ((x * x + y * y).sqrt() / 8.0).sin()\n        + 4.0)\n        / 8.0\n}\n\n/// Precalculate plasma field lookup-table for performance\nfn create_plasma_lut() -> Vec<f64> {\n    let mut plasma: Vec<f64> = vec![0.0; WIDTH * HEIGHT];\n    for y in 0..HEIGHT {\n        for x in 0..WIDTH {\n            plasma[(y * WIDTH) + x] = plasma_pixel(x as f64, y as f64);\n        }\n    }\n    plasma\n}\n\n/// Convert from HSV float(1.0,1.0,1.0) to RGB u8 tuple (255,255,255).\n/// From https://crates.io/crates/palette 0.5.0 rgb.rs, simplified for example\nfn hsv_to_rgb(hue: f64, saturation: f64, value: f64) -> (u8, u8, u8) {\n    let c = value * saturation;\n    let h = hue * 6.0;\n    let x = c * (1.0 - (h % 2.0 - 1.0).abs());\n    let m = value - c;\n    let (red, green, blue) = match (h % 6.0).floor() as u32 {\n        0 => (c, x, 0.0),\n        1 => (x, c, 0.0),\n        2 => (0.0, c, x),\n        3 => (0.0, x, c),\n        4 => (x, 0.0, c),\n        _ => (c, 0.0, x),\n    };\n    // Convert back to RGB (where components are integers from 0 to 255)\n    (\n        ((red + m) * 255.0).round() as u8,\n        ((green + m) * 255.0).round() as u8,\n        ((blue + m) * 255.0).round() as u8,\n    )\n}\nfn main() {\n    // The bitmap/framebuffer for our application. 3 u8 elements per output pixel\n    let mut framebuffer: Vec<u8> = vec![0; WIDTH * HEIGHT * 3];\n    // Generate a lookup table so we don't do too much math for every pixel.\n    // Do it in a function so that the local one can be immutable.\n    let plasma_lookup_table = create_plasma_lut();\n    // For each (r,g,b) pixel in our output buffer\n    for (index, rgb) in framebuffer.chunks_mut(3).enumerate() {\n        // Lookup the precalculated plasma value\n        let hue_lookup = plasma_lookup_table[index] % 1.0;\n        let (red, green, blue) = hsv_to_rgb(hue_lookup, 1.0, 1.0);\n        rgb[0] = red;\n        rgb[1] = green;\n        rgb[2] = blue;\n    }\n    // Save our plasma image to out.png\n    let output_path = Path::new(\"out.png\");\n    match image::save_buffer(\n        output_path,\n        framebuffer.as_slice(),\n        WIDTH as u32,\n        HEIGHT as u32,\n        ColorType::RGB(8),\n    ) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n\n",
    "title": "Plasma effect",
    "url": "http://rosettacode.org/wiki/Plasma_effect"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Play recorded sounds",
    "url": "http://rosettacode.org/wiki/Play_recorded_sounds"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Playfair cipher",
    "url": "http://rosettacode.org/wiki/Playfair_cipher"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::fmt;\n\nuse rand::prelude::*;\n\nuse Pip::*;\nuse Suit::*;\n\n#[derive(Copy, Clone, Debug)]\nenum Pip {\n    Ace,\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n}\nstatic PIPS: [Pip; 13] = [\n    Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King,\n];\n\n#[derive(Copy, Clone, Debug)]\nenum Suit {\n    Spades,\n    Hearts,\n    Diamonds,\n    Clubs,\n}\nstatic SUITS: [Suit; 4] = [Spades, Hearts, Diamonds, Clubs];\n\nstruct Card {\n    pip: Pip,\n    suit: Suit,\n}\n\nimpl fmt::Display for Card {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?} of {:?}\", self.pip, self.suit)\n    }\n}\n\nstruct Deck(Vec<Card>);\n\nimpl Deck {\n    fn new() -> Deck {\n        let mut cards: Vec<Card> = Vec::with_capacity(52);\n        for &suit in &SUITS {\n            for &pip in &PIPS {\n                cards.push(Card { pip, suit });\n            }\n        }\n        Deck(cards)\n    }\n\n    fn deal(&mut self) -> Option<Card> {\n        self.0.pop()\n    }\n\n    fn shuffle(&mut self) {\n        self.0.shuffle(&mut thread_rng());\n    }\n}\n\nimpl Default for Deck {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for Deck {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for card in &self.0 {\n            writeln!(f, \"{}\", card)?;\n        }\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut deck = Deck::new();\n    deck.shuffle();\n    for _ in 0..5 {\n        println!(\"{}\", deck.deal().unwrap());\n    }\n}\n",
    "path": "tasks/playing-cards",
    "remote_code": "extern crate rand;\n\nuse std::fmt;\nuse rand::Rng;\nuse Pip::*;\nuse Suit::*;\n\n#[derive(Copy, Clone, Debug)]\nenum Pip { Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King }\n\n#[derive(Copy, Clone, Debug)]\nenum Suit { Spades, Hearts, Diamonds, Clubs }\n\nstruct Card {\n\tpip: Pip,\n\tsuit: Suit\n}\n\nimpl fmt::Display for Card {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?} of {:?}\", self.pip, self.suit)\n    }\n}\n\nstruct Deck(Vec<Card>);\n\nimpl Deck {\n    fn new() -> Deck {\n        let mut cards:Vec<Card> = Vec::with_capacity(52);\n        for &suit in &[Spades, Hearts, Diamonds, Clubs] {\n            for &pip in &[Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King] {\n                cards.push( Card{pip: pip, suit: suit} );\n            }\n        }\n        Deck(cards)\n    }\n\n    fn deal(&mut self) -> Option<Card> {\n        self.0.pop()\n    }\n\n    fn shuffle(&mut self) {\n        rand::thread_rng().shuffle(&mut self.0)\n    }\n}\n\nimpl fmt::Display for Deck {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for card in self.0.iter() {\n            writeln!(f, \"{}\", card);\n        }\n        write!(f, \"\")\n    }\n}\n\nfn main() {\n    let mut deck = Deck::new();\n    deck.shuffle();\n    //println!(\"{}\", deck);\n    for _ in 0..5 {\n        println!(\"{}\", deck.deal().unwrap());\n    }\n}",
    "title": "Playing cards",
    "url": "http://rosettacode.org/wiki/Playing_cards"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Plot coordinate pairs",
    "url": "http://rosettacode.org/wiki/Plot_coordinate_pairs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pointers and references",
    "url": "http://rosettacode.org/wiki/Pointers_and_references"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\n    let hands = vec![\n        \"🂡 🂮 🂭 🂫 🂪\",\n        \"🃏 🃂 🂢 🂮 🃍\",\n        \"🃏 🂵 🃇 🂨 🃉\",\n        \"🃏 🃂 🂣 🂤 🂥\",\n        \"🃏 🂳 🃂 🂣 🃃\",\n        \"🃏 🂷 🃂 🂣 🃃\",\n        \"🃏 🂷 🃇 🂧 🃗\",\n        \"🃏 🂻 🂽 🂾 🂱\",\n        \"🃏 🃔 🃞 🃅 🂪\",\n        \"🃏 🃞 🃗 🃖 🃔\",\n        \"🃏 🃂 🃟 🂤 🂥\",\n        \"🃏 🃍 🃟 🂡 🂪\",\n        \"🃏 🃍 🃟 🃁 🃊\",\n        \"🃏 🃂 🂢 🃟 🃍\",\n        \"🃏 🃂 🂢 🃍 🃍\",\n        \"🃂 🃞 🃍 🃁 🃊\",\n    ];\n    for hand in hands{\n        println!(\"{} {}\", hand, poker_hand(hand));\n    }\n}\n\nfn poker_hand(cards: &str) -> &str {\n    let mut suits = vec![0u8; 4];\n    let mut faces = vec![0u8; 15];\n    let mut hand = vec![];\n\n    for card in cards.chars(){\n        if card == ' ' { continue; }\n        let values = get_card_value(card);\n        if values.0 < 14 && hand.contains(&values) {\n            return \"invalid\";\n        }\n        hand.push(values);\n        faces[values.0 as usize]+=1;\n        if values.1 >= 0 {\n            suits[values.1 as usize]+=1;\n        }\n    }\n    if hand.len()!=5 {\n        return \"invalid\";\n    }\n    faces[13] = faces[0]; //add ace-high count\n    let jokers = faces[14];\n\n    //count suits\n    let mut colors = suits.into_iter()\n        .filter(|&x| x > 0).collect::<Vec<_>>();\n    colors.sort_unstable();\n    colors[0] += jokers; // add joker suits to the highest one;\n    let is_flush = colors[0] == 5;\n\n    //straight\n    let mut is_straight = false;\n    //pointer to optimise some work\n    //avoids looking again at cards that were the start of a sequence\n    //as they cannot be part of another sequence\n    let mut ptr = 14;\n    while ptr>3{\n        let mut jokers_left = jokers;\n        let mut straight_cards = 0;\n        for i in (0..ptr).rev(){\n            if faces[i]==0 {\n                if jokers_left == 0 {break;}\n                jokers_left -= 1;\n            }\n            else if i==ptr-1 { ptr-=1; }\n            straight_cards+=1;\n        }\n        ptr-=1;\n        if straight_cards == 5 {\n            is_straight = true;\n            break;\n        }\n    }\n\n     //count values\n     let mut values = faces.into_iter().enumerate().take(14).filter(|&x| x.1>0).collect::<Vec<_>>();\n     //sort by quantity, then by value, high to low\n     values.sort_unstable_by(|a, b| if b.1 == a.1 { (b.0).cmp(&a.0) } else { (b.1).cmp(&a.1)} );\n     let first_group = values[0].1 + jokers;\n     let second_group = if values.len()>1 {values[1].1} else {0};\n     \n     match (is_flush, is_straight, first_group, second_group){\n        (_,_,5,_) => \"five-of-a-kind\",\n        (true, true, _, _) => if ptr == 8 {\"royal-flush\"} else {\"straight-flush\"},\n        (_,_,4,_) => \"four-of-a-kind\",\n        (_,_,3,2) => \"full-house\",\n        (true,_,_,_) => \"flush\",\n        (_,true,_,_) => \"straight\",\n        (_,_,3,_) => \"three-of-a-kind\",\n        (_,_,2,2) => \"two-pair\",\n        (_,_,2,_) => \"one-pair\",\n        _ => \"high-card\"\n     }\n}\n\nfn get_card_value(card: char) -> (i8,i8) {\n    // transform glyph to face + suit, zero-indexed\n    let base = card as u32 - 0x1F0A1;\n    let mut suit = (base / 16) as i8;\n    let mut face = (base % 16) as i8;\n    if face > 11 && face < 14 { face-=1; } // Unicode has a Knight that we do not want\n    if face == 14 { suit = -1; } //jokers do not have a suit\n    (face, suit)\n}\n",
    "title": "Poker hand analyser",
    "url": "http://rosettacode.org/wiki/Poker_hand_analyser"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polymorphic copy",
    "url": "http://rosettacode.org/wiki/Polymorphic_copy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polymorphism",
    "url": "http://rosettacode.org/wiki/Polymorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polynomial long division",
    "url": "http://rosettacode.org/wiki/Polynomial_long_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polynomial regression",
    "url": "http://rosettacode.org/wiki/Polynomial_regression"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polyspiral",
    "url": "http://rosettacode.org/wiki/Polyspiral"
  },
  {
    "local_code": "use std::iter::{Filter, Map};\nuse std::ops::RangeFrom;\n\nfn main() {\n    fn print_30<T: Iterator<Item = u32>>(it: T) {\n        for i in it.take(30) {\n            print!(\"{} \", i);\n        }\n    }\n\n    println!(\"Pow. of 3\");\n    print_30(pow_3());\n\n    println!(\"\\nEvil\");\n    print_30(evil());\n\n    println!(\"\\nOdious\");\n    print_30(odious());\n}\n\ntype EvilOdiousIter = Filter<RangeFrom<u32>, fn(&u32) -> bool>;\n\nfn even_ones(i: &u32) -> bool {\n    i.count_ones() % 2 == 0\n}\n\nfn odious() -> EvilOdiousIter {\n    fn odds(n: &u32) -> bool {\n        !even_ones(n)\n    }\n    (0..).filter(odds as fn(&u32) -> bool)\n}\n\nfn evil() -> EvilOdiousIter {\n    (0..).filter(even_ones as fn(&u32) -> bool)\n}\n\nfn pow_3() -> Map<RangeFrom<u32>, fn(u32) -> u32> {\n    fn pw(n: u32) -> u32 {\n        3u64.pow(n).count_ones()\n    }\n\n    (0..).map(pw as fn(u32) -> u32)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{evil, odious, pow_3};\n    #[test]\n    fn test_odious() {\n        let exp = vec![\n            1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44,\n            47, 49, 50, 52, 55, 56, 59,\n        ];\n        let act = odious().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n\n    #[test]\n    fn test_evil() {\n        let exp = vec![\n            0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45,\n            46, 48, 51, 53, 54, 57, 58,\n        ];\n        let act = evil().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n\n    #[test]\n    fn test_pow_3() {\n        let exp = vec![\n            1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22,\n            16, 18, 24, 30, 25, 25,\n        ];\n        let act = pow_3().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n}\n",
    "path": "tasks/population-count",
    "remote_code": "fn main() {\n    let mut num = 1u64;\n    let mut vec = Vec::new();\n    for _ in 0..30 {\n        vec.push(num.count_ones());\n        num *= 3;\n    }\n    println!(\"pop count of 3^0, 3^1 ... 3^29:\\n{:?}\",vec);\n    let mut even = Vec::new();\n    let mut odd  = Vec::new();\n    num = 1;\n    while even.len() < 30 || odd.len() < 30 {\n        match 0 == num.count_ones()%2 {\n            true if even.len() < 30 => even.push(num),\n            false if odd.len() < 30 => odd.push(num),\n            _                       => {}\n        }\n        num += 1;\n    }\n    println!(\"\\nFirst 30 even pop count:\\n{:?}\",even);\n    println!(\"\\nFirst 30 odd pop count:\\n{:?}\",odd);\n}",
    "title": "Population count",
    "url": "http://rosettacode.org/wiki/Population_count"
  },
  {
    "local_code": "//! Given a set, generate its power set, which is the set of all subsets of that set.\n\nuse std::slice::Iter;\nuse std::vec::Vec;\n\n// If set == {}\n//   return {{}}\n// else if set == {a} U rest\n//   return power_set(rest) U ({a} U each set in power_set(rest))\nfn power_set<T>(items: &mut Iter<T>) -> Vec<Vec<T>>\nwhere\n    T: Clone,\n{\n    let mut power = Vec::new();\n    match items.next() {\n        None => power.push(Vec::new()),\n        Some(item) => {\n            for mut set in power_set(items) {\n                power.push(set.clone());\n                set.push(item.clone());\n                power.push(set);\n            }\n        }\n    }\n    power\n}\n\n#[test]\nfn test() {\n    let set = Vec::<i32>::new();\n    let power = power_set(&mut set.iter());\n    assert!(power == vec![vec![]]);\n\n    let set = vec![1, 2, 3];\n    let power = power_set(&mut set.iter());\n    assert!(\n        power\n            == vec![\n                vec![],\n                vec![1],\n                vec![2],\n                vec![2, 1],\n                vec![3],\n                vec![3, 1],\n                vec![3, 2],\n                vec![3, 2, 1],\n            ]\n    );\n}\n\nfn main() {\n    let set = vec![1, 2, 3, 4];\n    let power = power_set(&mut set.iter());\n    println!(\"Set      : {:?}\", set);\n    println!(\"Power Set: {:?}\", power);\n}\n",
    "path": "tasks/power-set",
    "remote_code": "use std::collections::BTreeSet;\n\nfn powerset<T: Ord + Clone>(mut set: BTreeSet<T>) -> BTreeSet<BTreeSet<T>> {\n    if set.is_empty() {\n        let mut powerset = BTreeSet::new();\n        powerset.insert(set);\n        return powerset;\n    }\n    // Access the first value. This could be replaced with `set.pop_first().unwrap()`\n    // But this is an unstable feature \n    let entry = set.iter().nth(0).unwrap().clone(); \n    set.remove(&entry);\n    let mut powerset = powerset(set);\n    for mut set in powerset.clone().into_iter() {\n        set.insert(entry.clone());\n        powerset.insert(set);\n    }\n    powerset\n}\n\nfn main() {\n    let set = (1..5).collect();\n    let set = powerset(set);\n    println!(\"{:?}\", set);\n\n    let set = [\"a\", \"b\", \"c\", \"d\"].iter().collect();\n    let set = powerset(set);\n    println!(\"{:?}\", set);\n}\n",
    "title": "Power set",
    "url": "http://rosettacode.org/wiki/Power_set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pragmatic directives",
    "url": "http://rosettacode.org/wiki/Pragmatic_directives"
  },
  {
    "local_code": "fn fix_price(num: f64) -> f64 {\n    let cents = (num.fract() * 100_f64) as u16;\n\n    match cents {\n        96..=100 => 1.00,\n        91..=95 => 0.98,\n        86..=90 => 0.94,\n        81..=85 => 0.90,\n        76..=80 => 0.86,\n        71..=75 => 0.82,\n        66..=70 => 0.78,\n        61..=65 => 0.74,\n        56..=60 => 0.70,\n        51..=55 => 0.66,\n        46..=50 => 0.62,\n        41..=45 => 0.58,\n        36..=40 => 0.54,\n        31..=35 => 0.50,\n        26..=30 => 0.44,\n        21..=25 => 0.38,\n        16..=20 => 0.32,\n        11..=15 => 0.26,\n        6..=10 => 0.18,\n        0..=5 => 0.10,\n        // panics on invalid value\n        _ => panic!(\"price out of range\"),\n    }\n}\n\nfn main() {\n    let mut n: f64 = 0.04;\n    while n <= 1.00 {\n        println!(\"{:.2} => {:.2}\", n, fix_price(n));\n        n += 0.04;\n    }\n}\n\n// typically this could be included in the match as those check for exhaustiveness already\n// by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)\n// but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this\n#[test]\nfn exhaustiveness_check() {\n    let mut input_price = 0.;\n    while input_price <= 1. {\n        fix_price(input_price);\n        input_price += 0.01;\n    }\n}\n",
    "path": "tasks/price-fraction",
    "remote_code": "fn fix_price(num: f64) -> f64 {\n    match num {\n        0.96...1.00 => 1.00,\n        0.91...0.96 => 0.98,\n        0.86...0.91 => 0.94,\n        0.81...0.86 => 0.90,\n        0.76...0.81 => 0.86,\n        0.71...0.76 => 0.82,\n        0.66...0.71 => 0.78,\n        0.61...0.66 => 0.74,\n        0.56...0.61 => 0.70,\n        0.51...0.56 => 0.66,\n        0.46...0.51 => 0.62,\n        0.41...0.46 => 0.58,\n        0.36...0.41 => 0.54,\n        0.31...0.36 => 0.50,\n        0.26...0.31 => 0.44,\n        0.21...0.26 => 0.38,\n        0.16...0.21 => 0.32,\n        0.11...0.16 => 0.26,\n        0.06...0.11 => 0.18,\n        0.00...0.06 => 0.10,\n        // panics on invalid value\n        _ => unreachable!(),\n    }\n}\n\nfn main() {\n    let mut n: f64 = 0.04;\n    while n <= 1.00 {\n        println!(\"{:.2} => {}\", n, fix_price(n));\n        n += 0.04;\n    }\n}\n\n// and a unit test to check that we haven't forgotten a branch, use 'cargo test' to execute test.\n//\n// typically this could be included in the match as those check for exhaustiveness already\n// by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)\n// but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this\n#[test]\nfn exhaustiveness_check() {\n    let mut input_price = 0.;\n    while input_price <= 1. {\n        fix_price(input_price);\n        input_price += 0.01;\n    }\n}",
    "title": "Price fraction",
    "url": "http://rosettacode.org/wiki/Price_fraction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn factorial_mod(mut n: u32, p: u32) -> u32 {\n    let mut f = 1;\n    while n != 0 && f != 0 {\n        f = (f * n) % p;\n        n -= 1;\n    }\n    f\n}\n\nfn is_prime(p: u32) -> bool {\n    p > 1 && factorial_mod(p - 1, p) == p - 1\n}\n\nfn main() {\n    println!(\"  n | prime?\\n------------\");\n    for p in vec![2, 3, 9, 15, 29, 37, 47, 57, 67, 77, 87, 97, 237, 409, 659] {\n        println!(\"{:>3} | {}\", p, is_prime(p));\n    }\n    println!(\"\\nFirst 120 primes by Wilson's theorem:\");\n    let mut n = 0;\n    let mut p = 1;\n    while n < 120 {\n        if is_prime(p) {\n            n += 1;\n            print!(\"{:>3}{}\", p, if n % 20 == 0 { '\\n' } else { ' ' });\n        }\n        p += 1;\n    }\n    println!(\"\\n1000th through 1015th primes:\");\n    let mut i = 0;\n    while n < 1015 {\n        if is_prime(p) {\n            n += 1;\n            if n >= 1000 {\n                i += 1;\n                print!(\"{:>3}{}\", p, if i % 16 == 0 { '\\n' } else { ' ' });\n            }\n        }\n        p += 1;\n    }\n}",
    "title": "Primality by Wilson's theorem",
    "url": "http://rosettacode.org/wiki/Primality_by_Wilson's_theorem"
  },
  {
    "local_code": "fn is_prime(number: i32) -> bool {\n    if number % 2 == 0 && number != 2 || number == 1 {\n        return false;\n    }\n\n    let limit = (number as f32).sqrt() as i32 + 1;\n\n    // We test if the number is divisible by any odd number up to the limit\n    (3..limit).step_by(2).all(|x| number % x != 0)\n}\n\nfn main() {\n    println!(\"{}\", is_prime(15_485_863)); // The 1 000 000th prime.\n    println!(\"{}\", is_prime(62_773_913)); // The product of the 1000th and 1001st primes.\n}\n\n#[test]\nfn test_one() {\n    // https://primes.utm.edu/notes/faq/one.html\n    assert!(!is_prime(1));\n}\n\n#[test]\nfn test_two() {\n    assert!(is_prime(2));\n}\n\n#[test]\nfn test_many() {\n    let primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31];\n    assert!(primes.iter().all(|&x| is_prime(x)));\n}\n",
    "path": "tasks/primality-by-trial-division",
    "remote_code": "fn is_prime(n: u64) -> bool {\n    match n {\n        0 | 1 => false,\n        2 => true,\n        _even if n % 2 == 0 => false,\n        _ => {\n            let sqrt_limit = (n as f64).sqrt() as u64;\n            (3..=sqrt_limit).step_by(2).find(|i| n % i == 0).is_none()\n        }\n    }\n}\n\nfn main() {\n    for i in (1..30).filter(|i| is_prime(*i)) {\n        println!(\"{} \", i);\n    }\n}",
    "title": "Primality by trial division",
    "url": "http://rosettacode.org/wiki/Primality_by_trial_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// main.rs\nmod bit_array;\nmod prime_sieve;\n\nuse prime_sieve::PrimeSieve;\n\n// See https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number\nfn upper_bound_for_nth_prime(n: usize) -> usize {\n    let x = n as f64;\n    (x * (x.ln() + x.ln().ln())) as usize\n}\n\nfn compute_transitions(limit: usize) {\n    use std::collections::BTreeMap;\n    let mut transitions = BTreeMap::new();\n    let mut prev = 2;\n    let mut count = 0;\n    let sieve = PrimeSieve::new(upper_bound_for_nth_prime(limit));\n    let mut n = 3;\n    while count < limit {\n        if sieve.is_prime(n) {\n            count += 1;\n            let digit = n % 10;\n            let key = (prev, digit);\n            if let Some(v) = transitions.get_mut(&key) {\n                *v += 1;\n            } else {\n                transitions.insert(key, 1);\n            }\n            prev = digit;\n        }\n        n += 2;\n    }\n    println!(\"First {} prime numbers:\", limit);\n    for ((from, to), c) in &transitions {\n        let freq = 100.0 * (*c as f32) / (limit as f32);\n        println!(\n            \"{} -> {}: count = {:7}, frequency = {:.2} %\",\n            from, to, c, freq\n        );\n    }\n}\n\nfn main() {\n    compute_transitions(1000000);\n    println!();\n    compute_transitions(100000000);\n}",
    "title": "Prime conspiracy",
    "url": "http://rosettacode.org/wiki/Prime_conspiracy"
  },
  {
    "local_code": "extern crate prime_decomposition;\n\nuse prime_decomposition::factor;\n\nfn main() {\n    println!(\"Factors of 5: {:?}\", factor(5));\n    println!(\"Factors of 15: {:?}\", factor(15));\n    println!(\"Factors of 16: {:?}\", factor(16));\n    println!(\"Factors of 10287: {:?}\", factor(10_287));\n}\npub fn factor(mut nb: usize) -> Vec<usize> {\n    let mut result = vec![];\n\n    // First we take out all even factors.\n    while nb % 2 == 0 {\n        result.push(2);\n        nb /= 2;\n    }\n\n    // Then (if any left) we take out the odd ones.\n    let mut cand = 3;\n    let mut max_bound = (nb as f32).sqrt() as usize + 1;\n\n    while cand <= max_bound {\n        while nb % cand == 0 {\n            result.push(cand);\n            nb /= cand;\n        }\n        max_bound = (nb as f32).sqrt() as usize + 1;\n        cand += 2;\n    }\n\n    if nb > 1 {\n        result.push(nb);\n    }\n\n    result\n}\n#[test]\nfn test_basic() {\n    assert!(factor(5) == vec![5]);\n    assert!(factor(15) == vec![3, 5]);\n    assert!(factor(16) == vec![2, 2, 2, 2]);\n    assert!(factor(10287) == vec![3, 3, 3, 3, 127]);\n}\n",
    "path": "tasks/prime-decomposition",
    "remote_code": "use num_bigint::BigUint;\nuse num_traits::{One, Zero};\nuse std::fmt::{Display, Formatter};\n\n#[derive(Clone, Debug)]\npub struct Factors {\n    pub number: BigUint,\n    pub result: Vec<BigUint>,\n}\n\nimpl Factors {\n    pub fn of(number: BigUint) -> Factors {\n        let mut factors = Self {\n            number: number.clone(),\n            result: Vec::new(),\n        };\n\n        let big_2 = BigUint::from(2u8);\n        let big_4 = BigUint::from(4u8);\n\n        factors.check(&big_2);\n        factors.check(&BigUint::from(3u8));\n\n        let mut divisor = BigUint::from(5u8);\n        while &divisor * &divisor <= factors.number {\n            factors.check(&divisor);\n            divisor += &big_2;\n            factors.check(&divisor);\n            divisor += &big_4;\n        }\n\n        if factors.number > BigUint::one() {\n            factors.result.push(factors.number);\n        }\n\n        factors.number = number; // Restore the number\n        factors\n    }\n\n    pub fn is_prime(&self) -> bool {\n        self.result.len() == 1\n    }\n\n    fn check(&mut self, divisor: &BigUint) {\n        while (&self.number % divisor).is_zero() {\n            self.result.push(divisor.clone());\n            self.number /= divisor;\n        }\n    }\n}\n\nimpl Display for Factors {\n    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n        let mut iter = self.result.iter();\n\n        match iter.next() {\n            None => write!(f, \"[]\"),\n\n            Some(first) => {\n                write!(f, \"[{}\", first)?;\n                for next in iter {\n                    write!(f, \", {}\", next)?;\n                }\n\n                write!(f, \"]\")\n            }\n        }\n    }\n}\n\nfn print_factors(number: BigUint) {\n    let factors = Factors::of(number);\n\n    if factors.is_prime() {\n        println!(\"{} -> {} (prime)\", factors.number, factors);\n    } else {\n        println!(\"{} -> {}\", factors.number, factors);\n    }\n}\n\nfn main() {\n    print_factors(24u32.into());\n    print_factors(32u32.into());\n    print_factors(37u32.into());\n\n    // Find Mersenne primes\n\n    for n in 2..70 {\n        print!(\"2**{} - 1: \", n);\n        print_factors((BigUint::from(2u8) << n) - BigUint::one());\n    }\n}\n",
    "title": "Prime decomposition",
    "url": "http://rosettacode.org/wiki/Prime_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: u32) -> bool {\n    assert!(n < 64);\n    ((1u64 << n) & 0x28208a20a08a28ac) != 0\n}\n\nfn prime_triangle_row(a: &mut [u32]) -> bool {\n    if a.len() == 2 {\n        return is_prime(a[0] + a[1]);\n    }\n    for i in (1..a.len() - 1).step_by(2) {\n        if is_prime(a[0] + a[i]) {\n            a.swap(i, 1);\n            if prime_triangle_row(&mut a[1..]) {\n                return true;\n            }\n            a.swap(i, 1);\n        }\n    }\n    false\n}\n\nfn prime_triangle_count(a: &mut [u32]) -> u32 {\n    let mut count = 0;\n    if a.len() == 2 {\n        if is_prime(a[0] + a[1]) {\n            count += 1;\n        }\n    } else {\n        for i in (1..a.len() - 1).step_by(2) {\n            if is_prime(a[0] + a[i]) {\n                a.swap(i, 1);\n                count += prime_triangle_count(&mut a[1..]);\n                a.swap(i, 1);\n            }\n        }\n    }\n    count\n}\n\nfn print(a: &[u32]) {\n    if a.is_empty() {\n        return;\n    }\n    print!(\"{:2}\", a[0]);\n    for x in &a[1..] {\n        print!(\" {:2}\", x);\n    }\n    println!();\n}\n\nfn main() {\n    use std::time::Instant;\n    let start = Instant::now();\n    for n in 2..21 {\n        let mut a: Vec<u32> = (1..=n).collect();\n        if prime_triangle_row(&mut a) {\n            print(&a);\n        }\n    }\n    println!();\n    for n in 2..21 {\n        let mut a: Vec<u32> = (1..=n).collect();\n        if n > 2 {\n            print!(\" \");\n        }\n        print!(\"{}\", prime_triangle_count(&mut a));\n    }\n    println!();\n    let time = start.elapsed();\n    println!(\"\\nElapsed time: {} milliseconds\", time.as_millis());\n}",
    "title": "Prime triangle",
    "url": "http://rosettacode.org/wiki/Prime_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Primes - allocate descendants to their ancestors",
    "url": "http://rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate primal;\nextern crate rayon;\nextern crate rug;\n\nuse rayon::prelude::*;\nuse rug::Integer;\n\nfn partial(p1 : usize, p2 : usize) -> String {\n    let mut aux = Integer::from(1);\n    let (_, hi) = primal::estimate_nth_prime(p2 as u64);\n    let sieve = primal::Sieve::new(hi as usize);\n    let prime1 = sieve.nth_prime(p1);\n    let prime2 = sieve.nth_prime(p2);\n\n    for i in sieve.primes_from(prime1).take_while(|i| *i <= prime2) {\n        aux = Integer::from(aux * i as u32);\n    }\n    aux.to_string_radix(10)\n}\n\nfn main() {\n    let mut j1 = Integer::new();\n    for k in [2,3,5,7,11,13,17,19,23,29].iter() { \n        j1.assign_primorial(*k);\n        println!(\"Primorial : {}\", j1);\n    }\n    println!(\"Digits of primorial 10 : {}\", partial(1, 10).chars().fold(0, |n, _| n + 1));\n    println!(\"Digits of primorial 100 : {}\", partial(1, 100).chars().fold(0, |n, _| n + 1));\n    println!(\"Digits of primorial 1_000 : {}\", partial(1, 1_000).chars().fold(0, |n, _| n + 1));\n    println!(\"Digits of primorial 10_000 : {}\", partial(1, 10_000).chars().fold(0, |n, _| n + 1));\n    println!(\"Digits of primorial 100_000 : {}\", partial(1, 100_000).chars().fold(0, |n, _| n + 1));\n    \n    let mut auxi = Integer::from(1);\n    let ranges = vec![[1, 300_000], [300_001, 550_000], [550_001, 800_000], [800_001, 1_000_000]];\n    let v = ranges.par_iter().map(|value| partial(value[0], value[1])).collect::<Vec<_>>();\n    for i in v.iter() {\n        auxi =Integer::from(&auxi * i.parse::<Integer>().unwrap());\n    }\n    let result = auxi.to_string_radix(10).chars().fold(0, |n, _| n+1);\n    println!(\"Digits of primorial 1_000_000 : {}\",result);\n}\n",
    "title": "Primorial numbers",
    "url": "http://rosettacode.org/wiki/Primorial_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::BinaryHeap;\nuse std::cmp::Ordering;\nuse std::borrow::Cow;\n\n#[derive(Eq, PartialEq)]\nstruct Item<'a> {\n    priority: usize,\n    task: Cow<'a, str>, // Takes either borrowed or owned string\n}\n\nimpl<'a> Item<'a> {\n    fn new<T>(p: usize, t: T) -> Self\n        where T: Into<Cow<'a, str>>\n    {\n        Item {\n            priority: p,\n            task: t.into(),\n        }\n    }\n}\n\n// Manually implpement Ord so we have a min heap\nimpl<'a> Ord for Item<'a> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.priority.cmp(&self.priority)\n    }\n}\n\n// PartialOrd is required by Ord\nimpl<'a> PartialOrd for Item<'a> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n\nfn main() {\n    let mut queue = BinaryHeap::with_capacity(5);\n    queue.push(Item::new(3, \"Clear drains\"));\n    queue.push(Item::new(4, \"Feed cat\"));\n    queue.push(Item::new(5, \"Make tea\"));\n    queue.push(Item::new(1, \"Solve RC tasks\"));\n    queue.push(Item::new(2, \"Tax return\"));\n\n    for item in queue {\n        println!(\"{}\", item.task);\n    }\n}",
    "title": "Priority queue",
    "url": "http://rosettacode.org/wiki/Priority_queue"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::{weighted::alias_method::WeightedIndex, Distribution};\nuse rand::prelude::*;\n\nconst DATA: [(&str, f64); 8] = [\n    (\"aleph\", 1.0 / 5.0),\n    (\"beth\", 1.0 / 6.0),\n    (\"gimel\", 1.0 / 7.0),\n    (\"daleth\", 1.0 / 8.0),\n    (\"he\", 1.0 / 9.0),\n    (\"waw\", 1.0 / 10.0),\n    (\"zayin\", 1.0 / 11.0),\n    (\"heth\", 1759.0 / 27720.0),\n];\n\nconst SAMPLES: usize = 1_000_000;\n\n/// Generate a weighted distribution for choosing an index.\nfn distribution() -> impl Distribution<usize> {\n    WeightedIndex::new(DATA.iter().map(|(_, p)| *p).collect()).unwrap()\n}\n\nfn take_samples<R: Rng>(rng: &mut R, wc: &impl Distribution<usize>) -> [usize; 8] {\n    let mut counts = [0; 8];\n    for _ in 0..SAMPLES {\n        let sample = rng.sample(wc);\n        counts[sample] += 1;\n    }\n    counts\n}\n\nfn print_mapping(counts: &[usize]) {\n    println!(\"Item   | Expected | Actual   \");\n    println!(\"-------+----------+----------\");\n    for (&(name, expected), &count) in DATA.iter().zip(counts.iter()) {\n        let real = count as f64 / SAMPLES as f64;\n        println!(\"{:06} | {:.6} | {:.6}\", name, expected, real);\n    }\n}\n\nfn main() {\n    let counts = take_samples(&mut thread_rng(), &distribution());\n    print_mapping(&counts);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[ignore]\n    fn deviation() {\n        let mut rng = thread_rng();\n        let dist = distribution();\n\n        let counts = take_samples(&mut rng, &dist);\n        for (&(_, expected), &count) in DATA.iter().zip(counts.iter()) {\n            let real = count as f64 / SAMPLES as f64;\n            let dev = (1.0 - real / expected).abs();\n            assert!(dev < 0.01, \"{}\", dev);\n        }\n    }\n}\n",
    "path": "tasks/probabilistic-choice",
    "remote_code": "extern crate rand;\n\nuse rand::distributions::{IndependentSample, Sample, Weighted, WeightedChoice};\nuse rand::{weak_rng, Rng};\n\nconst DATA: [(&str, f64); 8] = [\n    (\"aleph\", 1.0 / 5.0),\n    (\"beth\", 1.0 / 6.0),\n    (\"gimel\", 1.0 / 7.0),\n    (\"daleth\", 1.0 / 8.0),\n    (\"he\", 1.0 / 9.0),\n    (\"waw\", 1.0 / 10.0),\n    (\"zayin\", 1.0 / 11.0),\n    (\"heth\", 1759.0 / 27720.0),\n];\n\nconst SAMPLES: usize = 1_000_000;\n\n/// Generate a mapping to be used by `WeightedChoice`\nfn gen_mapping() -> Vec<Weighted<usize>> {\n    DATA.iter()\n        .enumerate()\n        .map(|(i, &(_, p))| Weighted {\n            // `WeightedChoice` requires `u32` weights rather than raw probabilities.  For each\n            // probability, we convert it to a `u32` weight, and associate it with an index. We\n            // multiply by a constant because small numbers such as 0.2 when casted to `u32`\n            // become `0`.  This conversion decreases the accuracy of the mapping, which is why we\n            // provide an implementation which uses `f64`s for the best accuracy.\n            weight: (p * 1_000_000_000.0) as u32,\n            item: i,\n        })\n        .collect()\n}\n\n/// Generate a mapping of the raw probabilities\nfn gen_mapping_float() -> Vec<f64> {\n    // This does the work of `WeightedChoice::new`, splitting a number into various ranges.  The\n    // `item` of `Weighted` is represented here merely by the probability's position in the `Vec`.\n    let mut running_total = 0.0;\n    DATA.iter()\n        .map(|&(_, p)| {\n            running_total += p;\n            running_total\n        })\n        .collect()\n}\n\n/// An implementation of `WeightedChoice` which uses probabilities rather than weights.  Refer to\n/// the `WeightedChoice` source for serious usage.\nstruct WcFloat {\n    mapping: Vec<f64>,\n}\n\nimpl WcFloat {\n    fn new(mapping: &[f64]) -> Self {\n        Self {\n            mapping: mapping.to_vec(),\n        }\n    }\n\n    // This is roughly the same logic as `WeightedChoice::ind_sample` (though is likely slower)\n    fn search(&self, sample_prob: f64) -> usize {\n        let idx = self.mapping\n            .binary_search_by(|p| p.partial_cmp(&sample_prob).unwrap());\n        match idx {\n            Ok(i) | Err(i) => i,\n        }\n    }\n}\n\nimpl IndependentSample<usize> for WcFloat {\n    fn ind_sample<R: Rng>(&self, rng: &mut R) -> usize {\n        // Because we know the total is exactly 1.0, we can merely use a raw float value.\n        // Otherwise caching `Range::new(0.0, running_total)` and sampling with\n        // `range.ind_sample(&mut rng)` is recommended.\n        let sample_prob = rng.next_f64();\n        self.search(sample_prob)\n    }\n}\n\nimpl Sample<usize> for WcFloat {\n    fn sample<R: Rng>(&mut self, rng: &mut R) -> usize {\n        self.ind_sample(rng)\n    }\n}\n\nfn take_samples<R: Rng, T>(rng: &mut R, wc: &T) -> [usize; 8]\nwhere\n    T: IndependentSample<usize>,\n{\n    let mut counts = [0; 8];\n    for _ in 0..SAMPLES {\n        let sample = wc.ind_sample(rng);\n        counts[sample] += 1;\n    }\n    counts\n}\n\nfn print_mapping(counts: &[usize]) {\n    println!(\"Item   | Expected | Actual   \");\n    println!(\"-------+----------+----------\");\n    for (&(name, expected), &count) in DATA.iter().zip(counts.iter()) {\n        let real = count as f64 / SAMPLES as f64;\n        println!(\"{:6} | {:.6} | {:.6}\", name, expected, real);\n    }\n}\n\nfn main() {\n    let mut rng = weak_rng();\n\n    println!(\"    ~~~ U32 METHOD ~~~\");\n    let mut mapping = gen_mapping();\n    let wc = WeightedChoice::new(&mut mapping);\n\n    let counts = take_samples(&mut rng, &wc);\n    print_mapping(&counts);\n\n    println!();\n\n    println!(\"   ~~~ FLOAT METHOD ~~~\");\n    // initialize the float version of `WeightedChoice`\n    let mapping = gen_mapping_float();\n    let wc = WcFloat::new(&mapping);\n\n    let counts = take_samples(&mut rng, &wc);\n    print_mapping(&counts);\n}",
    "title": "Probabilistic choice",
    "url": "http://rosettacode.org/wiki/Probabilistic_choice"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Problem of Apollonius",
    "url": "http://rosettacode.org/wiki/Problem_of_Apollonius"
  },
  {
    "local_code": "fn main() {\n    println!(\"Program: {}\", std::env::args().next().unwrap());\n}\n",
    "path": "tasks/program-name",
    "remote_code": "fn main() {\n    println!(\"Program: {}\", std::env::args().next().unwrap());\n}",
    "title": "Program name",
    "url": "http://rosettacode.org/wiki/Program_name"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\"The program is running\");\n    return;\n    println!(\"This line won't be printed\");\n}",
    "title": "Program termination",
    "url": "http://rosettacode.org/wiki/Program_termination"
  },
  {
    "local_code": "use std::cmp::Ordering;\n\n/// Populate input vector with prime numbers < maxvalue\nfn add_more_prime_numbers(v: &mut Vec<usize>, maxvalue: usize) {\n    let mut prime: usize = v[v.len() - 1];\n    if prime <= 2 {\n        prime = 1;\n    } // start with odd number\n    loop {\n        prime += 2;\n        if prime >= maxvalue {\n            break;\n        }\n        let mut isprime = true;\n        let ceiling = (prime as f64).sqrt() as usize;\n        // check below sqrt(prime)\n        for i in v.iter().skip(1).take_while(|&i| *i <= ceiling) {\n            if prime % *i == 0 {\n                isprime = false;\n                break;\n            }\n        }\n        if isprime {\n            v.push(prime);\n        }\n    }\n}\n\n/// Get proper divisors\nfn find_divisors(primes: &mut Vec<usize>, num: usize) -> Vec<usize> {\n    assert!(num > 0);\n    if num == 1 {\n        return Vec::new();\n    }\n    let mut kprime_factors = vec![1];\n    let ceiling = ((num as f64).sqrt() as usize) + 1;\n    add_more_prime_numbers(primes, ceiling);\n    // Filter all primes num % p == 0\n    let prime_factors: Vec<usize> = primes.iter().filter(|&p| num % *p == 0).cloned().collect();\n    // Check all k*p p..ceiling\n    // Following code is ineffective (due to duplicates) but simple\n    for p in prime_factors {\n        let mut kp = p;\n        while kp < ceiling {\n            if num % kp == 0 {\n                kprime_factors.push(kp);\n                kprime_factors.push(num / kp)\n            }\n            kp += p;\n        }\n    }\n    kprime_factors.sort_unstable();\n    kprime_factors.dedup();\n    kprime_factors\n}\n\nfn main() {\n    let mut primes: Vec<usize> = vec![2, 3]; // reusable prime number array\n\n    // Show the proper divisors of the numbers 1 to 10 inclusive.\n    for i in 1..11 {\n        print!(\"{}: \", i);\n        println!(\"{:?}\", find_divisors(&mut primes, i));\n    }\n\n    // Find a number in the range 1 to 20,000\n    // with the most proper divisors.\n    let mut max_divs: (usize, Vec<usize>) = (0, Vec::new());\n    for n in 1..20_001 {\n        let div_q = find_divisors(&mut primes, n).len();\n        match div_q.cmp(&max_divs.0) {\n            Ordering::Greater => {\n                max_divs.0 = div_q;\n                max_divs.1.clear();\n                max_divs.1.push(n);\n            }\n            Ordering::Equal => max_divs.1.push(n),\n            Ordering::Less => (),\n        }\n    }\n    println!(\n        \"Most divisors a number within 1 to 20000 has: {}\",\n        max_divs.0\n    );\n    print!(\"Numbers with {} divisors: \", max_divs.0);\n    println!(\"{:?}\", max_divs.1);\n}\n\n#[test]\nfn test_divisors() {\n    fn proper_divisors(num: usize) -> Vec<usize> {\n        let mut primes: Vec<usize> = vec![2, 3];\n        find_divisors(&mut primes, num)\n    }\n\n    assert!(proper_divisors(6) == vec![1, 2, 3]);\n    assert!(proper_divisors(100) == vec![1, 2, 4, 5, 10, 20, 25, 50]);\n}\n",
    "path": "tasks/proper-divisors",
    "remote_code": "trait ProperDivisors {\n    fn proper_divisors(&self) -> Option<Vec<u64>>;\n}\n\nimpl ProperDivisors for u64 {\n    fn proper_divisors(&self) -> Option<Vec<u64>> {\n        if self.le(&1) {\n            return None;\n        }\n        let mut divisors: Vec<u64> = Vec::new();\n\n        for i in 1..*self {\n            if *self % i == 0 {\n                divisors.push(i);\n            }\n        }\n        Option::from(divisors)\n    }\n}\n\nfn main() {\n    for i in 1..11 {\n        println!(\"Proper divisors of {:2}: {:?}\", i,\n                 i.proper_divisors().unwrap_or(vec![]));\n    }\n\n    let mut most_idx: u64 = 0;\n    let mut most_divisors: Vec<u64> = Vec::new();\n    for i in 1..20_001 {\n        let divs = i.proper_divisors().unwrap_or(vec![]);\n        if divs.len() > most_divisors.len() {\n            most_divisors = divs;\n            most_idx = i;\n        }\n    }\n    println!(\"In 1 to 20000, {} has the most proper divisors at {}\", most_idx,\n             most_divisors.len());\n}\n",
    "title": "Proper divisors",
    "url": "http://rosettacode.org/wiki/Proper_divisors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pseudo-random numbers/Combined recursive generator MRG32k3a",
    "url": "http://rosettacode.org/wiki/Pseudo-random_numbers/Combined_recursive_generator_MRG32k3a"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pseudo-random numbers/Middle-square method",
    "url": "http://rosettacode.org/wiki/Pseudo-random_numbers/Middle-square_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pseudo-random numbers/PCG32",
    "url": "http://rosettacode.org/wiki/Pseudo-random_numbers/PCG32"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pseudo-random numbers/Splitmix64",
    "url": "http://rosettacode.org/wiki/Pseudo-random_numbers/Splitmix64"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pseudo-random numbers/Xorshift star",
    "url": "http://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star"
  },
  {
    "local_code": "//Creates a pythagoras_tree.svg file (12 levels) that can be opened in a browser\n\nuse svg::node::element::{Group, Polygon};\n\nfn main() {\n    let mut doc = svg::Document::new().set(\"stroke\", \"white\");\n    let mut base: Vec<[(f64, f64); 2]> = vec![[(-200.0, 0.0), (200.0, 0.0)]];\n    for lvl in 0..12u8 {\n        let rg = |step| lvl.wrapping_mul(step).wrapping_add(80 - step * 2);\n        let mut group = Group::new().set(\"fill\", format!(\"#{:02X}{:02X}18\", rg(20), rg(30))); // level color\n        let mut next_base = Vec::new();\n        for [a, b] in base {\n            let v = (b.0 - a.0, b.1 - a.1);\n            let c = (a.0 + v.1, a.1 - v.0);\n            let d = (c.0 + v.0, c.1 + v.1);\n            let e = (c.0 + 0.5 * (v.0 + v.1), c.1 + 0.5 * (v.1 - v.0));\n            group = group.add(Polygon::new().set(\"points\", vec![a, c, e, d, c, d, b]));\n            next_base.extend([[c, e], [e, d]]);\n        }\n        base = next_base;\n        doc = doc.add(group);\n    }\n    let (x0, y0) = (base.iter()).fold((0.0, 0.0), |(x0, y0), [(x, y), _]| (x.min(x0), y.min(y0)));\n    let file = \"pythagoras_tree.svg\";\n    match svg::save(file, &doc.set(\"viewBox\", (x0, y0, -x0 * 2.0, -y0))) {\n        Ok(_) => println!(\"{file} file written successfully!\"),\n        Err(e) => println!(\"failed to write {file}: {e}\"),\n    }\n}\n",
    "path": "tasks/pythagoras-tree",
    "remote_code": null,
    "title": "Pythagoras tree",
    "url": "http://rosettacode.org/wiki/Pythagoras_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::collections::BinaryHeap;\n\nfn a094958_iter() -> Vec<u16> {\n    (0..12)\n        .map(|n| vec![1 << n, 5 * (1 << n)])\n        .flatten()\n        .filter(|x| x < &2200)\n        .collect::<BinaryHeap<u16>>()\n        .into_sorted_vec()\n}\n\nfn a094958_filter() -> Vec<u16> {\n    (1..2200) // ported from Sidef\n        .filter(|n| ((n & (n - 1) == 0) || (n % 5 == 0 && ((n / 5) & (n / 5 - 1) == 0))))\n        .collect()\n}\n\nfn a094958_loop() -> Vec<u16> {\n    let mut v = vec![];\n    for n in 0..12 {\n        v.push(1 << n);\n        if 5 * (1 << n) < 2200 {\n            v.push(5 * (1 << n));\n        }\n    }\n    v.sort();\n    return v;\n}\n\nfn main() {\n    println!(\"{:?}\", a094958_iter());\n    println!(\"{:?}\", a094958_loop());\n    println!(\"{:?}\", a094958_filter());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    static HAPPY: &str = \"[1, 2, 4, 5, 8, 10, 16, 20, 32, 40, 64, 80, 128, 160, 256, 320, 512, 640, 1024, 1280, 2048]\";\n    #[test]\n    fn test_a094958_iter() {\n        assert!(format!(\"{:?}\", a094958_iter()) == HAPPY);\n    }\n    #[test]\n    fn test_a094958_loop() {\n        assert!(format!(\"{:?}\", a094958_loop()) == HAPPY);\n    }\n    #[test]\n    fn test_a094958_filter() {\n        assert!(format!(\"{:?}\", a094958_filter()) == HAPPY);\n    }\n}\n",
    "title": "Pythagorean quadruples",
    "url": "http://rosettacode.org/wiki/Pythagorean_quadruples"
  },
  {
    "local_code": "use std::collections::LinkedList;\n\n/// Count the number of Pythagorean triples whose sum are below the specified limit (inclusive).\n/// Does a BFS over the tree of primitive Pythagorean triples (see [0]), and uses the fact that\n/// each child has a bigger sum than its parent.\n///\n/// [0]: http://en.wikipedia.org/wiki/Tree_of_Pythagorean_triples\nfn count_pythagorean_triples(below: u64) -> (u64, u64) {\n    let mut tot_cnt = 0;\n    let mut prim_cnt = 0;\n    let mut queue = LinkedList::new();\n\n    // Initiate the BFS with the root of the tree: (3, 4, 5)\n    queue.push_back((3i64, 4i64, 5i64));\n\n    while let Some((a, b, c)) = queue.pop_back() {\n        // We found a new primitive Pythagorean triplet: (a, b, c).\n        // (k*a, k*b, k*c) is a (not necessarily primitive) Pythagorean triplet for any positive\n        // integer k.\n        // We're interested in those with k*a + k*b + k*c <= below, and the number of them are\n        // exactly below / (a + b + c)\n        let cur = below / (a + b + c) as u64;\n        if cur > 0 {\n            tot_cnt += cur;\n            prim_cnt += 1;\n\n            // Explore the children of the current node\n            queue.push_back((a - 2 * b + 2 * c, 2 * a - b + 2 * c, 2 * a - 2 * b + 3 * c));\n            queue.push_back((a + 2 * b + 2 * c, 2 * a + b + 2 * c, 2 * a + 2 * b + 3 * c));\n            queue.push_back((\n                -a + 2 * b + 2 * c,\n                -2 * a + b + 2 * c,\n                -2 * a + 2 * b + 3 * c,\n            ));\n        }\n    }\n\n    (tot_cnt, prim_cnt)\n}\n\nfn main() {\n    for n in 1..9 {\n        let (tot, prim) = count_pythagorean_triples(10u64.pow(n));\n        println!(\n            \"Up to 10^{}: {:>10} triples {:>10} primitives\",\n            n, tot, prim\n        );\n    }\n}\n\n#[test]\nfn test_count_pythagorean_triples() {\n    assert_eq!(count_pythagorean_triples(10u64.pow(6)), (808950, 70229));\n}\n",
    "path": "tasks/pythagorean-triples",
    "remote_code": "use std::thread;\n\nfn f1 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut primitive_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        primitive_count +=  1 + f1(triangle[0], triangle[1], triangle[2], d);\n    }\n    primitive_count\n}\n\nfn f2 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut triplet_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        triplet_count +=  (d/l) + f2(triangle[0], triangle[1], triangle[2], d);\n    }\n    triplet_count\n}\n\nfn main () {\n    let new_th_1 = thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Primitive triples below {} : {}\", i, f1(3, 4, 5, i) + 1);\n            i *= 10;\n        }\n    }).unwrap();\n\n    let new_th_2 =thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Triples below {} : {}\", i, f2(3, 4, 5, i) + i/12);\n            i *= 10;\n        }\n    }).unwrap();\n\n    new_th_1.join().unwrap();\n    new_th_2.join().unwrap();\n}",
    "title": "Pythagorean triples",
    "url": "http://rosettacode.org/wiki/Pythagorean_triples"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "QR decomposition",
    "url": "http://rosettacode.org/wiki/QR_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt::{Display, Error, Formatter};\nuse std::ops::{Add, Mul, Neg};\n\n#[derive(Clone,Copy,Debug)]\nstruct Quaternion {\n    a: f64,\n    b: f64,\n    c: f64,\n    d: f64\n}\n\nimpl Quaternion {\n    pub fn new(a: f64, b: f64, c: f64, d: f64) -> Quaternion {\n        Quaternion {\n            a: a,\n            b: b,\n            c: c,\n            d: d\n        }\n    }\n\n    pub fn norm(&self) -> f64 {\n        (self.a.powi(2) + self.b.powi(2) + self.c.powi(2) + self.d.powi(2)).sqrt()\n    }\n\n    pub fn conjugate(&self) -> Quaternion {\n        Quaternion {\n            a: self.a,\n            b: -self.b,\n            c: -self.c,\n            d: -self.d\n        }\n    }\n}\n\nimpl Add for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: self.a + other.a,\n            b: self.b + other.b,\n            c: self.c + other.c,\n            d: self.d + other.d\n        }\n    }\n}\n\nimpl Add<f64> for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: f64) -> Self::Output {\n        Quaternion {\n            a: self.a + other,\n            b: self.b,\n            c: self.c,\n            d: self.d\n        }\n    }\n}\n\nimpl Add<Quaternion> for f64 {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: other.a + self,\n            b: other.b,\n            c: other.c,\n            d: other.d\n        }\n    }\n}\n\nimpl Display for Quaternion {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"({} + {}i + {}j + {}k)\", self.a, self.b, self.c, self.d)\n    }\n}\n\nimpl Mul for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, rhs: Quaternion) -> Self::Output {\n        Quaternion {\n            a: self.a * rhs.a - self.b * rhs.b - self.c * rhs.c - self.d * rhs.d,\n            b: self.a * rhs.b + self.b * rhs.a + self.c * rhs.d - self.d * rhs.c,\n            c: self.a * rhs.c - self.b * rhs.d + self.c * rhs.a + self.d * rhs.b,\n            d: self.a * rhs.d + self.b * rhs.c - self.c * rhs.b + self.d * rhs.a,\n        }\n    }\n}\n\nimpl Mul<f64> for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, other: f64) -> Self::Output {\n        Quaternion {\n            a: self.a * other,\n            b: self.b * other,\n            c: self.c * other,\n            d: self.d * other\n        }\n    }\n}\n\nimpl Mul<Quaternion> for f64 {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: other.a * self,\n            b: other.b * self,\n            c: other.c * self,\n            d: other.d * self\n        }\n    }\n}\n\nimpl Neg for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Quaternion {\n            a: -self.a,\n            b: -self.b,\n            c: -self.c,\n            d: -self.d\n        }\n    }\n}\n\nfn main() {\n    let q0 = Quaternion { a: 1., b: 2., c: 3., d: 4. };\n    let q1 = Quaternion::new(2., 3., 4., 5.);\n    let q2 = Quaternion::new(3., 4., 5., 6.);\n    let r: f64 = 7.;\n\n    println!(\"q0 = {}\", q0);\n    println!(\"q1 = {}\", q1);\n    println!(\"q2 = {}\", q2);\n    println!(\"r  = {}\", r);\n    println!();\n    println!(\"-q0 = {}\", -q0);\n    println!(\"conjugate of q0 = {}\", q0.conjugate());\n    println!();\n    println!(\"r + q0 = {}\", r + q0);\n    println!(\"q0 + r = {}\", q0 + r);\n    println!();\n    println!(\"r * q0 = {}\", r * q0);\n    println!(\"q0 * r = {}\", q0 * r);\n    println!();\n    println!(\"q0 + q1 = {}\", q0 + q1);\n    println!(\"q0 * q1 = {}\", q0 * q1);\n    println!();\n    println!(\"q0 * (conjugate of q0) = {}\", q0 * q0.conjugate());\n    println!();\n    println!(\" q0 + q1  * q2 = {}\", q0 + q1 * q2);\n    println!(\"(q0 + q1) * q2 = {}\", (q0 + q1) * q2);\n    println!();\n    println!(\" q0 *  q1  * q2  = {}\", q0 *q1 * q2);\n    println!(\"(q0 *  q1) * q2  = {}\", (q0 * q1) * q2);\n    println!(\" q0 * (q1  * q2) = {}\", q0 * (q1 * q2));\n    println!();\n    println!(\"normal of q0 = {}\", q0.norm());\n}",
    "title": "Quaternion type",
    "url": "http://rosettacode.org/wiki/Quaternion_type"
  },
  {
    "local_code": "//! This shows the implementation of a singly-linked queue with dequeue and enqueue. There are two\n//! peek implementations, one returns an immutable reference, the other returns a mutable one. This\n//! implementation also shows iteration over the Queue by value (consumes queue), immutable\n//! reference, and mutable reference.\n\nuse std::ptr;\n\npub struct Queue<T> {\n    head: Link<T>,\n\n    /// Raw, C-like pointer. Cannot be guaranteed safe\n    tail: *mut Item<T>,\n}\n\ntype Link<T> = Option<Box<Item<T>>>;\n\nstruct Item<T> {\n    elem: T,\n    next: Link<T>,\n}\n\npub struct IntoIter<T>(Queue<T>);\n\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Item<T>>,\n}\n\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Item<T>>,\n}\n\nimpl<T> Queue<T> {\n    #[must_use]\n    pub fn new() -> Self {\n        Queue {\n            head: None,\n            tail: ptr::null_mut(),\n        }\n    }\n\n    pub fn enqueue(&mut self, elem: T) {\n        let mut new_tail = Box::new(Item { elem, next: None });\n\n        let raw_tail: *mut _ = &mut *new_tail;\n\n        if self.tail.is_null() {\n            self.head = Some(new_tail);\n        } else {\n            unsafe {\n                (*self.tail).next = Some(new_tail);\n            }\n        }\n\n        self.tail = raw_tail;\n    }\n\n    pub fn dequeue(&mut self) -> Option<T> {\n        self.head.take().map(|head| {\n            let head = *head;\n            self.head = head.next;\n\n            if self.head.is_none() {\n                self.tail = ptr::null_mut();\n            }\n\n            head.elem\n        })\n    }\n\n    #[must_use]\n    pub fn peek(&self) -> Option<&T> {\n        self.head.as_ref().map(|item| &item.elem)\n    }\n\n    pub fn peek_mut(&mut self) -> Option<&mut T> {\n        self.head.as_mut().map(|item| &mut item.elem)\n    }\n\n    #[must_use]\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            next: self.head.as_deref(),\n        }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            next: self.head.as_deref_mut(),\n        }\n    }\n}\n\nimpl<T> Default for Queue<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> Drop for Queue<T> {\n    fn drop(&mut self) {\n        let mut cur_link = self.head.take();\n        while let Some(mut boxed_item) = cur_link {\n            cur_link = boxed_item.next.take();\n        }\n    }\n}\n\nimpl<T> IntoIterator for Queue<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter(self)\n    }\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.dequeue()\n    }\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.map(|item| {\n            self.next = item.next.as_deref();\n            &item.elem\n        })\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|item| {\n            self.next = item.next.as_deref_mut();\n            &mut item.elem\n        })\n    }\n}\n\nfn main() {\n    // The standard library has a double-ended queue implementation\n    // (VecDeque<T>) which will work here.\n    use std::collections::VecDeque;\n\n    let mut deque = VecDeque::new();\n    deque.push_back(\"Element1\");\n    deque.push_back(\"Element2\");\n    deque.push_back(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), deque.front());\n    assert_eq!(Some(\"Element1\"), deque.pop_front());\n    assert_eq!(Some(\"Element2\"), deque.pop_front());\n    assert_eq!(Some(\"Element3\"), deque.pop_front());\n    assert_eq!(None, deque.pop_front());\n\n    let mut queue = Queue::new();\n    queue.enqueue(\"Element1\");\n    queue.enqueue(\"Element2\");\n    queue.enqueue(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), queue.peek());\n    assert_eq!(Some(\"Element1\"), queue.dequeue());\n    assert_eq!(Some(\"Element2\"), queue.dequeue());\n    assert_eq!(Some(\"Element3\"), queue.dequeue());\n    assert_eq!(None, queue.dequeue());\n}\n\n#[test]\nfn test_queue() {\n    let mut queue = Queue::new();\n    queue.enqueue(\"Element1\");\n    queue.enqueue(\"Element2\");\n    queue.enqueue(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), queue.peek());\n    assert_eq!(Some(\"Element1\"), queue.dequeue());\n    assert_eq!(Some(\"Element2\"), queue.dequeue());\n    assert_eq!(Some(\"Element3\"), queue.dequeue());\n    assert_eq!(None, queue.dequeue());\n}\n",
    "path": "tasks/queue/definition",
    "remote_code": "use std::collections::VecDeque;\nfn main() {\n    let mut stack = VecDeque::new();\n    stack.push_back(\"Element1\");\n    stack.push_back(\"Element2\");\n    stack.push_back(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), stack.front());\n    assert_eq!(Some(\"Element1\"), stack.pop_front());\n    assert_eq!(Some(\"Element2\"), stack.pop_front());\n    assert_eq!(Some(\"Element3\"), stack.pop_front());\n    assert_eq!(None, stack.pop_front());\n}",
    "title": "Queue/Definition",
    "url": "http://rosettacode.org/wiki/Queue/Definition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::VecDeque;\n\nfn main() {\n    let mut queue = VecDeque::new();\n    queue.push_back(\"Hello\");\n    queue.push_back(\"World\");\n    while let Some(item) = queue.pop_front() {\n        println!(\"{}\", item);\n    }\n\n    if queue.is_empty() {\n        println!(\"Yes, it is empty!\");\n    }\n}\n",
    "title": "Queue/Usage",
    "url": "http://rosettacode.org/wiki/Queue/Usage"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// See https://en.wikipedia.org/wiki/Quickselect\n\nfn partition<T: PartialOrd>(a: &mut [T], left: usize, right: usize, pivot: usize) -> usize {\n    a.swap(pivot, right);\n    let mut store_index = left;\n    for i in left..right {\n        if a[i] < a[right] {\n            a.swap(store_index, i);\n            store_index += 1;\n        }\n    }\n    a.swap(right, store_index);\n    store_index\n}\n\nfn pivot_index(left: usize, right: usize) -> usize {\n    return left + (right - left) / 2;\n}\n\nfn select<T: PartialOrd>(a: &mut [T], mut left: usize, mut right: usize, n: usize) {\n    loop {\n        if left == right {\n            break;\n        }\n        let mut pivot = pivot_index(left, right);\n        pivot = partition(a, left, right, pivot);\n        if n == pivot {\n            break;\n        } else if n < pivot {\n            right = pivot - 1;\n        } else {\n            left = pivot + 1;\n        }\n    }\n}\n\n// Rearranges the elements of 'a' such that the element at index 'n' is\n// the same as it would be if the array were sorted, smaller elements are\n// to the left of it and larger elements are to its right.\nfn nth_element<T: PartialOrd>(a: &mut [T], n: usize) {\n    select(a, 0, a.len() - 1, n);\n}\n\nfn main() {\n    let a = vec![9, 8, 7, 6, 5, 0, 1, 2, 3, 4];\n    for n in 0..a.len() {\n        let mut b = a.clone();\n        nth_element(&mut b, n);\n        println!(\"n = {}, nth element = {}\", n + 1, b[n]);\n    }\n}",
    "title": "Quickselect algorithm",
    "url": "http://rosettacode.org/wiki/Quickselect_algorithm"
  },
  {
    "local_code": "fn main() {\n    let x = \"fn main() {\\n    let x = \";\n    let y = \"print!(\\\"{}{:?};\\n    let y = {:?};\\n    {}\\\", x, x, y, y)\\n}\\n\";\n    print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::PathBuf;\nuse std::process::Command;\n\n#[test]\nfn validate_quine() {\n    let contents = {\n        let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"src/main.rs\");\n        let mut code = File::open(path).unwrap();\n        let mut contents = String::new();\n        code.read_to_string(&mut contents).unwrap();\n        contents\n    };\n\n    let output = Command::new(\"cargo\")\n        .args(&[\"run\", \"--release\"])\n        .output()\n        .expect(\"failed to execute binary\");\n\n    let output = String::from_utf8_lossy(&output.stdout);\n\n    assert_eq!(contents, output);\n}\n",
    "path": "tasks/quine",
    "remote_code": "fn main() {\n    let x = \"fn main() {\\n    let x = \";\n    let y = \"print!(\\\"{}{:?};\\n    let y = {:?};\\n    {}\\\", x, x, y, y)\\n}\\n\";\n    print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}",
    "title": "Quine",
    "url": "http://rosettacode.org/wiki/Quine"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Quoting constructs",
    "url": "http://rosettacode.org/wiki/Quoting_constructs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "RCRPG",
    "url": "http://rosettacode.org/wiki/RCRPG"
  },
  {
    "local_code": "use ripemd160::{Digest, Ripemd160};\n\n/// Create a lowercase hexadecimal string using the\n/// RIPEMD160 hashing algorithm\nfn ripemd160(text: &str) -> String {\n    // create a lowercase hexadecimal string\n    // using the shortand for the format macro\n    // https://doc.rust-lang.org/std/fmt/trait.LowerHex.html\n    format!(\"{:x}\", Ripemd160::digest(text.as_bytes()))\n}\n\nfn main() {\n    println!(\"{}\", ripemd160(\"Rosetta Code\"));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ripemd160;\n\n    #[test]\n    fn test_ripemd160() {\n        assert_eq!(\n            ripemd160(\"Rosetta Code\"),\n            \"b3be159860842cebaa7174c8fff0aa9e50a5199f\"\n        );\n        assert_eq!(ripemd160(\"\"), \"9c1185a5c5e9fc54612808977ee8f548b2258d31\");\n        assert_eq!(\n            ripemd160(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n            \"b0e20b6e3116640286ed3a87a5713079b21f5189\"\n        );\n    }\n}\n",
    "path": "tasks/ripemd-160",
    "remote_code": "\nuse ripemd160::{Digest, Ripemd160};\n\n/// Create a lowercase hexadecimal string using the\n/// RIPEMD160 hashing algorithm\nfn ripemd160(text: &str) -> String {\n    // create a lowercase hexadecimal string\n    // using the shortand for the format macro\n    // https://doc.rust-lang.org/std/fmt/trait.LowerHex.html\n    format!(\"{:x}\", Ripemd160::digest(text.as_bytes()))\n}\n\nfn main() {\n    println!(\"{}\", ripemd160(\"Rosetta Code\"));\n}\n",
    "title": "RIPEMD-160",
    "url": "http://rosettacode.org/wiki/RIPEMD-160"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse rand::distributions::Uniform;\nuse rand::prelude::{thread_rng, ThreadRng};\nuse rand::Rng;\n\nfn main() {\n    for _ in 0..=10 {\n        attributes_engine();\n    }\n}\n\n#[derive(Copy, Clone, Debug)]\npub struct Dice {\n    amount: i32,\n    range: Uniform<i32>,\n    rng: ThreadRng,\n}\n\nimpl Dice {\n    //  Modeled after d20 polyhederal dice use and notation.\n    //  roll_pool() - returns Vec<i32> with length of vector determined by dice amount.\n    //  attribute_out() - returns i32, by sorting a dice pool of 4d6, dropping the lowest integer, and summing all elements.\n    pub fn new(amount: i32, size: i32) -> Self {\n        Self {\n            amount,\n            range: Uniform::new(1, size + 1),\n            rng: thread_rng(),\n        }\n    }\n\n    fn roll_pool(mut self) -> Vec<i32> {\n        (0..self.amount)\n            .map(|_| self.rng.sample(self.range))\n            .collect()\n    }\n\n    fn attribute_out(&self) -> i32 {\n        // Sort dice pool lowest to high and drain all results to exclude the lowest before summing.\n        let mut attribute_array: Vec<i32> = self.roll_pool();\n        attribute_array.sort();\n        attribute_array.drain(1..=3).sum()\n    }\n}\n\nfn attributes_finalizer() -> (Vec<i32>, i32, bool) {\n    let die: Dice = Dice::new(4, 6);\n    let mut attributes: Vec<i32> = Vec::new();\n\n    for _ in 0..6 {\n        attributes.push(die.attribute_out())\n    }\n    \n    let attributes_total: i32 = attributes.iter().sum();\n\n    let numerical_condition: bool = attributes\n        .iter()\n        .filter(|attribute| **attribute >= 15)\n        .count()\n        >= 2;\n\n    (attributes, attributes_total, numerical_condition)\n}\n\nfn attributes_engine() {\n    loop {\n        let (attributes, attributes_total, numerical_condition) = attributes_finalizer();\n        if (attributes_total >= 75) && (numerical_condition) {\n            println!(\n                \"{:?} | sum: {:?}\",\n                attributes, attributes_total\n            );\n            break;\n        } else {\n            continue;\n        }\n    }\n}\n",
    "title": "RPG attributes generator",
    "url": "http://rosettacode.org/wiki/RPG_attributes_generator"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::BigUint;\nuse num::integer::Integer;\nuse num::traits::{One, Zero};\n\nfn mod_exp(b: &BigUint, e: &BigUint, n: &BigUint) -> Result<BigUint, &'static str> {\n    if n.is_zero() {\n        return Err(\"modulus is zero\");\n    }\n    if b >= n {\n        // base is too large and should be split into blocks\n        return Err(\"base is >= modulus\");\n    }\n    if b.gcd(n) != BigUint::one() {\n        return Err(\"base and modulus are not relatively prime\");\n    }\n\n    let mut bb = b.clone();\n    let mut ee = e.clone();\n    let mut result = BigUint::one();\n    while !ee.is_zero() {\n        if ee.is_odd() {\n            result = (result * &bb) % n;\n        }\n        ee >>= 1;\n        bb = (&bb * &bb) % n;\n    }\n    Ok(result)\n}\n\nfn main() {\n    let msg = \"Rosetta Code\";\n\n    let n = \"9516311845790656153499716760847001433441357\"\n        .parse()\n        .unwrap();\n    let e = \"65537\".parse().unwrap();\n    let d = \"5617843187844953170308463622230283376298685\"\n        .parse()\n        .unwrap();\n\n    let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n    let enc = mod_exp(&msg_int, &e, &n).unwrap();\n    let dec = mod_exp(&enc, &d, &n).unwrap();\n    let msg_dec = String::from_utf8(dec.to_bytes_be()).unwrap();\n\n    println!(\"msg as txt: {}\", msg);\n    println!(\"msg as num: {}\", msg_int);\n    println!(\"enc as num: {}\", enc);\n    println!(\"dec as num: {}\", dec);\n    println!(\"dec as txt: {}\", msg_dec);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::mod_exp;\n    use num::bigint::BigUint;\n    use num::integer::Integer;\n    use num::traits::{FromPrimitive, Zero};\n\n    const N: &str = \"9516311845790656153499716760847001433441357\";\n    const E: &str = \"65537\";\n    const D: &str = \"5617843187844953170308463622230283376298685\";\n\n    fn rsa_numbers() -> (BigUint, BigUint, BigUint) {\n        let n = N.parse().unwrap();\n        let e = E.parse().unwrap();\n        let d = D.parse().unwrap();\n        (n, e, d)\n    }\n\n    #[test]\n    fn test_enc_dec() {\n        let (n, e, d) = rsa_numbers();\n        let msg = \"Rosetta Code\";\n        let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n        let enc = mod_exp(&msg_int, &e, &n).unwrap();\n        let dec = mod_exp(&enc, &d, &n).unwrap();\n        let msg_dec = String::from_utf8(dec.to_bytes_be()).unwrap();\n        assert_eq!(msg, msg_dec);\n    }\n\n    #[test]\n    fn test_enc_too_large_base() {\n        let (n, e, _) = rsa_numbers();\n        let msg = \"I am too large for this modulus!\";\n        let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n        assert!(msg_int > n);\n        let result = mod_exp(&msg_int, &e, &n);\n        assert_eq!(Err(\"base is >= modulus\"), result);\n    }\n\n    #[test]\n    fn test_enc_zero_modulus() {\n        let (_, e, _) = rsa_numbers();\n        let msg_int = BigUint::from_bytes_be(b\"msg\");\n        let result = mod_exp(&msg_int, &e, &BigUint::zero());\n        assert_eq!(Err(\"modulus is zero\"), result);\n    }\n\n    #[test]\n    fn test_base_modulus_not_relatively_prime() {\n        let (_, e, _) = rsa_numbers();\n        let b = BigUint::from_u8(12).unwrap();\n        let n = BigUint::from_u8(18).unwrap();\n        assert_eq!(&BigUint::from_u8(6).unwrap(), &b.gcd(&n));\n        let result = mod_exp(&b, &e, &n);\n        assert_eq!(Err(\"base and modulus are not relatively prime\"), result);\n    }\n}\n",
    "path": "tasks/rsa-code",
    "remote_code": "\nextern crate num;\n\nuse num::bigint::BigUint;\nuse num::integer::Integer;\nuse num::traits::{One, Zero};\n\nfn mod_exp(b: &BigUint, e: &BigUint, n: &BigUint) -> Result<BigUint, &'static str> {\n    if n.is_zero() {\n        return Err(\"modulus is zero\");\n    }\n    if b >= n {\n        // base is too large and should be split into blocks\n        return Err(\"base is >= modulus\");\n    }\n    if b.gcd(n) != BigUint::one() {\n        return Err(\"base and modulus are not relatively prime\");\n    }\n\n    let mut bb = b.clone();\n    let mut ee = e.clone();\n    let mut result = BigUint::one();\n    while !ee.is_zero() {\n        if ee.is_odd() {\n            result = (result * &bb) % n;\n        }\n        ee >>= 1;\n        bb = (&bb * &bb) % n;\n    }\n    Ok(result)\n}\n\nfn main() {\n    let msg = \"Rosetta Code\";\n\n    let n = \"9516311845790656153499716760847001433441357\"\n        .parse()\n        .unwrap();\n    let e = \"65537\".parse().unwrap();\n    let d = \"5617843187844953170308463622230283376298685\"\n        .parse()\n        .unwrap();\n\n    let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n    let enc = mod_exp(&msg_int, &e, &n).unwrap();\n    let dec = mod_exp(&enc, &d, &n).unwrap();\n    let msg_dec = String::from_utf8(dec.to_bytes_be()).unwrap();\n\n    println!(\"msg as txt: {}\", msg);\n    println!(\"msg as num: {}\", msg_int);\n    println!(\"enc as num: {}\", enc);\n    println!(\"dec as num: {}\", dec);\n    println!(\"dec as txt: {}\", msg_dec);\n}\n\n",
    "title": "RSA code",
    "url": "http://rosettacode.org/wiki/RSA_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ramanujan primes/twins",
    "url": "http://rosettacode.org/wiki/Ramanujan_primes/twins"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ramanujan's constant",
    "url": "http://rosettacode.org/wiki/Ramanujan's_constant"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Copy, Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\n// Returns the distance from point p to the line between p1 and p2\nfn perpendicular_distance(p: &Point, p1: &Point, p2: &Point) -> f64 {\n    let dx = p2.x - p1.x;\n    let dy = p2.y - p1.y;\n    (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x).abs() / dx.hypot(dy)\n}\n\nfn rdp(points: &[Point], epsilon: f64, result: &mut Vec<Point>) {\n    let n = points.len();\n    if n < 2 {\n        return;\n    }\n    let mut max_dist = 0.0;\n    let mut index = 0;\n    for i in 1..n - 1 {\n        let dist = perpendicular_distance(&points[i], &points[0], &points[n - 1]);\n        if dist > max_dist {\n            max_dist = dist;\n            index = i;\n        }\n    }\n    if max_dist > epsilon {\n        rdp(&points[0..=index], epsilon, result);\n        rdp(&points[index..n], epsilon, result);\n    } else {\n        result.push(points[n - 1]);\n    }\n}\n\nfn ramer_douglas_peucker(points: &[Point], epsilon: f64) -> Vec<Point> {\n    let mut result = Vec::new();\n    if points.len() > 0 && epsilon >= 0.0 {\n        result.push(points[0]);\n        rdp(points, epsilon, &mut result);\n    }\n    result\n}\n\nfn main() {\n    let points = vec![\n        Point { x: 0.0, y: 0.0 },\n        Point { x: 1.0, y: 0.1 },\n        Point { x: 2.0, y: -0.1 },\n        Point { x: 3.0, y: 5.0 },\n        Point { x: 4.0, y: 6.0 },\n        Point { x: 5.0, y: 7.0 },\n        Point { x: 6.0, y: 8.1 },\n        Point { x: 7.0, y: 9.0 },\n        Point { x: 8.0, y: 9.0 },\n        Point { x: 9.0, y: 9.0 },\n    ];\n    for p in ramer_douglas_peucker(&points, 1.0) {\n        println!(\"{}\", p);\n    }\n}",
    "title": "Ramer-Douglas-Peucker line simplification",
    "url": "http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Random Latin squares",
    "url": "http://rosettacode.org/wiki/Random_Latin_squares"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse rand::rngs::OsRng;\n\nfn main() {\n    let mut rng = OsRng;\n    let rand_num: u32 = rng.gen();\n    println!(\"{}\", rand_num);\n}\n",
    "path": "tasks/random-number-generator/device",
    "remote_code": "extern crate rand;\n\nuse rand::{OsRng, Rng};\n\nfn main() {\n    // because `OsRng` opens files, it may fail\n    let mut rng = match OsRng::new() {\n        Ok(v) => v,\n        Err(e) => panic!(\"Failed to obtain OS RNG: {}\", e)\n    };\n\n    let rand_num: u32 = rng.gen();\n    println!(\"{}\", rand_num);\n}",
    "title": "Random number generator (device)",
    "url": "http://rosettacode.org/wiki/Random_number_generator_(device)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Random number generator (included)",
    "url": "http://rosettacode.org/wiki/Random_number_generator_(included)"
  },
  {
    "local_code": "use rand::Rng;\nuse rand_distr::Normal;\n\nfn main() {\n    let normal = Normal::new(1.0, 0.5).unwrap();\n    let mut rng = rand::thread_rng();\n\n    let rands = (0..1000).map(|_| rng.sample(normal)).collect::<Vec<_>>();\n    println!(\"{:?}\", rands);\n}\n",
    "path": "tasks/random-numbers",
    "remote_code": "extern crate rand;\nuse rand::distributions::{Normal, IndependentSample};\n\nfn main() {\n    let mut rands = [0.0; 1000];\n    let normal = Normal::new(1.0, 0.5);\n    let mut rng = rand::thread_rng();\n    for num in rands.iter_mut() {\n        *num = normal.ind_sample(&mut rng);\n    }\n}",
    "title": "Random numbers",
    "url": "http://rosettacode.org/wiki/Random_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Random sentence from book",
    "url": "http://rosettacode.org/wiki/Random_sentence_from_book"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt::{Display, Formatter};\n\n// We could use std::ops::RangeInclusive, but we would have to extend it to\n// normalize self (not much trouble) and it would not have to handle pretty\n// printing for it explicitly. So, let's make rather an own type.\n\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\npub struct ClosedRange<Idx> {\n    start: Idx,\n    end: Idx,\n}\n\nimpl<Idx> ClosedRange<Idx> {\n    pub fn start(&self) -> &Idx {\n        &self.start\n    }\n\n    pub fn end(&self) -> &Idx {\n        &self.end\n    }\n}\n\nimpl<Idx: PartialOrd> ClosedRange<Idx> {\n    pub fn new(start: Idx, end: Idx) -> Self {\n        if start <= end {\n            Self { start, end }\n        } else {\n            Self {\n                end: start,\n                start: end,\n            }\n        }\n    }\n}\n\n// To make test input more compact\nimpl<Idx: PartialOrd> From<(Idx, Idx)> for ClosedRange<Idx> {\n    fn from((start, end): (Idx, Idx)) -> Self {\n        Self::new(start, end)\n    }\n}\n\n// For the required print format\nimpl<Idx: Display> Display for ClosedRange<Idx> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"[{}, {}]\", self.start, self.end)\n    }\n}\n\nfn consolidate<Idx>(a: &ClosedRange<Idx>, b: &ClosedRange<Idx>) -> Option<ClosedRange<Idx>>\nwhere\n    Idx: PartialOrd + Clone,\n{\n    if a.start() <= b.start() {\n        if b.end() <= a.end() {\n            Some(a.clone())\n        } else if a.end() < b.start() {\n            None\n        } else {\n            Some(ClosedRange::new(a.start().clone(), b.end().clone()))\n        }\n    } else {\n        consolidate(b, a)\n    }\n}\n\nfn consolidate_all<Idx>(mut ranges: Vec<ClosedRange<Idx>>) -> Vec<ClosedRange<Idx>>\nwhere\n    Idx: PartialOrd + Clone,\n{\n    // Panics for incomparable elements! So no NaN for floats, for instance.\n    ranges.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut ranges = ranges.into_iter();\n    let mut result = Vec::new();\n\n    if let Some(current) = ranges.next() {\n        let leftover = ranges.fold(current, |mut acc, next| {\n            match consolidate(&acc, &next) {\n                Some(merger) => {\n                    acc = merger;\n                }\n\n                None => {\n                    result.push(acc);\n                    acc = next;\n                }\n            }\n\n            acc\n        });\n\n        result.push(leftover);\n    }\n\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{consolidate_all, ClosedRange};\n    use std::fmt::{Display, Formatter};\n\n    struct IteratorToDisplay<F>(F);\n\n    impl<F, I> Display for IteratorToDisplay<F>\n    where\n        F: Fn() -> I,\n        I: Iterator,\n        I::Item: Display,\n    {\n        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n            let mut items = self.0();\n\n            if let Some(item) = items.next() {\n                write!(f, \"{}\", item)?;\n                for item in items {\n                    write!(f, \", {}\", item)?;\n                }\n            }\n\n            Ok(())\n        }\n    }\n\n    macro_rules! parameterized {\n        ($($name:ident: $value:expr,)*) => {\n            $(\n                #[test]\n                fn $name() {\n                    let (input, expected) = $value;\n                    let expected: Vec<_> = expected.into_iter().map(ClosedRange::from).collect();\n                    let output = consolidate_all(input.into_iter().map(ClosedRange::from).collect());\n                    println!(\"{}: {}\", stringify!($name), IteratorToDisplay(|| output.iter()));\n                    assert_eq!(expected, output);\n                }\n            )*\n        }\n    }\n\n    parameterized! {\n        single: (vec![(1.1, 2.2)], vec![(1.1, 2.2)]),\n        touching: (vec![(6.1, 7.2), (7.2, 8.3)], vec![(6.1, 8.3)]),\n        disjoint: (vec![(4, 3), (2, 1)], vec![(1, 2), (3, 4)]),\n        overlap: (vec![(4.0, 3.0), (2.0, 1.0), (-1.0, -2.0), (3.9, 10.0)], vec![(-2.0, -1.0), (1.0, 2.0), (3.0, 10.0)]),\n        integer: (vec![(1, 3), (-6, -1), (-4, -5), (8, 2), (-6, -6)], vec![(-6, -1), (1, 8)]),\n    }\n}\n\nfn main() {\n    // To prevent dead code and to check empty input\n    consolidate_all(Vec::<ClosedRange<usize>>::new());\n\n    println!(\"Run: cargo test -- --nocapture\");\n}",
    "title": "Range consolidation",
    "url": "http://rosettacode.org/wiki/Range_consolidation"
  },
  {
    "local_code": "extern crate regex;\n\nuse regex::Regex;\n\nfn main() {\n    let range = \"-6,-3-1,3-5,7-11,14,15,17-20\";\n    println!(\"Expanded range: {:?}\", expand_range(range));\n}\n\n/// Expand a string containing numbers and ranges, into a vector of numbers\nfn expand_range(range: &str) -> Vec<isize> {\n    let mut result = vec![];\n\n    for item in range.split(',') {\n        result.extend(expand_item(item).into_iter());\n    }\n\n    result\n}\n\n/// Expand a single element, which can be a number or a range.\nfn expand_item(item: &str) -> Vec<isize> {\n    // Handle the case of a single number\n    if let Some(cap) = Regex::new(r\"^(-?\\d+)$\").unwrap().captures(item) {\n        return vec![cap.get(0).and_then(|s| s.as_str().parse().ok()).unwrap()];\n    }\n\n    // Handle the case of a range\n    if let Some(cap) = Regex::new(r\"^(-?\\d+)-(-?\\d+)$\").unwrap().captures(item) {\n        let left: isize = cap.get(1).and_then(|s| s.as_str().parse().ok()).unwrap();\n        let right: isize = cap.get(2).and_then(|s| s.as_str().parse().ok()).unwrap();\n\n        // Generate and collect a range between them\n        return (left..right + 1).collect();\n    }\n\n    panic!(\"The item `{}` is not a number or a range!\", item);\n}\n\n#[test]\nfn test_basic() {\n    let range = \"1-5,6\";\n    assert!(expand_range(range) == vec![1, 2, 3, 4, 5, 6]);\n\n    let range = \"-6,-3-1,3-5,7-11,14,15,17-20\";\n    assert!(\n        expand_range(range)\n            == vec![-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20,]\n    );\n}\n\n#[test]\n#[should_panic]\nfn test_wrong() {\n    let range = \"one-five,six\";\n    assert!(expand_range(range) == vec![1, 2, 3, 4, 5, 6]);\n}\n",
    "path": "tasks/range-expansion",
    "remote_code": "use std::str::FromStr;\n\n// Precondition: range doesn't contain multibyte UTF-8 characters\nfn range_expand(range : &str) -> Vec<i32> {\n   range.split(',').flat_map(|item| {\n        match i32::from_str(item) {\n            Ok(n) => n..n+1,\n            _ => {\n                let dashpos=\n                    match item.rfind(\"--\") {\n                        Some(p) => p,\n                        None => item.rfind('-').unwrap(),\n                    };\n                let rstart=i32::from_str(\n                    unsafe{ item.slice_unchecked(0,dashpos)} ).unwrap();\n                let rend=i32::from_str(\n                    unsafe{ item.slice_unchecked(dashpos+1,item.len()) } ).unwrap();\n                rstart..rend+1\n            },\n        }\n    }).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", range_expand(\"-6,-3--1,3-5,7-11,14,15,17-20\"));\n}\n",
    "title": "Range expansion",
    "url": "http://rosettacode.org/wiki/Range_expansion"
  },
  {
    "local_code": "extern crate num;\n\nuse num::One;\n\nuse std::ops::Add;\n\nstruct RangeFinder<'a, T: 'a> {\n    index: usize,\n    length: usize,\n    arr: &'a [T],\n}\n\nimpl<'a, T> Iterator for RangeFinder<'a, T>\nwhere\n    T: PartialEq + Add<T, Output = T> + Copy + One,\n{\n    type Item = (T, Option<T>);\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index == self.length {\n            return None;\n        }\n        let lo = self.index;\n        while self.index < self.length - 1\n            && self.arr[self.index + 1] == self.arr[self.index] + T::one()\n        {\n            self.index += 1\n        }\n        let hi = self.index;\n        self.index += 1;\n        if hi - lo > 1 {\n            Some((self.arr[lo], Some(self.arr[hi])))\n        } else {\n            if hi - lo == 1 {\n                self.index -= 1\n            }\n            Some((self.arr[lo], None))\n        }\n    }\n}\n\nimpl<'a, T> RangeFinder<'a, T> {\n    fn new(a: &'a [T]) -> Self {\n        RangeFinder {\n            index: 0,\n            arr: a,\n            length: a.len(),\n        }\n    }\n}\n\nfn main() {\n    let n = &[\n        0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29,\n        30, 31, 32, 33, 35, 36, 37, 38, 39,\n    ];\n\n    for (i, (lo, hi)) in RangeFinder::new(n).enumerate() {\n        if i > 0 {\n            print!(\", \")\n        }\n        print!(\"{}\", lo);\n        if hi.is_some() {\n            print!(\"-{}\", hi.unwrap())\n        }\n    }\n    println!();\n}\n\n#[test]\nfn test_solution() {\n    let n: &[u8] = &[\n        0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29,\n        30, 31, 32, 33, 35, 36, 37, 38, 39,\n    ];\n\n    let actual: Vec<(u8, Option<u8>)> = RangeFinder::new(n).collect();\n    let expected = &[\n        (0, Some(2)),\n        (4, None),\n        (6, Some(8)),\n        (11, None),\n        (12, None),\n        (14, Some(25)),\n        (27, Some(33)),\n        (35, Some(39)),\n    ];\n\n    assert_eq!(&actual, expected);\n}\n",
    "path": "tasks/range-extraction",
    "remote_code": "use std::ops::Add;\n \nstruct RangeFinder<'a, T: 'a> {\n    index: usize,\n    length: usize,\n    arr: &'a [T],\n}\n \nimpl<'a, T> Iterator for RangeFinder<'a, T> where T: PartialEq + Add<i8, Output=T> + Copy {\n    type Item = (T,  Option<T>);\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index == self.length {\n            return None;\n        }\n        let lo = self.index;\n        while self.index < self.length - 1 && self.arr[self.index + 1] == self.arr[self.index] + 1 {\n            self.index += 1\n        }\n        let hi = self.index;\n        self.index += 1;\n        if hi - lo > 1 {\n            Some((self.arr[lo], Some(self.arr[hi])))\n        } else {\n            if hi - lo == 1 {\n                self.index -= 1\n            }\n            Some((self.arr[lo], None))\n        }\n    }\n}\n \nimpl<'a, T> RangeFinder<'a, T> {\n    fn new(a: &'a [T]) -> Self {\n        RangeFinder {\n            index: 0,\n            arr: a,\n            length: a.len(),\n        }\n    }\n}\n\nfn main() {\n    let input_numbers : &[i8] = &[0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n                                  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n                                  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n                                  37, 38, 39];\n    for (i, (lo, hi)) in RangeFinder::new(&input_numbers).enumerate() {\n        if i > 0 {print!(\",\")}\n        print!(\"{}\", lo);\n        if hi.is_some() {print!(\"-{}\", hi.unwrap())}\n    }\n    println!(\"\");\n}",
    "title": "Range extraction",
    "url": "http://rosettacode.org/wiki/Range_extraction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ranking methods",
    "url": "http://rosettacode.org/wiki/Ranking_methods"
  },
  {
    "local_code": "use itertools::Itertools;\nuse std::collections::HashMap;\nuse std::convert::TryInto;\nuse std::fmt;\nuse std::time::Instant;\n\n#[derive(Debug)]\nstruct RareResults {\n    digits: u8,\n    time_to_find: u128,\n    counter: u32,\n    number: u64,\n}\n\nimpl fmt::Display for RareResults {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{:>6} {:>6} ms {:>2}. {}\",\n            self.digits, self.time_to_find, self.counter, self.number\n        )\n    }\n}\n\nfn print_results(results: Vec<RareResults>) {\n    if !results.is_empty() {\n        // println!(\"Results:\");\n        println!(\"digits      time  #. Rare number\");\n        for r in results {\n            println!(\"{}\", r);\n        }\n    }\n}\n\n#[allow(clippy::cast_precision_loss)]\n#[allow(clippy::cast_possible_truncation)]\n#[allow(clippy::cast_sign_loss)]\nfn isqrt(n: u64) -> u64 {\n    let mut s = (n as f64).sqrt() as u64;\n    s = (s + n / s) >> 1;\n    if s * s > n {\n        s - 1\n    } else {\n        s\n    }\n}\n\nfn is_square(n: u64) -> bool {\n    match n & 0xf {\n        0 | 1 | 4 | 9 => {\n            let t = isqrt(n);\n            t * t == n\n        }\n        _ => false,\n    }\n}\n\nfn get_reverse(number: u64) -> u64 {\n    number\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap())\n        .enumerate()\n        .fold(0_u64, |a, (i, d)| a + 10_u64.pow(i as u32) * u64::from(d))\n}\nfn is_rare(number: u64) -> bool {\n    let reverse = get_reverse(number);\n\n    reverse != number\n        && number > reverse\n        && is_square(number + reverse)\n        && is_square(number - reverse)\n}\n\n/// This method is a very simple naive search, using brute-force to check a high amount of numbers\n/// for satisfying the rare number criterias. As such it is rather slow, and above 10 digits it's\n/// not really performant, release version takes ~30 secs to find the first 5 (max 10 digits)\nfn naive(digit: u8) -> Vec<RareResults> {\n    let bp_equal = (0_u8..=9).zip(0_u8..=9).collect::<Vec<(u8, u8)>>();\n    let bp_zero_or_even = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| (pair.0 == pair.1) || (i32::from(pair.0) - i32::from(pair.1)).abs() % 2 == 0)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_odd = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| (i32::from(pair.0) - i32::from(pair.1)).abs() % 2 == 1)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_9 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| pair.0 + pair.1 == 9)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_73 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| [7, 3].contains(&(i16::from(pair.0) - i16::from(pair.1))))\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_11 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| pair.0 + pair.1 == 11 || pair.1 + pair.0 == 1)\n        .collect::<Vec<(u8, u8)>>();\n\n    let aq_bp_setup = vec![\n        ((2, 2), &bp_equal),\n        ((4, 0), &bp_zero_or_even),\n        ((6, 0), &bp_odd),\n        ((6, 5), &bp_odd),\n        ((8, 2), &bp_9),\n        ((8, 3), &bp_73),\n        ((8, 7), &bp_11),\n        ((8, 8), &bp_equal),\n    ];\n\n    //generate AB-PQ combinations\n    let aq_bp = aq_bp_setup\n        .iter()\n        .flat_map(|e| {\n            e.1.iter().fold(vec![], |mut out, b| {\n                out.push(vec![e.0 .0, b.0, b.1, e.0 .1]);\n                out\n            })\n        })\n        .collect::<Vec<_>>();\n\n    let mut results: Vec<RareResults> = Vec::new();\n    let mut counter = 0_u32;\n    let start_time = Instant::now();\n\n    let d = digit;\n    print!(\"Digits: {} \", d);\n\n    if d < 4 {\n        for n in 10_u64.pow((d - 1).into())..10_u64.pow(d.into()) {\n            if is_rare(n) {\n                counter += 1;\n                results.push(RareResults {\n                    digits: d,\n                    time_to_find: start_time.elapsed().as_millis(),\n                    counter,\n                    number: n,\n                });\n            }\n        }\n    } else {\n        aq_bp.iter().for_each(|abqp| {\n            let start = u64::from(abqp[0]) * 10_u64.pow((d - 1).into())\n                + u64::from(abqp[1]) * 10_u64.pow((d - 2).into())\n                + 10_u64 * u64::from(abqp[2])\n                + u64::from(abqp[3]);\n\n            // brute-force checking all numbers which matches the pattern AB...PQ\n            // very slow\n            for n in (start..start + 10_u64.pow((d - 2).into())).step_by(100) {\n                if is_rare(n) {\n                    counter += 1;\n                    results.push(RareResults {\n                        digits: d,\n                        time_to_find: start_time.elapsed().as_millis(),\n                        counter,\n                        number: n,\n                    });\n                }\n            }\n        });\n    }\n\n    println!(\n        \"Digits: {} done - Elapsed time(ms): {}\",\n        d,\n        start_time.elapsed().as_millis()\n    );\n\n    results\n}\n\n/// This algorithm uses an advanced search strategy based on Nigel Galloway's approach,\n/// and can find the first 40 rare numers (16 digits) within reasonable\n/// time in release version\nfn advanced(digit: u8) -> Vec<RareResults> {\n    // setup\n    let mut results: Vec<RareResults> = Vec::new();\n    let mut counter = 0_u32;\n    let start_time = Instant::now();\n\n    let numeric_digits = (0..=9).map(|x| [x, 0]).collect::<Vec<_>>();\n\n    // lookup table for the first diff\n    let lookup_1 = vec![\n        vec![[2, 2], [8, 8]], //Diff = 0\n        vec![[8, 7], [6, 5]], //Diff = 1\n        vec![],\n        vec![],\n        vec![[4, 0]],         // Diff = 4\n        vec![[8, 3]],         // Diff = 5\n        vec![[6, 0], [8, 2]], // Diff = 6\n    ];\n\n    // lookup table for all possible digits pairs and their diffs\n    let lookup_n: HashMap<i8, Vec<_>> = (0_i8..=9)\n        .cartesian_product(0_i8..=9)\n        .map(|x| [x.0, x.1])\n        .into_group_map_by(|elt| elt[0] - elt[1]);\n\n    // powers like 1, 10, 100, 1000....\n    let powers = (0..digit)\n        .map(|x| 10_u64.pow(x.into()))\n        .collect::<Vec<u64>>();\n\n    // for n-r (aka L) the required terms, like 9/ 99 / 999 & 90 / 99999 & 9999 & 900 etc\n    let terms = powers\n        .iter()\n        .zip(powers.iter().rev())\n        .map(|(a, b)| b.checked_sub(*a).unwrap_or(0))\n        .filter(|x| *x != 0)\n        .collect::<Vec<u64>>();\n\n    // create a cartesian product for all potetential diff numbers\n    // for the first use the very short one, for all other the complete 19 element\n    let diffs1: Vec<i8> = vec![0, 1, 4, 5, 6];\n    let all_diffs = (-9_i8..=9).collect::<Vec<_>>();\n\n    let diff_list_iter = (0_u8..(digit / 2))\n        .map(|i| match i {\n            0 => diffs1.iter(),\n            _ => all_diffs.iter(),\n        })\n        .multi_cartesian_product()\n        .filter(|x| {\n            // remove invalid first diff/second diff combinations - custom iterator would\n            // probably be better\n            if x.len() == 1 {\n                return true;\n            }\n            match (*x[0], *x[1]) {\n                (a, b) if (a == 0 && b != 0) => false,\n                (a, b) if (a == 1 && ![-7, -5, -3, -1, 1, 3, 5, 7].contains(&b)) => false,\n                (a, b) if (a == 4 && ![-8, -6, -4, -2, 0, 2, 4, 6, 8].contains(&b)) => false,\n                (a, b) if (a == 5 && ![7, -3].contains(&b)) => false,\n                (a, b) if (a == 6 && ![-9 - 7, -5, -3, -1, 1, 3, 5, 7, 9].contains(&b)) => false,\n                _ => true,\n            }\n        });\n\n    diff_list_iter.for_each(|diffs| {\n        // calculate difference of original n and its reverse (aka L = n-r)\n        // which must be a perfect square\n        let l: i64 = diffs\n            .iter()\n            .zip(terms.iter())\n            .map(|(diff, term)| **diff as i64 * *term as i64)\n            .sum();\n\n        if l > 0 && is_square(l.try_into().unwrap()) {\n            // potential candiate, at least L is a perfect square\n\n            // placeholder for the digits\n            let mut dig: Vec<i8> = vec![0_i8; digit.into()];\n\n            // generate a cartesian product for each identified diff using the lookup tables\n            let c_iter = (0..(diffs.len() + digit as usize % 2))\n                .map(|i| match i {\n                    0 => lookup_1[*diffs[0] as usize].iter(),\n                    _ if i != diffs.len() => lookup_n.get(diffs[i]).unwrap().iter(),\n                    _ => numeric_digits.iter(), // for the middle digits\n                })\n                .multi_cartesian_product();\n\n            // check each H (n+r) by using digit combination\n            c_iter.for_each(|elt| {\n                // print!(\"    digits combinations: {:?}\", elt);\n                for (i, digit_pair) in elt.iter().enumerate() {\n                    // print!(\"  digit pairs: {:?}, len: {}\", digit_pair, l.len());\n                    dig[i] = digit_pair[0];\n                    dig[digit as usize - 1 - i] = digit_pair[1]\n                }\n\n                // for numbers with odd # digits restore the middle digit\n                // which has been overwritten at the end of the previous cycle\n                if digit % 2 == 1 {\n                    dig[(digit as usize - 1) / 2] = elt[elt.len() - 1][0];\n                }\n\n                let num = dig\n                    .iter()\n                    .rev()\n                    .enumerate()\n                    .fold(0_u64, |acc, (i, d)| acc + 10_u64.pow(i as u32) * *d as u64);\n\n                let reverse = dig\n                    .iter()\n                    .enumerate()\n                    .fold(0_u64, |acc, (i, d)| acc + 10_u64.pow(i as u32) * *d as u64);\n\n                if num > reverse && is_square(num + reverse) {\n                    println!(\"  FOUND: {}, reverse: {}\", num, reverse);\n                    counter += 1;\n                    results.push(RareResults {\n                        digits: digit,\n                        time_to_find: start_time.elapsed().as_millis(),\n                        counter,\n                        number: num,\n                    });\n                }\n            });\n        }\n    });\n\n    println!(\n        \"Digits: {} done - Elapsed time(ms): {}\",\n        digit,\n        start_time.elapsed().as_millis()\n    );\n\n    results\n}\nfn main() {\n    println!(\"Run this program in release mode for measuring performance\");\n    println!(\"Naive version:\");\n    (1..=10).for_each(|x| print_results(naive(x)));\n\n    println!(\"Advanced version:\");\n    (1..=15).for_each(|x| print_results(advanced(x)));\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_naive() {\n        let result = naive(6);\n        assert_eq!(result[0].number, 621770);\n    }\n\n    #[test]\n    fn test_advanced() {\n        let result = advanced(10);\n        assert_eq!(result[0].number, 2022652202);\n        assert_eq!(result[1].number, 2042832002);\n    }\n}\n",
    "path": "tasks/rare-numbers",
    "remote_code": "\nuse itertools::Itertools;\nuse std::collections::HashMap;\nuse std::convert::TryInto;\nuse std::fmt;\nuse std::time::Instant;\n\n#[derive(Debug)]\nstruct RareResults {\n    digits: u8,\n    time_to_find: u128,\n    counter: u32,\n    number: u64,\n}\n\nimpl fmt::Display for RareResults {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{:>6} {:>6} ms {:>2}. {}\",\n            self.digits, self.time_to_find, self.counter, self.number\n        )\n    }\n}\n\nfn print_results(results: Vec<RareResults>) {\n    if results.len() != 0 {\n        // println!(\"Results:\");\n        println!(\"digits      time  #. Rare number\");\n        for r in results {\n            println!(\"{}\", r);\n        }\n    }\n}\n\nfn isqrt(n: u64) -> u64 {\n    let mut s = (n as f64).sqrt() as u64;\n    s = (s + n / s) >> 1;\n    if s * s > n {\n        s - 1\n    } else {\n        s\n    }\n}\n\nfn is_square(n: u64) -> bool {\n    match n & 0xf {\n        0 | 1 | 4 | 9 => {\n            let t = isqrt(n);\n            t * t == n\n        }\n        _ => false,\n    }\n}\n\nfn get_reverse(number: &u64) -> u64 {\n    number\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap())\n        .enumerate()\n        .fold(0_u64, |a, (i, d)| a + 10_u64.pow(i as u32) * d as u64)\n}\nfn is_rare(number: u64) -> bool {\n    let reverse = get_reverse(&number);\n\n    reverse != number\n        && number > reverse\n        && is_square(number + reverse)\n        && is_square(number - reverse)\n}\n\n/// This method is a very simple naive search, using brute-force to check a high amount of numbers\n/// for satisfying the rare number criterias. As such it is rather slow, and above 10 digits it's\n/// not really performant, release version takes ~30 secs to find the first 5 (max 10 digits)\nfn naive(digit: u8) -> Vec<RareResults> {\n    let bp_equal = (0_u8..=9).zip(0_u8..=9).collect::<Vec<(u8, u8)>>();\n    let bp_zero_or_even = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| (pair.0 == pair.1) || (pair.0 as i32 - pair.1 as i32).abs() % 2 == 0)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_odd = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| (pair.0 as i32 - pair.1 as i32).abs() % 2 == 1)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_9 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| pair.0 + pair.1 == 9)\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_73 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| [7, 3].contains(&(pair.0 as i8 - pair.1 as i8)))\n        .collect::<Vec<(u8, u8)>>();\n\n    let bp_11 = (0_u8..=9)\n        .cartesian_product(0_u8..=9)\n        .filter(|pair| pair.0 + pair.1 == 11 || pair.1 + pair.0 == 1)\n        .collect::<Vec<(u8, u8)>>();\n\n    let aq_bp_setup: Vec<((u8, u8), &Vec<(u8, u8)>)> = vec![\n        ((2, 2), &bp_equal),\n        ((4, 0), &bp_zero_or_even),\n        ((6, 0), &bp_odd),\n        ((6, 5), &bp_odd),\n        ((8, 2), &bp_9),\n        ((8, 3), &bp_73),\n        ((8, 7), &bp_11),\n        ((8, 8), &bp_equal),\n    ];\n\n    //generate AB-PQ combinations\n    let aq_bp = aq_bp_setup\n        .iter()\n        .map(|e| {\n            e.1.iter().fold(vec![], |mut out, b| {\n                out.push(vec![e.0 .0, b.0, b.1, e.0 .1]);\n                out\n            })\n        })\n        .flatten()\n        .collect::<Vec<_>>();\n\n    let mut results: Vec<RareResults> = Vec::new();\n    let mut counter = 0_u32;\n    let start_time = Instant::now();\n\n    let d = digit;\n    print!(\"Digits: {} \", d);\n\n    if d < 4 {\n        for n in 10_u64.pow((d - 1).into())..10_u64.pow(d.into()) {\n            if is_rare(n) {\n                counter += 1;\n                results.push(RareResults {\n                    digits: d,\n                    time_to_find: start_time.elapsed().as_millis(),\n                    counter,\n                    number: n,\n                });\n            }\n        }\n    } else {\n        aq_bp.iter().for_each(|abqp| {\n            let start = abqp[0] as u64 * 10_u64.pow((d - 1).into())\n                + abqp[1] as u64 * 10_u64.pow((d - 2).into())\n                + 10_u64 * abqp[2] as u64\n                + abqp[3] as u64;\n\n            // brute-force checking all numbers which matches the pattern AB...PQ\n            // very slow\n            for n in (start..start + 10_u64.pow((d - 2).into())).step_by(100) {\n                if is_rare(n) {\n                    counter += 1;\n                    results.push(RareResults {\n                        digits: d,\n                        time_to_find: start_time.elapsed().as_millis(),\n                        counter,\n                        number: n,\n                    });\n                }\n            }\n        });\n    }\n\n    println!(\n        \"Digits: {} done - Elapsed time(ms): {}\",\n        d,\n        start_time.elapsed().as_millis()\n    );\n\n    results\n}\n\n/// This algorithm uses an advanced search strategy based on Nigel Galloway's approach,\n/// and can find the first 40 rare numers (16 digits) within reasonable\n/// time in release version\nfn advanced(digit: u8) -> Vec<RareResults> {\n    // setup\n    let mut results: Vec<RareResults> = Vec::new();\n    let mut counter = 0_u32;\n    let start_time = Instant::now();\n\n    let numeric_digits = (0..=9).map(|x| [x, 0]).collect::<Vec<_>>();\n    let diffs1: Vec<i8> = vec![0, 1, 4, 5, 6];\n\n    // all possible digits pairs to calculate potential diffs\n    let pairs = (0_i8..=9)\n        .cartesian_product(0_i8..=9)\n        .map(|x| [x.0, x.1])\n        .collect::<Vec<_>>();\n    let all_diffs = (-9i8..=9).collect::<Vec<_>>();\n\n    // lookup table for the first diff\n    let lookup_1 = vec![\n        vec![[2, 2], [8, 8]], //Diff = 0\n        vec![[8, 7], [6, 5]], //Diff = 1\n        vec![],\n        vec![],\n        vec![[4, 0]],         // Diff = 4\n        vec![[8, 3]],         // Diff = 5\n        vec![[6, 0], [8, 2]], // Diff = 6\n    ];\n\n    // lookup table for all the remaining diffs\n    let lookup_n: HashMap<i8, Vec<_>> = pairs.into_iter().into_group_map_by(|elt| elt[0] - elt[1]);\n\n    let d = digit;\n\n    // powers like 1, 10, 100, 1000....\n    let powers = (0..d).map(|x| 10_u64.pow(x.into())).collect::<Vec<u64>>();\n\n    // for n-r (aka L) the required terms, like 9/ 99 / 999 & 90 / 99999 & 9999 & 900 etc\n    let terms = powers\n        .iter()\n        .zip(powers.iter().rev())\n        .map(|(a, b)| b.checked_sub(*a).unwrap_or(0))\n        .filter(|x| *x != 0)\n        .collect::<Vec<u64>>();\n\n    // create a cartesian product for all potential diff numbers\n    // for the first use the very short one, for all other the complete 19 element\n    let diff_list_iter = (0_u8..(d / 2))\n            .map(|i| match i {\n                0 => diffs1.iter(),\n                _ => all_diffs.iter(),\n            })\n            .multi_cartesian_product()\n            // remove invalid first diff/second diff combinations - custom iterator would be probably better\n            .filter(|x| {\n                if x.len() == 1 {\n                    return true;\n                }\n                match (*x[0], *x[1]) {\n                    (a, b) if (a == 0 && b != 0) => false,\n                    (a, b) if (a == 1 && ![-7, -5, -3, -1, 1, 3, 5, 7].contains(&b)) => false,\n                    (a, b) if (a == 4 && ![-8, -6, -4, -2, 0, 2, 4, 6, 8].contains(&b)) => false,\n                    (a, b) if (a == 5 && ![7, -3].contains(&b)) => false,\n                    (a, b) if (a == 6 && ![-9, -7, -5, -3, -1, 1, 3, 5, 7, 9].contains(&b)) => {\n                        false\n                    }\n                    _ => true,\n                }\n            });\n\n    #[cfg(debug_assertions)]\n    {\n        println!(\"  powers: {:?}\", powers);\n        println!(\"  terms: {:?}\", terms);\n    }\n\n    diff_list_iter.for_each(|diffs| {\n        // calculate difference of original n and its reverse (aka L = n-r)\n        // which must be a perfect square\n        let l: i64 = diffs\n            .iter()\n            .zip(terms.iter())\n            .map(|(diff, term)| **diff as i64 * *term as i64)\n            .sum();\n\n        if l > 0 && is_square(l.try_into().unwrap()) {\n            // potential candiate, at least L is a perfect square\n            #[cfg(debug_assertions)]\n            println!(\"  square L: {}, diffs: {:?}\", l, diffs);\n\n            // placeholder for the digits\n            let mut dig: Vec<i8> = vec![0_i8; d.into()];\n\n            // generate a cartesian product for each identified diff using the lookup tables\n            let c_iter = (0..(diffs.len() + d as usize % 2))\n                .map(|i| match i {\n                    0 => lookup_1[*diffs[0] as usize].iter(),\n                    _ if i != diffs.len() => lookup_n.get(diffs[i]).unwrap().iter(),\n                    _ => numeric_digits.iter(), // for the middle digits\n                })\n                .multi_cartesian_product();\n\n            // check each H (n+r) by using digit combination\n            c_iter.for_each(|elt| {\n                // print!(\"    digits combinations: {:?}\", elt);\n                for (i, digit_pair) in elt.iter().enumerate() {\n                    // print!(\"  digit pairs: {:?}, len: {}\", digit_pair, l.len());\n                    dig[i] = digit_pair[0];\n                    dig[d as usize - 1 - i] = digit_pair[1]\n                }\n\n                // for numbers with odd # digits restore the middle digit\n                // which has been overwritten at the end of the previous cycle\n                if d % 2 == 1 {\n                    dig[(d as usize - 1) / 2] = elt[elt.len() - 1][0];\n                }\n\n                let num = dig\n                    .iter()\n                    .rev()\n                    .enumerate()\n                    .fold(0_u64, |acc, (i, d)| acc + 10_u64.pow(i as u32) * *d as u64);\n\n                let reverse = dig\n                    .iter()\n                    .enumerate()\n                    .fold(0_u64, |acc, (i, d)| acc + 10_u64.pow(i as u32) * *d as u64);\n\n                if num > reverse && is_square(num + reverse) {\n                    println!(\"  FOUND: {}, reverse: {}\", num, reverse);\n                    counter += 1;\n                    results.push(RareResults {\n                        digits: d,\n                        time_to_find: start_time.elapsed().as_millis(),\n                        counter,\n                        number: num,\n                    });\n                }\n            });\n        }\n    });\n\n    println!(\n        \"Digits: {} done - Elapsed time(ms): {}\",\n        d,\n        start_time.elapsed().as_millis()\n    );\n\n    results\n}\nfn main() {\n    println!(\"Run this program in release mode for measuring performance\");\n    println!(\"Naive version:\");\n    (1..=10).for_each(|x| print_results(naive(x)));\n\n    println!(\"Advanced version:\");\n    (1..=15).for_each(|x| print_results(advanced(x)));\n}\n\n",
    "title": "Rare numbers",
    "url": "http://rosettacode.org/wiki/Rare_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rate counter",
    "url": "http://rosettacode.org/wiki/Rate_counter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::f64;\n\nconst _EPS: f64 = 0.00001;\nconst _MIN: f64 = f64::MIN_POSITIVE;\nconst _MAX: f64 = f64::MAX;\n\n#[derive(Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Clone)]\nstruct Edge {\n    pt1: Point,\n    pt2: Point,\n}\n\nimpl Edge {\n    fn new(pt1: (f64, f64), pt2: (f64, f64)) -> Edge {\n        Edge {\n            pt1: Point { x: pt1.0, y: pt1.1 },\n            pt2: Point { x: pt2.0, y: pt2.1 },\n        }\n    }\n}\n\nstruct Polygon {\n    edges: Vec<Edge>, // Polygon has to be created with counter-clockwise coordinates\n}\n\nfn pt_in_polygon(pt: &Point, poly: &Polygon) -> bool {\n    let count = poly.edges\n        .iter()\n        .filter(|edge| ray_intersect_seg(pt, edge))\n        .count();\n\n    count % 2 == 1\n}\n\nfn ray_intersect_seg(p: &Point, edge: &Edge) -> bool {\n    let mut pt = p.clone();\n    let (mut a, mut b): (&Point, &Point) = (&edge.pt1, &edge.pt2);\n    if a.y > b.y {\n        std::mem::swap(&mut a, &mut b);\n    }\n    if pt.y == a.y || pt.y == b.y {\n        pt.y += _EPS;\n    }\n\n    if (pt.y > b.y || pt.y < a.y) || pt.x > a.x.max(b.x) {\n        false\n    } else if pt.x < a.x.min(b.x) {\n        true\n    } else {\n        let m_red = if (a.x - b.x).abs() > _MIN {\n            (b.y - a.y) / (b.x - a.x)\n        } else {\n            _MAX\n        };\n        let m_blue = if (a.x - pt.x).abs() > _MIN {\n            (pt.y - a.y) / (pt.x - a.x)\n        } else {\n            _MAX\n        };\n        m_blue >= m_red\n    }\n}\n\nfn main() {\n    let p = |x, y| Point { x, y };\n    let testpoints = [p(5.0, 5.0), p(5.0, 8.0), p(-10.0, 5.0), p(0.0, 5.0), p(10.0, 5.0), p(8.0, 5.0), p(10.0, 10.0)];\n    let poly_square = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (0.0, 0.0)),\n        ],\n    };\n    let poly_square_hole = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (0.0, 0.0)),\n            Edge::new((2.5, 2.5), (7.5, 2.5)),\n            Edge::new((7.5, 2.5), (7.5, 7.5)),\n            Edge::new((7.5, 7.5), (2.5, 7.5)),\n            Edge::new((2.5, 7.5), (2.5, 2.5)),\n        ],\n    };\n    let poly_strange = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (2.5, 2.5)),\n            Edge::new((2.5, 2.5), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (2.5, 7.5)),\n            Edge::new((2.5, 7.5), (7.5, 7.5)),\n            Edge::new((7.5, 7.5), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (2.5, 2.5)),\n        ],\n    };\n    let poly_hexagon = Polygon {\n        edges: vec![\n            Edge::new((3.0, 0.0), (7.0, 0.0)),\n            Edge::new((7.0, 0.0), (10.0, 5.0)),\n            Edge::new((10.0, 5.0), (7.0, 10.0)),\n            Edge::new((7.0, 10.0), (3.0, 10.0)),\n            Edge::new((3.0, 10.0), (0.0, 5.0)),\n            Edge::new((0.0, 5.0), (3.0, 0.0)),\n        ],\n    };\n    print!(\"\\nSquare :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_square));\n    }\n    print!(\"\\nSquare with hole:\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_square_hole));\n    }\n    print!(\"\\nStrange polygon :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_strange));\n    }\n    print!(\"\\nHexagon :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_hexagon));\n    }\n    println!();\n}",
    "title": "Ray-casting algorithm",
    "url": "http://rosettacode.org/wiki/Ray-casting_algorithm"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader, Cursor, Read};\nuse std::path::Path;\nuse std::str::FromStr;\n\n#[derive(Debug)]\nenum ConfigVariable {\n    String(String),\n    Boolean(bool),\n    Vector(Vec<String>),\n}\n\ntrait FromConfig: Sized {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<Self, String>;\n}\n\nimpl FromConfig for String {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<String, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::String(ref value)) => Ok(value.clone()),\n            _ => Err(format!(\"Unknown configuration parameter: {:?}\", key)),\n        }\n    }\n}\n\nimpl FromConfig for bool {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<bool, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::Boolean(value)) => Ok(value),\n            _ => Ok(false),\n        }\n    }\n}\n\nimpl FromConfig for Vec<String> {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<Vec<String>, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::Vector(ref value)) => Ok(value.clone()),\n            _ => Err(format!(\"Unknown configuration parameter: {:?}\", key)),\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ConfigParams {\n    params: HashMap<String, ConfigVariable>,\n}\n\nfn is_comment(line: &str) -> bool {\n    let comment_chars = ['#', ';'];\n    line.starts_with(&comment_chars[..]) || line.is_empty()\n}\n\nimpl ConfigParams {\n    fn new() -> ConfigParams {\n        ConfigParams {\n            params: HashMap::new(),\n        }\n    }\n\n    fn parse<P: AsRef<Path>>(path: P) -> io::Result<ConfigParams> {\n        Self::from_reader(File::open(path)?)\n    }\n\n    fn from_reader(reader: impl Read) -> io::Result<ConfigParams> {\n        let reader = BufReader::new(reader);\n\n        let mut params = ConfigParams::new();\n        for line in reader.lines() {\n            let line = line?;\n            if is_comment(&line) {\n                continue;\n            }\n            params.update_config(&line);\n        }\n\n        Ok(params)\n    }\n\n    // Will parse the line and update the internal structure\n    fn update_config(&mut self, line: &str) {\n        let mut parts = line.splitn(2, ' ').map(|x| x.to_owned());\n        let key = parts.next().unwrap().to_lowercase();\n        match parts.next() {\n            None => {\n                self.params.insert(key, ConfigVariable::Boolean(true));\n            }\n            Some(value) => {\n                if value.contains(',') {\n                    self.params.insert(\n                        key,\n                        ConfigVariable::Vector(\n                            value\n                                .split(',')\n                                .map(|item| item.trim().to_owned())\n                                .collect(),\n                        ),\n                    );\n                } else {\n                    self.params.insert(key, ConfigVariable::String(value));\n                }\n            }\n        }\n    }\n\n    fn param<T: FromConfig>(&self, key: &str) -> Result<T, String> {\n        FromConfig::from_config(self, &key.to_lowercase())\n    }\n}\n\nimpl FromStr for ConfigParams {\n    type Err = std::convert::Infallible;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Ok(Self::from_reader(Cursor::new(s.as_bytes())).unwrap())\n    }\n}\n\nfn main() {\n    const CONF: &str = \"test.conf\";\n    let params = ConfigParams::parse(CONF).unwrap();\n\n    println!(\"{:?}\", params.param::<String>(\"fullname\"));\n    println!(\"{:?}\", params.param::<String>(\"favouritefruit\"));\n    println!(\"{:?}\", params.param::<bool>(\"needspeeling\"));\n    println!(\"{:?}\", params.param::<bool>(\"seedsremoved\"));\n    println!(\"{:?}\", params.param::<Vec<String>>(\"otherfamily\"));\n}\n\n#[cfg(test)]\nmod tests {\n    use indoc::indoc;\n\n    use super::ConfigParams;\n\n    #[test]\n    fn main_test() {\n        const CONF: &str = \"test.conf\";\n        let params = super::ConfigParams::parse(CONF).unwrap();\n        assert_eq!(params.param::<String>(\"fullname\").unwrap(), \"Foo Barber\");\n        assert_eq!(params.param::<String>(\"favouritefruit\").unwrap(), \"banana\");\n        assert!(params.param::<bool>(\"needspeeling\").unwrap());\n        assert!(!params.param::<bool>(\"seedsremoved\").unwrap());\n        assert_eq!(\n            params.param::<Vec<String>>(\"otherfamily\").unwrap(),\n            vec![\"Rhu Barber\", \"Harry Barber\"]\n        );\n    }\n\n    #[test]\n    fn options_names_are_case_insensitive() {\n        let config = indoc! {\"\n            FULLNAME Foo Barber\n        \"}\n        .parse::<ConfigParams>()\n        .unwrap();\n\n        assert_eq!(config.param::<String>(\"FULLNAME\").unwrap(), \"Foo Barber\");\n        assert_eq!(config.param::<String>(\"fullname\").unwrap(), \"Foo Barber\");\n    }\n}\n",
    "path": "tasks/read-a-configuration-file",
    "remote_code": "use std::fs::File;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::iter::FromIterator;\nuse std::path::Path;\n\nfn main() {\n    let path = String::from(\"file.conf\");\n    let cfg = config_from_file(path);\n    println!(\"{:?}\", cfg);\n}\n\nfn config_from_file(path: String) -> Config {\n    let path = Path::new(&path);\n    let file = File::open(path).expect(\"File not found or cannot be opened\");\n    let content = BufReader::new(&file);\n    let mut cfg = Config::new();\n\n    for line in content.lines() {\n        let line = line.expect(\"Could not read the line\");\n        // Remove whitespaces at the beginning and end\n        let line = line.trim();\n\n        // Ignore comments and empty lines\n        if line.starts_with(\"#\") || line.starts_with(\";\") || line.is_empty() {\n            continue;\n        }\n\n        // Split line into parameter name and rest tokens\n        let tokens = Vec::from_iter(line.split_whitespace()); \n        let name = tokens.first().unwrap();\n        let tokens = tokens.get(1..).unwrap();\n\n        // Remove the equal signs\n        let tokens = tokens.iter().filter(|t| !t.starts_with(\"=\"));\n        // Remove comment after the parameters\n        let tokens = tokens.take_while(|t| !t.starts_with(\"#\") && !t.starts_with(\";\"));\n        \n        // Concat back the parameters into one string to split for separated parameters\n        let mut parameters = String::new();\n        tokens.for_each(|t| { parameters.push_str(t); parameters.push(' '); });\n        // Splits the parameters and trims\n        let parameters = parameters.split(',').map(|s| s.trim());\n        // Converts them from Vec<&str> into Vec<String>\n        let parameters: Vec<String> = parameters.map(|s| s.to_string()).collect();\n        \n        // Setting the config parameters\n        match name.to_lowercase().as_str() {\n            \"fullname\" => cfg.full_name = parameters.get(0).cloned(),\n            \"favouritefruit\" => cfg.favourite_fruit = parameters.get(0).cloned(),\n            \"needspeeling\" => cfg.needs_peeling = true,\n            \"seedsremoved\" => cfg.seeds_removed = true,\n            \"otherfamily\" => cfg.other_family = Some(parameters),\n            _ => (),\n        }\n    }\n\n    cfg\n}\n\n#[derive(Clone, Debug)]\nstruct Config {\n    full_name: Option<String>,\n    favourite_fruit: Option<String>,\n    needs_peeling: bool,\n    seeds_removed: bool,\n    other_family: Option<Vec<String>>,\n}\n\nimpl Config {\n    fn new() -> Config {\n        Config {\n            full_name: None,\n            favourite_fruit: None,\n            needs_peeling: false,\n            seeds_removed: false,\n            other_family: None,\n        }\n    }\n}",
    "title": "Read a configuration file",
    "url": "http://rosettacode.org/wiki/Read_a_configuration_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    convert::TryFrom,\n    fmt::{Debug, Display, Formatter},\n    io::Read,\n};\n\npub struct ReadUtf8<I: Iterator> {\n    source: std::iter::Peekable<I>,\n}\n\nimpl<R: Read> From<R> for ReadUtf8<std::io::Bytes<R>> {\n    fn from(source: R) -> Self {\n        ReadUtf8 {\n            source: source.bytes().peekable(),\n        }\n    }\n}\n\nimpl<I, E> Iterator for ReadUtf8<I>\nwhere\n    I: Iterator<Item = Result<u8, E>>,\n{\n    type Item = Result<char, Error<E>>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.source.next().map(|next| match next {\n            Ok(lead) => self.complete_char(lead),\n            Err(e) => Err(Error::SourceError(e)),\n        })\n    }\n}\n\nimpl<I, E> ReadUtf8<I>\nwhere\n    I: Iterator<Item = Result<u8, E>>,\n{\n    fn continuation(&mut self) -> Result<u32, Error<E>> {\n        if let Some(Ok(byte)) = self.source.peek() {\n            let byte = *byte;\n\n            return if byte & 0b1100_0000 == 0b1000_0000 {\n                self.source.next();\n                Ok((byte & 0b0011_1111) as u32)\n            } else {\n                Err(Error::InvalidByte(byte))\n            };\n        }\n\n        match self.source.next() {\n            None => Err(Error::InputTruncated),\n            Some(Err(e)) => Err(Error::SourceError(e)),\n            Some(Ok(_)) => unreachable!(),\n        }\n    }\n\n    fn complete_char(&mut self, lead: u8) -> Result<char, Error<E>> {\n        let a = lead as u32; // Let's name the bytes in the sequence\n\n        let result = if a & 0b1000_0000 == 0 {\n            Ok(a)\n        } else if lead & 0b1110_0000 == 0b1100_0000 {\n            let b = self.continuation()?;\n            Ok((a & 0b0001_1111) << 6 | b)\n        } else if a & 0b1111_0000 == 0b1110_0000 {\n            let b = self.continuation()?;\n            let c = self.continuation()?;\n            Ok((a & 0b0000_1111) << 12 | b << 6 | c)\n        } else if a & 0b1111_1000 == 0b1111_0000 {\n            let b = self.continuation()?;\n            let c = self.continuation()?;\n            let d = self.continuation()?;\n            Ok((a & 0b0000_0111) << 18 | b << 12 | c << 6 | d)\n        } else {\n            Err(Error::InvalidByte(lead))\n        };\n\n        Ok(char::try_from(result?).unwrap())\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum Error<E> {\n    InvalidByte(u8),\n    InputTruncated,\n    SourceError(E),\n}\n\nimpl<E: Display> Display for Error<E> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Self::InvalidByte(b) => write!(f, \"invalid byte 0x{:x}\", b),\n            Self::InputTruncated => write!(f, \"character truncated\"),\n            Self::SourceError(e) => e.fmt(f),\n        }\n    }\n}\n\nfn main() -> std::io::Result<()> {\n    for (index, value) in ReadUtf8::from(std::fs::File::open(\"test.txt\")?).enumerate() {\n        match value {\n            Ok(c) => print!(\"{}\", c),\n\n            Err(e) => {\n                print!(\"\\u{fffd}\");\n                eprintln!(\"offset {}: {}\", index, e);\n            }\n        }\n    }\n\n    Ok(())\n}",
    "title": "Read a file character by character/UTF8",
    "url": "http://rosettacode.org/wiki/Read_a_file_character_by_character/UTF8"
  },
  {
    "local_code": "use std::env;\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let filename = env::args()\n        .nth(1)\n        .ok_or(\"You must enter a filename to read line by line\")?;\n\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n\n    for line in reader.lines() {\n        // Handle any errors that may arise\n        match line {\n            Ok(ln) => print!(\"{}\", ln),\n            Err(error) => print!(\"{}\", error),\n        }\n    }\n    println!();\n\n    Ok(())\n}\n",
    "path": "tasks/read-a-file-line-by-line",
    "remote_code": "use std::io::{BufReader,BufRead};\nuse std::fs::File;\n\nfn main() {\n    let file = File::open(\"file.txt\").unwrap();\n    for line in BufReader::new(file).lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}",
    "title": "Read a file line by line",
    "url": "http://rosettacode.org/wiki/Read_a_file_line_by_line"
  },
  {
    "local_code": "use std::env;\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut args = env::args();\n\n    let filename = args\n        .nth(1)\n        .ok_or(\"You must enter a filename to read line by line\")?;\n\n    let line_number = args\n        .next()\n        .ok_or(\"You must enter a line number\")?\n        .parse::<usize>()?;\n\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n\n    match reader.lines().nth(line_number - 1) {\n        None => panic!(\"No such line (file is too short)\"),\n        Some(result) => {\n            match result {\n                // Handle any errors that may arise\n                Ok(ln) => print!(\"{}\", ln),\n                Err(error) => print!(\"{}\", error),\n            }\n        }\n    }\n\n    Ok(())\n}\n",
    "path": "tasks/read-a-specific-line-from-a-file",
    "remote_code": "use std::fs::File;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::Error;\nuse std::path::Path;\n \nfn main() {\n    let path = Path::new(\"file.txt\");\n    let line_num = 7usize;\n    let line = get_line_at(&path, line_num - 1);\n    println!(\"{}\", line.unwrap());\n}\n \nfn get_line_at(path: &Path, line_num: usize) -> Result<String, Error> {\n    let file = File::open(path).expect(\"File not found or cannot be opened\");\n    let content = BufReader::new(&file);\n    let mut lines = content.lines();\n    lines.nth(line_num).expect(\"No line found at that position\")\n}",
    "title": "Read a specific line from a file",
    "url": "http://rosettacode.org/wiki/Read_a_specific_line_from_a_file"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let mut file = File::open(\"resources/input.txt\").unwrap();\n\n    let mut contents: Vec<u8> = Vec::new();\n    // Returns amount of bytes read and append the result to the buffer\n    let result = file.read_to_end(&mut contents).unwrap();\n    println!(\"Read {} bytes\", result);\n\n    // To print the contents of the file\n    let filestr = String::from_utf8(contents).unwrap();\n    println!(\"{}\", filestr);\n}\n",
    "path": "tasks/read-entire-file",
    "remote_code": "use std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let mut file = File::open(\"somefile.txt\").unwrap();\n\n    let mut contents: Vec<u8> = Vec::new();\n    // Returns amount of bytes read and append the result to the buffer\n    let result = file.read_to_end(&mut contents).unwrap();\n    println!(\"Read {} bytes\", result);\n\n    // To print the contents of the file\n    let filestr = String::from_utf8(contents).unwrap();\n    println!(\"{}\", filestr);\n}",
    "title": "Read entire file",
    "url": "http://rosettacode.org/wiki/Read_entire_file"
  },
  {
    "local_code": "use std::f64::consts::*;\n\n#[allow(clippy::float_cmp)]\nfn main() {\n    // e (base of the natural logarithm)\n    let mut x = E;\n    // π\n    x += PI;\n    // square root\n    x = x.sqrt();\n    // logarithm (any base allowed)\n    x = x.ln();\n    // ceiling (smallest integer not less than this number--not the same as round up)\n    x = x.ceil();\n    // exponential (ex)\n    x = x.exp();\n    // absolute value (a.k.a. \"magnitude\")\n    x = x.abs();\n    // floor (largest integer less than or equal to this number--not the same as truncate or int)\n    x = x.floor();\n    // power (xy)\n    x = x.powf(x);\n\n    assert_eq!(x, 4.0);\n}\n",
    "path": "tasks/real-constants-and-functions",
    "remote_code": "use std::f64::consts::*;\n\nfn main() {\n    // e (base of the natural logarithm)\n    let mut x = E;\n    // π\n    x += PI;\n    // square root\n    x = x.sqrt();\n    // logarithm (any base allowed)\n    x = x.ln();\n    // ceiling (smallest integer not less than this number--not the same as round up)\n    x = x.ceil();\n    // exponential (ex)\n    x = x.exp();\n    // absolute value (a.k.a. \"magnitude\")\n    x = x.abs();\n    // floor (largest integer less than or equal to this number--not the same as truncate or int)\n    x = x.floor();\n    // power (xy) \n    x = x.powf(x);\n\n    assert_eq!(x, 4.0);\n}",
    "title": "Real constants and functions",
    "url": "http://rosettacode.org/wiki/Real_constants_and_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Recaman's sequence",
    "url": "http://rosettacode.org/wiki/Recaman's_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Record sound",
    "url": "http://rosettacode.org/wiki/Record_sound"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn main() {\n    let mut matrix_to_reduce: Vec<Vec<f64>> = vec![vec![1.0, 2.0 , -1.0, -4.0], \n                                                vec![2.0, 3.0, -1.0, -11.0],\n                                                vec![-2.0, 0.0, -3.0, 22.0]];\n    let mut r_mat_to_red = &mut matrix_to_reduce;\n    let rr_mat_to_red = &mut r_mat_to_red;\n\n    println!(\"Matrix to reduce:\\n{:?}\", rr_mat_to_red);\n    let reduced_matrix = reduced_row_echelon_form(rr_mat_to_red);\n    println!(\"Reduced matrix:\\n{:?}\", reduced_matrix);\n}\n\nfn reduced_row_echelon_form(matrix: &mut Vec<Vec<f64>>) -> Vec<Vec<f64>> {\n    let mut matrix_out: Vec<Vec<f64>> = matrix.to_vec();\n    let mut pivot = 0;\n    let row_count = matrix_out.len();\n    let column_count = matrix_out[0].len();\n    \n    'outer: for r in 0..row_count {\n        if column_count <= pivot {\n            break;\n        }\n        let mut i = r;\n        while matrix_out[i][pivot] == 0.0 {\n            i = i+1;\n            if i == row_count {\n                i = r;\n                pivot = pivot + 1;\n                if column_count == pivot {\n                    pivot = pivot - 1;\n                    break 'outer;\n                }\n            }\n        }\n        for j in 0..row_count {\n            let temp = matrix_out[r][j];\n            matrix_out[r][j] = matrix_out[i][j];\n            matrix_out[i][j] = temp;\n        }\n        let divisor = matrix_out[r][pivot];\n        if divisor != 0.0 {\n            for j in 0..column_count {\n                matrix_out[r][j] = matrix_out[r][j] / divisor;\n            }\n        }\n        for j in 0..row_count {\n            if j != r {\n                let hold = matrix_out[j][pivot];\n                for k in 0..column_count {\n                    matrix_out[j][k] = matrix_out[j][k] - ( hold * matrix_out[r][k]);\n                }\n            }\n        }\n        pivot = pivot + 1;\n    }\n    matrix_out\n}\n",
    "title": "Reduced row echelon form",
    "url": "http://rosettacode.org/wiki/Reduced_row_echelon_form"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/Get source",
    "url": "http://rosettacode.org/wiki/Reflection/Get_source"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/List methods",
    "url": "http://rosettacode.org/wiki/Reflection/List_methods"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/List properties",
    "url": "http://rosettacode.org/wiki/Reflection/List_properties"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use regex::Regex;\n\nfn main() {\n    let s = \"I am a string\";\n\n    if Regex::new(\"string$\").unwrap().is_match(s) {\n        println!(\"Ends with string.\");\n    }\n\n    println!(\"{}\", Regex::new(\" a \").unwrap().replace(s, \" another \"));\n}",
    "title": "Regular expressions",
    "url": "http://rosettacode.org/wiki/Regular_expressions"
  },
  {
    "local_code": "use std::collections::HashSet;\nuse std::hash::Hash;\n\n#[allow(dead_code)]\nfn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {\n    let set: HashSet<_> = elements.drain(..).collect();\n    elements.extend(set.into_iter());\n}\n\nfn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {\n    elements.sort_unstable(); // order does not matter\n    elements.dedup();\n}\n\nfn main() {\n    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n    println!(\"Before removal of duplicates : {:?}\", sample_elements);\n    remove_duplicate_elements_sorting(&mut sample_elements);\n    println!(\"After removal of duplicates : {:?}\", sample_elements);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_remove_duplicate_elements_hashing() {\n        let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n        remove_duplicate_elements_hashing(&mut sample_elements);\n        sample_elements.sort_unstable();\n        assert_eq!(sample_elements, [0, 1, 2, 3])\n    }\n\n    #[test]\n    fn test_remove_duplicate_elements_sorting() {\n        let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n        remove_duplicate_elements_sorting(&mut sample_elements);\n        assert_eq!(sample_elements, [0, 1, 2, 3])\n    }\n}\n",
    "path": "tasks/remove-duplicate-elements",
    "remote_code": "use std::collections::HashSet;\nuse std::hash::Hash;\n\nfn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {\n    let set: HashSet<_> = elements.drain(..).collect();\n    elements.extend(set.into_iter());\n}\n\nfn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {\n    elements.sort_unstable(); // order does not matter\n    elements.dedup();\n}\n\nfn main() {\n    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n    println!(\"Before removal of duplicates : {:?}\", sample_elements);\n    remove_duplicate_elements_sorting(&mut sample_elements);\n    println!(\"After removal of duplicates : {:?}\", sample_elements);\n}",
    "title": "Remove duplicate elements",
    "url": "http://rosettacode.org/wiki/Remove_duplicate_elements"
  },
  {
    "local_code": "extern crate structopt;\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::path::PathBuf;\n\nuse structopt::StructOpt;\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// The file that lines should be removed from\n    #[structopt(parse(from_os_str))]\n    file: PathBuf,\n\n    /// The first line number that should be removed (starting at 1)\n    start: usize,\n\n    /// The number of lines that should be removed\n    count: usize,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n\n    let file = BufReader::new(File::open(opt.file).unwrap());\n\n    for (i, line) in file.lines().enumerate() {\n        let cur = i + 1;\n\n        if cur < opt.start || cur >= (opt.start + opt.count) {\n            println!(\"{}\", line.unwrap());\n        }\n    }\n}\n",
    "path": "tasks/remove-lines-from-a-file",
    "remote_code": "extern crate rustc_serialize;\nextern crate docopt;\n\nuse docopt::Docopt;\n\nuse std::io::{BufReader,BufRead};\nuse std::fs::File;\n\nconst USAGE: &'static str = \"\nUsage: rosetta <start> <count> <file>\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_start: usize,\n    arg_count: usize,\n    arg_file: String,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.decode())\n        .unwrap_or_else(|e| e.exit());\n\n    let file = BufReader::new(File::open(args.arg_file).unwrap());\n\n    for (i, line) in file.lines().enumerate() {\n        let cur = i + 1;\n\n        if cur < args.arg_start || cur >= (args.arg_start + args.arg_count) {\n            println!(\"{}\", line.unwrap());\n        }\n    }\n}",
    "title": "Remove lines from a file",
    "url": "http://rosettacode.org/wiki/Remove_lines_from_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::fs;\n\nfn main() {\n    let err = \"File move error\";\n    fs::rename(\"input.txt\", \"output.txt\").ok().expect(err);\n    fs::rename(\"docs\", \"mydocs\").ok().expect(err);\n    fs::rename(\"/input.txt\", \"/output.txt\").ok().expect(err);\n    fs::rename(\"/docs\", \"/mydocs\").ok().expect(err);\n}\n",
    "title": "Rename a file",
    "url": "http://rosettacode.org/wiki/Rename_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rendezvous",
    "url": "http://rosettacode.org/wiki/Rendezvous"
  },
  {
    "local_code": "fn main() {\n    for a_slice in &[\n        \"1001110011\",\n        \"1110111011\",\n        \"0010010010\",\n        \"1010101010\",\n        \"1111111111\",\n        \"0100101101\",\n        \"0100100\",\n        \"101\",\n        \"11\",\n        \"00\",\n        \"1\",\n    ] {\n        match rep_string(a_slice) {\n            Some(repeated) => println!(\n                \"Longest rep-string for '{}' is '{}' ({} chars)\",\n                a_slice,\n                repeated,\n                repeated.len(),\n            ),\n            None => println!(\"No rep-string found for '{}'\", a_slice),\n        };\n    }\n}\n\nfn rep_string(string: &str) -> Option<&str> {\n    let index = string.len() / 2;\n\n    for split_index in (1..=index).rev() {\n        let mut is_rep_string = true;\n        let (first, last) = string.split_at(split_index);\n\n        let inter = last.chars().collect::<Vec<char>>();\n        let mut iter = inter.chunks_exact(split_index);\n        for chunk in iter.by_ref() {\n            if first != chunk.iter().collect::<String>() {\n                is_rep_string = false;\n                break;\n            }\n        }\n        let rmnd = iter.remainder().iter().collect::<String>();\n\n        // Check that the remainder starts with the rep-string\n        if !first.starts_with(rmnd.as_str()) {\n            is_rep_string = false;\n        }\n\n        if is_rep_string {\n            return Some(first);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::rep_string;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_rep_string() {\n        let mut results = HashMap::new();\n        results.insert(String::from(\"1001110011\"), Some(\"10011\"));\n        results.insert(String::from(\"1110111011\"), Some(\"1110\"));\n        results.insert(String::from(\"0010010010\"), Some(\"001\"));\n        results.insert(String::from(\"1010101010\"), Some(\"1010\"));\n        results.insert(String::from(\"1111111111\"), Some(\"11111\"));\n        results.insert(String::from(\"0100101101\"), None);\n        results.insert(String::from(\"0100100\"), Some(\"010\"));\n        results.insert(String::from(\"101\"), None);\n        results.insert(String::from(\"11\"), Some(\"1\"));\n        results.insert(String::from(\"00\"), Some(\"0\"));\n        results.insert(String::from(\"1\"), None);\n\n        for (input, expected) in results {\n            assert_eq!(expected, rep_string(&input));\n        }\n    }\n}\n",
    "path": "tasks/rep-string",
    "remote_code": "fn main() {\n    let strings = vec![\n        String::from(\"1001110011\"),\n        String::from(\"1110111011\"),\n        String::from(\"0010010010\"),\n        String::from(\"1010101010\"),\n        String::from(\"1111111111\"),\n        String::from(\"0100101101\"),\n        String::from(\"0100100\"),\n        String::from(\"101\"),\n        String::from(\"11\"),\n        String::from(\"00\"),\n        String::from(\"1\"),\n    ];\n    for string in strings {\n        match rep_string(&string) {\n            Some(rep_string) => println!(\n                \"Longuest rep-string for '{}' is '{}' ({} chars)\",\n                string,\n                rep_string,\n                rep_string.len(),\n            ),\n            None => println!(\"No rep-string found for '{}'\", string),\n        };\n    }\n}\n\nfn rep_string(string: &str) -> Option<&str> {\n    let index = string.len() / 2;\n\n    for split_index in (1..=index).rev() {\n        let mut is_rep_string = true;\n        let (first, last) = string.split_at(split_index);\n\n        let inter = last.chars().collect::<Vec<char>>();\n        let mut iter = inter.chunks_exact(split_index);\n        for chunk in iter.by_ref() {\n            if first != chunk.iter().collect::<String>() {\n                is_rep_string = false;\n                break;\n            }\n        }\n        let rmnd = iter.remainder().iter().collect::<String>();\n\n        // Check that the remainder starts with the rep-string\n        if !first.starts_with(rmnd.as_str()) {\n            is_rep_string = false;\n        }\n\n        if is_rep_string {\n            return Some(first);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::rep_string;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_rep_string() {\n        let mut results = HashMap::new();\n        results.insert(String::from(\"1001110011\"), Some(\"10011\"));\n        results.insert(String::from(\"1110111011\"), Some(\"1110\"));\n        results.insert(String::from(\"0010010010\"), Some(\"001\"));\n        results.insert(String::from(\"1010101010\"), Some(\"1010\"));\n        results.insert(String::from(\"1111111111\"), Some(\"11111\"));\n        results.insert(String::from(\"0100101101\"), None);\n        results.insert(String::from(\"0100100\"), Some(\"010\"));\n        results.insert(String::from(\"101\"), None);\n        results.insert(String::from(\"11\"), Some(\"1\"));\n        results.insert(String::from(\"00\"), Some(\"0\"));\n        results.insert(String::from(\"1\"), None);\n\n        for (input, expected) in results {\n            assert_eq!(expected, rep_string(&input));\n        }\n    }\n}",
    "title": "Rep-string",
    "url": "http://rosettacode.org/wiki/Rep-string"
  },
  {
    "local_code": "// Repeat the function f, n times.\nfn repeat<F>(f: &F, n: u32)\nwhere\n    F: Fn(),\n{\n    for _ in 0..n {\n        f();\n    }\n}\n\n// Repeat the mutable function f, n times.\nfn repeat_mut<F>(f: &mut F, n: u32)\nwhere\n    F: FnMut(),\n{\n    for _ in 0..n {\n        f();\n    }\n}\n\nfn static_fn() {\n    print!(\"Static \");\n}\n\nfn main() {\n    // Repeat a static function.\n    repeat(&static_fn, 4);\n\n    println!();\n\n    // Repeat an anonymous closure.\n    repeat(&|| print!(\"Closure \"), 5);\n\n    println!();\n\n    // Repeat a mutable closure (can modify local variables).\n    let mut x = 1;\n    println!(\"X is {}\", x);\n    repeat_mut(&mut || x += 1, 5);\n    println!(\"X is now {}\", x);\n}\n\n#[test]\nfn test_closure() {\n    let mut x = 1;\n\n    repeat_mut(&mut || x += 1, 5);\n\n    assert_eq!(x, 6);\n}\n",
    "path": "tasks/repeat",
    "remote_code": "fn repeat(f: impl FnMut(usize), n: usize) {\n    (0..n).for_each(f);\n}",
    "title": "Repeat",
    "url": "http://rosettacode.org/wiki/Repeat"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    fs::rename(\"input.txt\", \"output.txt\").unwrap();\n    fs::rename(\"docs\", \"mydocs\").unwrap();\n    fs::rename(\"/input.txt\", \"/output.txt\").unwrap();\n    fs::rename(\"/docs\", \"/mydocs\").unwrap();\n}\n",
    "path": "tasks/rename-a-file",
    "remote_code": "std::iter::repeat(\"ha\").take(5).collect::<String>(); // ==> \"hahahahaha\"",
    "title": "Repeat a string",
    "url": "http://rosettacode.org/wiki/Repeat_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Repunit primes",
    "url": "http://rosettacode.org/wiki/Repunit_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Resistor mesh",
    "url": "http://rosettacode.org/wiki/Resistor_mesh"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Respond to an unknown method call",
    "url": "http://rosettacode.org/wiki/Respond_to_an_unknown_method_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Retrieve and search chat history",
    "url": "http://rosettacode.org/wiki/Retrieve_and_search_chat_history"
  },
  {
    "local_code": "fn multi_hello() -> (&'static str, i32) {\n    (\"Hello\", 42)\n}\n\nfn main() {\n    let (string, num) = multi_hello();\n    println!(\"{}, {}\", string, num);\n}\n",
    "path": "tasks/return-multiple-values",
    "remote_code": "fn multi_hello() -> (&'static str, i32) {\n    (\"Hello\",42)\n}\n\nfn main() {\n    let (str,num)=multi_hello();\n    println!(\"{},{}\",str,num);\n}\n",
    "title": "Return multiple values",
    "url": "http://rosettacode.org/wiki/Return_multiple_values"
  },
  {
    "local_code": "extern crate unicode_segmentation;\n\nuse unicode_segmentation::UnicodeSegmentation;\n\nfn main() {\n    let s = \"一二三四五六七八九十\";\n    let s2 = \"as⃝df̅\";\n    let reversed: String = s.chars().rev().collect();\n    let reversed2: String = UnicodeSegmentation::graphemes(s2, true).rev().collect();\n    println!(\"{}\", reversed);\n    println!(\"{}\", reversed2);\n}\n",
    "path": "tasks/reverse-a-string",
    "remote_code": "let mut buffer = b\"abcdef\".to_vec();\nbuffer.reverse();\nassert_eq!(buffer, b\"fedcba\");",
    "title": "Reverse a string",
    "url": "http://rosettacode.org/wiki/Reverse_a_string"
  },
  {
    "local_code": "fn rev_words(line: &str) -> String {\n    line.split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\nfn rev_words_on_lines(text: &str) -> String {\n    text.lines()\n        .map(rev_words)\n        .collect::<Vec<String>>()\n        .join(\"\\n\")\n}\n\nfn main() {\n    let text = r\"---------- Ice and Fire ------------\n\nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n\n... elided paragraph last ...\n\nFrost Robert -----------------------\";\n\n    println!(\"{}\", rev_words_on_lines(text));\n}\n\n#[test]\nfn test_rev_words() {\n    let tests = [\n        (\"\", \"\"),\n        (\"a\", \"a\"),\n        (\"a b\", \"b a\"),\n        (\"cat dog\", \"dog cat\"),\n        // According to the problem, multiple spaces can be\n        // compressed into a single space.\n        (\"cat     dog\", \"dog cat\"),\n        (\"cat dog frog\", \"frog dog cat\"),\n    ];\n\n    for &(input, expected) in &tests {\n        let output = rev_words(input);\n        assert_eq!(expected, output);\n    }\n}\n\n#[test]\nfn test_rev_words_on_lines() {\n    // The tests from test_rev_words should have the same results, so\n    // we include them.\n    let tests = [\n        (\"\", \"\"),\n        (\"a\", \"a\"),\n        (\"a b\", \"b a\"),\n        (\"cat dog\", \"dog cat\"),\n        // According to the problem, multiple spaces can be\n        // compressed into a single space.\n        (\"cat     dog\", \"dog cat\"),\n        (\"cat dog frog\", \"frog dog cat\"),\n        // Multiple Lines\n        (\"a b\\nb a\", \"b a\\na b\"),\n        (\"a b\\nc d\\ne f\", \"b a\\nd c\\nf e\"),\n    ];\n\n    for &(input, expected) in &tests {\n        let output = rev_words_on_lines(input);\n        assert_eq!(expected, output);\n    }\n}\n",
    "path": "tasks/reverse-words-in-a-string",
    "remote_code": "const TEXT: &'static str = \n\"---------- Ice and Fire ------------\n \nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n \n... elided paragraph last ...\n \nFrost Robert -----------------------\";\n \nfn main() {\n    println!(\"{}\", \n             TEXT.lines() // Returns iterator over lines\n             .map(|line|  // Applies closure to each item in iterator (for each line)\n                  line.split_whitespace() // Returns iterator of words\n                  .rev() // Reverses iterator of words\n                  .collect::<Vec<_>>() // Collects words into Vec<&str>\n                  .join(\" \")) // Convert vector of words back into line\n             .collect::<Vec<_>>() // Collect lines into Vec<String>\n             .join(\"\\n\")); // Concatenate lines into String\n}",
    "title": "Reverse words in a string",
    "url": "http://rosettacode.org/wiki/Reverse_words_in_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// radix_fmt = \"1.0\"\n\nfn digit_product(base: u32, mut n: u32) -> u32 {\n    let mut product = 1;\n    while n != 0 {\n        product *= n % base;\n        n /= base;\n    }\n    product\n}\n\nfn prime_factor_sum(mut n: u32) -> u32 {\n    let mut sum = 0;\n    while (n & 1) == 0 {\n        sum += 2;\n        n >>= 1;\n    }\n    let mut p = 3;\n    while p * p <= n {\n        while n % p == 0 {\n            sum += p;\n            n /= p;\n        }\n        p += 2;\n    }\n    if n > 1 {\n        sum += n;\n    }\n    sum\n}\n\nfn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn is_rhonda(base: u32, n: u32) -> bool {\n    digit_product(base, n) == base * prime_factor_sum(n)\n}\n\nfn main() {\n    let limit = 15;\n    for base in 2..=36 {\n        if is_prime(base) {\n            continue;\n        }\n        println!(\"First {} Rhonda numbers to base {}:\", limit, base);\n        let numbers: Vec<u32> = (1..).filter(|x| is_rhonda(base, *x)).take(limit).collect();\n        print!(\"In base 10:\");\n        for n in &numbers {\n            print!(\" {}\", n);\n        }\n        print!(\"\\nIn base {}:\", base);\n        for n in &numbers {\n            print!(\" {}\", radix_fmt::radix(*n, base as u8));\n        }\n        print!(\"\\n\\n\");\n    }\n}",
    "title": "Rhonda numbers",
    "url": "http://rosettacode.org/wiki/Rhonda_numbers"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io;\n\nuse rand::distributions::{Standard, Uniform};\nuse rand::prelude::*;\n\nuse Choice::*;\n\n#[derive(PartialEq, Clone, Copy, Debug)]\nenum Choice {\n    Rock,\n    Paper,\n    Scissors,\n}\n\nimpl Distribution<Choice> for Standard {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Choice {\n        // Use `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n        let range = Uniform::new(0, 3);\n        match rng.sample(range) {\n            0 => Rock,\n            1 => Paper,\n            2 => Scissors,\n            _ => unreachable!(), // `_ | 2` would remove the check\n        }\n    }\n}\n\nfn beats(c1: Choice, c2: Choice) -> bool {\n    (c1 == Rock && c2 == Scissors) || (c1 == Scissors && c2 == Paper) || (c1 == Paper && c2 == Rock)\n}\n\nfn ai_move<R: Rng>(rng: &mut R, v: [usize; 3]) -> Choice {\n    // weighted random choice, a dynamic version of `rand::distributions::WeightedChoice`\n    let rand = rng.gen_range(0, v[0] + v[1] + v[2]);\n    if rand < v[0] {\n        Paper\n    } else if rand < v[0] + v[1] {\n        Scissors\n    } else {\n        Rock\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"Rock, paper, scissors!\");\n    let mut ai_choice: Choice = rng.gen();\n    let mut ucf = [0, 0, 0]; // user choice frequency\n    let mut score = [0, 0];\n\n    loop {\n        println!(\"Please input your move: 'r', 'p' or 's'. Type 'q' to quit\");\n\n        let mut input = String::new();\n        io::stdin()\n            .read_line(&mut input)\n            .expect(\"failed to read line\");\n        // trim leading whitespace, get first lowercase character\n        let u_choice = match input\n            .trim_start()\n            .chars()\n            .next()\n            .and_then(|c| c.to_lowercase().next())\n        {\n            Some('r') => {\n                ucf[0] += 1;\n                Rock\n            }\n            Some('p') => {\n                ucf[1] += 1;\n                Paper\n            }\n            Some('s') => {\n                ucf[2] += 1;\n                Scissors\n            }\n            Some('q') => break,\n            _ => {\n                println!(\"Please enter a correct choice!\");\n                continue;\n            }\n        };\n        println!(\"You chose {:?}, I chose {:?}.\", u_choice, ai_choice);\n        if beats(u_choice, ai_choice) {\n            score[0] += 1;\n            println!(\"You win!\");\n        } else if u_choice == ai_choice {\n            println!(\"It's a tie!\");\n        } else {\n            score[1] += 1;\n            println!(\"I win!\");\n        }\n        println!(\"-Score: You {}, Me {}\", score[0], score[1]);\n\n        // only after the 1st iteration the AI knows the stats and can make\n        // its weighted random move\n        ai_choice = ai_move(&mut rng, ucf);\n    }\n    println!(\"Thank you for the game!\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_victory() {\n        assert!(beats(Scissors, Paper));\n        assert!(beats(Rock, Scissors));\n        assert!(beats(Paper, Rock));\n    }\n\n    #[test]\n    fn rand_choice() {\n        let mut rng = thread_rng();\n        for _ in 0..4 {\n            rng.gen::<Choice>();\n        }\n    }\n}\n",
    "path": "tasks/rock-paper-scissors",
    "remote_code": "extern crate rand;\n#[macro_use]\nextern crate rand_derive;\n\nuse std::io;\nuse rand::Rng;\nuse Choice::*;\n\n#[derive(PartialEq, Clone, Copy, Rand, Debug)]\nenum Choice {\n    Rock,\n    Paper,\n    Scissors,\n}\n\nfn beats(c1: Choice, c2: Choice) -> bool {\n    (c1 == Rock && c2 == Scissors) || (c1 == Scissors && c2 == Paper) || (c1 == Paper && c2 == Rock)\n}\n\nfn ai_move<R: Rng>(rng: &mut R, v: [usize; 3]) -> Choice {\n    // weighted random choice, a dynamic version of `rand::distributions::WeightedChoice`\n    let rand = rng.gen_range(0, v[0] + v[1] + v[2]);\n    if rand < v[0] {\n        Paper\n    } else if rand < v[0] + v[1] {\n        Scissors\n    } else {\n        Rock\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"Rock, paper, scissors!\");\n    let mut ai_choice: Choice = rng.gen();\n    let mut ucf = [0, 0, 0]; // user choice frequency\n    let mut score = [0, 0];\n\n    loop {\n        println!(\"Please input your move: 'r', 'p' or 's'. Type 'q' to quit\");\n\n        let mut input = String::new();\n        io::stdin()\n            .read_line(&mut input)\n            .expect(\"failed to read line\");\n        let u_choice = match input.to_lowercase().trim() {\n            s if s.starts_with('r') => {\n                ucf[0] += 1;\n                Rock\n            }\n            s if s.starts_with('p') => {\n                ucf[1] += 1;\n                Paper\n            }\n            s if s.starts_with('s') => {\n                ucf[2] += 1;\n                Scissors\n            }\n            s if s.starts_with('q') => break,\n            _ => {\n                println!(\"Please enter a correct choice!\");\n                continue;\n            }\n        };\n        println!(\"You chose {:?}, I chose {:?}.\", u_choice, ai_choice);\n        if beats(u_choice, ai_choice) {\n            score[0] += 1;\n            println!(\"You win!\");\n        } else if u_choice == ai_choice {\n            println!(\"It's a tie!\");\n        } else {\n            score[1] += 1;\n            println!(\"I win!\");\n        }\n        println!(\"-Score: You {}, Me {}\", score[0], score[1]);\n\n        // only after the 1st iteration the AI knows the stats and can make\n        // its weighted random move\n        ai_choice = ai_move(&mut rng, ucf);\n    }\n    println!(\"Thank you for the game!\");\n}",
    "title": "Rock-paper-scissors",
    "url": "http://rosettacode.org/wiki/Rock-paper-scissors"
  },
  {
    "local_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32,\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {\n        symbol: \"M\",\n        value: 1000,\n    },\n    RomanNumeral {\n        symbol: \"CM\",\n        value: 900,\n    },\n    RomanNumeral {\n        symbol: \"D\",\n        value: 500,\n    },\n    RomanNumeral {\n        symbol: \"CD\",\n        value: 400,\n    },\n    RomanNumeral {\n        symbol: \"C\",\n        value: 100,\n    },\n    RomanNumeral {\n        symbol: \"XC\",\n        value: 90,\n    },\n    RomanNumeral {\n        symbol: \"L\",\n        value: 50,\n    },\n    RomanNumeral {\n        symbol: \"XL\",\n        value: 40,\n    },\n    RomanNumeral {\n        symbol: \"X\",\n        value: 10,\n    },\n    RomanNumeral {\n        symbol: \"IX\",\n        value: 9,\n    },\n    RomanNumeral {\n        symbol: \"V\",\n        value: 5,\n    },\n    RomanNumeral {\n        symbol: \"IV\",\n        value: 4,\n    },\n    RomanNumeral {\n        symbol: \"I\",\n        value: 1,\n    },\n];\n\nfn to_hindu(roman: &str) -> u32 {\n    match NUMERALS.iter().find(|num| roman.starts_with(num.symbol)) {\n        Some(num) => num.value + to_hindu(&roman[num.symbol.len()..]),\n        None => 0, // if string empty, add nothing\n    }\n}\n\nfn main() {\n    let roms = [\"MMXIV\", \"MCMXCIX\", \"XXV\", \"MDCLXVI\", \"MMMDCCCLXXXVIII\"];\n    for &r in &roms {\n        // 15 is minimum formatting width of the first argument, there for alignment\n        println!(\"{:2$} = {}\", r, to_hindu(r), 15);\n    }\n}\n",
    "path": "tasks/roman-numerals/decode",
    "remote_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {symbol: \"M\",  value: 1000},\n    RomanNumeral {symbol: \"CM\", value: 900},\n    RomanNumeral {symbol: \"D\",  value: 500},\n    RomanNumeral {symbol: \"CD\", value: 400},\n    RomanNumeral {symbol: \"C\",  value: 100},\n    RomanNumeral {symbol: \"XC\", value: 90},\n    RomanNumeral {symbol: \"L\",  value: 50},\n    RomanNumeral {symbol: \"XL\", value: 40},\n    RomanNumeral {symbol: \"X\",  value: 10},\n    RomanNumeral {symbol: \"IX\", value: 9},\n    RomanNumeral {symbol: \"V\",  value: 5},\n    RomanNumeral {symbol: \"IV\", value: 4},\n    RomanNumeral {symbol: \"I\",  value: 1}\n];\n\nfn to_hindu(roman: &str) -> u32 {\n    match NUMERALS.iter().find(|num| roman.starts_with(num.symbol)) {\n        Some(num) => num.value + to_hindu(&roman[num.symbol.len()..]),\n        None => 0, // if string empty, add nothing\n    }\n}\n\nfn main() {\n    let roms = [\"MMXIV\", \"MCMXCIX\", \"XXV\", \"MDCLXVI\", \"MMMDCCCLXXXVIII\"];\n    for &r in &roms {\n        // 15 is minimum formatting width of the first argument, there for alignment\n        println!(\"{:2$} = {}\", r, to_hindu(r), 15);\n    }\n}",
    "title": "Roman numerals/Decode",
    "url": "http://rosettacode.org/wiki/Roman_numerals/Decode"
  },
  {
    "local_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32,\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {\n        symbol: \"M\",\n        value: 1000,\n    },\n    RomanNumeral {\n        symbol: \"CM\",\n        value: 900,\n    },\n    RomanNumeral {\n        symbol: \"D\",\n        value: 500,\n    },\n    RomanNumeral {\n        symbol: \"CD\",\n        value: 400,\n    },\n    RomanNumeral {\n        symbol: \"C\",\n        value: 100,\n    },\n    RomanNumeral {\n        symbol: \"XC\",\n        value: 90,\n    },\n    RomanNumeral {\n        symbol: \"L\",\n        value: 50,\n    },\n    RomanNumeral {\n        symbol: \"XL\",\n        value: 40,\n    },\n    RomanNumeral {\n        symbol: \"X\",\n        value: 10,\n    },\n    RomanNumeral {\n        symbol: \"IX\",\n        value: 9,\n    },\n    RomanNumeral {\n        symbol: \"V\",\n        value: 5,\n    },\n    RomanNumeral {\n        symbol: \"IV\",\n        value: 4,\n    },\n    RomanNumeral {\n        symbol: \"I\",\n        value: 1,\n    },\n];\n\nfn to_roman(mut number: u32) -> String {\n    let mut min_numeral = String::new();\n    for numeral in &NUMERALS {\n        while numeral.value <= number {\n            min_numeral += numeral.symbol;\n            number -= numeral.value;\n        }\n    }\n    min_numeral\n}\n\nfn main() {\n    let nums = [2014, 1999, 25, 1666, 3888];\n    for n in &nums {\n        // 4 is minimum printing width, for alignment\n        println!(\"{:2$} = {}\", n, to_roman(*n), 4);\n    }\n}\n",
    "path": "tasks/roman-numerals/encode",
    "remote_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {symbol: \"M\",  value: 1000},\n    RomanNumeral {symbol: \"CM\", value: 900},\n    RomanNumeral {symbol: \"D\",  value: 500},\n    RomanNumeral {symbol: \"CD\", value: 400},\n    RomanNumeral {symbol: \"C\",  value: 100},\n    RomanNumeral {symbol: \"XC\", value: 90},\n    RomanNumeral {symbol: \"L\",  value: 50},\n    RomanNumeral {symbol: \"XL\", value: 40},\n    RomanNumeral {symbol: \"X\",  value: 10},\n    RomanNumeral {symbol: \"IX\", value: 9},\n    RomanNumeral {symbol: \"V\",  value: 5},\n    RomanNumeral {symbol: \"IV\", value: 4},\n    RomanNumeral {symbol: \"I\",  value: 1}\n];\n\nfn to_roman(mut number: u32) -> String {\n    let mut min_numeral = String::new();\n    for numeral in NUMERALS.iter() {\n        while numeral.value <= number {\n            min_numeral = min_numeral + numeral.symbol;\n            number -= numeral.value;\n        }\n    }\n    min_numeral\n}\n\nfn main() {\n    let nums = [2014, 1999, 25, 1666, 3888];\n    for &n in nums.iter() {\n        // 4 is minimum printing width, for alignment\n        println!(\"{:2$} = {}\", n, to_roman(n), 4);\n    }\n}",
    "title": "Roman numerals/Encode",
    "url": "http://rosettacode.org/wiki/Roman_numerals/Encode"
  },
  {
    "local_code": "extern crate num;\n\nuse num::Float;\n\n/// Note: We cannot use `range_step` here because Floats don't implement\n/// the `CheckedAdd` trait.\nfn find_roots<T, F>(f: F, start: T, stop: T, step: T, epsilon: T) -> Vec<T>\nwhere\n    T: Copy + PartialOrd + Float,\n    F: Fn(T) -> T,\n{\n    let mut ret = vec![];\n    let mut current = start;\n    while current < stop {\n        if f(current).abs() < epsilon {\n            ret.push(current);\n        }\n        current = current + step;\n    }\n    ret\n}\n\n#[test]\nfn test_find_roots() {\n    let roots = find_roots(\n        |x: f64| x * x * x - 3.0 * x * x + 2.0 * x,\n        -1.0,\n        3.0,\n        0.0001,\n        0.00000001,\n    );\n    let expected = [0.0f64, 1.0, 2.0];\n\n    for (&a, &b) in roots.iter().zip(expected.iter()) {\n        assert!((a - b).abs() < 0.0001);\n    }\n}\n\nfn main() {\n    let roots = find_roots(\n        |x: f64| x * x * x - 3.0 * x * x + 2.0 * x,\n        -1.0,\n        3.0,\n        0.0001,\n        0.00000001,\n    );\n\n    println!(\"roots of f(x) = x^3 - 3x^2 + 2x are: {:?}\", roots);\n}\n",
    "path": "tasks/roots-of-a-function",
    "remote_code": "// 202100315 Rust programming solution\n\nuse roots::find_roots_cubic;\n\nfn main() {\n\n   let roots = find_roots_cubic(1f32, -3f32, 2f32, 0f32);\n\n   println!(\"Result : {:?}\", roots);\n}",
    "title": "Roots of a function",
    "url": "http://rosettacode.org/wiki/Roots_of_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Roots of a quadratic function",
    "url": "http://rosettacode.org/wiki/Roots_of_a_quadratic_function"
  },
  {
    "local_code": "extern crate num;\n\nuse std::f32::consts;\n\nuse num::complex::{Complex, Complex32};\n\nfn main() {\n    let degree = 3;\n\n    for root in roots_of_unity(degree) {\n        println!(\"{}\", root);\n    }\n}\n\nfn roots_of_unity(degree: usize) -> impl Iterator<Item = Complex32> {\n    (0..degree).map(move |el| {\n        Complex::<f32>::from_polar(1f32, 2f32 * consts::PI * (el as f32) / (degree as f32))\n    })\n}\n\n#[test]\nfn test_result() {\n    let expected = vec![\n        Complex::new(1f32, 0.),\n        Complex::new(-0.5, 0.866025),\n        Complex::new(-0.5, -0.866025),\n    ];\n\n    for (root, exp) in roots_of_unity(3).zip(expected.iter()) {\n        assert!((root - exp).norm() < 1e-6);\n    }\n}\n",
    "path": "tasks/roots-of-unity",
    "remote_code": "use num::Complex;\nfn main() {\n    let n = 8;\n    let z = Complex::from_polar(&1.0,&(1.0*std::f64::consts::PI/n as f64));\n    for k in 0..=n-1 {\n        println!(\"e^{:2}πi/{} ≈ {:>14.3}\",2*k,n,z.powf(2.0*k as f64));\n    }\n}",
    "title": "Roots of unity",
    "url": "http://rosettacode.org/wiki/Roots_of_unity"
  },
  {
    "local_code": "extern crate count_examples;\nfn main() {\n    let all_tasks = count_examples::query_all_tasks();\n    for task in &all_tasks {\n        let count = count_examples::query_a_task(task);\n        println!(\"Task: {} has {} examples\", task.title, count);\n    }\n}\nuse reqwest::Url;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n#[derive(Deserialize)]\npub struct Task {\n    #[serde(rename = \"pageid\")]\n    page_id: u64,\n    pub title: String,\n}\n\n#[derive(Debug)]\nenum ParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(serde_json::Error),\n\n    /// Unexpected JSON format from response\n    UnexpectedFormat,\n}\n\nimpl From<serde_json::Error> for ParseError {\n    fn from(error: serde_json::Error) -> Self {\n        ParseError::Json(error)\n    }\n}\n\nimpl From<reqwest::Error> for ParseError {\n    fn from(error: reqwest::Error) -> Self {\n        ParseError::Http(error)\n    }\n}\n\nfn construct_query_category(category: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let cat = format!(\"Category:{}\", category);\n    let query_pairs = vec![\n        (\"action\", \"query\"),\n        (\"format\", \"json\"),\n        (\"list\", \"categorymembers\"),\n        (\"cmlimit\", \"500\"),\n        (\"cmtitle\", &cat),\n        (\"continue\", \"\"),\n    ];\n    base_url\n        .query_pairs_mut()\n        .extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn construct_query_task_content(task_id: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let mut query_pairs = vec![\n        (\"action\", \"query\"),\n        (\"format\", \"json\"),\n        (\"prop\", \"revisions\"),\n        (\"rvprop\", \"content\"),\n    ];\n    query_pairs.push((\"pageids\", task_id));\n    base_url\n        .query_pairs_mut()\n        .extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn query_api(url: Url) -> Result<Value, ParseError> {\n    Ok(reqwest::blocking::get(url)?.json()?)\n}\n\nfn parse_all_tasks(reply: &Value) -> Result<Vec<Task>, ParseError> {\n    let tasks_json = reply\n        .pointer(\"/query/categorymembers\")\n        .and_then(|tasks| tasks.as_array())\n        .ok_or(ParseError::UnexpectedFormat)?;\n\n    tasks_json\n        .iter()\n        .map(|json| Task::deserialize(json).map_err(From::from))\n        .collect()\n}\n\nfn count_number_examples(task: &Value, task_id: u64) -> Result<u32, ParseError> {\n    let revisions = task\n        .pointer(&format!(\"/query/pages/{}/revisions\", task_id))\n        .and_then(|content| content.as_array())\n        .ok_or(ParseError::UnexpectedFormat)?;\n    let content = revisions[0]\n        .get(\"*\")\n        .and_then(Value::as_str)\n        .ok_or(ParseError::UnexpectedFormat)?;\n    Ok(content.split(\"=={{header\").count() as u32)\n}\n\npub fn query_all_tasks() -> Vec<Task> {\n    let query = construct_query_category(\"Programming_Tasks\");\n    let json: Value = query_api(query).unwrap();\n    parse_all_tasks(&json).unwrap()\n}\n\npub fn query_a_task(task: &Task) -> u32 {\n    let query = construct_query_task_content(&task.page_id.to_string());\n    let json: Value = query_api(query).unwrap();\n    count_number_examples(&json, task.page_id).unwrap()\n}\n",
    "path": "tasks/rosetta-code/count-examples",
    "remote_code": "extern crate reqwest;\nextern crate url;\nextern crate rustc_serialize;\n\nuse std::io::Read;\nuse self::url::Url;\nuse rustc_serialize::json::{self, Json};\n\npub struct Task {\n    page_id: u64,\n    pub title: String,\n}\n\n#[derive(Debug)]\nenum ParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(json::ParserError),\n\n    /// Unexpected JSON format from response\n    UnexpectedFormat,\n}\nimpl From<json::ParserError> for ParseError {\n    fn from(error: json::ParserError) -> Self {\n        ParseError::Json(error)\n    }\n}\n\nimpl From<reqwest::Error> for ParseError {\n    fn from(error: reqwest::Error) -> Self {\n        ParseError::Http(error)\n    }\n}\n\n\nfn construct_query_category(category: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let cat = format!(\"Category:{}\", category);\n    let query_pairs = vec![(\"action\", \"query\"),\n                           (\"format\", \"json\"),\n                           (\"list\", \"categorymembers\"),\n                           (\"cmlimit\", \"500\"),\n                           (\"cmtitle\", &cat),\n                           (\"continue\", \"\")];\n    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn construct_query_task_content(task_id: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let mut query_pairs =\n        vec![(\"action\", \"query\"), (\"format\", \"json\"), (\"prop\", \"revisions\"), (\"rvprop\", \"content\")];\n    query_pairs.push((\"pageids\", task_id));\n    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn query_api(url: Url) -> Result<Json, ParseError> {\n    let mut response = try!(reqwest::get(url.as_str()));\n    // Build JSON\n    let mut body = String::new();\n    response.read_to_string(&mut body).unwrap();\n\n    Ok(try!(Json::from_str(&body)))\n}\n\nfn parse_all_tasks(reply: &Json) -> Result<Vec<Task>, ParseError> {\n    let json_to_task = |json: &Json| -> Result<Task, ParseError> {\n        let page_id: u64 = try!(json.find(\"pageid\")\n            .and_then(|id| id.as_u64())\n            .ok_or(ParseError::UnexpectedFormat));\n        let title: &str = try!(json.find(\"title\")\n            .and_then(|title| title.as_string())\n            .ok_or(ParseError::UnexpectedFormat));\n\n        Ok(Task {\n            page_id: page_id,\n            title: title.to_owned(),\n        })\n    };\n    let tasks_json = try!(reply.find_path(&[\"query\", \"categorymembers\"])\n        .and_then(|tasks| tasks.as_array())\n        .ok_or(ParseError::UnexpectedFormat));\n\n    // Convert into own type\n    tasks_json.iter().map(json_to_task).collect()\n}\nfn count_number_examples(task: &Json, task_id: u64) -> Result<u32, ParseError> {\n    let revisions =\n        try!(task.find_path(&[\"query\", \"pages\", task_id.to_string().as_str(), \"revisions\"])\n            .and_then(|content| content.as_array())\n            .ok_or(ParseError::UnexpectedFormat));\n    let content = try!(revisions[0]\n        .find(\"*\")\n        .and_then(|content| content.as_string())\n        .ok_or(ParseError::UnexpectedFormat));\n    Ok(content.split(\"=={{header\").count() as u32)\n}\n\npub fn query_all_tasks() -> Vec<Task> {\n    let query = construct_query_category(\"Programming_Tasks\");\n    let json: Json = query_api(query).unwrap();\n    parse_all_tasks(&json).unwrap()\n}\n\npub fn query_a_task(task: &Task) -> u32 {\n    let query = construct_query_task_content(&task.page_id.to_string());\n    let json: Json = query_api(query).unwrap();\n    count_number_examples(&json, task.page_id).unwrap()\n}",
    "title": "Rosetta Code/Count examples",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Count_examples"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nfn find_bare_lang_tags(input: &str) -> Vec<(Option<String>, i32)> {\n    let mut language_pairs = vec![];\n    let mut language = None;\n    let mut counter = 0_i32;\n\n    let header_re = Regex::new(r\"==\\{\\{header\\|(?P<lang>[[:alpha:]]+)\\}\\}==\").unwrap();\n\n    for line in input.lines() {\n        if let Some(captures) = header_re.captures(line) {\n            if let Some(header_lang) = captures.name(\"lang\") {\n                language_pairs.push((language, counter));\n                language = Some(header_lang.as_str().to_owned());\n                counter = 0;\n            }\n        }\n\n        if line.contains(\"<lang>\") {\n            counter += 1;\n        }\n    }\n\n    language_pairs.push((language, counter));\n    language_pairs\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    let results = find_bare_lang_tags(&buf);\n    let total_bare = results.iter().map(|r| r.1).sum::<i32>();\n\n    println!(\"{} bare language tags.\\n\", total_bare);\n    for result in &results {\n        let num_bare = result.1;\n\n        if num_bare > 0 {\n            println!(\n                \"{} in {}\",\n                result.1,\n                result\n                    .0\n                    .to_owned()\n                    .unwrap_or_else(|| String::from(\"no language\"))\n            );\n        }\n    }\n}\n\n#[test]\nfn test_bare_tags() {\n    let input = r#\"\n    Description\n    <lang>Pseudocode</lang>\n\n    =={{header|C}}==\n    <lang C>printf(\"Hello world!\\n\");</lang>\n\n    =={{header|Perl}}==\n    <lang>print \"Hello world!\\n\"</lang>\"#;\n\n    let expected = vec![\n        (None, 1),\n        (Some(\"C\".to_owned()), 0),\n        (Some(\"Perl\".to_owned()), 1),\n    ];\n\n    assert_eq!(expected, find_bare_lang_tags(input));\n}\n",
    "path": "tasks/rosetta-code/find-bare-lang-tags",
    "remote_code": "\nextern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nfn find_bare_lang_tags(input: &str) -> Vec<(Option<String>, i32)> {\n    let mut language_pairs = vec![];\n    let mut language = None;\n    let mut counter = 0_i32;\n\n    let header_re = Regex::new(r\"==\\{\\{header\\|(?P<lang>[[:alpha:]]+)\\}\\}==\").unwrap();\n\n    for line in input.lines() {\n        if let Some(captures) = header_re.captures(line) {\n            if let Some(header_lang) = captures.name(\"lang\") {\n                language_pairs.push((language, counter));\n                language = Some(header_lang.as_str().to_owned());\n                counter = 0;\n            }\n        }\n\n        if line.contains(\"<lang>\") {\n            counter += 1;\n        }\n    }\n\n    language_pairs.push((language, counter));\n    language_pairs\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    let results = find_bare_lang_tags(&buf);\n    let total_bare = results.iter().map(|r| r.1).sum::<i32>();\n\n    println!(\"{} bare language tags.\\n\", total_bare);\n    for result in &results {\n        let num_bare = result.1;\n\n        if num_bare > 0 {\n            println!(\n                \"{} in {}\",\n                result.1,\n                result\n                    .0\n                    .to_owned()\n                    .unwrap_or_else(|| String::from(\"no language\"))\n            );\n        }\n    }\n}\n",
    "title": "Rosetta Code/Find bare lang tags",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Find_bare_lang_tags"
  },
  {
    "local_code": "use std::collections::{BTreeMap, HashSet};\n\nuse reqwest::Url;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n/// A Rosetta Code task.\n#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize)]\npub struct Task {\n    /// The ID of the page containing the task in the MediaWiki API.\n    #[serde(rename = \"pageid\")]\n    pub id: u64,\n\n    /// The human-readable title of the task.\n    pub title: String,\n}\n\n/// Encapsulates errors that might occur during JSON parsing.\n#[derive(Debug)]\nenum TaskParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(serde_json::Error),\n\n    /// The response JSON contained unexpected keys or values.\n    UnexpectedFormat,\n}\n\nimpl From<serde_json::Error> for TaskParseError {\n    fn from(err: serde_json::Error) -> Self {\n        TaskParseError::Json(err)\n    }\n}\n\nimpl From<reqwest::Error> for TaskParseError {\n    fn from(err: reqwest::Error) -> Self {\n        TaskParseError::Http(err)\n    }\n}\n\n/// Represents a category of pages on Rosetta Code, such as \"Rust\".\nstruct Category {\n    name: String,\n    continue_params: Option<BTreeMap<String, String>>,\n}\n\nimpl Category {\n    fn new(name: &str) -> Category {\n        let mut continue_params = BTreeMap::new();\n        continue_params.insert(\"continue\".to_owned(), \"\".to_owned());\n\n        Category {\n            name: name.to_owned(),\n            continue_params: Some(continue_params),\n        }\n    }\n}\n\n/// Sends a request to Rosetta Code through the MediaWiki API. If successful, returns the response\n/// as a JSON object.\nfn query_api(\n    category_name: &str,\n    continue_params: &BTreeMap<String, String>,\n) -> Result<Value, TaskParseError> {\n    let mut url = Url::parse(\"http://rosettacode.org/mw/api.php\").expect(\"invalid URL\");\n    url.query_pairs_mut()\n        .append_pair(\"action\", \"query\")\n        .append_pair(\"list\", \"categorymembers\")\n        .append_pair(\"cmtitle\", &format!(\"Category:{}\", category_name))\n        .append_pair(\"cmlimit\", \"500\")\n        .append_pair(\"format\", \"json\")\n        .extend_pairs(continue_params);\n\n    Ok(reqwest::blocking::get(url)?.json()?)\n}\n\n/// Given a JSON object, parses the task information from the MediaWiki API response.\nfn parse_tasks(json: &Value) -> Result<Vec<Task>, TaskParseError> {\n    let tasks_json = json\n        .pointer(\"/query/categorymembers\")\n        .and_then(Value::as_array)\n        .ok_or(TaskParseError::UnexpectedFormat)?;\n\n    tasks_json\n        .iter()\n        .map(|json| Task::deserialize(json).map_err(From::from))\n        .collect()\n}\n\nimpl Iterator for Category {\n    type Item = Vec<Task>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.continue_params.as_ref()?;\n\n        query_api(&self.name, self.continue_params.as_ref()?)\n            .and_then(|result| {\n                // If there are more pages of results to request, save them for the next iteration.\n                self.continue_params =\n                    result\n                        .get(\"continue\")\n                        .and_then(Value::as_object)\n                        .map(|continue_params| {\n                            continue_params\n                                .iter()\n                                .map(|(key, value)| {\n                                    (key.to_owned(), value.as_str().unwrap().to_owned())\n                                })\n                                .collect()\n                        });\n\n                parse_tasks(&result)\n            })\n            .map_err(|err| println!(\"Error parsing response: {:?}\", err))\n            .ok()\n    }\n}\n\npub fn all_tasks() -> Vec<Task> {\n    Category::new(\"Programming Tasks\").flatten().collect()\n}\n\npub fn unimplemented_tasks(lang: &str) -> Vec<Task> {\n    let all_tasks = all_tasks().iter().cloned().collect::<HashSet<_>>();\n    let implemented_tasks = Category::new(lang).flatten().collect::<HashSet<_>>();\n    let mut unimplemented_tasks = all_tasks\n        .difference(&implemented_tasks)\n        .cloned()\n        .collect::<Vec<Task>>();\n    unimplemented_tasks.sort_by(|a, b| a.title.cmp(&b.title));\n    unimplemented_tasks\n}\nextern crate find_unimplemented_tasks;\n\nfn main() {\n    for task in find_unimplemented_tasks::unimplemented_tasks(\"Rust\") {\n        println!(\"{:6} {}\", task.id, task.title);\n    }\n}\n",
    "path": "tasks/rosetta-code/find-unimplemented-tasks",
    "remote_code": "\nuse std::collections::{BTreeMap, HashSet};\n\nuse reqwest::Url;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n/// A Rosetta Code task.\n#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize)]\npub struct Task {\n    /// The ID of the page containing the task in the MediaWiki API.\n    #[serde(rename = \"pageid\")]\n    pub id: u64,\n\n    /// The human-readable title of the task.\n    pub title: String,\n}\n\n/// Encapsulates errors that might occur during JSON parsing.\n#[derive(Debug)]\nenum TaskParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(serde_json::Error),\n\n    /// The response JSON contained unexpected keys or values.\n    UnexpectedFormat,\n}\n\nimpl From<serde_json::Error> for TaskParseError {\n    fn from(err: serde_json::Error) -> Self {\n        TaskParseError::Json(err)\n    }\n}\n\nimpl From<reqwest::Error> for TaskParseError {\n    fn from(err: reqwest::Error) -> Self {\n        TaskParseError::Http(err)\n    }\n}\n\n/// Represents a category of pages on Rosetta Code, such as \"Rust\".\nstruct Category {\n    name: String,\n    continue_params: Option<BTreeMap<String, String>>,\n}\n\nimpl Category {\n    fn new(name: &str) -> Category {\n        let mut continue_params = BTreeMap::new();\n        continue_params.insert(\"continue\".to_owned(), \"\".to_owned());\n\n        Category {\n            name: name.to_owned(),\n            continue_params: Some(continue_params),\n        }\n    }\n}\n\n/// Sends a request to Rosetta Code through the MediaWiki API. If successful, returns the response\n/// as a JSON object.\nfn query_api(\n    category_name: &str,\n    continue_params: &BTreeMap<String, String>,\n) -> Result<Value, TaskParseError> {\n    let mut url = Url::parse(\"http://rosettacode.org/mw/api.php\").expect(\"invalid URL\");\n    url.query_pairs_mut()\n        .append_pair(\"action\", \"query\")\n        .append_pair(\"list\", \"categorymembers\")\n        .append_pair(\"cmtitle\", &format!(\"Category:{}\", category_name))\n        .append_pair(\"cmlimit\", \"500\")\n        .append_pair(\"format\", \"json\")\n        .extend_pairs(continue_params);\n\n    Ok(reqwest::blocking::get(url)?.json()?)\n}\n\n/// Given a JSON object, parses the task information from the MediaWiki API response.\nfn parse_tasks(json: &Value) -> Result<Vec<Task>, TaskParseError> {\n    let tasks_json = json\n        .pointer(\"/query/categorymembers\")\n        .and_then(Value::as_array)\n        .ok_or(TaskParseError::UnexpectedFormat)?;\n\n    tasks_json\n        .iter()\n        .map(|json| Task::deserialize(json).map_err(From::from))\n        .collect()\n}\n\nimpl Iterator for Category {\n    type Item = Vec<Task>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.continue_params.as_ref()?;\n\n        query_api(&self.name, self.continue_params.as_ref()?)\n            .and_then(|result| {\n                // If there are more pages of results to request, save them for the next iteration.\n                self.continue_params =\n                    result\n                        .get(\"continue\")\n                        .and_then(Value::as_object)\n                        .map(|continue_params| {\n                            continue_params\n                                .iter()\n                                .map(|(key, value)| {\n                                    (key.to_owned(), value.as_str().unwrap().to_owned())\n                                })\n                                .collect()\n                        });\n\n                parse_tasks(&result)\n            })\n            .map_err(|err| println!(\"Error parsing response: {:?}\", err))\n            .ok()\n    }\n}\n\npub fn all_tasks() -> Vec<Task> {\n    Category::new(\"Programming Tasks\").flatten().collect()\n}\n\npub fn unimplemented_tasks(lang: &str) -> Vec<Task> {\n    let all_tasks = all_tasks().iter().cloned().collect::<HashSet<_>>();\n    let implemented_tasks = Category::new(lang).flatten().collect::<HashSet<_>>();\n    let mut unimplemented_tasks = all_tasks\n        .difference(&implemented_tasks)\n        .cloned()\n        .collect::<Vec<Task>>();\n    unimplemented_tasks.sort_by(|a, b| a.title.cmp(&b.title));\n    unimplemented_tasks\n}\n\n\nfn main() {\n    for task in find_unimplemented_tasks::unimplemented_tasks(\"Rust\") {\n        println!(\"{:6} {}\", task.id, task.title);\n    }\n}\n",
    "title": "Rosetta Code/Find unimplemented tasks",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nconst LANGUAGES: &str =\n    \"_div abap actionscript actionscript3 ada apache applescript apt_sources asm asp autoit \\\n     avisynth bash basic4gl bf blitzbasic bnf boo c c_mac caddcl cadlisp cfdg cfm cil cobol cpp \\\n     cpp-qt csharp css d delphi diff dos dot eiffel email fortran freebasic genero gettext glsl \\\n     gml gnuplot groovy haskell hq9plus html4strict idl ini inno intercal io java java5 \\\n     javascript kixtart klonec klonecpp latex lisp lolcode lotusformulas lotusscript lscript lua \\\n     m68k make matlab mirc modula3 mpasm mxml mysql nsis objc ocaml ocaml-brief oobas oracle11 \\\n     oracle8 pascal per perl php php-brief pic16 pixelbender plsql povray powershell progress \\\n     prolog providex python qbasic rails reg robots ruby rust sas scala scheme scilab sdlbasic \\\n     smalltalk smarty sql tcl teraterm text thinbasic tsql typoscript vb vbnet verilog vhdl vim \\\n     visualfoxpro visualprolog whitespace winbatch xml xorg_conf xpp z80\";\n\nfn fix_tags(languages: &[&str], text: &str) -> String {\n    let mut replaced_text = text.to_owned();\n\n    for lang in languages.iter() {\n        let bad_open = Regex::new(&format!(\"<{lang}>|<code {lang}>\", lang = lang)).unwrap();\n        let bad_close = Regex::new(&format!(\"</{lang}>|</code>\", lang = lang)).unwrap();\n        let open = format!(\"<lang {}>\", lang);\n        let close = \"</lang>\";\n\n        replaced_text = bad_open.replace_all(&replaced_text, &open[..]).into_owned();\n        replaced_text = bad_close.replace_all(&replaced_text, close).into_owned();\n    }\n\n    replaced_text\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    println!(\n        \"{}\",\n        fix_tags(&LANGUAGES.split_whitespace().collect::<Vec<_>>(), &buf)\n    );\n}\n\n#[test]\nfn test_replace() {\n    let input = \"Lorem ipsum <code foo>saepe audire</code> elaboraret ne quo, id equidem atomorum \\\n                 inciderint usu. <foo>In sit inermis deleniti percipit</foo>, ius ex tale civibus \\\n                 omittam. <barf>Vix ut doctus cetero invenire</barf>, his eu altera electram. \\\n                 Tota adhuc altera te sea, <code bar>soluta appetere ut mel</bar>. Quo quis \\\n                 graecis vivendo te, <baz>posse nullam lobortis ex usu</code>. Eam volumus \\\n                 perpetua constituto id, mea an omittam fierent vituperatoribus.\";\n\n    let expected = \"Lorem ipsum <lang foo>saepe audire</lang> elaboraret ne quo, id equidem \\\n                    atomorum inciderint usu. <lang foo>In sit inermis deleniti percipit</lang>, \\\n                    ius ex tale civibus omittam. <barf>Vix ut doctus cetero invenire</barf>, his \\\n                    eu altera electram. Tota adhuc altera te sea, <lang bar>soluta appetere ut \\\n                    mel</lang>. Quo quis graecis vivendo te, <lang baz>posse nullam lobortis ex \\\n                    usu</lang>. Eam volumus perpetua constituto id, mea an omittam fierent \\\n                    vituperatoribus.\";\n\n    let languages = vec![\"foo\", \"bar\", \"baz\"];\n\n    assert_eq!(expected, fix_tags(&languages, input));\n}\n",
    "path": "tasks/rosetta-code/fix-code-tags",
    "remote_code": "\nextern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nconst LANGUAGES: &str =\n    \"_div abap actionscript actionscript3 ada apache applescript apt_sources asm asp autoit \\\n     avisynth bash basic4gl bf blitzbasic bnf boo c c_mac caddcl cadlisp cfdg cfm cil cobol cpp \\\n     cpp-qt csharp css d delphi diff dos dot eiffel email fortran freebasic genero gettext glsl \\\n     gml gnuplot groovy haskell hq9plus html4strict idl ini inno intercal io java java5 \\\n     javascript kixtart klonec klonecpp latex lisp lolcode lotusformulas lotusscript lscript lua \\\n     m68k make matlab mirc modula3 mpasm mxml mysql nsis objc ocaml ocaml-brief oobas oracle11 \\\n     oracle8 pascal per perl php php-brief pic16 pixelbender plsql povray powershell progress \\\n     prolog providex python qbasic rails reg robots ruby rust sas scala scheme scilab sdlbasic \\\n     smalltalk smarty sql tcl teraterm text thinbasic tsql typoscript vb vbnet verilog vhdl vim \\\n     visualfoxpro visualprolog whitespace winbatch xml xorg_conf xpp z80\";\n\nfn fix_tags(languages: &[&str], text: &str) -> String {\n    let mut replaced_text = text.to_owned();\n\n    for lang in languages.iter() {\n        let bad_open = Regex::new(&format!(\"<{lang}>|<code {lang}>\", lang = lang)).unwrap();\n        let bad_close = Regex::new(&format!(\"</{lang}>|</code>\", lang = lang)).unwrap();\n        let open = format!(\"<lang {}>\", lang);\n        let close = \"&lt;/lang&gt;\";\n\n        replaced_text = bad_open.replace_all(&replaced_text, &open[..]).into_owned();\n        replaced_text = bad_close\n            .replace_all(&replaced_text, &close[..])\n            .into_owned();\n    }\n\n    replaced_text\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    println!(\n        \"{}\",\n        fix_tags(&LANGUAGES.split_whitespace().collect::<Vec<_>>(), &buf)\n    );\n}\n\n",
    "title": "Rosetta Code/Fix code tags",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Fix_code_tags"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rosetta Code/Rank languages by number of users",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_number_of_users"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rosetta Code/Rank languages by popularity",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_popularity"
  },
  {
    "local_code": "fn rot13(string: &str) -> String {\n    fn rot13u8(c: char) -> char {\n        let d = c as u8;\n        match c {\n            'a'..='m' | 'A'..='M' => (d + 13) as char,\n            'n'..='z' | 'N'..='Z' => (d - 13) as char,\n            _ => c,\n        }\n    }\n\n    string.chars().map(rot13u8).collect()\n}\n\nfn main() {\n    let string = \"Do you love apples?\";\n\n    println!(\"Original: {}\", string);\n    println!(\"Encoded: {}\", rot13(string));\n}\n\n#[test]\nfn test_basic() {\n    assert_eq!(rot13(\"abc\"), \"nop\");\n}\n\n#[test]\nfn test_coherence() {\n    let coherence_test = (50000i32..50050).map(|x| format!(\"{}\", x)).all(|s| {\n        let encoded = rot13(&s[..]);\n        let decoded = rot13(&encoded[..]);\n        decoded == s\n    });\n\n    assert!(coherence_test);\n}\n",
    "path": "tasks/rot-13",
    "remote_code": "fn rot13(string: &str) -> String {\n    string.chars().map(|c| {\n        match c {\n            'a'..='m' | 'A'..='M' => ((c as u8) + 13) as char,\n            'n'..='z' | 'N'..='Z' => ((c as u8) - 13) as char,\n            _ => c\n        }\n    }).collect()\n}\n\nfn main () {\n    assert_eq!(rot13(\"abc\"), \"nop\");\n}",
    "title": "Rot-13",
    "url": "http://rosettacode.org/wiki/Rot-13"
  },
  {
    "local_code": "extern crate run_length_encoding;\n\nuse run_length_encoding::{decode, encode, INPUT};\n\nfn main() {\n    let enc = encode(INPUT);\n    println!(\"encoded {}\", enc);\n\n    let dec = decode(&enc[..]);\n    println!(\"decoded {}\", dec.unwrap());\n}\nuse std::iter::repeat;\n\npub const INPUT: &str = r\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n\npub fn encode(value: &str) -> String {\n    let mut ret = String::new();\n    let mut chars = value.chars();\n\n    let (mut count, mut cur) = (1, chars.next());\n    if cur.is_none() {\n        return ret;\n    }\n\n    for chr in chars {\n        if cur == Some(chr) {\n            count += 1\n        } else {\n            ret.push_str(&(count.to_string())[..]);\n            ret.push(cur.unwrap());\n            count = 1;\n            cur = Some(chr);\n        }\n    }\n    ret.push_str(&(count.to_string())[..]);\n    ret.push(cur.unwrap());\n    ret\n}\n\npub fn decode(value: &str) -> Result<String, String> {\n    let mut result = String::new();\n    if value.is_empty() {\n        return Ok(result);\n    }\n\n    let mut start = 0;\n\n    for (i, c) in value.char_indices() {\n        if c.is_numeric() {\n            continue;\n        }\n        if i == start {\n            return Err(format!(\"expected digit, found {}\", c));\n        }\n\n        let ret_s = &value[start..i];\n        let ret = ret_s.parse::<usize>().unwrap();\n\n        let repeated: String = repeat(c).take(ret).collect();\n        start = i + 1;\n\n        result.push_str(&repeated[..]);\n    }\n    Ok(result)\n}\n\n#[test]\nfn test_encode_decode() {\n    assert_eq!(decode(&encode(INPUT)[..]).unwrap(), INPUT);\n    assert_eq!(decode(\"a\"), Err(\"expected digit, found a\".to_string()));\n}\n",
    "path": "tasks/run-length-encoding",
    "remote_code": "fn encode(s: &str) -> String {\n    s.chars()\n        // wrap all values in Option::Some\n        .map(Some)\n        // add an Option::None onto the iterator to clean the pipeline at the end\n        .chain(std::iter::once(None))\n        .scan((0usize, '\\0'), |(n, c), elem| match elem {\n            Some(elem) if *n == 0 || *c == elem => {\n                // the run continues or starts here\n                *n += 1;\n                *c = elem;\n                // this will not have an effect on the final string because it is empty\n                Some(String::new())\n            }\n            Some(elem) => {\n                // the run ends here\n                let run = format!(\"{}{}\", n, c);\n                *n = 1;\n                *c = elem;\n                Some(run)\n            }\n            None => {\n                // the string ends here\n                Some(format!(\"{}{}\", n, c))\n            }\n        })\n        // concatenate together all subresults\n        .collect()\n}\n\nfn decode(s: &str) -> String {\n    s.chars()\n        .fold((0usize, String::new()), |(n, text), c| {\n            if c.is_ascii_digit() {\n                // some simple number parsing\n                (\n                    n * 10 + c.to_digit(10).expect(\"invalid encoding\") as usize,\n                    text,\n                )\n            } else {\n                // this must be the character that is repeated\n                (0, text + &format!(\"{}\", c.to_string().repeat(n)))\n            }\n        })\n        .1\n}\n\nfn main() {\n    let text = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n    let encoded = encode(text);\n    let decoded = decode(&encoded);\n\n    println!(\"original: {}\\n encoded: {}\\n decoded: {}\", text, encoded, decoded);\n    assert_eq!(text, decoded);\n}\n",
    "title": "Run-length encoding",
    "url": "http://rosettacode.org/wiki/Run-length_encoding"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn runge_kutta4(fx: &dyn Fn(f64, f64) -> f64, x: f64, y: f64, dx: f64) -> f64 {\n    let k1 = dx * fx(x, y);\n    let k2 = dx * fx(x + dx / 2.0, y + k1 / 2.0);\n    let k3 = dx * fx(x + dx / 2.0, y + k2 / 2.0);\n    let k4 = dx * fx(x + dx, y + k3);\n\n    y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n}\n\nfn f(x: f64, y: f64) -> f64 {\n    x * y.sqrt()\n}\n\nfn actual(x: f64) -> f64 {\n    (1.0 / 16.0) * (x * x + 4.0).powi(2)\n}\n\nfn main() {\n    let mut y = 1.0;\n    let mut x = 0.0;\n    let step = 0.1;\n    let max_steps = 101;\n    let sample_every_n = 10;\n\n    for steps in 0..max_steps {\n        if steps % sample_every_n == 0 {\n            println!(\"y({}):\\t{:.10}\\t\\t {:E}\", x, y, actual(x) - y)\n        }\n\n        y = runge_kutta4(&f, x, y, step);\n\n        x = ((x * 10.0) + (step * 10.0)) / 10.0;\n    }\n}",
    "title": "Runge-Kutta method",
    "url": "http://rosettacode.org/wiki/Runge-Kutta_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Runtime evaluation",
    "url": "http://rosettacode.org/wiki/Runtime_evaluation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Runtime evaluation/In an environment",
    "url": "http://rosettacode.org/wiki/Runtime_evaluation/In_an_environment"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ruth-Aaron numbers",
    "url": "http://rosettacode.org/wiki/Ruth-Aaron_numbers"
  },
  {
    "local_code": "//! This implementation isn't based on anything in particular, although it's probably informed by a\n//! lot of Rust's JSON encoding code.  It should be very fast (both encoding and decoding the toy\n//! example here takes under a microsecond on my machine) and tries to avoid unnecessary allocation.\n//!\n//! In a real implementation, most of this would be private, with only a few visible functions, and\n//! there would be somewhat nicer signatures (in particular, the fact that `ParseContext` has to be\n//! mutable would get annoying in real code pretty quickly, so it would probably be split out).\n//!\n//! It supports the ability to read individual atoms, not just lists, although whether this is\n//! useful is questionable.\n//!\n//! Caveats: Does not support symbols vs. non-symbols (it wouldn't be hard, but it would greatly\n//! complicate setting up our test structure since we'd have to force it to go through functions\n//! that checked to make sure `Symbol`s couldn't have spaces, or slow down our parser by checking\n//! for this information each time, which is obnoxious).  Does not support string escaping, because\n//! the decoding technique doesn't allocate extra space for strings.  Does support numbers, but\n//! only float types (supporting more types is possible but would complicate the code\n//! significantly).\n\nextern crate typed_arena;\n\nuse typed_arena::Arena;\n\nuse self::Error::{ExpectedEof, IncorrectCloseDelimiter, UnexpectedEof, UnterminatedStringLiteral};\nuse self::SExp::{List, Str, F64};\nuse self::Token::{Eof, ListEnd, ListStart, Literal};\nuse std::io;\nuse std::num::FpCategory;\nuse std::str::FromStr;\n\n/// The actual `SExp` structure.  Supports `f64`s, lists, and string literals.  Note that it takes\n/// everything by reference, rather than owning it--this is mostly done just so we can allocate\n/// `SExp`s statically (since we don't have to call `Vec`).  It does complicate the code a bit,\n/// requiring us to have a `ParseContext` that holds an arena where lists are actually allocated.\n#[derive(PartialEq, Debug)]\npub enum SExp<'a> {\n    /// Float literal: 0.5\n    F64(f64),\n\n    /// List of SExps: ( a b c)\n    List(&'a [SExp<'a>]),\n\n    /// Plain old string literal: \"abc\"\n    Str(&'a str),\n}\n\n/// Errors that can be thrown by the parser.\n#[derive(PartialEq, Debug)]\npub enum Error {\n    /// If the float is `NaN`, `Infinity`, etc.\n    NoReprForFloat,\n\n    /// Missing an end double quote during string parsing\n    UnterminatedStringLiteral,\n\n    /// Some other kind of I/O error\n    Io,\n\n    /// ) appeared where it shouldn't (usually as the first token)\n    IncorrectCloseDelimiter,\n\n    /// Usually means a missing ), but could also mean there were no tokens at all.\n    UnexpectedEof,\n\n    /// More tokens after the list is finished, or after a literal if there is no list.\n    ExpectedEof,\n}\n\nimpl From<io::Error> for Error {\n    fn from(_err: io::Error) -> Error {\n        Error::Io\n    }\n}\n\n/// Tokens returned from the token stream.\n#[derive(PartialEq, Debug)]\nenum Token<'a> {\n    /// Left parenthesis\n    ListStart,\n\n    /// Right parenthesis\n    ListEnd,\n\n    /// String or float literal, quotes removed.\n    Literal(SExp<'a>),\n\n    /// Stream is out of tokens.\n    Eof,\n}\n\n/// An iterator over a string that yields a stream of Tokens.\n///\n/// Implementation note: it probably seems weird to store first, rest, AND string, since they should\n/// all be derivable from string.  But see below.\n#[derive(Copy, Clone, Debug)]\nstruct Tokens<'a> {\n    /// The part of the string that still needs to be parsed\n    string: &'a str,\n\n    /// The first character to parse\n    first: Option<char>,\n\n    /// The rest of the string after the first character\n    rest: &'a str,\n}\n\nimpl<'a> Tokens<'a> {\n    /// Initialize a token stream for a given string.\n    fn new(string: &str) -> Tokens {\n        let mut chars = string.chars();\n\n        match chars.next() {\n            Some(ch) => Tokens {\n                string,\n                first: Some(ch),\n                rest: chars.as_str(),\n            },\n            None => Tokens {\n                string,\n                first: None,\n                rest: string,\n            },\n        }\n    }\n\n    /// Utility function to update information in the iterator.  It might not be performant to keep\n    /// rest cached, but there are times where we don't know exactly what string is (at least, not\n    /// in a way that we can *safely* reconstruct it without allocating), so we keep both here.\n    /// With some unsafe code we could probably get rid of one of them (and maybe first, too).\n    fn update(&mut self, string: &'a str) {\n        self.string = string;\n        let mut chars = self.string.chars();\n\n        if let Some(ch) = chars.next() {\n            self.first = Some(ch);\n            self.rest = chars.as_str();\n        } else {\n            self.first = None;\n        };\n    }\n\n    /// This is where the lexing happens.  Note that it does not handle string escaping.\n    fn next_token(&mut self) -> Result<Token<'a>, Error> {\n        loop {\n            match self.first {\n                // List start\n                Some('(') => {\n                    self.update(self.rest);\n                    return Ok(ListStart);\n                }\n                // List end\n                Some(')') => {\n                    self.update(self.rest);\n                    return Ok(ListEnd);\n                }\n                // Quoted literal start\n                Some('\"') => {\n                    // Split the string at most once.  This lets us get a\n                    // reference to the next piece of the string without having\n                    // to loop through the string again.\n                    let mut iter = self.rest.splitn(2, '\"');\n                    // The first time splitn is run it will never return None, so this is safe.\n                    let str = iter.next().unwrap();\n                    match iter.next() {\n                        // Extract the interior of the string without allocating.  If we want to\n                        // handle string escaping, we would have to allocate at some point though.\n                        Some(s) => {\n                            self.update(s);\n                            return Ok(Literal(Str(str)));\n                        }\n                        None => return Err(UnterminatedStringLiteral),\n                    }\n                }\n                // Plain old literal start\n                Some(c) => {\n                    // Skip whitespace.  This could probably be made more efficient.\n                    if c.is_whitespace() {\n                        self.update(self.rest);\n                        continue;\n                    }\n                    // Since we've exhausted all other possibilities, this must be a real literal.\n                    // Unlike the quoted case, it's not an error to encounter EOF before whitespace.\n                    let mut end_ch = None;\n                    let str = {\n                        let mut iter = self.string.splitn(2, |ch: char| {\n                            let term = ch == ')' || ch == '(';\n                            if term {\n                                end_ch = Some(ch)\n                            }\n                            term || ch.is_whitespace()\n                        });\n                        // The first time splitn is run it will never return None, so this is safe.\n                        let str = iter.next().unwrap();\n                        self.rest = iter.next().unwrap_or(\"\");\n                        str\n                    };\n                    match end_ch {\n                        // self.string will be incorrect in the Some(_) case.  The only reason it's\n                        // okay is because the next time next() is called in this case, we know it\n                        // will be '(' or ')', so it will never reach any code that actually looks\n                        // at self.string.  In a real implementation this would be enforced by\n                        // visibility rules.\n                        Some(_) => self.first = end_ch,\n                        None => self.update(self.rest),\n                    }\n                    return Ok(Literal(parse_literal(str)));\n                }\n                None => return Ok(Eof),\n            }\n        }\n    }\n}\n\n/// This is not the most efficient way to do this, because we end up going over numeric literals\n/// twice, but it avoids having to write our own number parsing logic.\nfn parse_literal(literal: &str) -> SExp {\n    match literal.bytes().next() {\n        Some(b'0'..=b'9') | Some(b'-') => match f64::from_str(literal) {\n            Ok(f) => F64(f),\n            Err(_) => Str(literal),\n        },\n        _ => Str(literal),\n    }\n}\n\n/// Parse context, holds information required by the parser (and owns any allocations it makes)\npub struct ParseContext<'a> {\n    /// The string being parsed.  Not required, but convenient.\n    string: &'a str,\n\n    /// Arena holding any allocations made by the parser.\n    arena: Option<Arena<Vec<SExp<'a>>>>,\n\n    /// Stored in the parse context so it can be reused once allocated.\n    stack: Vec<Vec<SExp<'a>>>,\n}\n\nimpl<'a> ParseContext<'a> {\n    /// Create a new parse context from a given string\n    #[must_use]\n    pub fn new(string: &'a str) -> ParseContext<'a> {\n        ParseContext {\n            string,\n            arena: None,\n            stack: Vec::new(),\n        }\n    }\n}\n\nimpl<'a> SExp<'a> {\n    /// Serialize a `SExp`.\n    fn encode<T: io::Write>(&self, writer: &mut T) -> Result<(), Error> {\n        match *self {\n            F64(f) => {\n                match f.classify() {\n                    // We don't want to identify NaN, Infinity, etc. as floats.\n                    FpCategory::Normal | FpCategory::Zero => {\n                        write!(writer, \"{}\", f)?;\n                        Ok(())\n                    }\n                    _ => Err(Error::NoReprForFloat),\n                }\n            }\n            List(l) => {\n                // Writing a list is very straightforward--write a left parenthesis, then\n                // recursively call encode on each member, and then write a right parenthesis.  The\n                // only reason the logic is as long as it is is to make sure we don't write\n                // unnecessary spaces between parentheses in the zero or one element cases.\n                write!(writer, \"(\")?;\n                let mut iter = l.iter();\n                if let Some(sexp) = iter.next() {\n                    sexp.encode(writer)?;\n                    for sexp in iter {\n                        write!(writer, \" \")?;\n                        sexp.encode(writer)?;\n                    }\n                }\n                write!(writer, \")\")?;\n                Ok(())\n            }\n            Str(s) => {\n                write!(writer, \"\\\"{}\\\"\", s)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Deserialize a `SExp`.\n    /// # Panics\n    /// If allocation fails\n    /// # Errors\n    /// When reaches unexpected EOF or invalid close delimiter\n    pub fn parse(ctx: &'a mut ParseContext<'a>) -> Result<SExp<'a>, Error> {\n        ctx.arena = Some(Arena::new());\n        // Hopefully this unreachable! gets optimized out, because it should literally be\n        // unreachable.\n        let arena = match ctx.arena {\n            Some(ref mut arena) => arena,\n            None => unreachable!(),\n        };\n        let ParseContext {\n            string,\n            ref mut stack,\n            ..\n        } = *ctx;\n        // Make sure the stack is cleared--we keep it in the context to avoid unnecessary\n        // reallocation between parses (if you need to remember old parse information for a new\n        // list, you can pass in a new context).\n        stack.clear();\n        let mut tokens = Tokens::new(string);\n        // First, we check the very first token to see if we're parsing a full list.  It\n        // simplifies parsing a lot in the subsequent code if we can assume that.\n        let next = tokens.next_token();\n        let mut list = match next? {\n            ListStart => Vec::new(),\n            Literal(s) => {\n                return if tokens.next_token()? == Eof {\n                    Ok(s)\n                } else {\n                    Err(ExpectedEof)\n                };\n            }\n            ListEnd => return Err(IncorrectCloseDelimiter),\n            Eof => return Err(UnexpectedEof),\n        };\n\n        // We know we're in a list if we got this far.\n        loop {\n            let tok = tokens.next_token();\n            match tok? {\n                ListStart => {\n                    // We push the previous context onto our stack when we start reading a new list.\n                    stack.push(list);\n                    list = Vec::new()\n                }\n                Literal(s) => list.push(s), // Plain old literal, push it onto the current list\n                ListEnd => {\n                    match stack.pop() {\n                        // Pop the old context off the stack on list end.\n                        Some(mut l) => {\n                            // We allocate a slot for the current list in our parse context (needed\n                            // for safety) before pushing it onto its parent list.\n                            l.push(List(&*arena.alloc(list)));\n                            // Now reset the current list to the parent list\n                            list = l;\n                        }\n                        // There was nothing on the stack, so we're at the end of the topmost list.\n                        // The check to make sure there are no more tokens is required for\n                        // correctness.\n                        None => {\n                            return match tokens.next_token()? {\n                                Eof => Ok(List(&*arena.alloc(list))),\n                                _ => Err(ExpectedEof),\n                            };\n                        }\n                    }\n                }\n                // We encountered an EOF before the list ended--that's an error.\n                Eof => return Err(UnexpectedEof),\n            }\n        }\n    }\n\n    /// Convenience method for the common case where you just want to encode a `SExp` as a String.\n    /// # Errors\n    /// In case encode fails\n    pub fn buffer_encode(&self) -> Result<String, Error> {\n        let mut m = Vec::new();\n        self.encode(&mut m)?;\n        // Because encode() only ever writes valid UTF-8, we can safely skip the secondary check we\n        // normally have to do when converting from Vec<u8> to String.  If we didn't know that the\n        // buffer was already UTF-8, we'd want to call container_as_str() here.\n        unsafe { Ok(String::from_utf8_unchecked(m)) }\n    }\n}\n\npub const SEXP_STRUCT: SExp<'static> = List(&[\n    List(&[Str(\"data\"), Str(\"quoted data\"), F64(123.), F64(4.5)]),\n    List(&[\n        Str(\"data\"),\n        List(&[Str(\"!@#\"), List(&[F64(4.5)]), Str(\"(more\"), Str(\"data)\")]),\n    ]),\n]);\n\npub const SEXP_STRING_IN: &str = r#\"((data \"quoted data\" 123 4.5)\n(data (!@# (4.5) \"(more\" \"data)\")))\"#;\n\n#[test]\nfn test_sexp_encode() {\n    const SEXP_STRING: &str =\n        r#\"((\"data\" \"quoted data\" 123 4.5) (\"data\" (\"!@#\" (4.5) \"(more\" \"data)\")))\"#;\n    assert_eq!(Ok(SEXP_STRING.to_string()), SEXP_STRUCT.buffer_encode());\n}\n\n#[test]\nfn test_sexp_decode() {\n    const SEXP_STRING_IN: &str = r#\"((data \"quoted data\" 123 4.5)\n    (data (!@# (4.5) \"(more\" \"data)\")))\"#;\n\n    let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n    assert_eq!(Ok(SEXP_STRUCT), SExp::parse(ctx));\n}\nuse s_expressions::{ParseContext, SExp, SEXP_STRING_IN, SEXP_STRUCT};\n\nfn main() {\n    println!(\"{:?}\", SEXP_STRUCT.buffer_encode());\n    let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n    println!(\"{:?}\", SExp::parse(ctx));\n}\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nuse s_expressions::SExp::*;\nuse s_expressions::{ParseContext, SExp};\n\nconst SEXP_STRING_IN: &str = r#\"((data \"quoted data\" 123 4.5)\n(data (!@# (4.5) \"(more\" \"data)\")))\"#;\n\nconst SEXP_STRUCT: SExp<'static> = List(&[\n    List(&[Str(\"data\"), Str(\"quoted data\"), F64(123.), F64(4.5)]),\n    List(&[\n        Str(\"data\"),\n        List(&[Str(\"!@#\"), List(&[F64(4.5)]), Str(\"(more\"), Str(\"data)\")]),\n    ]),\n]);\n\nfn benchmark(c: &mut Criterion) {\n    c.bench_function(\"encoding\", |b| {\n        b.iter(|| {\n            black_box(SEXP_STRUCT).buffer_encode().unwrap();\n        })\n    });\n\n    c.bench_function(\"decoding\", |b| {\n        b.iter(|| {\n            let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n            SExp::parse(black_box(ctx)).unwrap();\n        })\n    });\n}\n\ncriterion_group!(benches, benchmark);\ncriterion_main!(benches);\n",
    "path": "tasks/s-expressions",
    "remote_code": null,
    "title": "S-Expressions",
    "url": "http://rosettacode.org/wiki/S-Expressions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n//! This implementation isn't based on anything in particular, although it's probably informed by a\n//! lot of Rust's JSON encoding code.  It should be very fast (both encoding and decoding the toy\n//! example here takes under a microsecond on my machine) and tries to avoid unnecessary allocation.\n//!\n//! In a real implementation, most of this would be private, with only a few visible functions, and\n//! there would be somewhat nicer signatures (in particular, the fact that `ParseContext` has to be\n//! mutable would get annoying in real code pretty quickly, so it would probably be split out).\n//!\n//! It supports the ability to read individual atoms, not just lists, although whether this is\n//! useful is questionable.\n//!\n//! Caveats: Does not support symbols vs. non-symbols (it wouldn't be hard, but it would greatly\n//! complicate setting up our test structure since we'd have to force it to go through functions\n//! that checked to make sure `Symbol`s couldn't have spaces, or slow down our parser by checking\n//! for this information each time, which is obnoxious).  Does not support string escaping, because\n//! the decoding technique doesn't allocate extra space for strings.  Does support numbers, but\n//! only float types (supporting more types is possible but would complicate the code\n//! significantly).\n\nextern crate typed_arena;\n\nuse typed_arena::Arena;\n\nuse self::Error::*;\nuse self::SExp::*;\nuse self::Token::*;\nuse std::io;\nuse std::num::FpCategory;\nuse std::str::FromStr;\n\n/// The actual `SExp` structure.  Supports `f64`s, lists, and string literals.  Note that it takes\n/// everything by reference, rather than owning it--this is mostly done just so we can allocate\n/// `SExp`s statically (since we don't have to call `Vec`).  It does complicate the code a bit,\n/// requiring us to have a `ParseContext` that holds an arena where lists are actually allocated.\n#[derive(PartialEq, Debug)]\npub enum SExp<'a> {\n    /// Float literal: 0.5\n    F64(f64),\n\n    /// List of SExps: ( a b c)\n    List(&'a [SExp<'a>]),\n\n    /// Plain old string literal: \"abc\"\n    Str(&'a str),\n}\n\n/// Errors that can be thrown by the parser.\n#[derive(PartialEq, Debug)]\npub enum Error {\n    /// If the float is `NaN`, `Infinity`, etc.\n    NoReprForFloat,\n\n    /// Missing an end double quote during string parsing\n    UnterminatedStringLiteral,\n\n    /// Some other kind of I/O error\n    Io,\n\n    /// ) appeared where it shouldn't (usually as the first token)\n    IncorrectCloseDelimiter,\n\n    /// Usually means a missing ), but could also mean there were no tokens at all.\n    UnexpectedEOF,\n\n    /// More tokens after the list is finished, or after a literal if there is no list.\n    ExpectedEOF,\n}\n\nimpl From<io::Error> for Error {\n    fn from(_err: io::Error) -> Error {\n        Error::Io\n    }\n}\n\n/// Tokens returned from the token stream.\n#[derive(PartialEq, Debug)]\nenum Token<'a> {\n    /// Left parenthesis\n    ListStart,\n\n    /// Right parenthesis\n    ListEnd,\n\n    /// String or float literal, quotes removed.\n    Literal(SExp<'a>),\n\n    /// Stream is out of tokens.\n    Eof,\n}\n\n/// An iterator over a string that yields a stream of Tokens.\n///\n/// Implementation note: it probably seems weird to store first, rest, AND string, since they should\n/// all be derivable from string.  But see below.\n#[derive(Copy, Clone, Debug)]\nstruct Tokens<'a> {\n    /// The part of the string that still needs to be parsed\n    string: &'a str,\n\n    /// The first character to parse\n    first: Option<char>,\n\n    /// The rest of the string after the first character\n    rest: &'a str,\n}\n\nimpl<'a> Tokens<'a> {\n    /// Initialize a token stream for a given string.\n    fn new(string: &str) -> Tokens {\n        let mut chars = string.chars();\n\n        match chars.next() {\n            Some(ch) => Tokens {\n                string,\n                first: Some(ch),\n                rest: chars.as_str(),\n            },\n            None => Tokens {\n                string,\n                first: None,\n                rest: string,\n            },\n        }\n    }\n\n    /// Utility function to update information in the iterator.  It might not be performant to keep\n    /// rest cached, but there are times where we don't know exactly what string is (at least, not\n    /// in a way that we can *safely* reconstruct it without allocating), so we keep both here.\n    /// With some unsafe code we could probably get rid of one of them (and maybe first, too).\n    fn update(&mut self, string: &'a str) {\n        self.string = string;\n        let mut chars = self.string.chars();\n\n        if let Some(ch) = chars.next() {\n            self.first = Some(ch);\n            self.rest = chars.as_str();\n        } else {\n            self.first = None;\n        };\n    }\n\n    /// This is where the lexing happens.  Note that it does not handle string escaping.\n    fn next_token(&mut self) -> Result<Token<'a>, Error> {\n        loop {\n            match self.first {\n                // List start\n                Some('(') => {\n                    self.update(self.rest);\n                    return Ok(ListStart);\n                }\n                // List end\n                Some(')') => {\n                    self.update(self.rest);\n                    return Ok(ListEnd);\n                }\n                // Quoted literal start\n                Some('\"') => {\n                    // Split the string at most once.  This lets us get a\n                    // reference to the next piece of the string without having\n                    // to loop through the string again.\n                    let mut iter = self.rest.splitn(2, '\"');\n                    // The first time splitn is run it will never return None, so this is safe.\n                    let str = iter.next().unwrap();\n                    match iter.next() {\n                        // Extract the interior of the string without allocating.  If we want to\n                        // handle string escaping, we would have to allocate at some point though.\n                        Some(s) => {\n                            self.update(s);\n                            return Ok(Literal(Str(str)));\n                        }\n                        None => return Err(UnterminatedStringLiteral),\n                    }\n                }\n                // Plain old literal start\n                Some(c) => {\n                    // Skip whitespace.  This could probably be made more efficient.\n                    if c.is_whitespace() {\n                        self.update(self.rest);\n                        continue;\n                    }\n                    // Since we've exhausted all other possibilities, this must be a real literal.\n                    // Unlike the quoted case, it's not an error to encounter EOF before whitespace.\n                    let mut end_ch = None;\n                    let str = {\n                        let mut iter = self.string.splitn(2, |ch: char| {\n                            let term = ch == ')' || ch == '(';\n                            if term {\n                                end_ch = Some(ch)\n                            }\n                            term || ch.is_whitespace()\n                        });\n                        // The first time splitn is run it will never return None, so this is safe.\n                        let str = iter.next().unwrap();\n                        self.rest = iter.next().unwrap_or(\"\");\n                        str\n                    };\n                    match end_ch {\n                        // self.string will be incorrect in the Some(_) case.  The only reason it's\n                        // okay is because the next time next() is called in this case, we know it\n                        // will be '(' or ')', so it will never reach any code that actually looks\n                        // at self.string.  In a real implementation this would be enforced by\n                        // visibility rules.\n                        Some(_) => self.first = end_ch,\n                        None => self.update(self.rest),\n                    }\n                    return Ok(Literal(parse_literal(str)));\n                }\n                None => return Ok(Eof),\n            }\n        }\n    }\n}\n\n/// This is not the most efficient way to do this, because we end up going over numeric literals\n/// twice, but it avoids having to write our own number parsing logic.\nfn parse_literal(literal: &str) -> SExp {\n    match literal.bytes().next() {\n        Some(b'0'..=b'9') | Some(b'-') => match f64::from_str(literal) {\n            Ok(f) => F64(f),\n            Err(_) => Str(literal),\n        },\n        _ => Str(literal),\n    }\n}\n\n/// Parse context, holds information required by the parser (and owns any allocations it makes)\npub struct ParseContext<'a> {\n    /// The string being parsed.  Not required, but convenient.\n    string: &'a str,\n\n    /// Arena holding any allocations made by the parser.\n    arena: Option<Arena<Vec<SExp<'a>>>>,\n\n    /// Stored in the parse context so it can be reused once allocated.\n    stack: Vec<Vec<SExp<'a>>>,\n}\n\nimpl<'a> ParseContext<'a> {\n    /// Create a new parse context from a given string\n    pub fn new(string: &'a str) -> ParseContext<'a> {\n        ParseContext {\n            string,\n            arena: None,\n            stack: Vec::new(),\n        }\n    }\n}\n\nimpl<'a> SExp<'a> {\n    /// Serialize a SExp.\n    fn encode<T: io::Write>(&self, writer: &mut T) -> Result<(), Error> {\n        match *self {\n            F64(f) => {\n                match f.classify() {\n                    // We don't want to identify NaN, Infinity, etc. as floats.\n                    FpCategory::Normal | FpCategory::Zero => {\n                        write!(writer, \"{}\", f)?;\n                        Ok(())\n                    }\n                    _ => Err(Error::NoReprForFloat),\n                }\n            }\n            List(l) => {\n                // Writing a list is very straightforward--write a left parenthesis, then\n                // recursively call encode on each member, and then write a right parenthesis.  The\n                // only reason the logic is as long as it is is to make sure we don't write\n                // unnecessary spaces between parentheses in the zero or one element cases.\n                write!(writer, \"(\")?;\n                let mut iter = l.iter();\n                if let Some(sexp) = iter.next() {\n                    sexp.encode(writer)?;\n                    for sexp in iter {\n                        write!(writer, \" \")?;\n                        sexp.encode(writer)?;\n                    }\n                }\n                write!(writer, \")\")?;\n                Ok(())\n            }\n            Str(s) => {\n                write!(writer, \"\\\"{}\\\"\", s)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Deserialize a SExp.\n    pub fn parse(ctx: &'a mut ParseContext<'a>) -> Result<SExp<'a>, Error> {\n        ctx.arena = Some(Arena::new());\n        // Hopefully this unreachable! gets optimized out, because it should literally be\n        // unreachable.\n        let arena = match ctx.arena {\n            Some(ref mut arena) => arena,\n            None => unreachable!(),\n        };\n        let ParseContext {\n            string,\n            ref mut stack,\n            ..\n        } = *ctx;\n        // Make sure the stack is cleared--we keep it in the context to avoid unnecessary\n        // reallocation between parses (if you need to remember old parse information for a new\n        // list, you can pass in a new context).\n        stack.clear();\n        let mut tokens = Tokens::new(string);\n        // First, we check the very first token to see if we're parsing a full list.  It\n        // simplifies parsing a lot in the subsequent code if we can assume that.\n        let next = tokens.next_token();\n        let mut list = match next? {\n            ListStart => Vec::new(),\n            Literal(s) => {\n                return if tokens.next_token()? == Eof {\n                    Ok(s)\n                } else {\n                    Err(ExpectedEOF)\n                };\n            }\n            ListEnd => return Err(IncorrectCloseDelimiter),\n            Eof => return Err(UnexpectedEOF),\n        };\n\n        // We know we're in a list if we got this far.\n        loop {\n            let tok = tokens.next_token();\n            match tok? {\n                ListStart => {\n                    // We push the previous context onto our stack when we start reading a new list.\n                    stack.push(list);\n                    list = Vec::new()\n                }\n                Literal(s) => list.push(s), // Plain old literal, push it onto the current list\n                ListEnd => {\n                    match stack.pop() {\n                        // Pop the old context off the stack on list end.\n                        Some(mut l) => {\n                            // We allocate a slot for the current list in our parse context (needed\n                            // for safety) before pushing it onto its parent list.\n                            l.push(List(&*arena.alloc(list)));\n                            // Now reset the current list to the parent list\n                            list = l;\n                        }\n                        // There was nothing on the stack, so we're at the end of the topmost list.\n                        // The check to make sure there are no more tokens is required for\n                        // correctness.\n                        None => {\n                            return match tokens.next_token()? {\n                                Eof => Ok(List(&*arena.alloc(list))),\n                                _ => Err(ExpectedEOF),\n                            };\n                        }\n                    }\n                }\n                // We encountered an EOF before the list ended--that's an error.\n                Eof => return Err(UnexpectedEOF),\n            }\n        }\n    }\n\n    /// Convenience method for the common case where you just want to encode a SExp as a String.\n    pub fn buffer_encode(&self) -> Result<String, Error> {\n        let mut m = Vec::new();\n        self.encode(&mut m)?;\n        // Because encode() only ever writes valid UTF-8, we can safely skip the secondary check we\n        // normally have to do when converting from Vec<u8> to String.  If we didn't know that the\n        // buffer was already UTF-8, we'd want to call container_as_str() here.\n        unsafe { Ok(String::from_utf8_unchecked(m)) }\n    }\n}\n\npub const SEXP_STRUCT: SExp<'static> = List(&[\n    List(&[Str(\"data\"), Str(\"quoted data\"), F64(123.), F64(4.5)]),\n    List(&[\n        Str(\"data\"),\n        List(&[Str(\"!@#\"), List(&[F64(4.5)]), Str(\"(more\"), Str(\"data)\")]),\n    ]),\n]);\n\npub const SEXP_STRING_IN: &str = r#\"((data \"quoted data\" 123 4.5)\n(data (!@# (4.5) \"(more\" \"data)\")))\"#;\n\n\nand main.rs:\n\nuse s_expressions::{ParseContext, SExp, SEXP_STRING_IN, SEXP_STRUCT};\n\nfn main() {\n    println!(\"{:?}\", SEXP_STRUCT.buffer_encode());\n    let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n    println!(\"{:?}\", SExp::parse(ctx));\n}\n",
    "title": "S-expressions",
    "url": "http://rosettacode.org/wiki/S-expressions"
  },
  {
    "local_code": "fn sedol(input: &str) -> Option<String> {\n    let weights = vec![1, 3, 1, 7, 3, 9, 1];\n    let valid_chars = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\";\n\n    if input.len() != 6 {\n        return None;\n    }\n\n    // could be done by regex if needed\n    for c in input.chars() {\n        if !valid_chars.contains(c) {\n            return None;\n        }\n    }\n\n    let mut result: u32 = input\n        .chars()\n        .map(|c| {\n            if c.is_digit(10) {\n                c as u32 - 48\n            } else {\n                c as u32 - 55\n            }\n        })\n        .zip(weights)\n        .map(|(cnum, w)| w * cnum)\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum();\n\n    result = (10 - result % 10) % 10;\n\n    Some(input.to_owned() + &result.to_string())\n}\n\nfn main() {\n    let inputs = vec![\n        \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\", \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\",\n        \"B0YBKT\", \"B00030\",\n    ];\n\n    for input in inputs {\n        println!(\"{} SEDOL: {:?}\", &input, sedol(input).unwrap());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::sedol;\n\n    #[test]\n    fn test_sedol() {\n        let input = \"710889\".to_string();\n        let output = sedol(&input);\n        assert_eq!(output.unwrap(), \"7108899\");\n\n        let input = \"B0YBLH\".to_string();\n        let output = sedol(&input);\n        assert_eq!(output.unwrap(), \"B0YBLH2\");\n    }\n    #[test]\n    fn test_sedol_invalid_input() {\n        let input = \"12345\".to_string();\n        let output = sedol(&input);\n        assert_eq!(output, None);\n\n        let input = \"1234567\".to_string();\n        let output = sedol(&input);\n        assert_eq!(output, None);\n\n        let input = \"BOYBLH\".to_string();\n        let output = sedol(&input);\n        assert_eq!(output, None);\n    }\n}\n",
    "path": "tasks/sedols",
    "remote_code": "\nfn sedol(input: &str) -> Option<String> {\n    let weights = vec![1, 3, 1, 7, 3, 9, 1];\n    let valid_chars = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\";\n\n    if input.len() != 6 {\n        return None;\n    }\n\n    // could be done by regex if needed\n    for c in input.chars() {\n        if !valid_chars.contains(c) {\n            return None;\n        }\n    }\n\n    let mut result: u32 = input\n        .chars()\n        .map(|c| {\n            if c.is_digit(10) {\n                c as u32 - 48\n            } else {\n                c as u32 - 55\n            }\n        })\n        .zip(weights)\n        .map(|(cnum, w)| w * cnum)\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum();\n\n    result = (10 - result % 10) % 10;\n\n    Some(input.to_owned() + &result.to_string())\n}\n\nfn main() {\n    let inputs = vec![\n        \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\", \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\",\n        \"B0YBKT\", \"B00030\",\n    ];\n\n    for input in inputs {\n        println!(\"{} SEDOL: {:?}\", &input, sedol(&input).unwrap());\n    }\n}\n\n",
    "title": "SEDOLs",
    "url": "http://rosettacode.org/wiki/SEDOLs"
  },
  {
    "local_code": "#![allow(clippy::many_single_char_names)]\n#![allow(clippy::needless_range_loop)]\n\n//! Straight port from golang crypto/sha1 library implementation\nuse std::io::{Result, Write};\nuse std::num::Wrapping as wr;\n\n/// The size of a SHA1 checksum in bytes.\nconst SIZE: usize = 20;\n\n/// The blocksize of SHA1 in bytes.\nconst CHUNK: usize = 64;\nconst INIT: [wr<u32>; 5] = [\n    wr(0x6745_2301),\n    wr(0xEFCD_AB89),\n    wr(0x98BA_DCFE),\n    wr(0x1032_5476),\n    wr(0xC3D2_E1F0),\n];\n\nfn main() {\n    let mut d = Digest::new();\n    let _ = write!(&mut d, \"The quick brown fox jumps over the lazy dog\");\n    let sha1 = d.sha1();\n\n    for h in &sha1 {\n        print!(\"{:x} \", *h);\n    }\n}\n\n/// digest represents the partial evaluation of a checksum.\nstruct Digest {\n    h: [wr<u32>; 5],\n    x: [u8; CHUNK],\n    nx: usize,\n    len: u64,\n}\n\nimpl Digest {\n    fn new() -> Digest {\n        Digest {\n            h: INIT,\n            x: [0u8; CHUNK],\n            nx: 0,\n            len: 0u64,\n        }\n    }\n\n    fn sha1(&mut self) -> [u8; SIZE] {\n        let mut len = self.len;\n        // Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n        let mut tmp: [u8; 64] = [0u8; 64];\n        tmp[0] = 0x80u8;\n\n        let m: usize = (len % 64u64) as usize;\n        if m < 56 {\n            self.write_all(&tmp[0..56 - m]).unwrap();\n        } else {\n            self.write_all(&tmp[0..64 + 56 - m]).unwrap();\n        }\n\n        // Length in bits (=length in bytes*8=shift 3 bits to the right).\n        len <<= 3;\n        for (i, byte) in tmp.iter_mut().take(8).enumerate() {\n            *byte = (len >> (56 - 8 * i)) as u8;\n        }\n        self.write_all(&tmp[0..8]).unwrap();\n\n        assert!(self.nx == 0);\n\n        let mut digest: [u8; SIZE] = [0u8; SIZE];\n        for (i, s) in self.h.iter().enumerate() {\n            digest[i * 4] = (*s >> 24).0 as u8;\n            digest[i * 4 + 1] = (*s >> 16).0 as u8;\n            digest[i * 4 + 2] = (*s >> 8).0 as u8;\n            digest[i * 4 + 3] = s.0 as u8;\n        }\n        digest\n    }\n\n    fn process_block(&self, data: &[u8]) -> [wr<u32>; 5] {\n        let k: [u32; 4] = [0x5A82_7999, 0x6ED9_EBA1, 0x8F1B_BCDC, 0xCA62_C1D6];\n\n        #[inline]\n        fn part(a: wr<u32>, b: wr<u32>) -> (wr<u32>, wr<u32>) {\n            ((a << 5 | a >> (32 - 5)), (b << 30 | b >> (32 - 30)))\n        }\n\n        let mut w: [u32; 16] = [0u32; 16];\n\n        let (mut h0, mut h1, mut h2, mut h3, mut h4) =\n            (self.h[0], self.h[1], self.h[2], self.h[3], self.h[4]);\n\n        let mut p = data;\n\n        while p.len() >= CHUNK {\n            for i in 0..16 {\n                let j = i * 4;\n                w[i] = u32::from(p[j]) << 24\n                    | u32::from(p[j + 1]) << 16\n                    | u32::from(p[j + 2]) << 8\n                    | u32::from(p[j + 3]);\n            }\n\n            let (mut a, mut b, mut c, mut d, mut e) = (h0, h1, h2, h3, h4);\n\n            for i in 0..16 {\n                let f = b & c | (!b) & d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[0]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 16..20 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b & c | (!b) & d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[0]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 20..40 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b ^ c ^ d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[1]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 40..60 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = ((b | c) & d) | (b & c);\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[2]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 60..80 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b ^ c ^ d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[3]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            h0 += a;\n            h1 += b;\n            h2 += c;\n            h3 += d;\n            h4 += e;\n\n            p = &p[CHUNK..];\n        }\n        [h0, h1, h2, h3, h4]\n    }\n}\n\nimpl Default for Digest {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Write for Digest {\n    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.write_all(buf)?;\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> Result<()> {\n        let mut buf_m = buf;\n\n        self.len += buf_m.len() as u64;\n\n        if self.nx > 0 {\n            let mut n = buf_m.len();\n            if n > CHUNK - self.nx {\n                n = CHUNK - self.nx;\n            }\n            for i in 0..n {\n                self.x[self.nx + i] = buf_m[i];\n            }\n            self.nx += n;\n            if self.nx == CHUNK {\n                let x = &(self.x[..]);\n                self.h = self.process_block(x);\n                self.nx = 0;\n            }\n            buf_m = &buf_m[n..];\n        }\n        if buf_m.len() >= CHUNK {\n            let n = buf_m.len() & !(CHUNK - 1);\n            let x = &(self.x[n..]);\n            self.h = self.process_block(x);\n            buf_m = &buf_m[n..];\n        }\n        let ln = buf_m.len();\n        if ln > 0 {\n            assert!(self.x.len() >= ln);\n            self.x.as_mut().write_all(buf_m).unwrap();\n            self.nx = ln;\n        }\n        Ok(())\n    }\n\n    fn flush(&mut self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn known_sha1s() {\n    let input_output = [\n        (\n            \"His money is twice tainted: 'taint yours and 'taint mine.\",\n            [\n                0x59u8, 0x7f, 0x6a, 0x54, 0x0, 0x10, 0xf9, 0x4c, 0x15, 0xd7, 0x18, 0x6, 0xa9, 0x9a,\n                0x2c, 0x87, 0x10, 0xe7, 0x47, 0xbd,\n            ],\n        ),\n        (\n            \"The quick brown fox jumps over the lazy dog\",\n            [\n                0x2fu8, 0xd4, 0xe1, 0xc6, 0x7a, 0x2d, 0x28, 0xfc, 0xed, 0x84, 0x9e, 0xe1, 0xbb,\n                0x76, 0xe7, 0x39, 0x1b, 0x93, 0xeb, 0x12,\n            ],\n        ),\n        (\n            \"The quick brown fox jumps over the lazy cog\",\n            [\n                0xdeu8, 0x9f, 0x2c, 0x7f, 0xd2, 0x5e, 0x1b, 0x3a, 0xfa, 0xd3, 0xe8, 0x5a, 0x0b,\n                0xd1, 0x7d, 0x9b, 0x10, 0x0d, 0xb4, 0xb3,\n            ],\n        ),\n    ];\n\n    for &(i, o) in &input_output {\n        let mut d = Digest::new();\n        let _ = write!(&mut d, \"{}\", i);\n        let sha1 = d.sha1();\n\n        assert_eq!(sha1, o);\n    }\n}\n",
    "path": "tasks/sha-1",
    "remote_code": "use sha1::Sha1;\n\nfn main() {\n    let mut hash_msg = Sha1::new();\n    hash_msg.update(b\"Rosetta Code\");\n    println!(\"{}\", hash_msg.digest().to_string());\n}\n",
    "title": "SHA-1",
    "url": "http://rosettacode.org/wiki/SHA-1"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/SHA-256\n\nextern crate ring;\n\nuse ring::digest::{digest, SHA256};\n\nfn main() {\n    println!(\"{}\", sha_256(\"Rosetta code\"));\n}\n\nfn sha_256(input: &str) -> String {\n    let result = digest(&SHA256, input.as_bytes());\n    result.as_ref().iter().map(|b| format!(\"{:x}\", b)).collect()\n}\n\n#[test]\nfn test_rosetta() {\n    let expected_hash = \"764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf\";\n    assert_eq!(sha_256(\"Rosetta code\"), expected_hash);\n}\n",
    "path": "tasks/sha-256",
    "remote_code": "use sha2::{Digest, Sha256};\n\nfn hex_string(input: &[u8]) -> String {\n    input.as_ref().iter().map(|b| format!(\"{:x}\", b)).collect()\n}\n\nfn main() {\n    // create a Sha256 object\n    let mut hasher = Sha256::new();\n\n    // write input message\n    hasher.update(b\"Rosetta code\");\n\n    // read hash digest and consume hasher\n    let result = hasher.finalize();\n\n    let hex = hex_string(&result);\n\n    assert_eq!(\n        hex,\n        \"764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf\"\n    );\n    \n    println!(\"{}\", hex);\n}\n",
    "title": "SHA-256",
    "url": "http://rosettacode.org/wiki/SHA-256"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate crypto;\n\nuse crypto::digest::Digest;\nuse crypto::sha2::Sha256;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::BufReader;\n\nfn sha256_merkle_tree(filename: &str, block_size: usize) -> std::io::Result<Option<Vec<u8>>> {\n    let mut md = Sha256::new();\n    let mut input = BufReader::new(File::open(filename)?);\n    let mut buffer = vec![0; block_size];\n    let mut digest = vec![0; md.output_bytes()];\n    let mut digests = Vec::new();\n    loop {\n        let bytes = input.read(&mut buffer)?;\n        if bytes == 0 {\n            break;\n        }\n        md.reset();\n        md.input(&buffer[0..bytes]);\n        md.result(&mut digest);\n        digests.push(digest.clone());\n    }\n    let mut len = digests.len();\n    if len == 0 {\n        return Ok(None);\n    }\n    while len > 1 {\n        let mut j = 0;\n        let mut i = 0;\n        while i < len {\n            if i + 1 < len {\n                md.reset();\n                md.input(&digests[i]);\n                md.input(&digests[i + 1]);\n                md.result(&mut digests[j]);\n            } else {\n                digests.swap(i, j);\n            }\n            i += 2;\n            j += 1;\n        }\n        len = j;\n    }\n    Ok(Some(digests[0].clone()))\n}\n\nfn digest_to_string(digest: &[u8]) -> String {\n    let mut result = String::new();\n    for x in digest {\n        result.push_str(&format!(\"{:02x}\", x));\n    }\n    result\n}\n\nfn main() {\n    match sha256_merkle_tree(\"title.png\", 1024) {\n        Ok(Some(digest)) => println!(\"{}\", digest_to_string(&digest)),\n        Ok(None) => {}\n        Err(error) => eprintln!(\"I/O error: {}\", error),\n    }\n}",
    "title": "SHA-256 Merkle tree",
    "url": "http://rosettacode.org/wiki/SHA-256_Merkle_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "SOAP",
    "url": "http://rosettacode.org/wiki/SOAP"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "SQL-based authentication",
    "url": "http://rosettacode.org/wiki/SQL-based_authentication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Safe addition",
    "url": "http://rosettacode.org/wiki/Safe_addition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: i32) -> bool {\n\tfor i in 2..n {\n\t\tif i * i > n {\n\t\t\treturn true;\n\t\t}\n\t\tif n % i == 0 {\n\t\t\treturn false;\n\t\t}\n\t}\n\tn > 1\n}\n\nfn is_safe_prime(n: i32) -> bool {\n\tis_prime(n) && is_prime((n - 1) / 2)\n}\n\nfn is_unsafe_prime(n: i32) -> bool {\n\tis_prime(n) && !is_prime((n - 1) / 2)\n}\n\nfn next_prime(n: i32) -> i32 {\n\tfor i in (n+1).. {\n\t\tif is_prime(i) {\n\t\t\treturn i;\n\t\t}\n\t}\n\t0\n}\n\nfn main() {\n\tlet mut safe = 0;\n\tlet mut unsf = 0;\n\tlet mut p = 2;\n\n\tprint!(\"first 35 safe primes: \");\n\twhile safe < 35 {\n\t\tif is_safe_prime(p) {\n\t\t\tsafe += 1;\n\t\t\tprint!(\"{} \", p);\n\t\t}\n\t\tp = next_prime(p);\n\t}\n\tprintln!(\"\");\n\n\tp = 2;\n\n\tprint!(\"first 35 unsafe primes: \");\n\twhile unsf < 35 {\n\t\tif is_unsafe_prime(p) {\n\t\t\tunsf += 1;\n\t\t\tprint!(\"{} \", p);\n\t\t}\n\t\tp = next_prime(p);\n\t}\n\tprintln!(\"\");\n\n\tp = 2;\n\tsafe = 0;\n\tunsf = 0;\n\n\twhile p < 1000000 {\n\t\tif is_safe_prime(p) {\n\t\t\tsafe += 1;\n\t\t} else {\n\t\t\tunsf += 1;\n\t\t}\n\t\tp = next_prime(p);\n\t}\n\tprintln!(\"safe primes below 1,000,000: {}\", safe);\n\tprintln!(\"unsafe primes below 1,000,000: {}\", unsf);\n\n\twhile p < 10000000 {\n\t\tif is_safe_prime(p) {\n\t\t\tsafe += 1;\n\t\t} else {\n\t\t\tunsf += 1;\n\t\t}\n\t\tp = next_prime(p);\n\t}\n\tprintln!(\"safe primes below 10,000,000: {}\", safe);\n\tprintln!(\"unsafe primes below 10,000,000: {}\", unsf);\n}",
    "title": "Safe primes and unsafe primes",
    "url": "http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sailors, coconuts and a monkey problem",
    "url": "http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Same fringe",
    "url": "http://rosettacode.org/wiki/Same_fringe"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Scope modifiers",
    "url": "http://rosettacode.org/wiki/Scope_modifiers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Scope/Function names and labels",
    "url": "http://rosettacode.org/wiki/Scope/Function_names_and_labels"
  },
  {
    "local_code": "fn main() {\n    let haystack = vec![\n        \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Boz\", \"Zag\",\n    ];\n\n    println!(\n        \"First occurence of 'Bush' at {:?}\",\n        haystack.iter().position(|s| *s == \"Bush\")\n    );\n    println!(\n        \"Last occurence of 'Bush' at {:?}\",\n        haystack.iter().rposition(|s| *s == \"Bush\")\n    );\n    println!(\n        \"First occurence of 'Rob' at {:?}\",\n        haystack.iter().position(|s| *s == \"Rob\")\n    );\n}\n",
    "path": "tasks/search-a-list",
    "remote_code": "fn main() {\n    let haystack=vec![\"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \n                        \"Bush\", \"Boz\", \"Zag\"];\n\n    println!(\"First occurence of 'Bush' at {:?}\",haystack.iter().position(|s| *s==\"Bush\"));\n    println!(\"Last occurence of 'Bush' at {:?}\",haystack.iter().rposition(|s| *s==\"Bush\"));\n    println!(\"First occurence of 'Rob' at {:?}\",haystack.iter().position(|s| *s==\"Rob\"));\n}\n",
    "title": "Search a list",
    "url": "http://rosettacode.org/wiki/Search_a_list"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct City {\n    name: &'static str,\n    population: f64,\n}\n\nfn main() {\n    let cities = [\n        City {\n            name: \"Lagos\",\n            population: 21.0,\n        },\n        City {\n            name: \"Cairo\",\n            population: 15.2,\n        },\n        City {\n            name: \"Kinshasa-Brazzaville\",\n            population: 11.3,\n        },\n        City {\n            name: \"Greater Johannesburg\",\n            population: 7.55,\n        },\n        City {\n            name: \"Mogadishu\",\n            population: 5.85,\n        },\n        City {\n            name: \"Khartoum-Omdurman\",\n            population: 4.98,\n        },\n        City {\n            name: \"Dar Es Salaam\",\n            population: 4.7,\n        },\n        City {\n            name: \"Alexandria\",\n            population: 4.58,\n        },\n        City {\n            name: \"Abidjan\",\n            population: 4.4,\n        },\n        City {\n            name: \"Casablanca\",\n            population: 3.98,\n        },\n    ];\n\n    println!(\n        \"{:?}\",\n        cities.iter().position(|city| city.name == \"Dar Es Salaam\")\n    );\n    println!(\n        \"{:?}\",\n        cities\n            .iter()\n            .find(|city| city.population < 5.0)\n            .map(|city| city.name)\n    );\n    println!(\n        \"{:?}\",\n        cities\n            .iter()\n            .find(|city| city.name.starts_with('A'))\n            .map(|city| city.population)\n    );\n}\n",
    "title": "Search a list of records",
    "url": "http://rosettacode.org/wiki/Search_a_list_of_records"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Search in paragraph's text",
    "url": "http://rosettacode.org/wiki/Search_in_paragraph's_text"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// 202100322 Rust programming solution\n\nuse tempfile::tempfile;\n\nfn main() {\n\n    let fh = tempfile();\n\n    println!(\"{:?}\", fh);\n}",
    "title": "Secure temporary file",
    "url": "http://rosettacode.org/wiki/Secure_temporary_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Selectively replace multiple instances of a character within a string",
    "url": "http://rosettacode.org/wiki/Selectively_replace_multiple_instances_of_a_character_within_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Self numbers",
    "url": "http://rosettacode.org/wiki/Self_numbers"
  },
  {
    "local_code": "fn is_self_describing(mut n: u64) -> bool {\n    // Compute the length of the number (the number of digits)\n    let mut tmp = n;\n    let mut len = 0;\n    while tmp > 0 {\n        len += 1;\n        tmp /= 10;\n    }\n\n    // In base 10, numbers with more than 10 digits can't be self-describing\n    if len > 10 || len == 0 {\n        return false;\n    }\n\n    // Go through each digit of the number, count how many times each digit occurs, and then\n    // subtract how often each digit is supposed to occur according to the number\n    let mut cnt = [0i32; 10];\n    for i in 0..len {\n        cnt[(n % 10) as usize] += 1;\n        cnt[len - i - 1] -= (n % 10) as i32;\n        n /= 10;\n    }\n\n    // If the number is self-describing, then all counters should be zero\n    cnt.iter().all(|&c| c == 0)\n}\n\nfn main() {\n    // Print out all self-describing numbers below 10^8\n    for i in 0u64..100_000_000 {\n        if is_self_describing(i) {\n            println!(\"{} is self-describing\", i);\n        }\n    }\n}\n\n#[test]\nfn test_is_self_describing() {\n    let tests = [\n        (0, false),\n        (1, false),\n        (200, false),\n        (1337, false),\n        (2020, true),\n        (1210, true),\n        (21200, true),\n        (3211000, true),\n        (42101000, true),\n        (43101000, false),\n        (521001000, true),\n        (6210001000, true),\n    ];\n\n    for &(n, expected) in &tests {\n        assert_eq!(is_self_describing(n), expected);\n    }\n}\n",
    "path": "tasks/self-describing-numbers",
    "remote_code": "\nfn is_self_desc(xx: u64) -> bool\n{\n    let s: String = xx.to_string();\n    let mut count_vec = vec![0; 10];\n    for c in s.chars() {\n        count_vec[c.to_digit(10).unwrap() as usize] += 1;\n    }\n    for (i, c) in s.chars().enumerate() {\n        if count_vec[i] != c.to_digit(10).unwrap() as usize {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    for i in 1..100000000 {\n        if is_self_desc(i) {\n            println!(\"{}\", i)\n        }\n    }\n}\n",
    "title": "Self-describing numbers",
    "url": "http://rosettacode.org/wiki/Self-describing_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_semiprime(n: usize) -> bool {\n    fn iter(x: usize, start: usize, acc: &[usize]) -> Vec<usize> {\n        if acc.len() > 2 {return acc.to_vec()} // break for semi_prime\n        let limit = (x as f64).sqrt().ceil() as usize;\n        match (start..=limit).skip_while(|i| x % i > 0).next() {\n            Some(v) => iter(x / v, v, &[&[v], acc].concat()),\n            None => if x < 2 { acc.to_vec() } \n                    else { [&[x], acc].concat() }\n        }\n    }\n    iter(n, 2, &[]).len() == 2\n}",
    "title": "Semiprime",
    "url": "http://rosettacode.org/wiki/Semiprime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashSet;\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::iter::FromIterator;\n\nfn semordnilap(filename: &str) -> std::io::Result<()> {\n    let file = File::open(filename)?;\n    let mut seen = HashSet::new();\n    let mut count = 0;\n    for line in io::BufReader::new(file).lines() {\n        let mut word = line?;\n        word.make_ascii_lowercase();\n        let rev = String::from_iter(word.chars().rev());\n        if seen.contains(&rev) {\n            if count < 5 {\n                println!(\"{}\\t{}\", word, rev);\n            }\n            count += 1;\n        } else {\n            seen.insert(word);\n        }\n    }\n    println!(\"\\nSemordnilap pairs found: {}\", count);\n    Ok(())\n}\n\nfn main() {\n    match semordnilap(\"unixdict.txt\") {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"{}\", error),\n    }\n}",
    "title": "Semordnilap",
    "url": "http://rosettacode.org/wiki/Semordnilap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Send an unknown method call",
    "url": "http://rosettacode.org/wiki/Send_an_unknown_method_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Send email",
    "url": "http://rosettacode.org/wiki/Send_email"
  },
  {
    "local_code": "/// the formula that should produce no perfect squares\nfn non_sq(n: u64) -> u64 {\n    n + (0.5 + (n as f64).sqrt()) as u64\n}\n\nfn main() {\n    // print the first 22 non squares\n    for n in (1u64..23).map(non_sq) {\n        println!(\"{}\", n);\n    }\n}\n\n#[test]\nfn test_no_squares() {\n    // check if a number is a square\n    let is_square = |n: u64| {\n        let r = (n as f64).sqrt() as u64;\n        r * r == n\n    };\n    // verify that there are no squares in the first million of\n    // values calculated by non_sq\n    for ns in (1u64..1000001).map(non_sq) {\n        assert!(!is_square(ns));\n    }\n}\n",
    "path": "tasks/sequence-of-non-squares",
    "remote_code": "\nfn f(n: i64) -> i64 {\n    n + (0.5 + (n as f64).sqrt()) as i64\n}\n\nfn is_sqr(n: i64) -> bool {\n    let a = (n as f64).sqrt() as i64;\n    n == a * a || n == (a+1) * (a+1) || n == (a-1) * (a-1) \n}\n\nfn main() {\n    println!( \"{:?}\", (1..23).map(|n| f(n)).collect::<Vec<i64>>() );\n    let count = (1..1_000_000).map(|n| f(n)).filter(|&n| is_sqr(n)).count();\n    println!(\"{} unexpected squares found\", count);\n}\n",
    "title": "Sequence of non-squares",
    "url": "http://rosettacode.org/wiki/Sequence_of_non-squares"
  },
  {
    "local_code": "fn is_prime(number: u32) -> bool {\n    #[allow(clippy::cast_precision_loss)]\n    #[allow(clippy::cast_possible_truncation)]\n    #[allow(clippy::cast_sign_loss)]\n    let limit = (number as f32).sqrt() as u32 + 1;\n\n    // We test if the number is divisible by any number up to the limit\n    !(number < 2 || (2..limit).any(|x| number % x == 0))\n}\n\nfn main() {\n    println!(\n        \"Primes below 100:\\n{:?}\",\n        (0_u32..100).fold(vec![], |mut acc, number| {\n            if is_prime(number) {\n                acc.push(number)\n            };\n            acc\n        })\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_prime;\n\n    #[test]\n    fn test_is_prime() {\n        assert_eq!(is_prime(1), false);\n        assert_eq!(is_prime(2), true);\n        assert_eq!(is_prime(3), true);\n        assert_eq!(is_prime(4), false);\n        assert_eq!(is_prime(5), true);\n        assert_eq!(is_prime(7919), true);\n    }\n}\n",
    "path": "tasks/sequence-of-primes-by-trial-division",
    "remote_code": "\nfn is_prime(number: u32) -> bool {\n    #[allow(clippy::cast_precision_loss)]\n    let limit = (number as f32).sqrt() as u32 + 1;\n\n    // We test if the number is divisible by any number up to the limit\n    !(number < 2 || (2..limit).any(|x| number % x == 0))\n}\n\nfn main() {\n    println!(\n        \"Primes below 100:\\n{:?}\",\n        (0_u32..100).fold(vec![], |mut acc, number| {\n            if is_prime(number) {\n                acc.push(number)\n            };\n            acc\n        })\n    );\n}\n",
    "title": "Sequence of primes by trial division",
    "url": "http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence of primorial primes",
    "url": "http://rosettacode.org/wiki/Sequence_of_primorial_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence: nth number with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_nth_number_with_exactly_n_divisors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence: smallest number greater than previous term with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors"
  },
  {
    "local_code": "use itertools::Itertools;\n\nconst PRIMES: [u64; 15] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];\nconst MAX_DIVISOR: usize = 64;\n\nstruct DivisorSeq {\n    max_number_of_divisors: u64,\n    index: u64,\n}\n\nimpl DivisorSeq {\n    fn new(max_number_of_divisors: u64) -> DivisorSeq {\n        DivisorSeq {\n            max_number_of_divisors,\n            index: 1,\n        }\n    }\n}\n\nimpl Iterator for DivisorSeq {\n    type Item = u64;\n\n    #[allow(clippy::cast_possible_truncation)]\n    fn next(&mut self) -> Option<u64> {\n        if self.max_number_of_divisors < self.index {\n            return None;\n        }\n        #[allow(unused_mut)]\n        let mut result: u64;\n        let divisors_of_divisor = get_divisors(self.index);\n        match divisors_of_divisor.len() {\n            1 | 2 => {\n                // when # divisors is a prime\n                result = 2_u64.pow(self.index as u32 - 1);\n                self.index += 1;\n            }\n            3 => {\n                // when # divisors is a prime square\n                result = 6_u64.pow(divisors_of_divisor[1] as u32 - 1);\n                self.index += 1;\n            }\n            4 => {\n                // when # divisors is a prime * non-prime\n                result = 2_u64.pow(divisors_of_divisor[2] as u32 - 1)\n                    * 3_u64.pow(divisors_of_divisor[1] as u32 - 1);\n                self.index += 1;\n            }\n            8 if divisors_of_divisor\n                .iter()\n                .filter(|x| PRIMES.contains(x))\n                .count()\n                == 3 =>\n            {\n                // sphenic numbers, aka p*m*q, where, p, m and q are prime\n                let first_primes = divisors_of_divisor\n                    .iter()\n                    .filter(|x| PRIMES.contains(x))\n                    .collect::<Vec<_>>();\n                result = 2_u64.pow(*first_primes[2] as u32 - 1)\n                    * 3_u64.pow(*first_primes[1] as u32 - 1)\n                    * 5_u64.pow(*first_primes[0] as u32 - 1);\n                self.index += 1;\n            }\n            _ => {\n                // brute force and slow: iterates over the numbers to find\n                // one with the appropriate number of divisors\n                let mut x: u64 = 1;\n                loop {\n                    if get_divisors(x).len() as u64 == self.index {\n                        break;\n                    }\n                    x += 1;\n                }\n\n                result = x;\n                self.index += 1;\n            }\n        }\n        Some(result)\n    }\n}\n/// Gets all divisors of a number\nfn get_divisors(n: u64) -> Vec<u64> {\n    let mut results = Vec::new();\n\n    for i in 1..=(n / 2) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\n#[allow(clippy::cast_possible_truncation)]\nfn main() {\n    // simple version using factorizing numbers\n    // with rules applied from A005179 so speed up\n    // but as such it is slow in some cases, e.g for 52\n    let seq_iter = DivisorSeq::new(64);\n    println!(\"Simple method with rules\");\n    println!(\"# divisors     Smallest number\");\n    for (i, x) in seq_iter.enumerate() {\n        println!(\"{:>10}{:20}\", i + 1, x);\n    }\n\n    // more advanced version using calculations based on number of\n    // prime factors and their exponent\n\n    // load initial result table with an initial value of 2**n for each item\n    let mut min_numbers = vec![0_u64; MAX_DIVISOR];\n    (0_usize..MAX_DIVISOR).for_each(|n| min_numbers[n] = 2_u64.pow(n as u32));\n\n    let prime_list = (1..15).map(|i| PRIMES[0..=i].to_vec()).collect::<Vec<_>>();\n\n    for pl in &prime_list {\n        // calculate the max exponent a prime can get in a given prime-list\n        // to be able to produce the desired number of divisors\n        let max_exponent = 1 + MAX_DIVISOR as u32 / 2_u32.pow(pl.len() as u32 - 1);\n\n        // create a combination of exponents using cartesian product\n        let exponents = (1_usize..=pl.len())\n            .map(|_| 1_u32..=max_exponent)\n            .multi_cartesian_product()\n            .filter(|elt| {\n                let mut prev = None::<&u32>;\n                elt.iter().all(|x| match prev {\n                    Some(n) if x > n => false,\n                    _ => {\n                        prev = Some(x);\n                        true\n                    }\n                })\n            });\n\n        // iterate throught he exponent combinations\n        for exp in exponents {\n            // calculate the number of divisors using the formula\n            // given primes of p, q, r\n            // and exponents of a1, a2, a3\n            // the # divisors is (a1+1)* (a2+1) *(a3+1)\n            let num_of_divisors = exp.iter().map(|x| x + 1).product::<u32>() as usize;\n\n            // and calculate the number with those primes and the given exponent set\n            let num = pl.iter().zip(exp.iter()).fold(1_u64, |mut acc, (p, e)| {\n                // check for overflow if numbers won't fit into u64\n                acc = acc.checked_mul(p.pow(*e)).unwrap_or(0);\n                acc\n            });\n\n            // finally, if the number is less than what we have so far in the result table\n            // replace the result table with the smaller number\n            if num > 0\n                && min_numbers.len() >= num_of_divisors\n                && min_numbers[num_of_divisors - 1] > num\n            {\n                min_numbers[num_of_divisors - 1] = num;\n            }\n        }\n    }\n\n    println!(\"Advanced method\");\n    println!(\"# divisors     Smallest number\");\n    for (i, x) in min_numbers.iter().enumerate() {\n        println!(\"{:>10}{:20}\", i + 1, x);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::DivisorSeq;\n\n    #[test]\n    fn test_divisor_seq() {\n        let seq_iter = DivisorSeq::new(10);\n        let result = seq_iter.collect::<Vec<_>>();\n        assert_eq!(result, vec![1, 2, 4, 6, 16, 12, 64, 24, 36, 48]);\n    }\n}\n",
    "path": "tasks/sequence-smallest-number-with-exactly-n-divisors",
    "remote_code": "\nuse itertools::Itertools;\n\nconst PRIMES: [u64; 15] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];\nconst MAX_DIVISOR: usize = 64;\n\nstruct DivisorSeq {\n    max_number_of_divisors: u64,\n    index: u64,\n}\n\nimpl DivisorSeq {\n    fn new(max_number_of_divisors: u64) -> DivisorSeq {\n        DivisorSeq {\n            max_number_of_divisors,\n            index: 1,\n        }\n    }\n}\n\nimpl Iterator for DivisorSeq {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        if self.max_number_of_divisors < self.index {\n            return None;\n        }\n        #[allow(unused_mut)]\n        let mut result: u64;\n        let divisors_of_divisor = get_divisors(self.index);\n        match divisors_of_divisor.len() {\n            1 | 2 => {\n                // when # divisors is a prime\n                result = 2_u64.pow(self.index as u32 - 1);\n                self.index += 1;\n            }\n            3 => {\n                // when # divisors is a prime square\n                result = 6_u64.pow(divisors_of_divisor[1] as u32 - 1);\n                self.index += 1;\n            }\n            4 => {\n                // when # divisors is a prime * non-prime\n                result = 2_u64.pow(divisors_of_divisor[2] as u32 - 1)\n                    * 3_u64.pow(divisors_of_divisor[1] as u32 - 1);\n                self.index += 1;\n            }\n            8 if divisors_of_divisor\n                .iter()\n                .filter(|x| PRIMES.contains(x))\n                .count()\n                == 3 =>\n            {\n                // sphenic numbers, aka p*m*q, where, p, m and q are prime\n                let first_primes = divisors_of_divisor\n                    .iter()\n                    .filter(|x| PRIMES.contains(x))\n                    .collect::<Vec<_>>();\n                result = 2_u64.pow(*first_primes[2] as u32 - 1)\n                    * 3_u64.pow(*first_primes[1] as u32 - 1)\n                    * 5_u64.pow(*first_primes[0] as u32 - 1);\n                self.index += 1;\n            }\n            _ => {\n                // brute force and slow: iterates over the numbers to find\n                // one with the appropriate number of divisors\n                let mut x: u64 = 1;\n                loop {\n                    if get_divisors(x).len() as u64 == self.index {\n                        break;\n                    }\n                    x += 1;\n                }\n\n                result = x;\n                self.index += 1;\n            }\n        }\n        Some(result)\n    }\n}\n/// Gets all divisors of a number\nfn get_divisors(n: u64) -> Vec<u64> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\nfn main() {\n    // simple version using factorizing numbers\n    // with rules applied from A005179 so speed up\n    // but as such it is slow in some cases, e.g for 52\n    let seq_iter = DivisorSeq::new(64);\n    println!(\"Simple method with rules\");\n    println!(\"# divisors     Smallest number\");\n    for (i, x) in seq_iter.enumerate() {\n        println!(\"{:>10}{:20}\", i + 1, x);\n    }\n\n    // more advanced version using calculations based on number of\n    // prime factors and their exponent\n\n    // load initial result table with an initial value of 2**n for each item\n    let mut min_numbers = vec![0_u64; MAX_DIVISOR];\n    (0_usize..MAX_DIVISOR).for_each(|n| min_numbers[n] = 2_u64.pow(n as u32));\n\n    let prime_list = (1..15).map(|i| PRIMES[0..=i].to_vec()).collect::<Vec<_>>();\n\n    for pl in prime_list.iter() {\n        // calculate the max exponent a prime can get in a given prime-list\n        // to be able to produce the desired number of divisors\n        let max_exponent = 1 + MAX_DIVISOR as u32 / 2_u32.pow(pl.len() as u32 - 1);\n\n        // create a combination of exponents using cartesian product\n        let exponents = (1_usize..=pl.len())\n            .map(|_| 1_u32..=max_exponent)\n            .multi_cartesian_product()\n            .filter(|elt| {\n                let mut prev = None::<&u32>;\n                elt.iter().all(|x| match prev {\n                    Some(n) if x > n => false,\n                    _ => {\n                        prev = Some(x);\n                        true\n                    }\n                })\n            });\n\n        // iterate throught he exponent combinations\n        for exp in exponents {\n            // calculate the number of divisors using the formula\n            // given primes of p, q, r\n            // and exponents of a1, a2, a3\n            // the # divisors is (a1+1)* (a2+1) *(a3+1)\n            let num_of_divisors = exp.iter().map(|x| x + 1).product::<u32>() as usize;\n\n            // and calculate the number with those primes and the given exponent set\n            let num = pl.iter().zip(exp.iter()).fold(1_u64, |mut acc, (p, e)| {\n                // check for overflow if numbers won't fit into u64\n                acc = match acc.checked_mul(p.pow(*e)) {\n                    Some(z) => z,\n                    _ => 0,\n                };\n                acc\n            });\n\n            // finally, if the number is less than what we have so far in the result table\n            // replace the result table with the smaller number\n            if num > 0\n                && min_numbers.len() >= num_of_divisors\n                && min_numbers[num_of_divisors - 1] > num\n            {\n                min_numbers[num_of_divisors - 1] = num;\n            }\n        }\n    }\n\n    println!(\"Advanced method\");\n    println!(\"# divisors     Smallest number\");\n    for (i, x) in min_numbers.iter().enumerate() {\n        println!(\"{:>10}{:20}\", i + 1, x);\n    }\n}\n\n",
    "title": "Sequence: smallest number with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors"
  },
  {
    "local_code": "use std::collections::HashSet;\n\nfn main() {\n    // The first set contains integers from 0 to 7\n    let set1 = (0i32..7).collect::<HashSet<i32>>();\n\n    // The second set contains integers from 5 to 10\n    let set2 = (5i32..10).collect();\n\n    // A subset of set1\n    let subset1 = (2i32..5).collect::<HashSet<i32>>();\n\n    // Test if element is member of the set\n    assert!(set1.contains(&1));\n\n    // Test if subset1 is subset of set1\n    assert!(subset1.is_subset(&set1));\n\n    // Test if set1_copy is equal to set1\n    let set1_copy = set1.clone();\n    assert!(set1_copy == set1);\n\n    println!();\n    println!(\"Print the union of set1 and set2\");\n    for num in set1.union(&set2) {\n        println!(\"{}\", num);\n    }\n\n    println!();\n    println!(\"Print the intersection of set1 and set2\");\n    for num in set1.intersection(&set2) {\n        println!(\"{}\", num);\n    }\n\n    println!();\n    println!(\"Print the difference between set1 and set2\");\n    for num in set1.difference(&set2) {\n        println!(\"{}\", num);\n    }\n}\n",
    "path": "tasks/set",
    "remote_code": "use std::collections::HashSet;\n\nfn main() {\n  let a = vec![1, 3, 4].into_iter().collect::<HashSet<i32>>();\n  let b = vec![3, 5, 6].into_iter().collect::<HashSet<i32>>();\n\n  println!(\"Set A: {:?}\", a.iter().collect::<Vec<_>>());\n  println!(\"Set B: {:?}\", b.iter().collect::<Vec<_>>());\n  println!(\"Does A contain 4? {}\", a.contains(&4));\n  println!(\"Union: {:?}\", a.union(&b).collect::<Vec<_>>());\n  println!(\"Intersection: {:?}\", a.intersection(&b).collect::<Vec<_>>());\n  println!(\"Difference: {:?}\", a.difference(&b).collect::<Vec<_>>());\n  println!(\"Is A a subset of B? {}\", a.is_subset(&b));\n  println!(\"Is A equal to B? {}\", a == b);\n}",
    "title": "Set",
    "url": "http://rosettacode.org/wiki/Set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Set consolidation",
    "url": "http://rosettacode.org/wiki/Set_consolidation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Debug)]\nenum SetOperation {\n    Union,\n    Intersection,\n    Difference,\n}\n\n#[derive(Debug, PartialEq)]\nenum RangeType {\n    Inclusive,\n    Exclusive,\n}\n\n#[derive(Debug)]\nstruct CompositeSet<'a> {\n    operation: SetOperation,\n    a: &'a RealSet<'a>,\n    b: &'a RealSet<'a>,\n}\n\n#[derive(Debug)]\nstruct RangeSet {\n    range_types: (RangeType, RangeType),\n    start: f64,\n    end: f64,\n}\n\n#[derive(Debug)]\nenum RealSet<'a> {\n    RangeSet(RangeSet),\n    CompositeSet(CompositeSet<'a>),\n}\n\nimpl RangeSet {\n    fn compare_start(&self, n: f64) -> bool {\n        if self.range_types.0 == RangeType::Inclusive {\n            self.start <= n\n        } else {\n            self.start < n\n        }\n    }\n\n    fn compare_end(&self, n: f64) -> bool {\n        if self.range_types.1 == RangeType::Inclusive {\n            n <= self.end\n        } else {\n            n < self.end\n        }\n    }\n}\n\nimpl<'a> RealSet<'a> {\n    fn new(start_type: RangeType, start: f64, end: f64, end_type: RangeType) -> Self {\n        RealSet::RangeSet(RangeSet {\n            range_types: (start_type, end_type),\n            start,\n            end,\n        })\n    }\n\n    fn operation(&'a self, other: &'a Self, operation: SetOperation) -> Self {\n        RealSet::CompositeSet(CompositeSet {\n            operation,\n            a: self,\n            b: other,\n        })\n    }\n\n    fn union(&'a self, other: &'a Self) -> Self {\n        self.operation(other, SetOperation::Union)\n    }\n\n    fn intersection(&'a self, other: &'a Self) -> Self {\n        self.operation(other, SetOperation::Intersection)\n    }\n\n    fn difference(&'a self, other: &'a Self) -> Self {\n        self.operation(other, SetOperation::Difference)\n    }\n\n    fn contains(&self, n: f64) -> bool {\n        if let RealSet::RangeSet(range) = self {\n            range.compare_start(n) && range.compare_end(n)\n        } else if let RealSet::CompositeSet(range) = self {\n            match range.operation {\n                SetOperation::Union => range.a.contains(n) || range.b.contains(n),\n                SetOperation::Intersection => range.a.contains(n) && range.b.contains(n),\n                SetOperation::Difference => range.a.contains(n) && !range.b.contains(n),\n            }\n        } else {\n            unimplemented!();\n        }\n    }\n}\n\nfn make_contains_phrase(does_contain: bool) -> &'static str {\n    if does_contain {\n        \"contains\"\n    } else {\n        \"does not contain\"\n    }\n}\n\nuse RangeType::*;\n\nfn main() {\n    for (set_name, set) in [\n        (\n            \"(0, 1] ∪ [0, 2)\",\n            RealSet::new(Exclusive, 0.0, 1.0, Inclusive)\n                .union(&RealSet::new(Inclusive, 0.0, 2.0, Exclusive)),\n        ),\n        (\n            \"[0, 2) ∩ (1, 2]\",\n            RealSet::new(Inclusive, 0.0, 2.0, Exclusive)\n                .intersection(&RealSet::new(Exclusive, 1.0, 2.0, Inclusive)),\n        ),\n        (\n            \"[0, 3) − (0, 1)\",\n            RealSet::new(Inclusive, 0.0, 3.0, Exclusive)\n                .difference(&RealSet::new(Exclusive, 0.0, 1.0, Exclusive)),\n        ),\n        (\n            \"[0, 3) − [0, 1]\",\n            RealSet::new(Inclusive, 0.0, 3.0, Exclusive)\n                .difference(&RealSet::new(Inclusive, 0.0, 1.0, Inclusive)),\n        ),\n    ] {\n        println!(\"Set {}\", set_name);\n\n        for i in [0.0, 1.0, 2.0] {\n            println!(\"- {} {}\", make_contains_phrase(set.contains(i)), i);\n        }\n    }\n}",
    "title": "Set of real numbers",
    "url": "http://rosettacode.org/wiki/Set_of_real_numbers"
  },
  {
    "local_code": "use itertools::Itertools;\nuse rand::Rng;\n\nconst DECK_SIZE: usize = 81;\nconst NUM_ATTRIBUTES: usize = 4;\nconst ATTRIBUTES: [&[&str]; NUM_ATTRIBUTES] = [\n    &[\"red\", \"green\", \"purple\"],\n    &[\"one\", \"two\", \"three\"],\n    &[\"oval\", \"squiggle\", \"diamond\"],\n    &[\"solid\", \"open\", \"striped\"],\n];\n\nfn get_random_card_indexes(num_of_cards: usize) -> Vec<usize> {\n    let mut selected_cards: Vec<usize> = Vec::with_capacity(num_of_cards);\n    let mut rng = rand::thread_rng();\n    loop {\n        let idx = rng.gen_range(0..DECK_SIZE);\n        if !selected_cards.contains(&idx) {\n            selected_cards.push(idx);\n        }\n        if selected_cards.len() == num_of_cards {\n            break;\n        }\n    }\n\n    selected_cards\n}\n\nfn run_game(num_of_cards: usize, minimum_number_of_sets: usize) {\n    println!(\n        \"\\nGAME: # of cards: {} # of sets: {}\",\n        num_of_cards, minimum_number_of_sets\n    );\n\n    // generate the deck with 81 unique cards\n    let deck = (0..NUM_ATTRIBUTES)\n        .map(|_| (0..=2_usize))\n        .multi_cartesian_product()\n        .collect::<Vec<_>>();\n\n    // closure to return true if the three attributes are the same, or each of them is different\n    let valid_attribute =\n        |a: usize, b: usize, c: usize| -> bool { a == b && b == c || (a != b && b != c && a != c) };\n\n    // closure to test all attributes, each of them should be true to have a valid set\n    let valid_set = |t: &Vec<&Vec<usize>>| -> bool {\n        for attr in 0..NUM_ATTRIBUTES {\n            if !valid_attribute(t[0][attr], t[1][attr], t[2][attr]) {\n                return false;\n            }\n        }\n        true\n    };\n\n    loop {\n        // select the required # of cards from the deck randomly\n        let selected_cards = get_random_card_indexes(num_of_cards)\n            .iter()\n            .map(|idx| deck[*idx].clone())\n            .collect::<Vec<_>>();\n\n        // generate all combinations, and filter/keep only which are valid sets\n        let valid_sets = selected_cards\n            .iter()\n            .combinations(3)\n            .filter(|triplet| valid_set(triplet))\n            .collect::<Vec<_>>();\n\n        // if the # of the sets is matching the requirement, print it and finish\n        if valid_sets.len() == minimum_number_of_sets {\n            print!(\"SELECTED CARDS:\");\n            for card in &selected_cards {\n                print!(\"\\ncard: \");\n                for attr in 0..NUM_ATTRIBUTES {\n                    print!(\"{}, \", ATTRIBUTES[attr][card[attr]]);\n                }\n            }\n\n            print!(\"\\nSets:\");\n            for triplet in &valid_sets {\n                print!(\"\\nSet: \");\n                for card in triplet {\n                    for attr in 0..NUM_ATTRIBUTES {\n                        print!(\"{}, \", ATTRIBUTES[attr][card[attr]]);\n                    }\n                    print!(\" | \");\n                }\n            }\n\n            break;\n        }\n\n        //otherwise generate again\n    }\n}\nfn main() {\n    run_game(9, 4);\n    run_game(12, 6);\n}\n",
    "path": "tasks/set-puzzle",
    "remote_code": "\nuse itertools::Itertools;\nuse rand::Rng;\n\nconst DECK_SIZE: usize = 81;\nconst NUM_ATTRIBUTES: usize = 4;\nconst ATTRIBUTES: [&[&str]; NUM_ATTRIBUTES] = [\n    &[\"red\", \"green\", \"purple\"],\n    &[\"one\", \"two\", \"three\"],\n    &[\"oval\", \"squiggle\", \"diamond\"],\n    &[\"solid\", \"open\", \"striped\"],\n];\n\nfn get_random_card_indexes(num_of_cards: usize) -> Vec<usize> {\n    let mut selected_cards: Vec<usize> = Vec::with_capacity(num_of_cards);\n    let mut rng = rand::thread_rng();\n    loop {\n        let idx = rng.gen_range(0..DECK_SIZE);\n        if !selected_cards.contains(&idx) {\n            selected_cards.push(idx);\n        }\n        if selected_cards.len() == num_of_cards {\n            break;\n        }\n    }\n\n    selected_cards\n}\n\nfn run_game(num_of_cards: usize, minimum_number_of_sets: usize) {\n    println!(\n        \"\\nGAME: # of cards: {} # of sets: {}\",\n        num_of_cards, minimum_number_of_sets\n    );\n\n    // generate the deck with 81 unique cards\n    let deck = (0..NUM_ATTRIBUTES)\n        .map(|_| (0..=2_usize))\n        .multi_cartesian_product()\n        .collect::<Vec<_>>();\n\n    // closure to return true if the three attributes are the same, or each of them is different\n    let valid_attribute =\n        |a: usize, b: usize, c: usize| -> bool { a == b && b == c || (a != b && b != c && a != c) };\n\n    // closure to test all attributes, each of them should be true to have a valid set\n    let valid_set = |t: &Vec<&Vec<usize>>| -> bool {\n        for attr in 0..NUM_ATTRIBUTES {\n            if !valid_attribute(t[0][attr], t[1][attr], t[2][attr]) {\n                return false;\n            }\n        }\n        true\n    };\n\n    loop {\n        // select the required # of cards from the deck randomly\n        let selected_cards = get_random_card_indexes(num_of_cards)\n            .iter()\n            .map(|idx| deck[*idx].clone())\n            .collect::<Vec<_>>();\n\n        // generate all combinations, and filter/keep only which are valid sets\n        let valid_sets = selected_cards\n            .iter()\n            .combinations(3)\n            .filter(|triplet| valid_set(triplet))\n            .collect::<Vec<_>>();\n\n        // if the # of the sets is matching the requirement, print it and finish\n        if valid_sets.len() == minimum_number_of_sets {\n            print!(\"SELECTED CARDS:\");\n            for card in &selected_cards {\n                print!(\"\\ncard: \");\n                for attr in 0..NUM_ATTRIBUTES {\n                    print!(\"{}, \", ATTRIBUTES[attr][card[attr]]);\n                }\n            }\n\n            print!(\"\\nSets:\");\n            for triplet in &valid_sets {\n                print!(\"\\nSet: \");\n                for card in triplet {\n                    for attr in 0..NUM_ATTRIBUTES {\n                        print!(\"{}, \", ATTRIBUTES[attr][card[attr]]);\n                    }\n                    print!(\" | \");\n                }\n            }\n\n            break;\n        }\n\n        //otherwise generate again\n    }\n}\nfn main() {\n    run_game(9, 4);\n    run_game(12, 6);\n}\n\n",
    "title": "Set puzzle",
    "url": "http://rosettacode.org/wiki/Set_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::ops::{BitOrAssign, Shr};\n\nfn set_right_adjacent_bits<E: Clone + BitOrAssign + Shr<usize, Output = E>>(b: &mut E, n: usize) {\n    for _ in 1..=n {\n        *b |= b.clone() >> 1;\n    }\n}\n\nmacro_rules! test {\n    ( $t:ident, $n:expr, $e:expr, $g:ty, $b:expr, $c:expr$(,)? ) => {\n        #[test]\n        fn $t() {\n            let n: usize = $n;\n            let e: usize = $e;\n            let b_original: $g = $b;\n            let mut b = b_original.clone();\n            set_right_adjacent_bits(&mut b, n);\n            println!(\"n = {n}; e = {e}:\");\n            println!(\"          b = {:0>e$b}\", b_original);\n            println!(\"     output = {:0>e$b}\", b);\n            assert_eq!(b, $c);\n        }\n    };\n}\n\ntest!(test_a1, 2, 4, u8, 0b1000, 0b1110);\ntest!(test_a2, 2, 4, u8, 0b0100, 0b0111);\ntest!(test_a3, 2, 4, u8, 0b0010, 0b0011);\ntest!(test_a4, 2, 4, u8, 0b0000, 0b0000);\ntest!(\n    test_b1, 0, 66, u128,\n    0b010000000000100000000010000000010000000100000010000010000100010010,\n    0b010000000000100000000010000000010000000100000010000010000100010010,\n);\ntest!(\n    test_b2, 1, 66, u128,\n    0b010000000000100000000010000000010000000100000010000010000100010010,\n    0b011000000000110000000011000000011000000110000011000011000110011011,\n);\ntest!(\n    test_b3, 2, 66, u128,\n    0b010000000000100000000010000000010000000100000010000010000100010010,\n    0b011100000000111000000011100000011100000111000011100011100111011111,\n);\ntest!(\n    test_b4, 3, 66, u128,\n    0b010000000000100000000010000000010000000100000010000010000100010010,\n    0b011110000000111100000011110000011110000111100011110011110111111111,\n);",
    "title": "Set right-adjacent bits",
    "url": "http://rosettacode.org/wiki/Set_right-adjacent_bits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Seven-sided dice from five-sided dice",
    "url": "http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.2\"\n// circular-queue = \"0.2.5\"\n\nuse circular_queue::CircularQueue;\n\nfn main() {\n    let max = 1000035;\n    let max_group_size = 5;\n    let diff = 6;\n    let max_groups = 5;\n    let max_unsexy = 10;\n\n    let sieve = primal::Sieve::new(max + diff);\n    let mut group_count = vec![0; max_group_size];\n    let mut unsexy_count = 0;\n    let mut groups = Vec::new();\n    let mut unsexy_primes = CircularQueue::with_capacity(max_unsexy);\n\n    for _ in 0..max_group_size {\n        groups.push(CircularQueue::with_capacity(max_groups));\n    }\n\n    for p in sieve.primes_from(2).take_while(|x| *x < max) {\n        if !sieve.is_prime(p + diff) && (p < diff + 2 || !sieve.is_prime(p - diff)) {\n            unsexy_count += 1;\n            unsexy_primes.push(p);\n        } else {\n            let mut group = Vec::new();\n            group.push(p);\n            for group_size in 1..max_group_size {\n                let next = p + group_size * diff;\n                if next >= max || !sieve.is_prime(next) {\n                    break;\n                }\n                group.push(next);\n                group_count[group_size] += 1;\n                groups[group_size].push(group.clone());\n            }\n        }\n    }\n\n    for size in 1..max_group_size {\n        println!(\n            \"Number of groups of size {} is {}\",\n            size + 1,\n            group_count[size]\n        );\n        println!(\"Last {} groups of size {}:\", groups[size].len(), size + 1);\n        println!(\n            \"{}\\n\",\n            groups[size]\n                .asc_iter()\n                .map(|g| format!(\"({})\", to_string(&mut g.iter())))\n                .collect::<Vec<String>>()\n                .join(\", \")\n        );\n    }\n    println!(\"Number of unsexy primes is {}\", unsexy_count);\n    println!(\"Last {} unsexy primes:\", unsexy_primes.len());\n    println!(\"{}\", to_string(&mut unsexy_primes.asc_iter()));\n}\n\nfn to_string<T: ToString>(iter: &mut dyn std::iter::Iterator<Item = T>) -> String {\n    iter.map(|n| n.to_string())\n        .collect::<Vec<String>>()\n        .join(\", \")\n}",
    "title": "Sexy primes",
    "url": "http://rosettacode.org/wiki/Sexy_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shell one-liner",
    "url": "http://rosettacode.org/wiki/Shell_one-liner"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shoelace formula for polygonal area",
    "url": "http://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area"
  },
  {
    "local_code": "fn a(x: bool) -> bool {\n    println!(\"Inside function a\");\n    x\n}\n\nfn b(x: bool) -> bool {\n    println!(\"Inside function b\");\n    x\n}\n\nfn main() {\n    let booleans = [true, false];\n\n    for &i in &booleans {\n        for &j in &booleans {\n            println!(\"{} and {} is {}\", i, j, a(i) && b(j));\n            println!(\"{} or {} is {}\", i, j, a(i) || b(j));\n        }\n    }\n}\n",
    "path": "tasks/short-circuit-evaluation",
    "remote_code": "fn a(foo: bool) -> bool {\n    println!(\"a\");\n    foo\n}\n\nfn b(foo: bool) -> bool {\n    println!(\"b\");\n    foo\n}\n\nfn main() {\n    for i in vec![true, false] {\n        for j in vec![true, false] {\n            println!(\"{} and {} == {}\", i, j, a(i) && b(j));\n            println!(\"{} or {} == {}\", i, j, a(i) || b(j));\n            println!();\n        }\n    }\n}",
    "title": "Short-circuit evaluation",
    "url": "http://rosettacode.org/wiki/Short-circuit_evaluation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shortest common supersequence",
    "url": "http://rosettacode.org/wiki/Shortest_common_supersequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    for i in 0u8..16 {\n        for j in ((32+i)..128).step_by(16) {\n            let k = (j as char).to_string();\n            print!(\"{:3} : {:<3}   \", j, match j {\n                32 => \"Spc\",\n                127 => \"Del\",\n                _ => &k,\n            });\n        }\n        println!();\n    }\n}",
    "title": "Show ASCII table",
    "url": "http://rosettacode.org/wiki/Show_ASCII_table"
  },
  {
    "local_code": "use chrono::{TimeZone, Utc};\n\nfn main() {\n    let epoch = Utc.timestamp(0, 0);\n    println!(\"{}\", epoch.to_rfc3339());\n}\n",
    "path": "tasks/show-the-epoch",
    "remote_code": "extern crate time;\n\nuse time::{at_utc, Timespec};\n\nfn main() {\n    let epoch = at_utc(Timespec::new(0, 0));  \n    println!(\"{}\", epoch.asctime());\n}",
    "title": "Show the epoch",
    "url": "http://rosettacode.org/wiki/Show_the_epoch"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nconst SQRT3_2: f64 = 0.86602540378444;\n\nuse svg::node::element::path::Data;\n\nstruct Cursor {\n    x: f64,\n    y: f64,\n    angle: i32,\n}\n\nimpl Cursor {\n    fn new(x: f64, y: f64) -> Cursor {\n        Cursor {\n            x: x,\n            y: y,\n            angle: 0,\n        }\n    }\n    fn turn(&mut self, angle: i32) {\n        self.angle = (self.angle + angle) % 360;\n    }\n    fn draw_line(&mut self, data: Data, length: f64) -> Data {\n        let theta = (self.angle as f64).to_radians();\n        self.x += length * theta.cos();\n        self.y += length * theta.sin();\n        data.line_to((self.x, self.y))\n    }\n}\n\nfn curve(mut data: Data, order: usize, length: f64, cursor: &mut Cursor, angle: i32) -> Data {\n    if order == 0 {\n        return cursor.draw_line(data, length);\n    }\n    data = curve(data, order - 1, length / 2.0, cursor, -angle);\n    cursor.turn(angle);\n    data = curve(data, order - 1, length / 2.0, cursor, angle);\n    cursor.turn(angle);\n    curve(data, order - 1, length / 2.0, cursor, -angle)\n}\n\nfn write_sierpinski_arrowhead(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n    use svg::node::element::Path;\n    use svg::node::element::Rectangle;\n\n    let margin = 20.0;\n    let side = (size as f64) - 2.0 * margin;\n    let y = 0.5 * (size as f64) + 0.5 * SQRT3_2 * side;\n    let x = margin;\n    let mut cursor = Cursor::new(x, y);\n    if (order & 1) != 0 {\n        cursor.turn(-60);\n    }\n    let mut data = Data::new().move_to((x, y));\n    data = curve(data, order, side, &mut cursor, 60);\n    let rect = Rectangle::new()\n        .set(\"width\", \"100%\")\n        .set(\"height\", \"100%\")\n        .set(\"fill\", \"white\");\n    let mut document = svg::Document::new()\n        .set(\"width\", size)\n        .set(\"height\", size)\n        .add(rect);\n    let path = Path::new()\n        .set(\"fill\", \"none\")\n        .set(\"stroke\", \"black\")\n        .set(\"stroke-width\", \"1\")\n        .set(\"d\", data);\n    document = document.add(path);\n    svg::save(file, &document)\n}\n\nfn main() {\n    write_sierpinski_arrowhead(\"sierpinski_arrowhead.svg\", 600, 8).unwrap();\n}",
    "title": "Sierpinski arrowhead curve",
    "url": "http://rosettacode.org/wiki/Sierpinski_arrowhead_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    for i in 0..4 {\n        println!(\"\\nN={}\", i);\n        println!(\"{}\", sierpinski_carpet(i));\n    }\n}\n\nfn sierpinski_carpet(n: u32) -> String {\n    let mut carpet = vec![\"#\".to_string()];\n    for _ in 0..n {\n        let mut top: Vec<_> = carpet.iter().map(|x| x.repeat(3)).collect();\n        let middle: Vec<_> = carpet\n            .iter()\n            .map(|x| x.to_string() + &x.replace(\"#\", \" \") + x)\n            .collect();\n        let bottom = top.clone();\n\n        top.extend(middle);\n        top.extend(bottom);\n        carpet = top;\n    }\n    carpet.join(\"\\n\")\n}\n\n",
    "title": "Sierpinski carpet",
    "url": "http://rosettacode.org/wiki/Sierpinski_carpet"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nfn sierpinski_pentagon(\n    mut document: svg::Document,\n    mut x: f64,\n    mut y: f64,\n    mut side: f64,\n    order: usize,\n) -> svg::Document {\n    use std::f64::consts::PI;\n    use svg::node::element::Polygon;\n\n    let degrees72 = 0.4 * PI;\n    let mut angle = 3.0 * degrees72;\n    let scale_factor = 1.0 / (2.0 + degrees72.cos() * 2.0);\n\n    if order == 1 {\n        let mut points = Vec::new();\n        points.push((x, y));\n        for _ in 0..5 {\n            x += angle.cos() * side;\n            y -= angle.sin() * side;\n            angle += degrees72;\n            points.push((x, y));\n        }\n        let polygon = Polygon::new()\n            .set(\"fill\", \"blue\")\n            .set(\"stroke\", \"black\")\n            .set(\"stroke-width\", \"1\")\n            .set(\"points\", points);\n        document = document.add(polygon);\n    } else {\n        side *= scale_factor;\n        let distance = side + side * degrees72.cos() * 2.0;\n        for _ in 0..5 {\n            x += angle.cos() * distance;\n            y -= angle.sin() * distance;\n            angle += degrees72;\n            document = sierpinski_pentagon(document, x, y, side, order - 1);\n        }\n    }\n    document\n}\n\nfn write_sierpinski_pentagon(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n    use std::f64::consts::PI;\n    use svg::node::element::Rectangle;\n\n    let margin = 5.0;\n    let radius = (size as f64) / 2.0 - 2.0 * margin;\n    let side = radius * (0.2 * PI).sin() * 2.0;\n    let height = side * ((0.2 * PI).sin() + (0.4 * PI).sin());\n    let x = (size as f64) / 2.0;\n    let y = (size as f64 - height) / 2.0;\n\n    let rect = Rectangle::new()\n        .set(\"width\", \"100%\")\n        .set(\"height\", \"100%\")\n        .set(\"fill\", \"white\");\n\n    let mut document = svg::Document::new()\n        .set(\"width\", size)\n        .set(\"height\", size)\n        .add(rect);\n\n    document = sierpinski_pentagon(document, x, y, side, order);\n    svg::save(file, &document)\n}\n\nfn main() {\n    write_sierpinski_pentagon(\"sierpinski_pentagon.svg\", 600, 5).unwrap();\n}",
    "title": "Sierpinski pentagon",
    "url": "http://rosettacode.org/wiki/Sierpinski_pentagon"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nuse svg::node::element::path::Data;\nuse svg::node::element::Path;\n\nstruct SierpinskiSquareCurve {\n    current_x: f64,\n    current_y: f64,\n    current_angle: i32,\n    line_length: f64,\n}\n\nimpl SierpinskiSquareCurve {\n    fn new(x: f64, y: f64, length: f64, angle: i32) -> SierpinskiSquareCurve {\n        SierpinskiSquareCurve {\n            current_x: x,\n            current_y: y,\n            current_angle: angle,\n            line_length: length,\n        }\n    }\n    fn rewrite(order: usize) -> String {\n        let mut str = String::from(\"F+XF+F+XF\");\n        for _ in 0..order {\n            let mut tmp = String::new();\n            for ch in str.chars() {\n                match ch {\n                    'X' => tmp.push_str(\"XF-F+F-XF+F+XF-F+F-X\"),\n                    _ => tmp.push(ch),\n                }\n            }\n            str = tmp;\n        }\n        str\n    }\n    fn execute(&mut self, order: usize) -> Path {\n        let mut data = Data::new().move_to((self.current_x, self.current_y));\n        for ch in SierpinskiSquareCurve::rewrite(order).chars() {\n            match ch {\n                'F' => data = self.draw_line(data),\n                '+' => self.turn(90),\n                '-' => self.turn(-90),\n                _ => {}\n            }\n        }\n        Path::new()\n            .set(\"fill\", \"none\")\n            .set(\"stroke\", \"black\")\n            .set(\"stroke-width\", \"1\")\n            .set(\"d\", data)\n    }\n    fn draw_line(&mut self, data: Data) -> Data {\n        let theta = (self.current_angle as f64).to_radians();\n        self.current_x += self.line_length * theta.cos();\n        self.current_y += self.line_length * theta.sin();\n        data.line_to((self.current_x, self.current_y))\n    }\n    fn turn(&mut self, angle: i32) {\n        self.current_angle = (self.current_angle + angle) % 360;\n    }\n    fn save(file: &str, size: usize, length: f64, order: usize) -> std::io::Result<()> {\n        use svg::node::element::Rectangle;\n        let x = (size as f64 - length) / 2.0;\n        let y = length;\n        let rect = Rectangle::new()\n            .set(\"width\", \"100%\")\n            .set(\"height\", \"100%\")\n            .set(\"fill\", \"white\");\n        let mut s = SierpinskiSquareCurve::new(x, y, length, 0);\n        let document = svg::Document::new()\n            .set(\"width\", size)\n            .set(\"height\", size)\n            .add(rect)\n            .add(s.execute(order));\n        svg::save(file, &document)\n    }\n}\n\nfn main() {\n    SierpinskiSquareCurve::save(\"sierpinski_square_curve.svg\", 635, 5.0, 5).unwrap();\n}",
    "title": "Sierpinski square curve",
    "url": "http://rosettacode.org/wiki/Sierpinski_square_curve"
  },
  {
    "local_code": "fn sierpinski(order: usize) {\n    let mut triangle = vec![\"*\".to_string()];\n    for i in 0..order {\n        #[allow(clippy::cast_possible_truncation)]\n        let space = \" \".repeat(2_usize.pow(i as u32));\n\n        // save original state\n        let mut d = triangle.clone();\n\n        // extend existing lines\n        d.iter_mut().for_each(|r| {\n            let new_row = format!(\"{}{}{}\", space, r, space);\n            *r = new_row;\n        });\n\n        // add new lines\n        triangle.iter().for_each(|r| {\n            let new_row = format!(\"{}{}{}\", r, \" \", r);\n            d.push(new_row);\n        });\n\n        triangle = d;\n    }\n\n    triangle.iter().for_each(|r| println!(\"{}\", r));\n}\nfn main() {\n    let order = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"4\".to_string())\n        .parse::<usize>()\n        .unwrap();\n\n    sierpinski(order);\n}\n\n#[cfg(test)]\n#[rustfmt::skip]\nmod tests {\n    use assert_cmd::Command;\n    use indoc::indoc;\n\n    #[test]\n    fn test_outputs() {\n        let mut cmd = Command::cargo_bin(\"sierpinski-triangle\").unwrap();\n        cmd.arg(\"2\").assert().success().stdout(indoc! {\"\n               *   \n              * *  \n             *   * \n            * * * *\n        \"});\n\n        let mut cmd = Command::cargo_bin(\"sierpinski-triangle\").unwrap();\n        cmd.arg(\"3\").assert().success().stdout(indoc! {\"\n                     *       \n                    * *      \n                   *   *     \n                  * * * *    \n                 *       *   \n                * *     * *  \n               *   *   *   * \n              * * * * * * * *\n        \"});\n    }\n}\n",
    "path": "tasks/sierpinski-triangle",
    "remote_code": "\nuse std::iter::repeat;\n\nfn sierpinski(order: usize) {\n    let mut triangle = vec![\"*\".to_string()];\n    for i in 0..order {\n        let space = repeat(' ').take(2_usize.pow(i as u32)).collect::<String>();\n\n        // save original state\n        let mut d = triangle.clone();\n\n        // extend existing lines\n        d.iter_mut().for_each(|r| {\n            let new_row = format!(\"{}{}{}\", space, r, space);\n            *r = new_row;\n        });\n\n        // add new lines\n        triangle.iter().for_each(|r| {\n            let new_row = format!(\"{}{}{}\", r, \" \", r);\n            d.push(new_row);\n        });\n\n        triangle = d;\n    }\n\n    triangle.iter().for_each(|r| println!(\"{}\", r));\n}\nfn main() {\n    let order = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"4\".to_string())\n        .parse::<usize>()\n        .unwrap();\n\n    sierpinski(order);\n}\n\n",
    "title": "Sierpinski triangle",
    "url": "http://rosettacode.org/wiki/Sierpinski_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// svg = \"0.8.0\"\n\nconst SQRT3_2: f64 = 0.86602540378444;\n\nfn sierpinski_triangle(\n    mut document: svg::Document,\n    mut x: f64,\n    mut y: f64,\n    mut side: f64,\n    order: usize,\n) -> svg::Document {\n    use svg::node::element::Polygon;\n\n    if order == 1 {\n        let mut points = Vec::new();\n        points.push((x, y));\n        y += side * SQRT3_2;\n        x -= side * 0.5;\n        points.push((x, y));\n        x += side;\n        points.push((x, y));\n        let polygon = Polygon::new()\n            .set(\"fill\", \"black\")\n            .set(\"stroke\", \"none\")\n            .set(\"points\", points);\n        document = document.add(polygon);\n    } else {\n        side *= 0.5;\n        document = sierpinski_triangle(document, x, y, side, order - 1);\n        y += side * SQRT3_2;\n        x -= side * 0.5;\n        document = sierpinski_triangle(document, x, y, side, order - 1);\n        x += side;\n        document = sierpinski_triangle(document, x, y, side, order - 1);\n    }\n    document\n}\n\nfn write_sierpinski_triangle(file: &str, size: usize, order: usize) -> std::io::Result<()> {\n    use svg::node::element::Rectangle;\n\n    let margin = 20.0;\n    let side = (size as f64) - 2.0 * margin;\n    let y = 0.5 * ((size as f64) - SQRT3_2 * side);\n    let x = margin + side * 0.5;\n\n    let rect = Rectangle::new()\n        .set(\"width\", \"100%\")\n        .set(\"height\", \"100%\")\n        .set(\"fill\", \"white\");\n\n    let mut document = svg::Document::new()\n        .set(\"width\", size)\n        .set(\"height\", size)\n        .add(rect);\n\n    document = sierpinski_triangle(document, x, y, side, order);\n    svg::save(file, &document)\n}\n\nfn main() {\n    write_sierpinski_triangle(\"sierpinski_triangle.svg\", 600, 8).unwrap();\n}",
    "title": "Sierpinski triangle/Graphical",
    "url": "http://rosettacode.org/wiki/Sierpinski_triangle/Graphical"
  },
  {
    "local_code": "use std::iter::repeat;\n\nfn int_sqrt(n: usize) -> usize {\n    (n as f64).sqrt() as usize\n}\n\n/// Return the prime numbers up to limit\n#[allow(clippy::needless_range_loop)]\nfn simple_sieve(limit: usize) -> Vec<usize> {\n    if limit < 2 {\n        return vec![];\n    }\n\n    let mut primes: Vec<bool> = repeat(true).take(limit + 1).collect();\n\n    for prime in 2..(int_sqrt(limit) + 1) {\n        if primes[prime] {\n            for multiple in (prime * prime..limit + 1).step_by(prime) {\n                primes[multiple] = false\n            }\n        }\n    }\n\n    (2..limit + 1).filter(|&n| primes[n]).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", simple_sieve(100))\n}\n\n#[test]\nfn test_basic() {\n    let primes = simple_sieve(30);\n    assert!(primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n}\n",
    "path": "tasks/sieve-of-eratosthenes",
    "remote_code": "fn primes(n: usize) -> impl Iterator<Item = usize> {\n    const START: usize = 2;\n    if n < START {\n        Vec::new()\n    } else {\n        let mut is_prime = vec![true; n + 1 - START];\n        let limit = (n as f64).sqrt() as usize;\n        for i in START..limit + 1 {\n            let mut it = is_prime[i - START..].iter_mut().step_by(i);\n            if let Some(true) = it.next() {\n                it.for_each(|x| *x = false);\n            }\n        }\n        is_prime\n    }\n    .into_iter()\n    .enumerate()\n    .filter_map(|(e, b)| if b { Some(e + START) } else { None })\n}",
    "title": "Sieve of Eratosthenes",
    "url": "http://rosettacode.org/wiki/Sieve_of_Eratosthenes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simple database",
    "url": "http://rosettacode.org/wiki/Simple_database"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simple turtle graphics",
    "url": "http://rosettacode.org/wiki/Simple_turtle_graphics"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use iced::{ // 0.2.0\n    button, Button, Column, Element, Length,\n    Text, Sandbox, Settings, Space,\n};\n\n#[derive(Debug, Copy, Clone)]\nstruct Pressed;\nstruct Simple {\n    value: i32,\n    button: button::State,\n}\n\nimpl Sandbox for Simple {\n    type Message = Pressed;\n\n    fn new() -> Simple {\n        Simple {\n            value: 0,\n            button: button::State::new(),\n        }\n    }\n\n    fn title(&self) -> String {\n        \"Simple Windowed Application\".into()\n    }\n\n    fn view(&mut self) -> Element<Self::Message> {\n        Column::new()\n            .padding(20)\n            .push({\n                let text = match self.value {\n                    0 => \"there have been no clicks yet\".into(),\n                    1 => \"there has been 1 click\".into(),\n                    n => format!(\"there have been {} clicks\", n),\n                };\n                Text::new(text).size(24)\n            }).push(\n                Space::with_height(Length::Fill)\n            ).push(\n                Button::new(&mut self.button, Text::new(\"Click Me!\"))\n                    .on_press(Pressed)\n            ).into()\n    }\n\n    fn update(&mut self, _: Self::Message) {\n        self.value += 1;\n    }\n}\n\nfn main() {\n    let mut settings = Settings::default();\n    settings.window.size = (600, 400);\n    Simple::run(settings).unwrap();\n}",
    "title": "Simple windowed application",
    "url": "http://rosettacode.org/wiki/Simple_windowed_application"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate autopilot;\nfn main() {\n    autopilot::key::type_string(\"Hello, world!\", None, None, &[]);\n}",
    "title": "Simulate input/Keyboard",
    "url": "http://rosettacode.org/wiki/Simulate_input/Keyboard"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate autopilot;\nextern crate rand;\nuse rand::Rng;\n\n// Moves the mouse in a sine wave across the screen.\nconst TWO_PI: f64 = std::f64::consts::PI * 2.0;\nfn sine_mouse_wave() -> Result<(), autopilot::mouse::MouseError> {\n    let screen_size = autopilot::screen::size();\n    let scoped_height = screen_size.height / 2.0 - 10.0; // Stay in screen bounds.\n    for x in 0..screen_size.width as u64 {\n        let y = (scoped_height * ((TWO_PI * x as f64) / screen_size.width).sin() + scoped_height)\n            .round();\n        let duration: u64 = rand::thread_rng().gen_range(1, 3);\n        try!(autopilot::mouse::move_to(autopilot::geometry::Point::new(\n            x as f64,\n            y as f64\n        )));\n        std::thread::sleep(std::time::Duration::from_millis(duration));\n    }\n    Ok(())\n}\n\nfn main() {\n    sine_mouse_wave().expect(\"Unable to move mouse\");\n}",
    "title": "Simulate input/Mouse",
    "url": "http://rosettacode.org/wiki/Simulate_input/Mouse"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Singleton",
    "url": "http://rosettacode.org/wiki/Singleton"
  },
  {
    "local_code": "#![allow(dead_code)]\n\n//! Rust's `Option<T>` type makes the definition of a singly-linked list trivial. The use of\n//! `Box<T>` (an owned pointer) is necessary because it has a known size, thus making sure the\n//! struct that contains it can have a finite size.\n//!\n//! ```\n//! struct Node<T> {\n//!     elem: T,\n//!     next: Option<Box<Node<T>>>,\n//! }\n//! ```\n//!\n//! However, the above example would not be suitable for a library because, first and foremost, it\n//! is private by default but simply making it public would not allow for any encapsulation.\n\n/// Type alias\ntype Link<T> = Option<Box<Node<T>>>;\n\n/// User-facing interface for list\n#[derive(Debug)]\npub struct List<T> {\n    head: Link<T>,\n}\n\n/// Private implementation of Node\n#[derive(Debug)]\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    /// List constructor\n    #[inline]\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    // Add other methods here...\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let _ = List::<i32>::new();\n}\n",
    "path": "tasks/singly-linked-list/element-definition",
    "remote_code": " struct Node<T> {\n    elem: T,\n    next: Option<Box<Node<T>>>,\n}",
    "title": "Singly-linked list/Element definition",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Element_definition"
  },
  {
    "local_code": "#![allow(dead_code)]\n\ntype Link<T> = Option<Box<Node<T>>>;\n\npub struct List<T> {\n    head: Link<T>,\n}\n\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n        let new_node = Box::new(Node {\n            elem,\n            next: self.head.take(),\n        });\n        self.head = Some(new_node);\n    }\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut list = List::new();\n    list.push(1);\n}\n",
    "path": "tasks/singly-linked-list/element-insertion",
    "remote_code": "impl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n    let new_node = Box::new(Node {\n        elem: elem,\n        next: self.head.take(),\n    });\n    self.head = Some(new_node);\n}",
    "title": "Singly-linked list/Element insertion",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Element_insertion"
  },
  {
    "local_code": "type Link<T> = Option<Box<Node<T>>>;\n\npub struct List<T> {\n    head: Link<T>,\n}\n\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n        let new_node = Box::new(Node {\n            elem,\n            next: self.head.take(),\n        });\n        self.head = Some(new_node);\n    }\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Iteration by value (simply empties the list as the caller now owns all values)\npub struct IntoIter<T>(List<T>);\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.head.take().map(|node| {\n            let node = *node;\n            self.0.head = node.next;\n            node.elem\n        })\n    }\n}\n\n/// Iteration by immutable reference\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Node<T>>,\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_deref();\n            &node.elem\n        })\n    }\n}\n\n/// Iteration by mutable reference\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Node<T>>,\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_deref_mut();\n            &mut node.elem\n        })\n    }\n}\n\n/// Methods implemented for List<T>\nimpl<T> List<T> {\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            next: self.head.as_deref(),\n        }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            next: self.head.as_deref_mut(),\n        }\n    }\n}\n\nimpl<T> IntoIterator for List<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter(self)\n    }\n}\n\nfn main() {\n    let mut list = List::new();\n    list.push(1);\n    list.push(2);\n    list.push(3);\n\n    for item in list.iter() {\n        println!(\"{}\", item);\n    }\n}\n",
    "path": "tasks/singly-linked-list/traversal",
    "remote_code": "// \n//\n// Iteration by value (simply empties the list as the caller now owns all values)\n//\n//\npub struct IntoIter<T>(List<T>);\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.head.take().map(|node| { \n            let node = *node;\n            self.0.head = node.next;\n            node.elem\n        })\n    }\n}\n\n//\n//\n// Iteration by immutable reference\n//\n//\n\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Node<T>>,\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_ref().map(|node| &**node);\n            &node.elem\n        })\n    }\n}\n\n//\n//\n// Iteration by mutable reference\n//\n//\n\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Node<T>>,\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_mut().map(|node| &mut **node);\n            &mut node.elem\n        })\n    }\n}\n\n//\n//\n// Methods implemented for List<T>\n//\n//\n\nimpl<T> List<T> {\n    pub fn into_iter(self) -> IntoIter<T> {\n        IntoIter(self)\n    }\n\n    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n        Iter { next: self.head.as_ref().map(|node| &**node) }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { next: self.head.as_mut().map(|node| &mut **node) }\n    }\n\n}",
    "title": "Singly-linked list/Traversal",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Traversal"
  },
  {
    "local_code": "//! Sleeps for the number of seconds specified on the command line.\n\nuse std::env;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let amount: u64 = env::args().nth(1).unwrap().parse().unwrap();\n    println!(\"Sleeping...\");\n    thread::sleep(Duration::from_secs(amount));\n    println!(\"Awake!\");\n}\n",
    "path": "tasks/sleep",
    "remote_code": "use std::{io, time, thread};\n\nfn main() {\n    println!(\"How long should we sleep in milliseconds?\");\n    \n    let mut sleep_string = String::new();\n\n    io::stdin().read_line(&mut sleep_string)\n               .expect(\"Failed to read line\");\n\n    let sleep_timer: u64 = sleep_string.trim()\n                                       .parse()\n                                       .expect(\"Not an integer\");\n    let sleep_duration = time::Duration::from_millis(sleep_timer);\n    \n    println!(\"Sleeping...\");\n    thread::sleep(sleep_duration);\n    println!(\"Awake!\");\n}",
    "title": "Sleep",
    "url": "http://rosettacode.org/wiki/Sleep"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sleeping Beauty problem",
    "url": "http://rosettacode.org/wiki/Sleeping_Beauty_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Smallest number k such that k+2^m is composite for all m less than k",
    "url": "http://rosettacode.org/wiki/Smallest_number_k_such_that_k%2B2^m_is_composite_for_all_m_less_than_k"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    if n % 5 == 0 {\n        return n == 5;\n    }\n    let mut p = 7;\n    const WHEEL: [u32; 8] = [4, 2, 4, 2, 4, 6, 2, 6];\n    loop {\n        for w in &WHEEL {\n            if p * p > n {\n                return true;\n            }\n            if n % p == 0 {\n                return false;\n            }\n            p += w;\n        }\n    }\n}\n\nfn next_prime_digit_number(n: u32) -> u32 {\n    if n == 0 {\n        return 2;\n    }\n    match n % 10 {\n        2 => n + 1,\n        3 | 5 => n + 2,\n        _ => 2 + next_prime_digit_number(n / 10) * 10,\n    }\n}\n\nfn smarandache_prime_digital_sequence() -> impl std::iter::Iterator<Item = u32> {\n    let mut n = 0;\n    std::iter::from_fn(move || {\n        loop {\n            n = next_prime_digit_number(n);\n            if is_prime(n) {\n                break;\n            }\n        }\n        Some(n)\n    })\n}\n\nfn main() {\n    let limit = 1000000000;\n    let mut seq = smarandache_prime_digital_sequence().take_while(|x| *x < limit);\n    println!(\"First 25 SPDS primes:\");\n    for i in seq.by_ref().take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    if let Some(p) = seq.by_ref().nth(99 - 25) {\n        println!(\"100th SPDS prime: {}\", p);\n    }\n    if let Some(p) = seq.by_ref().nth(999 - 100) {\n        println!(\"1000th SPDS prime: {}\", p);\n    }\n    if let Some(p) = seq.by_ref().nth(9999 - 1000) {\n        println!(\"10,000th SPDS prime: {}\", p);\n    }\n    if let Some(p) = seq.last() {\n        println!(\"Largest SPDS prime less than {}: {}\", limit, p);\n    }\n}",
    "title": "Smarandache prime-digital sequence",
    "url": "http://rosettacode.org/wiki/Smarandache_prime-digital_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main () {\n    //We just need the primes below 100\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut solution = Vec::new();\n    let mut number;\n    for i in 4..10000 {\n        //Factorize each number below 10.000\n        let mut prime_factors = Vec::new();\n        number = i;\n        for j in &primes {\n            while number % j == 0 {\n                number = number / j;\n                prime_factors.push(j);\n            }\n            if number == 1 { break; }\n        }\n        //Number is 1 (not a prime factor) if the factorization is complete or a prime bigger than 100\n        if number != 1 { prime_factors.push(&number); }\n        //Avoid the prime numbers\n        if prime_factors.len() < 2 { continue; }\n        //Check the smith number definition\n        if prime_factors.iter().fold(0, |n,x| n + x.to_string().chars().map(|d| d.to_digit(10).unwrap()).fold(0, |n,x| n + x))  \n            == i.to_string().chars().map(|d| d.to_digit(10).unwrap()).fold(0, |n,x| n + x) {\n            solution.push(i);\n        }\n    }\n    println!(\"Smith numbers below 10000 ({}) : {:?}\",solution.len(), solution);\n}",
    "title": "Smith numbers",
    "url": "http://rosettacode.org/wiki/Smith_numbers"
  },
  {
    "local_code": "// Implemented smooth (per-pixel) animation on Win32 API (tested on Windows 7)\n// Used winsafe - a safe rust bindings library for Win32 GUI: young but very handy, with links to docs.microsoft.com from doc and src for all Win32 entities involved.\n// Along the way, the possibility of restarting while maintaining the length of the snake has been implemented. Now a long snake is available to everyone!\n\n#![cfg(windows)]\n\nuse rand::Rng;\nuse std::{cell::RefCell, rc::Rc};\nuse winsafe::{co, gui, prelude::*, COLORREF, HBRUSH, HPEN, SIZE};\n\nconst STEP: i32 = 3; // px, motion per frame. STEP and FPS determine the smoothness and speed of the animation.\nconst FPS: u32 = 90;\nconst CELL: i32 = 21; // px, game grid (logical step). Will be aligned by STEP\nconst FIELD_W: i32 = 20; // width of the square field in CELLs\nconst SNAKE_W: i32 = 20; // px\nconst ROUNDING: SIZE = SIZE::new(SNAKE_W / 2, SNAKE_W / 2);\n\nconst RATIO: i32 = CELL / STEP;\nconst START_CELL: i32 = FIELD_W / 2 * RATIO;\n/// total field width (with overlap for collisions) in STEPs\nconst TW: i32 = (FIELD_W + 2) * RATIO;\n#[derive(Clone, Copy)]\n#[repr(i32)]\nenum Direction {\n    Start = 0,\n    A = -1,\n    D = 1,\n    W = -TW,\n    S = TW,\n}\nuse Direction::*;\n\nstruct Context {\n    wnd: gui::WindowMain,\n    snake: Vec<i32>, // [ids_rect] where id_rect = y * TW + x (where x, y: nSTEPs)\n    id_r: [i32; 6],  // ID 6 rectangles to color in next frame (bg, tail, turn, body, food, head)\n    gap: i32,        // gap in STEPs between animation and logic cell (negative - remove tail)\n    dir: Direction,\n    ordered_dir: Direction,\n}\nimpl Context {\n    fn new(wnd: gui::WindowMain, len: usize) -> Self {\n        Self {\n            wnd,\n            snake: vec![START_CELL; len.saturating_sub(RATIO as usize)],\n            id_r: [START_CELL; 6],\n            gap: 0,\n            dir: Start,\n            ordered_dir: S,\n        }\n    }\n}\n\npub fn main() {\n    let [bg, tail, turn, body, food, head] = [0usize, 1, 2, 3, 4, 5];\n    let mut colors = [(0x00, 0xF0, 0xA0); 6]; // color tail, turn, body\n    colors[bg] = (0x00, 0x50, 0x90);\n    colors[food] = (0xFF, 0x50, 0x00);\n    colors[head] = (0xFF, 0xFF, 0x00);\n    let brushes = COLORREF::new_array(&colors).map(|c| HBRUSH::CreateSolidBrush(c).unwrap());\n\n    let wnd = gui::WindowMain::new(gui::WindowMainOpts {\n        title: \"Snake - Start: Space, then press W-A-S-D\".to_string(),\n        size: winsafe::SIZE::new(FIELD_W * RATIO * STEP, FIELD_W * RATIO * STEP),\n        ex_style: co::WS_EX::CLIENTEDGE,\n        class_bg_brush: brushes[bg],\n        ..Default::default()\n    });\n\n    let context = Rc::new(RefCell::new(Context::new(wnd.clone(), 0)));\n\n    wnd.on().wm_key_down({\n        let context = Rc::clone(&context);\n        move |k| {\n            let mut ctx = context.borrow_mut();\n            match (ctx.dir, k.char_code as u8) {\n                (Start, bt @ (b' ' | 113)) => {\n                    let len = ctx.snake.len(); //                              113 == F2 key\n                    *ctx = Context::new(ctx.wnd.clone(), if bt == b' ' { len } else { 0 });\n                    ctx.wnd.hwnd().InvalidateRect(None, true)?; // call .wm_paint() with erase\n                    ctx.wnd.hwnd().SetTimer(1, 1000 / FPS, None)?;\n                }\n                (W | S, bt @ (b'A' | b'D')) => ctx.ordered_dir = if bt == b'A' { A } else { D },\n                (A | D, bt @ (b'S' | b'W')) => ctx.ordered_dir = if bt == b'S' { S } else { W },\n                _ => (),\n            }\n            Ok(())\n        }\n    });\n\n    wnd.on().wm_timer(1, {\n        let context = Rc::clone(&context);\n        let cells: Vec<i32> = (1..=FIELD_W)\n            .flat_map(|y| (1..=FIELD_W).map(move |x| (y * TW + x) * RATIO))\n            .collect();\n        move || {\n            let mut ctx = context.borrow_mut();\n            let new_h = ctx.id_r[head] + ctx.dir as i32;\n            ctx.id_r[body] = ctx.id_r[head];\n            ctx.id_r[head] = new_h;\n            if ctx.gap < 0 {\n                ctx.id_r[bg] = ctx.snake.remove(0);\n                ctx.id_r[tail] = ctx.snake[0];\n                ctx.id_r[turn] = ctx.snake[RATIO as usize / 2];\n            }\n            ctx.gap -= ctx.gap.signum();\n            if ctx.gap == 0 {\n                ctx.dir = ctx.ordered_dir;\n                let hw = ctx.wnd.hwnd();\n                let eat = new_h == ctx.id_r[food];\n                if !eat && (cells.binary_search(&new_h).is_err() || ctx.snake.contains(&&new_h)) {\n                    hw.KillTimer(1)?;\n                    hw.SetWindowText(&(hw.GetWindowText()? + \"  Restart: F2 (with save - Space)\"))?;\n                    ctx.dir = Start;\n                    return Ok(());\n                } else if eat || ctx.id_r[food] == 0 && ctx.id_r[tail] != START_CELL {\n                    let mut snk_cells: Vec<_> = ctx.snake.iter().step_by(RATIO as usize).collect();\n                    if eat && snk_cells.len() == cells.len() - 2 {\n                        hw.SetWindowText(&format!(\"Snake - EATEN ALL: {} !!!\", snk_cells.len()))?\n                    } else if eat {\n                        hw.SetWindowText(&format!(\"Snake - Eaten: {}.\", snk_cells.len()))?\n                    }\n                    if ctx.id_r[tail] == START_CELL || eat && snk_cells.len() == cells.len() - 2 {\n                        ctx.id_r[food] = 0; // hide food if not all of the saved snake has come out or everything is eaten\n                    } else if snk_cells.len() + 1 < cells.len() {\n                        snk_cells.sort();\n                        ctx.id_r[food] = *(cells.iter())\n                            .filter(|i| **i != new_h && snk_cells.binary_search(i).is_err())\n                            .nth(rand::thread_rng().gen_range(0..cells.len() - snk_cells.len() - 1))\n                            .unwrap();\n                    }\n                }\n                ctx.gap = if eat { RATIO } else { -RATIO }\n            }\n            ctx.snake.push(new_h);\n            ctx.wnd.hwnd().InvalidateRect(None, false)?; // call .wm_paint() without erase\n            Ok(())\n        }\n    });\n\n    wnd.on().wm_paint(move || {\n        let ctx = context.borrow();\n        let mut ps = winsafe::PAINTSTRUCT::default();\n        let hdc = ctx.wnd.hwnd().BeginPaint(&mut ps)?;\n        hdc.SelectObjectPen(HPEN::CreatePen(co::PS::NULL, 0, COLORREF::new(0, 0, 0))?)?;\n        for (&id_rect, &brush) in ctx.id_r.iter().zip(&brushes) {\n            hdc.SelectObjectBrush(brush)?;\n            let left = id_rect % TW * STEP - (STEP * RATIO + SNAKE_W) / 2;\n            let top = id_rect / TW * STEP - (STEP * RATIO + SNAKE_W) / 2;\n            hdc.RoundRect(\n                winsafe::RECT {\n                    left,\n                    top,\n                    right: left + SNAKE_W,\n                    bottom: top + SNAKE_W,\n                },\n                ROUNDING,\n            )?;\n        }\n        ctx.wnd.hwnd().EndPaint(&ps);\n        Ok(())\n    });\n\n    if let Err(e) = wnd.run_main(None) {\n        winsafe::HWND::NULL\n            .MessageBox(&e.to_string(), \"Uncaught error\", co::MB::ICONERROR)\n            .unwrap();\n    }\n}\n#![cfg_attr(windows, windows_subsystem = \"windows\")]\n\n#[cfg(windows)]\nmod cfg_windows;\n\n#[cfg(windows)]\nfn main() {\n    cfg_windows::main();\n}\n\n#[cfg(not(windows))]\nfn main() {\n    println!(\"So far implemented only for Windows\");\n}\n",
    "path": "tasks/snake",
    "remote_code": null,
    "title": "Snake",
    "url": "http://rosettacode.org/wiki/Snake"
  },
  {
    "local_code": "use std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn main() {\n    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)\n    let mut my_stream = TcpStream::connect(\"127.0.0.1:256\").unwrap();\n\n    // Write 'hello socket world' to the stream\n    write!(my_stream, \"hello socket world\").unwrap();\n} // <- my_stream's drop function gets called, which closes the socket\n",
    "path": "tasks/sockets",
    "remote_code": "use std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn main() {\n    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)\n    let mut my_stream = TcpStream::connect(\"127.0.0.1:256\").unwrap();\n\n    // Write 'hello socket world' to the stream, ignoring the result of write\n    let _ = my_stream.write(b\"hello socket world\");\n\n} // <- my_stream's drop function gets called, which closes the socket",
    "title": "Sockets",
    "url": "http://rosettacode.org/wiki/Sockets"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sokoban",
    "url": "http://rosettacode.org/wiki/Sokoban"
  },
  {
    "local_code": "use std::cmp::{max, min};\nuse std::fmt;\nuse std::ops;\n\n#[derive(Debug, Clone, PartialEq)]\nstruct Board {\n    cells: Vec<Vec<Option<u32>>>,\n}\n\nimpl Board {\n    fn new(initial_board: Vec<Vec<u32>>) -> Self {\n        let b = initial_board\n            .iter()\n            .map(|r| {\n                r.iter()\n                    .map(|c| if *c == u32::MAX { None } else { Some(*c) })\n                    .collect()\n            })\n            .collect();\n\n        Board { cells: b }\n    }\n\n    fn height(&self) -> usize {\n        self.cells.len()\n    }\n\n    fn width(&self) -> usize {\n        self.cells[0].len()\n    }\n}\nimpl ops::Index<(usize, usize)> for Board {\n    type Output = Option<u32>;\n\n    fn index(&self, (y, x): (usize, usize)) -> &Self::Output {\n        &self.cells[y][x]\n    }\n}\nimpl ops::IndexMut<(usize, usize)> for Board {\n    /// Returns a mutable reference to an cell for a given 'x' 'y' coordinates\n    fn index_mut(&mut self, (y, x): (usize, usize)) -> &mut Option<u32> {\n        &mut self.cells[y][x]\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let output: Vec<String> = self\n            .cells\n            .iter()\n            .map(|r| {\n                let mut row = String::default();\n\n                r.iter().for_each(|c| match c {\n                    None => row.push_str(format!(\"{:>2} \", \" \").as_ref()),\n                    Some(c) if c == &0 => row.push_str(format!(\"{:>2} \", \".\").as_ref()),\n                    Some(c) => row.push_str(format!(\"{:>2} \", c).as_ref()),\n                });\n                row\n            })\n            .collect();\n\n        write!(f, \"{}\", output.join(\"\\n\"))\n    }\n}\n\n/// Structure for holding puzzle related information.\n#[derive(Clone, Debug)]\nstruct Puzzle {\n    /// The state of the board.\n    board: Board,\n\n    /// All the numbers which were given at puzzle setup:\n    /// the numbers which cannot be changed during solving the puzzle.\n    fixed: Vec<u32>,\n\n    /// Position of the first number (1).\n    start: (usize, usize),\n}\n\nimpl Puzzle {\n    /// Creates a new puzzle\n    /// * `initial_board` contains the  layout and the startin position.\n    ///\n    /// - Simple numbers in the `initial_board` are considered as \"fixed\",\n    /// aka the solving does not change them\n    ///\n    /// - As the board can be non-rectangular, all cells which are invalid or cannot be used\n    /// are marked with u32::MAX in the `initial_board`\n    fn new(initial_board: Vec<Vec<u32>>) -> Self {\n        let mut s: (usize, usize) = (0, 0);\n        let mut f = initial_board\n            .iter()\n            .enumerate()\n            .flat_map(|(y, r)| r.iter().enumerate().map(move |(x, c)| (y, x, *c)))\n            .filter(|(_, _, c)| (1..u32::MAX).contains(c))\n            .fold(Vec::new(), |mut fixed, (y, x, c)| {\n                fixed.push(c);\n                if c == 1 {\n                    // store the position of the start\n                    s = (y, x)\n                };\n                fixed\n            });\n\n        f.sort_unstable();\n\n        Puzzle {\n            board: Board::new(initial_board),\n            fixed: f,\n            start: s,\n        }\n    }\n\n    pub fn print_board(&self) {\n        println!(\"{}\", self.board);\n    }\n\n    fn solver(&mut self, current: (usize, usize), n: &u32, mut next: usize) -> bool {\n        // reached the last number, solving successful\n        if n > self.fixed.last().unwrap() {\n            return true;\n        }\n\n        // check for exit conditions\n        match self.board[current] {\n            // cell outside of the board\n            None => return false,\n\n            //cell is already has a number in it\n            Some(c) if c != 0 && c != *n => return false,\n\n            //cell is empty, but the to be placed number is already matching the next fixed number\n            Some(c) if c == 0 && self.fixed[next] == *n => return false,\n\n            // continue\n            _ => (),\n        }\n\n        let mut backup: u32 = 0;\n        if self.board[current] == Some(*n) {\n            backup = *n;\n            next += 1;\n        }\n\n        self.board[current] = Some(*n);\n\n        for y in (max(current.0, 1) - 1)..=min(current.0 + 1, self.board.height() - 1) {\n            for x in (max(current.1, 1) - 1)..=min(current.1 + 1, self.board.width() - 1) {\n                if self.solver((y, x), &(n + 1), next) {\n                    return true;\n                }\n            }\n        }\n\n        // unsuccessful branch, restore original value\n        self.board[current] = Some(backup);\n        false\n    }\n\n    pub fn solve(&mut self) {\n        let start = self.start;\n        self.solver(start, &1, 0);\n    }\n}\n\nfn main() {\n    let input = vec![\n        vec![0, 33, 35, 0, 0, u32::MAX, u32::MAX, u32::MAX],\n        vec![0, 0, 24, 22, 0, u32::MAX, u32::MAX, u32::MAX],\n        vec![0, 0, 0, 21, 0, 0, u32::MAX, u32::MAX],\n        vec![0, 26, 0, 13, 40, 11, u32::MAX, u32::MAX],\n        vec![27, 0, 0, 0, 9, 0, 1, u32::MAX],\n        vec![u32::MAX, u32::MAX, 0, 0, 18, 0, 0, u32::MAX],\n        vec![u32::MAX, u32::MAX, u32::MAX, u32::MAX, 0, 7, 0, 0],\n        vec![\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            5,\n            0,\n        ],\n    ];\n\n    let mut p = Puzzle::new(input);\n    p.print_board();\n    p.solve();\n    println!(\"\\nSolution:\");\n    p.print_board();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solver() {\n        let input = vec![vec![0, 1], vec![4, 0]];\n        let mut p = Puzzle::new(input);\n        p.solve();\n        assert_eq!(p.board, Board::new(vec![vec![2, 1], vec![4, 3]]));\n\n        // test disabled cells\n        let input = vec![vec![u32::MAX, 1, 0], vec![5, 0, 0]];\n        let mut p = Puzzle::new(input);\n        p.solve();\n        assert_eq!(\n            p.board,\n            Board::new(vec![vec![u32::MAX, 1, 2], vec![5, 4, 3]])\n        );\n    }\n}\n",
    "path": "tasks/solve-a-hidato-puzzle",
    "remote_code": "\nuse std::cmp::{max, min};\nuse std::fmt;\nuse std::ops;\n\n#[derive(Debug, Clone, PartialEq)]\nstruct Board {\n    cells: Vec<Vec<Option<u32>>>,\n}\n\nimpl Board {\n    fn new(initial_board: Vec<Vec<u32>>) -> Self {\n        let b = initial_board\n            .iter()\n            .map(|r| {\n                r.iter()\n                    .map(|c| if *c == u32::MAX { None } else { Some(*c) })\n                    .collect()\n            })\n            .collect();\n\n        Board { cells: b }\n    }\n\n    fn height(&self) -> usize {\n        self.cells.len()\n    }\n\n    fn width(&self) -> usize {\n        self.cells[0].len()\n    }\n}\nimpl ops::Index<(usize, usize)> for Board {\n    type Output = Option<u32>;\n\n    fn index(&self, (y, x): (usize, usize)) -> &Self::Output {\n        &self.cells[y][x]\n    }\n}\nimpl ops::IndexMut<(usize, usize)> for Board {\n    /// Returns a mutable reference to an cell for a given 'x' 'y' coordinates\n    fn index_mut(&mut self, (y, x): (usize, usize)) -> &mut Option<u32> {\n        &mut self.cells[y][x]\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let output: Vec<String> = self\n            .cells\n            .iter()\n            .map(|r| {\n                let mut row = String::default();\n\n                r.iter().for_each(|c| match c {\n                    None => row.push_str(format!(\"{:>2} \", \" \").as_ref()),\n                    Some(c) if c == &0 => row.push_str(format!(\"{:>2} \", \".\").as_ref()),\n                    Some(c) => row.push_str(format!(\"{:>2} \", c).as_ref()),\n                });\n                row\n            })\n            .collect();\n\n        write!(f, \"{}\", output.join(\"\\n\"))\n    }\n}\n\n/// Structure for holding puzzle related information.\n#[derive(Clone, Debug)]\nstruct Puzzle {\n    /// The state of the board.\n    board: Board,\n\n    /// All the numbers which were given at puzzle setup:\n    /// the numbers which cannot be changed during solving the puzzle.\n    fixed: Vec<u32>,\n\n    /// Position of the first number (1).\n    start: (usize, usize),\n}\n\nimpl Puzzle {\n    /// Creates a new puzzle\n    /// * `initial_board` contains the  layout and the startin position.\n    ///\n    /// - Simple numbers in the `initial_board` are considered as \"fixed\",\n    /// aka the solving does not change them\n    ///\n    /// - As the board can be non-rectangular, all cells which are invalid or cannot be used\n    /// are marked with u32::MAX in the `initial_board`\n    fn new(initial_board: Vec<Vec<u32>>) -> Self {\n        let mut s: (usize, usize) = (0, 0);\n        let mut f = initial_board\n            .iter()\n            .enumerate()\n            .flat_map(|(y, r)| r.iter().enumerate().map(move |(x, c)| (y, x, *c)))\n            .filter(|(_, _, c)| (1..u32::MAX).contains(c))\n            .fold(Vec::new(), |mut fixed, (y, x, c)| {\n                fixed.push(c);\n                if c == 1 {\n                    // store the position of the start\n                    s = (y, x)\n                };\n                fixed\n            });\n\n        f.sort_unstable();\n\n        Puzzle {\n            board: Board::new(initial_board),\n            fixed: f,\n            start: s,\n        }\n    }\n\n    pub fn print_board(&self) {\n        println!(\"{}\", self.board);\n    }\n\n    fn solver(&mut self, current: (usize, usize), n: &u32, mut next: usize) -> bool {\n        // reached the last number, solving successful\n        if n > self.fixed.last().unwrap() {\n            return true;\n        }\n\n        // check for exit conditions\n        match self.board[current] {\n            // cell outside of the board\n            None => return false,\n\n            //cell is already has a number in it\n            Some(c) if c != 0 && c != *n => return false,\n\n            //cell is empty, but the to be placed number is already matching the next fixed number\n            Some(c) if c == 0 && self.fixed[next] == *n => return false,\n\n            // continue\n            _ => (),\n        }\n\n        let mut backup: u32 = 0;\n        if self.board[current] == Some(*n) {\n            backup = *n;\n            next += 1;\n        }\n\n        self.board[current] = Some(*n);\n\n        for y in (max(current.0, 1) - 1)..=min(current.0 + 1, self.board.height() - 1) {\n            for x in (max(current.1, 1) - 1)..=min(current.1 + 1, self.board.width() - 1) {\n                if self.solver((y, x), &(n + 1), next) {\n                    return true;\n                }\n            }\n        }\n\n        // unsuccessful branch, restore original value\n        self.board[current] = Some(backup);\n        false\n    }\n\n    pub fn solve(&mut self) {\n        let start = self.start;\n        self.solver(start, &1, 0);\n    }\n}\n\nfn main() {\n    let input = vec![\n        vec![0, 33, 35, 0, 0, u32::MAX, u32::MAX, u32::MAX],\n        vec![0, 0, 24, 22, 0, u32::MAX, u32::MAX, u32::MAX],\n        vec![0, 0, 0, 21, 0, 0, u32::MAX, u32::MAX],\n        vec![0, 26, 0, 13, 40, 11, u32::MAX, u32::MAX],\n        vec![27, 0, 0, 0, 9, 0, 1, u32::MAX],\n        vec![u32::MAX, u32::MAX, 0, 0, 18, 0, 0, u32::MAX],\n        vec![u32::MAX, u32::MAX, u32::MAX, u32::MAX, 0, 7, 0, 0],\n        vec![\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            u32::MAX,\n            5,\n            0,\n        ],\n    ];\n\n    let mut p = Puzzle::new(input);\n    p.print_board();\n    p.solve();\n    println!(\"\\nSolution:\");\n    p.print_board();\n}\n\n",
    "title": "Solve a Hidato puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Hidato_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Holy Knight's tour",
    "url": "http://rosettacode.org/wiki/Solve_a_Holy_Knight's_tour"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Hopido puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Hopido_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Numbrix puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve the no connection puzzle",
    "url": "http://rosettacode.org/wiki/Solve_the_no_connection_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn split(s: &str) -> impl Iterator<Item = u64> + '_ {\n    s.split('.').map(|x| x.parse().unwrap())\n}\n\nfn main() {\n    let mut oids = vec![\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n        \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n        \"1.3.6.1.4.1.11150.3.4.0.1\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n        \"1.3.6.1.4.1.11150.3.4.0\",\n    ];\n\n    oids.sort_by(|a, b| Iterator::cmp(split(a), split(b)));\n    \n    println!(\"{:#?}\", oids);\n}",
    "title": "Sort a list of object identifiers",
    "url": "http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers"
  },
  {
    "local_code": "#[derive(Debug, PartialEq)]\npub struct Element {\n    name: String,\n    value: String,\n}\n\nimpl Element {\n    fn new(name: &str, value: &str) -> Element {\n        Element {\n            name: name.to_string(),\n            value: value.to_string(),\n        }\n    }\n}\n\npub fn sort_by_name(elements: &mut Vec<Element>) {\n    elements.sort_by(|a, b| a.name.cmp(&b.name));\n}\n\nfn main() {\n    let mut values = vec![\n        Element::new(\"Iron\", \"Fe\"),\n        Element::new(\"Cobalt\", \"Co\"),\n        Element::new(\"Nickel\", \"Ni\"),\n        Element::new(\"Copper\", \"Cu\"),\n        Element::new(\"Zinc\", \"Zn\"),\n    ];\n    sort_by_name(&mut values);\n    println!(\"{:?}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_example() {\n        let mut values = vec![\n            Element::new(\"Iron\", \"Fe\"),\n            Element::new(\"Cobalt\", \"Co\"),\n            Element::new(\"Nickel\", \"Ni\"),\n            Element::new(\"Copper\", \"Cu\"),\n            Element::new(\"Zinc\", \"Zn\"),\n        ];\n        sort_by_name(&mut values);\n        assert_eq!(\n            values,\n            vec![\n                Element::new(\"Cobalt\", \"Co\"),\n                Element::new(\"Copper\", \"Cu\"),\n                Element::new(\"Iron\", \"Fe\"),\n                Element::new(\"Nickel\", \"Ni\"),\n                Element::new(\"Zinc\", \"Zn\"),\n            ]\n        );\n    }\n}\n",
    "path": "tasks/sort-an-array-of-composite-structures",
    "remote_code": "use std::cmp::Ordering;\n\n#[derive(Debug)]\nstruct Employee {\n    name: String,\n    category: String,\n}\n\nimpl Employee {\n    fn new(name: &str, category: &str) -> Self {\n        Employee {\n            name: name.into(),\n            category: category.into(),\n        }\n    }\n}\n\nimpl PartialEq for Employee {\n    fn eq(&self, other: &Self) -> bool {\n        self.name == other.name\n    }\n}\n\nimpl Eq for Employee {}\n\nimpl PartialOrd for Employee {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Employee {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.name.cmp(&other.name)\n    }\n}\n\nfn main() {\n    let mut employees = vec![\n        Employee::new(\"David\", \"Manager\"),\n        Employee::new(\"Alice\", \"Sales\"),\n        Employee::new(\"Joanna\", \"Director\"),\n        Employee::new(\"Henry\", \"Admin\"),\n        Employee::new(\"Tim\", \"Sales\"),\n        Employee::new(\"Juan\", \"Admin\"),\n    ];\n    employees.sort();\n    for e in employees {\n        println!(\"{:<6} : {}\", e.name, e.category);\n    }\n}",
    "title": "Sort an array of composite structures",
    "url": "http://rosettacode.org/wiki/Sort_an_array_of_composite_structures"
  },
  {
    "local_code": "fn main() {\n    let mut a = vec![9, 8, 7, 6, 5, 4, 3, 2, 1, 0];\n\n    // Merge sort in place, allocates ~2*n memory\n    a.sort_unstable();\n    println!(\"{:?}\", a);\n}\n\n#[test]\nfn test_sort() {\n    let mut a = vec![3, 1, 4, 1, 5, 9];\n    a.sort_unstable();\n    assert!(a == vec![1, 1, 3, 4, 5, 9]);\n}\n",
    "path": "tasks/sort-an-integer-array",
    "remote_code": "fn main() {\n    let mut a = vec!(9, 8, 7, 6, 5, 4, 3, 2, 1, 0);\n\n    a.sort();\n    println!(\"{:?}\", a);\n}",
    "title": "Sort an integer array",
    "url": "http://rosettacode.org/wiki/Sort_an_integer_array"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sort an outline at every level",
    "url": "http://rosettacode.org/wiki/Sort_an_outline_at_every_level"
  },
  {
    "local_code": "pub fn sort_disjoint(values: &mut [i32], indices: &[usize]) {\n    let mut sublist_indices = indices.to_owned();\n    sublist_indices.sort_unstable();\n    let mut sublist: Vec<i32> = sublist_indices.iter().map(|&i| values[i]).collect();\n    sublist.sort_unstable();\n    for i in 0..sublist.len() {\n        values[sublist_indices[i]] = sublist[i];\n    }\n}\n\nfn main() {\n    let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n    let indices = [6, 1, 7];\n    sort_disjoint(&mut values, &indices);\n    println!(\"{:?}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::sort_disjoint;\n    #[test]\n    fn test_example() {\n        let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n        let indices = [6, 1, 7];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [7, 0, 5, 4, 3, 2, 1, 6]);\n    }\n    #[test]\n    fn test_sort_one() {\n        let mut values = [0];\n        let indices = [0];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [0]);\n    }\n    #[test]\n    fn test_sort_all() {\n        let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n        let indices = [6, 1, 7, 2, 0, 4, 3, 5];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [0, 1, 2, 3, 4, 5, 6, 7]);\n    }\n}\n",
    "path": "tasks/sort-disjoint-sublist",
    "remote_code": "use std::collections::BTreeSet;\n\nfn disjoint_sort(array: &mut [impl Ord], indices: &[usize]) {\n    let mut sorted = indices.to_owned();\n    sorted.sort_unstable_by_key(|k| &array[*k]);\n    indices\n        .iter()\n        .zip(sorted.iter())\n        .map(|(&a, &b)| if a > b { (b, a) } else { (a, b) })\n        .collect::<BTreeSet<_>>()\n        .iter()\n        .for_each(|(a, b)| array.swap(*a, *b))\n}\n\nfn main() {\n    let mut array = [7, 6, 5, 4, 3, 2, 1, 0];\n    let indices = [6, 1, 7];\n    disjoint_sort(&mut array, &indices);\n    println!(\"{:?}\", array);\n}\n",
    "title": "Sort disjoint sublist",
    "url": "http://rosettacode.org/wiki/Sort_disjoint_sublist"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn lex_sorted_vector(num: i32) -> Vec<i32> {\n    let (min, max) = if num >= 1 { (1, num) } else { (num, 1) };\n    let mut str: Vec<String> = (min..=max).map(|i| i.to_string()).collect();\n    str.sort();\n    str.iter().map(|s| s.parse::<i32>().unwrap()).collect()\n}\n\nfn main() {\n    for n in &[0, 5, 13, 21, -22] {\n        println!(\"{}: {:?}\", n, lex_sorted_vector(*n));\n    }\n}",
    "title": "Sort numbers lexicographically",
    "url": "http://rosettacode.org/wiki/Sort_numbers_lexicographically"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let country_city = [\n        (\"UK\", \"London\"),\n        (\"US\", \"New York\"),\n        (\"US\", \"Birmingham\"),\n        (\"UK\", \"Birmingham\"),\n    ];\n\n    let mut city_sorted = country_city.clone();\n    city_sorted.sort_by_key(|k| k.1);\n\n    let mut country_sorted = country_city.clone();\n    country_sorted.sort_by_key(|k| k.0);\n\n    println!(\"Original:\");\n    for x in &country_city {\n        println!(\"{} {}\", x.0, x.1);\n    }\n\n    println!(\"\\nWhen sorted by city:\");\n    for x in &city_sorted {\n        println!(\"{} {}\", x.0, x.1);\n    }\n\n    println!(\"\\nWhen sorted by county:\");\n    for x in &country_sorted {\n        println!(\"{} {}\", x.0, x.1);\n    }\n}",
    "title": "Sort stability",
    "url": "http://rosettacode.org/wiki/Sort_stability"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut array = [5, 1, 3];\n    array.sort();\n    println!(\"Sorted: {:?}\", array);\n    array.sort_by(|a, b| b.cmp(a));\n    println!(\"Reverse sorted: {:?}\", array);\n}\n",
    "title": "Sort three variables",
    "url": "http://rosettacode.org/wiki/Sort_three_variables"
  },
  {
    "local_code": "fn sort_custom(strings: &mut Vec<&str>) {\n    use std::cmp::Ordering;\n    strings.sort_by(|a, b| {\n        if a.len() > b.len() {\n            return Ordering::Less;\n        }\n        if a.len() < b.len() {\n            return Ordering::Greater;\n        }\n        a.cmp(b)\n    });\n}\n\nfn main() {\n    let mut strings = vec![\n        \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\",\n    ];\n    sort_custom(&mut strings);\n    println!(\"{:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::sort_custom;\n    #[test]\n    fn test_descending_in_length() {\n        let mut strings = vec![\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\"]);\n    }\n    #[test]\n    fn test_ascending_lexicographically() {\n        let mut strings = vec![\"baaaa\", \"abaaa\", \"aabaa\", \"aaaba\", \"aaaab\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aaaab\", \"aaaba\", \"aabaa\", \"abaaa\", \"baaaa\"]);\n    }\n    #[test]\n    fn test_mixture() {\n        let mut strings = vec![\"a\", \"A\", \"ba\", \"aa\", \"AA\", \"aAa\", \"aaa\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aAa\", \"aaa\", \"AA\", \"aa\", \"ba\", \"A\", \"a\"]);\n    }\n}\n",
    "path": "tasks/sort-using-a-custom-comparator",
    "remote_code": "\nfn main() {\n    let mut words = [\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"];\n    words.sort_by(|l, r| Ord::cmp(&r.len(), &l.len()).then(Ord::cmp(l, r)));\n    println!(\"{:?}\", words);\n}\n",
    "title": "Sort using a custom comparator",
    "url": "http://rosettacode.org/wiki/Sort_using_a_custom_comparator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn _circle_sort<T: PartialOrd>(a: &mut [T], low: usize, high: usize, swaps: usize) -> usize {\n    if low == high {\n        return swaps;\n    }\n    let mut lo = low;\n    let mut hi = high;\n    let mid = (hi - lo) / 2;\n    let mut s = swaps;\n    while lo < hi {\n        if a[lo] > a[hi] {\n            a.swap(lo, hi);\n            s += 1;\n        }\n        lo += 1;\n        hi -= 1;\n    }\n    if lo == hi {\n        if a[lo] > a[hi + 1] {\n            a.swap(lo, hi + 1);\n            s += 1;\n        }\n    }\n    s = _circle_sort(a, low, low + mid, s);\n    s = _circle_sort(a, low + mid + 1, high, s);\n    return s;\n}\n\nfn circle_sort<T: PartialOrd>(a: &mut [T]) {\n    let len = a.len();\n    loop {\n        if _circle_sort(a, 0, len - 1, 0) == 0 {\n            break;\n        }\n    }\n}\n\nfn main() {\n    let mut v = vec![10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6];\n    println!(\"before: {:?}\", v);\n    circle_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Sorting Algorithms/Circle Sort",
    "url": "http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Bead sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nextern crate rand;\n\nuse rand::prelude::*;\n\nfn bogo_sort<T: Ord>(v: &mut [T]) {\n    let mut rng = thread_rng();\n    while !is_sorted(v) {\n        v.shuffle(&mut rng);\n    }\n}\n\n// helper function that checks for ascending order\nfn is_sorted<T: Ord>(v: &[T]) -> bool {\n    if v.len() > 1 {\n        for i in 0..(v.len() - 1) {\n            if v[i] > v[i + 1] {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    bogo_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    // The sort is random, so it could take a very long time!\n    test_sort!(super::bogo_sort, #[ignore]);\n}\n",
    "path": "tasks/sorting-algorithms/bogosort",
    "remote_code": "extern crate rand;\nuse rand::Rng;\n\nfn bogosort_by<T,F>(order: F, coll: &mut [T])\n    where F: Fn(&T, &T) -> bool\n{\n    let mut rng = rand::thread_rng();\n    while !is_sorted_by(&order, coll) {\n        rng.shuffle(coll);\n    }\n}\n\n#[inline]\nfn is_sorted_by<T,F>(order: F, coll: &[T]) -> bool\n    where F: Fn(&T,&T) -> bool,\n{\n    coll[..].iter().zip(&coll[1..]).all(|(x,y)| order(x,y))\n}\n\n \nfn main() {\n    let mut testlist = [1,55,88,24,990876,312,67,0,854,13,4,7];\n    bogosort_by(|x,y| x < y, &mut testlist);\n    println!(\"{:?}\", testlist);\n    bogosort_by(|x,y| x > y, &mut testlist);\n    println!(\"{:?}\", testlist);\n}\n",
    "title": "Sorting algorithms/Bogosort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bogosort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// Progress through the slice and 'bubble' elements up until they are in order.\nfn bubble_sort<T: PartialOrd>(v: &mut [T]) {\n    (1..v.len() + 1).rev().all(|length| {\n        let mut changes = 0;\n\n        for index in 0..length - 1 {\n            if v[index] > v[index + 1] {\n                changes += 1;\n                v.swap(index, index + 1);\n            }\n        }\n\n        // Continue to iterate if any 'bubble-ing' took place\n        changes > 0\n    });\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    bubble_sort(&mut numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::bubble_sort);\n}\n",
    "path": "tasks/sorting-algorithms/bubble-sort",
    "remote_code": "fn bubble_sort<T: Ord>(values: &mut[T]) {\n    let mut n = values.len();\n    let mut swapped = true;\n\n    while swapped {\n        swapped = false;\n\n        for i in 1..n {\n            if values[i - 1] > values[i] {\n                values.swap(i - 1, i);\n                swapped = true;\n            }\n        }\n\n        n = n - 1;\n    }\n}\n\nfn main() {\n    // Sort numbers.\n    let mut numbers = [8, 7, 1, 2, 9, 3, 4, 5, 0, 6];\n    println!(\"Before: {:?}\", numbers);\n\n    bubble_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings.\n    let mut strings = [\"empty\", \"beach\", \"art\", \"car\", \"deal\"];\n    println!(\"Before: {:?}\", strings);\n\n    bubble_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}",
    "title": "Sorting algorithms/Bubble sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n// Progress through the slice and 'bubble' elements up and down until they are in order.\nfn cocktail_sort<T: PartialOrd>(v: &mut [T]) {\n    (1..v.len() + 1).rev().all(|length| {\n        let mut swapped: bool = false;\n        // bubble up\n        for index in 0..length - 1 {\n            if v[index] > v[index + 1] {\n                swapped = true;\n                v.swap(index, index + 1);\n            }\n        }\n        // break if no swap occured before bubbling down\n        if !swapped {\n            return false;\n        }\n        // bubble down\n        for index in (0..length - 1).rev() {\n            if v[index] > v[index + 1] {\n                swapped = true;\n                v.swap(index, index + 1);\n            }\n        }\n        // Continue to iterate if any swapping took place\n        swapped\n    });\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    cocktail_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::cocktail_sort);\n}\n",
    "path": "tasks/sorting-algorithms/cocktail-sort",
    "remote_code": "fn cocktail_sort<T: PartialOrd>(a: &mut [T]) {\n    let len = a.len();\n    loop {\n        let mut swapped = false;\n        let mut i = 0;\n        while i + 1 < len {\n            if a[i] > a[i + 1] {\n                a.swap(i, i + 1);\n                swapped = true;\n            }\n            i += 1;\n        }\n        if swapped {\n            swapped = false;\n            i = len - 1;\n            while i > 0 {\n                if a[i - 1] > a[i] {\n                    a.swap(i - 1, i);\n                    swapped = true;\n                }\n                i -= 1;\n            }\n        }\n        if !swapped {\n            break;\n        }\n    }\n}\n\nfn main() {\n    let mut v = vec![10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6];\n    println!(\"before: {:?}\", v);\n    cocktail_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Sorting algorithms/Cocktail sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn cocktail_shaker_sort<T: PartialOrd>(a: &mut [T]) {\n    let mut begin = 0;\n    let mut end = a.len();\n    if end == 0 {\n        return;\n    }\n    end -= 1;\n    while begin < end {\n        let mut new_begin = end;\n        let mut new_end = begin;\n        for i in begin..end {\n            if a[i + 1] < a[i] {\n                a.swap(i, i + 1);\n                new_end = i;\n            }\n        }\n        end = new_end;\n        let mut i = end;\n        while i > begin {\n            if a[i] < a[i - 1] {\n                a.swap(i, i - 1);\n                new_begin = i;\n            }\n            i -= 1;\n        }\n        begin = new_begin;\n    }\n}\n\nfn main() {\n    let mut v = vec![5, 1, -6, 12, 3, 13, 2, 4, 0, 15];\n    println!(\"before: {:?}\", v);\n    cocktail_shaker_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Sorting algorithms/Cocktail sort with shifting bounds",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[allow(clippy::needless_range_loop)]\nfn comb_sort<T: PartialOrd>(v: &mut [T]) {\n    let len = v.len();\n    let mut gap: usize = v.len();\n    let mut swapped: bool = true;\n    while gap > 1 || swapped {\n        if gap > 1 {\n            gap = (gap as f32 / 1.25) as usize;\n        }\n        swapped = false;\n        for i in 0..len - gap {\n            if v[i] > v[i + gap] {\n                swapped = true;\n                v.swap(i, i + gap);\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    comb_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::comb_sort);\n}\n",
    "path": "tasks/sorting-algorithms/comb-sort",
    "remote_code": "fn comb_sort<T: PartialOrd>(a: &mut [T]) {\n    let len = a.len();\n    let mut gap = len;\n    let mut swapped = true;\n    while gap > 1 || swapped {\n        gap = (4 * gap) / 5;\n        if gap < 1 {\n            gap = 1;\n        }\n        let mut i = 0;\n        swapped = false;\n        while i + gap < len {\n            if a[i] > a[i + gap] {\n                a.swap(i, i + gap);\n                swapped = true;\n            }\n            i += 1;\n        }\n    }\n}\n\nfn main() {\n    let mut v = vec![10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6];\n    println!(\"before: {:?}\", v);\n    comb_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Sorting algorithms/Comb sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort"
  },
  {
    "local_code": "#[allow(clippy::needless_range_loop)]\nfn counting_sort(array: &mut [i32], min: i32, max: i32) {\n    // nothing to do for arrays shorter than 2\n    if array.len() < 2 {\n        return;\n    }\n\n    // we count occurences of values\n    let size = (max - min + 1) as usize;\n    let mut count = vec![0; size];\n\n    for e in array.iter() {\n        count[(*e - min) as usize] += 1;\n    }\n\n    // then we write values back, sorted\n    let mut index = 0;\n    for value in 0..count.len() {\n        for _ in 0..count[value] {\n            array[index] = value as i32;\n            index += 1;\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    counting_sort(&mut numbers, -31, 782);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate meta;\n\n    fn check_sort(array: &mut [i32], min: i32, max: i32) {\n        super::counting_sort(array, min, max);\n\n        meta::test_utils::check_sorted(array);\n    }\n\n    #[test]\n    fn rosetta_vector() {\n        let numbers = &mut [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n        check_sort(numbers, -31, 782);\n    }\n\n    #[test]\n    fn one_element_vector() {\n        let numbers = &mut [0i32];\n        check_sort(numbers, 0, 0);\n    }\n\n    #[test]\n    fn repeat_vector() {\n        let numbers = &mut [1i32, 1, 1, 1, 1];\n        check_sort(numbers, 1, 1);\n    }\n\n    #[test]\n    fn worst_case_vector() {\n        let numbers = &mut [20i32, 10, 0, -1, -5];\n        check_sort(numbers, -5, 20);\n    }\n\n    #[test]\n    fn already_sorted_vector() {\n        let numbers = &mut [-1i32, 0, 3, 6, 99];\n        check_sort(numbers, -1, 99);\n    }\n\n    #[test]\n    #[should_panic]\n    fn bad_min() {\n        let numbers = &mut [-1i32, 0, 3, 6, 99];\n        check_sort(numbers, 2, 99);\n    }\n}\n",
    "path": "tasks/sorting-algorithms/counting-sort",
    "remote_code": "fn counting_sort(\n    mut data: Vec<usize>,\n    min: usize,\n    max: usize,\n) -> Vec<usize> {\n    // create and fill counting bucket with 0\n    let mut count: Vec<usize> = Vec::with_capacity(data.len());\n    count.resize(data.len(), 0);\n\n    for num in &data {\n        count[num - min] = count[num - min] + 1;\n    }\n    let mut z: usize = 0;\n    for i in min..max+1 {\n        while count[i - min] > 0 {\n            data[z] = i;\n            z += 1;\n            count[i - min] = count[i - min] - 1;\n        }\n    }\n\n    data\n}\n\nfn main() {\n    let arr1 = vec![1, 0, 2, 9, 3, 8, 4, 7, 5, 6];\n    println!(\"{:?}\", counting_sort(arr1, 0, 9));\n\n    let arr2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    println!(\"{:?}\", counting_sort(arr2, 0, 9));\n\n    let arr3 = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];\n    println!(\"{:?}\", counting_sort(arr3, 0, 10));\n}",
    "title": "Sorting algorithms/Counting sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn gnome_sort<T: PartialOrd>(v: &mut [T]) {\n    let len = v.len();\n    let mut i: usize = 1;\n    let mut j: usize = 2;\n    while i < len {\n        if v[i - 1] <= v[i] {\n            i = j;\n            j += 1;\n        } else {\n            v.swap(i - 1, i);\n            i -= 1;\n            if i == 0 {\n                i = j;\n                j += 1;\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    gnome_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::gnome_sort);\n}\n",
    "path": "tasks/sorting-algorithms/gnome-sort",
    "remote_code": "fn gnome_sort<T: PartialOrd>(a: &mut [T]) {\n    let len = a.len();\n    let mut i: usize = 1;\n    let mut j: usize = 2;\n    while i < len {\n        if a[i - 1] <= a[i] {\n            // for descending sort, use >= for comparison\n            i = j;\n            j += 1;\n        } else {\n            a.swap(i - 1, i);\n            i -= 1;\n            if i == 0 {\n                i = j;\n                j += 1;\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut v = vec![10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6];\n    println!(\"before: {:?}\", v);\n    gnome_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Sorting algorithms/Gnome sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// This is ported from the Dart heap sort implementation\nfn heap_sort<T: Ord>(a: &mut [T]) {\n    let count = a.len();\n\n    if count == 0 {\n        return;\n    }\n\n    // first place 'a' in max-heap order\n    heapify(a, count);\n\n    let mut end = count - 1;\n    while end > 0 {\n        // swap the root (maximum value) of the heap with the\n        // last element of the heap\n        a.swap(0, end);\n\n        // put the heap back in max-heap order\n        sift_down(a, 0, end - 1);\n\n        // decrement the size of the heap so that the previous\n        // max value will stay in its proper place\n        end -= 1;\n    }\n}\n\nfn heapify<T: Ord>(a: &mut [T], count: usize) {\n    if count < 2 {\n        return;\n    }\n\n    // start is assigned the index in 'a' of the last parent node\n    let mut start: i32 = (count as i32 - 2) / 2; // binary heap\n\n    while start >= 0 {\n        // sift down the node at index 'start' to the proper place\n        // such that all nodes below the 'start' index are in heap order\n        sift_down(a, start as usize, count - 1);\n        start -= 1;\n    }\n}\n\nfn sift_down<T: Ord>(a: &mut [T], start: usize, end: usize) {\n    // end represents the limit of how far down the heap to shift\n    let mut root = start;\n\n    // while the root has at least one child\n    while (root * 2 + 1) <= end {\n        // root*2+1 points to the left child\n        let mut child: usize = root * 2 + 1;\n\n        // if the chile has a sibling and the child's value is less that its sibling's...\n        if child < end && a[child] < a[child + 1] {\n            // .. then point to the right child instead\n            child += 1;\n        }\n\n        // out of max-heap order\n        if a[root] < a[child] {\n            a.swap(root, child);\n            // repeat to continue shifting down the child now\n            root = child;\n        } else {\n            return;\n        }\n    }\n}\n\n#[allow(clippy::shadow_unrelated)]\npub fn main() {\n    let mut arr = [1_i32, 5, 2, 7, 3, 9, 4, 6, 8];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n\n    let mut arr = [1_i32, 2, 3, 4, 5, 6, 7, 8, 9];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n\n    let mut arr = [9_i32, 8, 7, 6, 5, 4, 3, 2, 1];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::heap_sort);\n}\n",
    "path": "tasks/sorting-algorithms/heapsort",
    "remote_code": "fn main() {\n    let mut v = [4, 6, 8, 1, 0, 3, 2, 2, 9, 5];\n    heap_sort(&mut v, |x, y| x < y);\n    println!(\"{:?}\", v);\n}\n\nfn heap_sort<T, F>(array: &mut [T], order: F)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let len = array.len();\n    // Create heap\n    for start in (0..len / 2).rev() {\n        shift_down(array, &order, start, len - 1)\n    }\n\n    for end in (1..len).rev() {\n        array.swap(0, end);\n        shift_down(array, &order, 0, end - 1)\n    }\n}\n\nfn shift_down<T, F>(array: &mut [T], order: &F, start: usize, end: usize)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let mut root = start;\n    loop {\n        let mut child = root * 2 + 1;\n        if child > end {\n            break;\n        }\n        if child + 1 <= end && order(&array[child], &array[child + 1]) {\n            child += 1;\n        }\n        if order(&array[root], &array[child]) {\n            array.swap(root, child);\n            root = child\n        } else {\n            break;\n        }\n    }\n}",
    "title": "Sorting algorithms/Heapsort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Heapsort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn insertion_sort<T>(arr: &mut [T])\nwhere\n    T: Ord,\n{\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j - 1] {\n            arr.swap(j, j - 1);\n            j -= 1;\n        }\n    }\n}\n\nfn main() {\n    let mut arr = vec![6, 8, 5, 9, 3, 2, 1, 4, 7];\n    insertion_sort(&mut arr);\n    println!(\"{:?}\", arr);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::insertion_sort);\n}\n",
    "path": "tasks/sorting-algorithms/insertion-sort",
    "remote_code": "fn insertion_sort<T: std::cmp::Ord>(arr: &mut [T]) {\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swap(j, j-1);\n            j = j-1;\n        }\n    }\n}",
    "title": "Sorting algorithms/Insertion sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort"
  },
  {
    "local_code": "//! This is an idiomatic-but-slow implementation. A more efficient implementation\n//! would use `unsafe` to avoid allocating so many temporary vectors.\n\nfn merge_sort<E: PartialOrd + Clone>(arr: &[E]) -> Vec<E> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n    let midpoint = arr.len() / 2;\n    let left = merge_sort(&arr[0..midpoint]);\n    let right = merge_sort(&arr[midpoint..]);\n    merge(&left[..], &right[..])\n}\n\nfn merge<E: PartialOrd + Clone>(left: &[E], right: &[E]) -> Vec<E> {\n    let mut merged = Vec::with_capacity(left.len() + right.len());\n    let mut i = 0;\n    let mut j = 0;\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            merged.push(left[i].clone());\n            i += 1;\n        } else {\n            merged.push(right[j].clone());\n            j += 1;\n        }\n    }\n    while i < left.len() {\n        merged.push(left[i].clone());\n        i += 1;\n    }\n    while j < right.len() {\n        merged.push(right[j].clone());\n        j += 1;\n    }\n    merged\n}\n\npub fn main() {\n    let arr = [1i32, 9, 3, 2, 1003, 23, -123, 7];\n    let sorted = merge_sort(&arr);\n    println!(\"{:?}\", sorted);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::merge_sort;\n\n    #[test]\n    fn sorted() {\n        let arr = [1i32, 2, 3, 4, 6, 8];\n        assert_eq!(merge_sort(&arr), arr.to_vec());\n    }\n\n    #[test]\n    fn reverse() {\n        let arr = [8i32, 6, 4, 3, 2, 1];\n        assert_eq!(merge_sort(&arr), vec![1i32, 2, 3, 4, 6, 8]);\n    }\n\n    #[test]\n    fn random() {\n        let arr = [12i32, 54, 2, 93, 13, 43, 15, 299, 234];\n        assert_eq!(\n            merge_sort(&arr),\n            vec![2i32, 12, 13, 15, 43, 54, 93, 234, 299]\n        );\n    }\n}\n",
    "path": "tasks/sorting-algorithms/merge-sort",
    "remote_code": "\nfn merge<T: Copy + PartialOrd>(x1: &[T], x2: &[T], y: &mut [T]) {\n\tassert_eq!(x1.len() + x2.len(), y.len());\n\tlet mut i = 0;\n\tlet mut j = 0;\n\tlet mut k = 0;\n\twhile i < x1.len() && j < x2.len() {\n\t\tif x1[i] < x2[j] {\n\t\t\ty[k] = x1[i];\n\t\t\tk += 1;\n\t\t\ti += 1;\n\t\t} else {\n\t\t\ty[k] = x2[j];\n\t\t\tk += 1;\n\t\t\tj += 1;\n\t\t}\n\t}\n\tif i < x1.len() {\n\t\ty[k..].copy_from_slice(&x1[i..]);\n\t}\n\tif j < x2.len() {\n\t\ty[k..].copy_from_slice(&x2[j..]);\n\t}\n}\n",
    "title": "Sorting algorithms/Merge sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn pancake_sort<T: Ord>(v: &mut [T]) {\n    let len = v.len();\n    // trivial case -- no flips\n    if len < 2 {\n        return;\n    }\n    for i in (0..len).rev() {\n        // find index of the maximum element within `v[0..i]` (inclusive)\n        let max_index = v\n            .iter()\n            .take(i + 1)\n            .enumerate()\n            .max_by_key(|&(_, elem)| elem)\n            .map(|(idx, _)| idx)\n            .expect(\"already checked to be non-empty\");\n        // if `max_index` is not where it's supposed to be\n        // do two flips to move it to `i`\n        if max_index != i {\n            flip(v, max_index);\n            flip(v, i);\n        }\n    }\n}\n\n// function to flip a section of a mutable collection from 0..num (inclusive)\nfn flip<E: PartialOrd>(v: &mut [E], num: usize) {\n    v[0..num + 1].reverse();\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    pancake_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n    pancake_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::pancake_sort);\n}\n",
    "path": "tasks/sorting-algorithms/pancake-sort",
    "remote_code": "fn pancake_sort<T: Ord>(v: &mut [T]) {\n    let len = v.len();\n    // trivial case -- no flips\n    if len < 2 {\n        return;\n    }\n    for i in (0..len).rev() {\n        // find index of the maximum element within `v[0..i]` (inclusive)\n        let max_index = v.iter()\n            .take(i + 1)\n            .enumerate()\n            .max_by_key(|&(_, elem)| elem)\n            .map(|(idx, _)| idx)\n            // safe because we already checked if `v` is empty\n            .unwrap();\n        // if `max_index` is not where it's supposed to be\n        // do two flips to move it to `i`\n        if max_index != i {\n            flip(v, max_index);\n            flip(v, i);\n        }\n    }\n}\n\n// function to flip a section of a mutable collection from 0..num (inclusive)\nfn flip<E: PartialOrd>(v: &mut [E], num: usize) {\n    v[0..num + 1].reverse();\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    pancake_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n    pancake_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}",
    "title": "Sorting algorithms/Pancake sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Patience sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Patience_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Permutation sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// We use an [in-place quick sort].\n///\n/// [in-place quick sort]: http://en.wikipedia.org/wiki/Quicksort#In-place_version\nfn quick_sort<T: Ord>(v: &mut [T]) {\n    let len = v.len();\n    if len < 2 {\n        return;\n    }\n\n    let pivot_index = partition(v);\n\n    // Sort the left side\n    quick_sort(&mut v[0..pivot_index]);\n\n    // Sort the right side\n    quick_sort(&mut v[pivot_index + 1..len]);\n}\n\n/// Reorders the slice with values lower than the pivot at the left side,\n/// and values bigger than it at the right side.\n/// Also returns the store index.\n#[allow(clippy::needless_range_loop)]\nfn partition<T: Ord>(v: &mut [T]) -> usize {\n    let len = v.len();\n    let pivot_index = len / 2;\n\n    v.swap(pivot_index, len - 1);\n\n    let mut store_index = 0;\n    for i in 0..(len - 1) {\n        if v[i] <= v[len - 1] {\n            v.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n\n    v.swap(store_index, len - 1);\n    store_index\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    quick_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::quick_sort);\n}\n",
    "path": "tasks/sorting-algorithms/quicksort",
    "remote_code": "fn main() {\n    println!(\"Sort numbers in descending order\");\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    quick_sort(&mut numbers, &|x,y| x > y);\n    println!(\"After:  {:?}\\n\", numbers);\n\n    println!(\"Sort strings alphabetically\");\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x < y);\n    println!(\"After:  {:?}\\n\", strings);\n    \n    println!(\"Sort strings by length\");\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x.len() < y.len());\n    println!(\"After:  {:?}\", strings);    \n}\n\nfn quick_sort<T,F>(v: &mut [T], f: &F) \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    if len >= 2 {\n        let pivot_index = partition(v, f);\n        quick_sort(&mut v[0..pivot_index], f);\n        quick_sort(&mut v[pivot_index + 1..len], f);\n    }\n}\n\nfn partition<T,F>(v: &mut [T], f: &F) -> usize \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    let pivot_index = len / 2;\n    let last_index = len - 1;\n\n    v.swap(pivot_index, last_index);\n\n    let mut store_index = 0;\n    for i in 0..last_index {\n        if f(&v[i], &v[last_index]) {\n            v.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n\n    v.swap(store_index, len - 1);\n    store_index\n}",
    "title": "Sorting algorithms/Quicksort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Quicksort"
  },
  {
    "local_code": "fn merge(in1: &[i32], in2: &[i32], out: &mut [i32]) {\n    let (left, right) = out.split_at_mut(in1.len());\n    left.clone_from_slice(in1);\n    right.clone_from_slice(in2);\n}\n\n// least significant digit radix sort\nfn radix_sort(data: &mut [i32]) {\n    for bit in 0..31 {\n        // types of small and big is Vec<i32>.\n        // It will be infered from the next call of merge function.\n        let (small, big): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| (x >> bit) & 1 == 0);\n        merge(&small, &big, data);\n    }\n    // last bit is sign\n    let (negative, positive): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| x < 0);\n    merge(&negative, &positive, data);\n}\n\nfn main() {\n    let mut data = [170, 45, 75, -90, -802, 24, 2, 66, -17, 2];\n    println!(\"Before: {:?}\", data);\n    radix_sort(&mut data);\n    println!(\"After: {:?}\", data);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n    use self::rand::{thread_rng, Rng};\n\n    use super::radix_sort;\n\n    fn check_numbers(numbers: &mut [i32]) {\n        let mut correct = numbers.to_vec();\n        correct.sort_unstable();\n        radix_sort(numbers);\n        assert_eq!(correct, numbers);\n    }\n\n    #[test]\n    fn test_rosetta_vector() {\n        check_numbers(&mut [170, 45, 75, -90, -802, 24, 2, 66, -17, 2]);\n    }\n\n    #[test]\n    fn test_empty_vector() {\n        check_numbers(&mut []);\n    }\n\n    #[test]\n    fn test_one_element_vector() {\n        check_numbers(&mut [0i32]);\n    }\n\n    #[test]\n    fn test_repeat_vector() {\n        check_numbers(&mut [1i32, 1, 1, 1, 1]);\n    }\n\n    #[test]\n    fn test_already_sorted_vector() {\n        check_numbers(&mut [-1i32, 0, 3, 6, 99]);\n    }\n\n    #[test]\n    fn test_random_numbers() {\n        let mut rng = thread_rng();\n        let mut numbers: Vec<i32> = (0..500).map(|_| rng.gen()).collect();\n        check_numbers(numbers.as_mut_slice());\n    }\n}\n",
    "path": "tasks/sorting-algorithms/radix-sort",
    "remote_code": "\nfn merge(in1: &[i32], in2: &[i32], out: &mut [i32]) {\n    let (left, right) = out.split_at_mut(in1.len());\n    left.clone_from_slice(in1);\n    right.clone_from_slice(in2);\n}\n\n// least significant digit radix sort\nfn radix_sort(data: &mut [i32]) {\n    for bit in 0..31 {\n        // types of small and big is Vec<i32>.\n        // It will be infered from the next call of merge function.\n        let (small, big): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| (x >> bit) & 1 == 0);\n        merge(&small, &big, data);\n    }\n    // last bit is sign\n    let (negative, positive): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| x < 0);\n    merge(&negative, &positive, data);\n}\n\nfn main() {\n    let mut data = [170, 45, 75, -90, -802, 24, 2, 66, -17, 2];\n    println!(\"Before: {:?}\", data);\n    radix_sort(&mut data);\n    println!(\"After: {:?}\", data);\n}\n",
    "title": "Sorting algorithms/Radix sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[allow(clippy::needless_range_loop)]\nfn selection_sort<T: Ord>(v: &mut [T]) {\n    if v.is_empty() {\n        return;\n    }\n\n    let len = v.len();\n\n    for j in 0..len - 1 {\n        let mut min_index = j;\n        for i in j + 1..len {\n            if v[i] <= v[min_index] {\n                min_index = i;\n            }\n        }\n        v.swap(j, min_index);\n    }\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4_i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    selection_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    selection_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::selection_sort);\n}\n",
    "path": "tasks/sorting-algorithms/selection-sort",
    "remote_code": "\nfn selection_sort(array: &mut [i32]) {\n\n    let mut min;\n\n    for i in 0..array.len() {\n\n        min = i;\n\n        for j in (i+1)..array.len() {\n\n            if array[j] < array[min] {\n                min = j;\n            }\n        }\n\n        let tmp = array[i];\n        array[i] = array[min];\n        array[min] = tmp;\n    }\n}\n\nfn main() {\n\n    let mut array = [ 9, 4, 8, 3, -5, 2, 1, 6 ];\n    println!(\"The initial array is {:?}\", array);\n\n    selection_sort(&mut array);\n    println!(\" The sorted array is {:?}\", array);\n}\n",
    "title": "Sorting algorithms/Selection sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[allow(clippy::needless_range_loop)]\nfn shell_sort<T: Ord + Copy>(v: &mut [T]) {\n    let mut gap = v.len() / 2;\n    let len = v.len();\n    while gap > 0 {\n        for i in gap..len {\n            let temp = v[i];\n            let mut j = i;\n            while j >= gap && v[j - gap] > temp {\n                v[j] = v[j - gap];\n                j -= gap;\n            }\n            v[j] = temp;\n        }\n        gap /= 2;\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    shell_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::shell_sort);\n}\n",
    "path": "tasks/sorting-algorithms/shell-sort",
    "remote_code": "\nfn shell_sort<T: Ord + Copy>(v: &mut [T]) {\n    let mut gap = v.len() / 2;\n    let len = v.len();\n    while gap > 0 {\n        for i in gap..len {\n            let temp = v[i];\n            let mut j = i;\n            while j >= gap && v[j - gap] > temp {\n                v[j] = v[j - gap];\n                j -= gap;\n            }\n            v[j] = temp;\n        }\n        gap /= 2;\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    shell_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n",
    "title": "Sorting algorithms/Shell sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort"
  },
  {
    "local_code": "use std::thread;\nuse std::time::Duration;\n\nfn sleepsort<I>(nums: I)\nwhere\n    I: Iterator<Item = u64>,\n{\n    let threads: Vec<_> = nums\n        .map(|n| {\n            thread::spawn(move || {\n                thread::sleep(Duration::from_millis(n));\n                println!(\"{}\", n);\n            })\n        })\n        .collect();\n\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n\nfn main() {\n    sleepsort(std::env::args().skip(1).map(|s| s.parse().unwrap()));\n}\n",
    "path": "tasks/sorting-algorithms/sleep-sort",
    "remote_code": "use std::thread;\n\nfn sleepsort<I: Iterator<Item=u32>>(nums: I) {\n    let threads: Vec<_> = nums.map(|n|\n        thread::spawn(move || {\n            thread::sleep_ms(n);\n            println!(\"{}\", n); })).collect();\n    for t in threads { t.join(); }\n}\n\nfn main() {\n    sleepsort(std::env::args().skip(1).map(|s| s.parse().unwrap()));\n}",
    "title": "Sorting algorithms/Sleep sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn stoogesort<E>(a: &mut [E])\nwhere\n    E: PartialOrd,\n{\n    if a.is_empty() {\n        return;\n    }\n\n    let len = a.len();\n\n    if a.first().unwrap() > a.last().unwrap() {\n        a.swap(0, len - 1);\n    }\n    if len - 1 > 1 {\n        let t = len / 3;\n        stoogesort(&mut a[..len - 1]);\n        stoogesort(&mut a[t..]);\n        stoogesort(&mut a[..len - 1]);\n    }\n}\n\nfn main() {\n    let mut numbers = vec![1_i32, 9, 4, 7, 6, 5, 3, 2, 8];\n    println!(\"Before: {:?}\", &numbers);\n    stoogesort(&mut numbers);\n    println!(\"After: {:?}\", &numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::stoogesort);\n}\n",
    "path": "tasks/sorting-algorithms/stooge-sort",
    "remote_code": "fn stoogesort<E>(a: &mut [E])\n    where E: PartialOrd\n{\n    let len = a.len();\n\n    if a.first().unwrap() > a.last().unwrap() {\n        a.swap(0, len - 1);\n    }\n    if len - 1 > 1 {\n        let t = len / 3;\n        stoogesort(&mut a[..len - 1]);\n        stoogesort(&mut a[t..]);\n        stoogesort(&mut a[..len - 1]);\n    }\n}\n\nfn main() {\n    let mut numbers = vec![1_i32, 9, 4, 7, 6, 5, 3, 2, 8];\n    println!(\"Before: {:?}\", &numbers);\n    stoogesort(&mut numbers);\n    println!(\"After: {:?}\", &numbers);\n}",
    "title": "Sorting algorithms/Stooge sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Strand sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Strand_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Soundex",
    "url": "http://rosettacode.org/wiki/Soundex"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::f64;\n\nuse regex::Regex;\n\nconst BARS: &str = \"▁▂▃▄▅▆▇█\";\n\nfn read_samples(input: &str) -> Vec<f64> {\n    let regex = Regex::new(r\"[\\s,]+\").unwrap();\n\n    input\n        .split(&regex)\n        .map(|value| value.parse().unwrap())\n        .collect()\n}\n\nfn sparkline(samples: &[f64]) -> String {\n    let min = samples.iter().cloned().fold(f64::NAN, f64::min);\n    let max = samples.iter().cloned().fold(f64::NAN, f64::max);\n\n    let diff = (max - min) / ((BARS.chars().count() - 1) as f64);\n\n    samples\n        .iter()\n        .map(|sample| (sample - min) / diff)\n        .map(|idx| BARS.chars().nth(idx as usize).unwrap())\n        .collect()\n}\n\nfn main() {\n    let samples = \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\";\n    println!(\"{}\", samples);\n    println!(\"{}\", sparkline(&read_samples(samples)));\n\n    let samples = \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\";\n    println!(\"{}\", samples);\n    println!(\"{}\", sparkline(&read_samples(samples)));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{read_samples, sparkline};\n\n    #[test]\n    fn simple() {\n        assert_eq!(\n            \"▁▂▃▄▅▆▇█▇▆▅▄▃▂▁\",\n            sparkline(&read_samples(\"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\"))\n        );\n    }\n\n    #[test]\n    fn complex() {\n        assert_eq!(\n            \"▂▁▄▃▆▅█▇\",\n            sparkline(&read_samples(\"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\"))\n        );\n    }\n}\n",
    "path": "tasks/sparkline-in-unicode",
    "remote_code": "\nconst BARS: &'static str = \"▁▂▃▄▅▆▇█\";\n\nfn print_sparkline(s: &str){\n    let v = BARS.chars().collect::<Vec<char>>();\n    let line: String = s.replace(\",\", \" \").split(\" \")\n                            .filter(|x| !x.is_empty())\n                            .map(|x| v[x.parse::<f64>().unwrap().ceil() as usize - 1])\n                            .collect();\n    println!(\"{:?}\", line);\n}\n\nfn main(){\n    let s1 = \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\";\n    print_sparkline(s1);\n    let s2 = \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\";\n    print_sparkline(s2);\n}\n",
    "title": "Sparkline in unicode",
    "url": "http://rosettacode.org/wiki/Sparkline_in_unicode"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Special characters",
    "url": "http://rosettacode.org/wiki/Special_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Special variables",
    "url": "http://rosettacode.org/wiki/Special_variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Speech synthesis",
    "url": "http://rosettacode.org/wiki/Speech_synthesis"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct NumberNames {\n    cardinal: &'static str,\n    ordinal: &'static str,\n}\n\nimpl NumberNames {\n    fn get_name(&self, ordinal: bool) -> &'static str {\n        if ordinal {\n            return self.ordinal;\n        }\n        self.cardinal\n    }\n}\n\nconst SMALL_NAMES: [NumberNames; 20] = [\n    NumberNames {\n        cardinal: \"zero\",\n        ordinal: \"zeroth\",\n    },\n    NumberNames {\n        cardinal: \"one\",\n        ordinal: \"first\",\n    },\n    NumberNames {\n        cardinal: \"two\",\n        ordinal: \"second\",\n    },\n    NumberNames {\n        cardinal: \"three\",\n        ordinal: \"third\",\n    },\n    NumberNames {\n        cardinal: \"four\",\n        ordinal: \"fourth\",\n    },\n    NumberNames {\n        cardinal: \"five\",\n        ordinal: \"fifth\",\n    },\n    NumberNames {\n        cardinal: \"six\",\n        ordinal: \"sixth\",\n    },\n    NumberNames {\n        cardinal: \"seven\",\n        ordinal: \"seventh\",\n    },\n    NumberNames {\n        cardinal: \"eight\",\n        ordinal: \"eighth\",\n    },\n    NumberNames {\n        cardinal: \"nine\",\n        ordinal: \"ninth\",\n    },\n    NumberNames {\n        cardinal: \"ten\",\n        ordinal: \"tenth\",\n    },\n    NumberNames {\n        cardinal: \"eleven\",\n        ordinal: \"eleventh\",\n    },\n    NumberNames {\n        cardinal: \"twelve\",\n        ordinal: \"twelfth\",\n    },\n    NumberNames {\n        cardinal: \"thirteen\",\n        ordinal: \"thirteenth\",\n    },\n    NumberNames {\n        cardinal: \"fourteen\",\n        ordinal: \"fourteenth\",\n    },\n    NumberNames {\n        cardinal: \"fifteen\",\n        ordinal: \"fifteenth\",\n    },\n    NumberNames {\n        cardinal: \"sixteen\",\n        ordinal: \"sixteenth\",\n    },\n    NumberNames {\n        cardinal: \"seventeen\",\n        ordinal: \"seventeenth\",\n    },\n    NumberNames {\n        cardinal: \"eighteen\",\n        ordinal: \"eighteenth\",\n    },\n    NumberNames {\n        cardinal: \"nineteen\",\n        ordinal: \"nineteenth\",\n    },\n];\n\nconst TENS: [NumberNames; 8] = [\n    NumberNames {\n        cardinal: \"twenty\",\n        ordinal: \"twentieth\",\n    },\n    NumberNames {\n        cardinal: \"thirty\",\n        ordinal: \"thirtieth\",\n    },\n    NumberNames {\n        cardinal: \"forty\",\n        ordinal: \"fortieth\",\n    },\n    NumberNames {\n        cardinal: \"fifty\",\n        ordinal: \"fiftieth\",\n    },\n    NumberNames {\n        cardinal: \"sixty\",\n        ordinal: \"sixtieth\",\n    },\n    NumberNames {\n        cardinal: \"seventy\",\n        ordinal: \"seventieth\",\n    },\n    NumberNames {\n        cardinal: \"eighty\",\n        ordinal: \"eightieth\",\n    },\n    NumberNames {\n        cardinal: \"ninety\",\n        ordinal: \"ninetieth\",\n    },\n];\n\nstruct NamedNumber {\n    cardinal: &'static str,\n    ordinal: &'static str,\n    number: usize,\n}\n\nimpl NamedNumber {\n    fn get_name(&self, ordinal: bool) -> &'static str {\n        if ordinal {\n            return self.ordinal;\n        }\n        self.cardinal\n    }\n}\n\nconst N: usize = 7;\nconst NAMED_NUMBERS: [NamedNumber; N] = [\n    NamedNumber {\n        cardinal: \"hundred\",\n        ordinal: \"hundredth\",\n        number: 100,\n    },\n    NamedNumber {\n        cardinal: \"thousand\",\n        ordinal: \"thousandth\",\n        number: 1000,\n    },\n    NamedNumber {\n        cardinal: \"million\",\n        ordinal: \"millionth\",\n        number: 1000000,\n    },\n    NamedNumber {\n        cardinal: \"billion\",\n        ordinal: \"billionth\",\n        number: 1000000000,\n    },\n    NamedNumber {\n        cardinal: \"trillion\",\n        ordinal: \"trillionth\",\n        number: 1000000000000,\n    },\n    NamedNumber {\n        cardinal: \"quadrillion\",\n        ordinal: \"quadrillionth\",\n        number: 1000000000000000,\n    },\n    NamedNumber {\n        cardinal: \"quintillion\",\n        ordinal: \"quintillionth\",\n        number: 1000000000000000000,\n    },\n];\n\nfn big_name(n: usize) -> &'static NamedNumber {\n    for i in 1..N {\n        if n < NAMED_NUMBERS[i].number {\n            return &NAMED_NUMBERS[i - 1];\n        }\n    }\n    &NAMED_NUMBERS[N - 1]\n}\n\nfn number_name(n: usize, ordinal: bool) -> String {\n    if n < 20 {\n        return String::from(SMALL_NAMES[n].get_name(ordinal));\n    } else if n < 100 {\n        if n % 10 == 0 {\n            return String::from(TENS[n / 10 - 2].get_name(ordinal));\n        }\n        let s1 = TENS[n / 10 - 2].get_name(false);\n        let s2 = SMALL_NAMES[n % 10].get_name(ordinal);\n        return format!(\"{}-{}\", s1, s2);\n    }\n    let big = big_name(n);\n    let mut result = number_name(n / big.number, false);\n    result.push(' ');\n    if n % big.number == 0 {\n        result.push_str(big.get_name(ordinal));\n    } else {\n        result.push_str(big.get_name(false));\n        result.push(' ');\n        result.push_str(&number_name(n % big.number, ordinal));\n    }\n    result\n}\n\nfn test_ordinal(n: usize) {\n    println!(\"{}: {}\", n, number_name(n, true));\n}\n\nfn main() {\n    test_ordinal(1);\n    test_ordinal(2);\n    test_ordinal(3);\n    test_ordinal(4);\n    test_ordinal(5);\n    test_ordinal(11);\n    test_ordinal(15);\n    test_ordinal(21);\n    test_ordinal(42);\n    test_ordinal(65);\n    test_ordinal(98);\n    test_ordinal(100);\n    test_ordinal(101);\n    test_ordinal(272);\n    test_ordinal(300);\n    test_ordinal(750);\n    test_ordinal(23456);\n    test_ordinal(7891233);\n    test_ordinal(8007006005004003);\n}",
    "title": "Spelling of ordinal numbers",
    "url": "http://rosettacode.org/wiki/Spelling_of_ordinal_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let characters = ['|', '/', '-', '\\\\'];\n    let mut current = 0;\n\n    println!(\"{}[2J\", 27 as char); // Clear screen.\n\n    loop {\n        println!(\"{}[;H{}\", 27 as char, characters[current]); // Move cursor to 1,1 and output the next character.\n        current += 1; // Advance current character.\n        if current == 4 {current = 0;} // If we reached the end of the array, start from the beginning.\n        std::thread::sleep(std::time::Duration::from_millis(250)); // Sleep 250 ms.\n    }\n}",
    "title": "Spinning rod animation/Text",
    "url": "http://rosettacode.org/wiki/Spinning_rod_animation/Text"
  },
  {
    "local_code": "const VECTORS: [(isize, isize); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];\n\npub fn spiral_matrix(size: usize) -> Vec<Vec<u32>> {\n    let mut matrix = vec![vec![0; size]; size];\n    let mut movement = VECTORS.iter().cycle();\n    let (mut x, mut y, mut n) = (-1, 0, 0..);\n\n    for (move_x, move_y) in std::iter::once(size)\n        .chain((1..size).rev().flat_map(|n| std::iter::repeat(n).take(2)))\n        .flat_map(|steps| std::iter::repeat(movement.next().unwrap()).take(steps))\n    {\n        x += move_x;\n        y += move_y;\n        matrix[y as usize][x as usize] = n.next().unwrap();\n    }\n\n    matrix\n}\n\nfn main() {\n    for i in spiral_matrix(5).iter() {\n        for j in i.iter() {\n            print!(\"{:>2} \", j);\n        }\n        println!();\n    }\n}\n\n#[test]\nfn empty_spiral() {\n    let expected: Vec<Vec<u32>> = Vec::new();\n    assert_eq!(spiral_matrix(0), expected);\n}\n\n#[test]\nfn size_one_spiral() {\n    let expected: Vec<Vec<u32>> = vec![vec![0]];\n    assert_eq!(spiral_matrix(1), expected);\n}\n#[test]\nfn size_two_spiral() {\n    let expected: Vec<Vec<u32>> = vec![vec![0, 1], vec![3, 2]];\n    assert_eq!(spiral_matrix(2), expected);\n}\n\n#[test]\nfn size_three_spiral() {\n    let expected: Vec<Vec<u32>> = vec![vec![0, 1, 2], vec![7, 8, 3], vec![6, 5, 4]];\n    assert_eq!(spiral_matrix(3), expected);\n}\n#[test]\nfn size_four_spiral() {\n    let expected: Vec<Vec<u32>> = vec![\n        vec![0, 1, 2, 3],\n        vec![11, 12, 13, 4],\n        vec![10, 15, 14, 5],\n        vec![9, 8, 7, 6],\n    ];\n    assert_eq!(spiral_matrix(4), expected);\n}\n#[test]\nfn size_five_spiral() {\n    let expected: Vec<Vec<u32>> = vec![\n        vec![0, 1, 2, 3, 4],\n        vec![15, 16, 17, 18, 5],\n        vec![14, 23, 24, 19, 6],\n        vec![13, 22, 21, 20, 7],\n        vec![12, 11, 10, 9, 8],\n    ];\n    assert_eq!(spiral_matrix(5), expected);\n}\n",
    "path": "tasks/spiral-matrix",
    "remote_code": "const VECTORS: [(isize, isize); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];\n\npub fn spiral_matrix(size: usize) -> Vec<Vec<u32>> {\n    let mut matrix = vec![vec![0; size]; size];\n    let mut movement = VECTORS.iter().cycle();\n    let (mut x, mut y, mut n) = (-1, 0, 1..);\n\n    for (move_x, move_y) in std::iter::once(size)\n        .chain((1..size).rev().flat_map(|n| std::iter::repeat(n).take(2)))\n        .flat_map(|steps| std::iter::repeat(movement.next().unwrap()).take(steps))\n    {\n        x += move_x;\n        y += move_y;\n        matrix[y as usize][x as usize] = n.next().unwrap();\n    }\n\n    matrix\n}\n\nfn main() {\n    for i in spiral_matrix(4).iter() {\n        for j in i.iter() {\n            print!(\"{:>2} \", j);\n        }\n        println!();\n    }\n}",
    "title": "Spiral matrix",
    "url": "http://rosettacode.org/wiki/Spiral_matrix"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn splitter(string: &str) -> String {\n    let chars: Vec<_> = string.chars().collect();\n    let mut result = Vec::new();\n    let mut last_mismatch = 0;\n    for i in 0..chars.len() {\n        if chars.len() == 1 {\n            return chars[0..1].iter().collect();\n        }\n        if i > 0 && chars[i-1] != chars[i] {\n            let temp_result: String = chars[last_mismatch..i].iter().collect();\n            result.push(temp_result);\n            last_mismatch = i;\n        }\n        if i == chars.len() - 1 {\n            let temp_result: String = chars[last_mismatch..chars.len()].iter().collect();\n            result.push(temp_result);\n        }\n    }\n    result.join(\", \")\n}\n\nfn main() {\n    let test_string = \"g\";\n    println!(\"input string: {}\", test_string);\n    println!(\"output string: {}\", splitter(test_string));\n\n    let test_string = \"\";\n    println!(\"input string: {}\", test_string);\n    println!(\"output string: {}\", splitter(test_string));\n\n    let test_string = \"gHHH5YY++///\\\\\";\n    println!(\"input string: {}\", test_string);\n    println!(\"output string: {}\", splitter(test_string));\n}",
    "title": "Split a character string based on change of character",
    "url": "http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut s = 1;\n    let mut c = 1;\n    let mut cube = 1;\n    let mut n = 0;\n    while n < 30 {\n        let square = s * s;\n        while cube < square {\n            c += 1;\n            cube = c * c * c;\n        }\n        if cube == square {\n            println!(\"{} is a square and a cube.\", square);\n        } else {\n            println!(\"{}\", square);\n            n += 1;\n        }\n        s += 1;\n    }\n}",
    "title": "Square but not cube",
    "url": "http://rosettacode.org/wiki/Square_but_not_cube"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Square form factorization",
    "url": "http://rosettacode.org/wiki/Square_form_factorization"
  },
  {
    "local_code": "fn sieve(limit: usize) -> Vec<usize> {\n    let mut c = vec![false; limit + 1];\n    let mut p = 3;\n    loop {\n        let p2 = p * p;\n        if p2 > limit {\n            break;\n        }\n        (p2..=limit).step_by(2 * p).for_each(|i| c[i] = true);\n        loop {\n            p += 2;\n            if !c[p] {\n                break;\n            }\n        }\n    }\n    let mut two: Vec<usize> = vec![2];\n    two.drain(0..1)\n        .chain(\n            c.iter()\n                .enumerate()\n                .skip(3)\n                .step_by(2)\n                .filter_map(|(i, composite)| if *composite { None } else { Some(i) }),\n        )\n        .collect()\n}\n\nfn square_free(from: u64, to: u64) -> Vec<u64> {\n    let limit = ((to as f64).sqrt()) as usize;\n    let primes = sieve(limit);\n    (from..=to)\n        .filter(|i| {\n            primes\n                .iter()\n                .map(|p| *p as u64)\n                .map(|p| p.pow(2))\n                .take_while(|p2| *p2 <= *i)\n                .all(|p2| *i % p2 != 0)\n        })\n        .collect()\n}\n\nconst TRILLION: u64 = 1000000000000;\nfn main() {\n    println!(\"Square-free integers from 1 to 145:\");\n    let sf = square_free(1, 145);\n    sf.iter().enumerate().for_each(|(i, n)| {\n        if i > 0 && i % 20 == 0 {\n            println!();\n        }\n        print!(\"{:4}\", n);\n    });\n\n    println!(\n        \"\\n\\nSquare-free integers from {} to {}\",\n        TRILLION,\n        TRILLION + 145\n    );\n    let sf = square_free(TRILLION, TRILLION + 145);\n    sf.iter().enumerate().for_each(|(i, n)| {\n        if i > 0 && i % 5 == 0 {\n            println!();\n        }\n        print!(\"{:14}\", n);\n    });\n\n    println!(\"\\n\\nNumber of square-free integers:\");\n    (2..7).map(|i| (10_u64).pow(i)).for_each(|n| {\n        println!(\"  from 1 to {} = {}\", n, square_free(1, n).len());\n    });\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        square_free(1, 145),\n        vec![\n            1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35,\n            37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71,\n            73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97, 101, 102, 103, 105,\n            106, 107, 109, 110, 111, 113, 114, 115, 118, 119, 122, 123, 127, 129, 130, 131, 133,\n            134, 137, 138, 139, 141, 142, 143, 145\n        ]\n    );\n\n    assert_eq!(\n        square_free(TRILLION, TRILLION + 145),\n        vec![\n            1000000000001,\n            1000000000002,\n            1000000000003,\n            1000000000005,\n            1000000000006,\n            1000000000007,\n            1000000000009,\n            1000000000011,\n            1000000000013,\n            1000000000014,\n            1000000000015,\n            1000000000018,\n            1000000000019,\n            1000000000021,\n            1000000000022,\n            1000000000023,\n            1000000000027,\n            1000000000029,\n            1000000000030,\n            1000000000031,\n            1000000000033,\n            1000000000037,\n            1000000000038,\n            1000000000039,\n            1000000000041,\n            1000000000042,\n            1000000000043,\n            1000000000045,\n            1000000000046,\n            1000000000047,\n            1000000000049,\n            1000000000051,\n            1000000000054,\n            1000000000055,\n            1000000000057,\n            1000000000058,\n            1000000000059,\n            1000000000061,\n            1000000000063,\n            1000000000065,\n            1000000000066,\n            1000000000067,\n            1000000000069,\n            1000000000070,\n            1000000000073,\n            1000000000074,\n            1000000000077,\n            1000000000078,\n            1000000000079,\n            1000000000081,\n            1000000000082,\n            1000000000085,\n            1000000000086,\n            1000000000087,\n            1000000000090,\n            1000000000091,\n            1000000000093,\n            1000000000094,\n            1000000000095,\n            1000000000097,\n            1000000000099,\n            1000000000101,\n            1000000000102,\n            1000000000103,\n            1000000000105,\n            1000000000106,\n            1000000000109,\n            1000000000111,\n            1000000000113,\n            1000000000114,\n            1000000000115,\n            1000000000117,\n            1000000000118,\n            1000000000119,\n            1000000000121,\n            1000000000122,\n            1000000000123,\n            1000000000126,\n            1000000000127,\n            1000000000129,\n            1000000000130,\n            1000000000133,\n            1000000000135,\n            1000000000137,\n            1000000000138,\n            1000000000139,\n            1000000000141,\n            1000000000142,\n            1000000000145\n        ]\n    );\n}\n",
    "path": "tasks/square-free-integers",
    "remote_code": "fn square_free(mut n: usize) -> bool {\n    if n & 3 == 0 {\n        return false;\n    }\n    let mut p: usize = 3;\n    while p * p <= n {\n        let mut count = 0;\n        while n % p == 0 {\n            count += 1;\n            if count > 1 {\n                return false;\n            }\n            n /= p;\n        }\n        p += 2;\n    }\n    true\n}\n\nfn print_square_free_numbers(from: usize, to: usize) {\n    println!(\"Square-free numbers between {} and {}:\", from, to);\n    let mut line = String::new();\n    for i in from..=to {\n        if square_free(i) {\n            if !line.is_empty() {\n                line.push_str(\" \");\n            }\n            line.push_str(&i.to_string());\n            if line.len() >= 80 {\n                println!(\"{}\", line);\n                line.clear();\n            }\n        }\n    }\n    if !line.is_empty() {\n        println!(\"{}\", line);\n    }\n}\n\nfn print_square_free_count(from: usize, to: usize) {\n    let mut count = 0;\n    for i in from..=to {\n        if square_free(i) {\n            count += 1;\n        }\n    }\n    println!(\n        \"Number of square-free numbers between {} and {}: {}\",\n        from, to, count\n    )\n}\n\nfn main() {\n    print_square_free_numbers(1, 145);\n    print_square_free_numbers(1000000000000, 1000000000145);\n    let mut n: usize = 100;\n    while n <= 1000000 {\n        print_square_free_count(1, n);\n        n *= 10;\n    }\n}",
    "title": "Square-free integers",
    "url": "http://rosettacode.org/wiki/Square-free_integers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stable marriage problem",
    "url": "http://rosettacode.org/wiki/Stable_marriage_problem"
  },
  {
    "local_code": "#[derive(Debug)]\nstruct Stack<T> {\n    /// We use a vector because of simplicity\n    vec: Vec<T>,\n}\n\nimpl<T> Stack<T> {\n    fn new() -> Stack<T> {\n        Stack { vec: Vec::new() }\n    }\n\n    /// Adds an element at the top of the stack\n    fn push(&mut self, elem: T) {\n        self.vec.push(elem);\n    }\n\n    /// Removes and returns the element at the top of the stack\n    fn pop(&mut self) -> Option<T> {\n        self.vec.pop()\n    }\n\n    /// Returns a reference of the element at the top of the stack\n    fn peek(&self) -> Option<&T> {\n        self.vec.last()\n    }\n\n    /// Returns true if the stack is empty\n    fn empty(&self) -> bool {\n        self.vec.is_empty()\n    }\n}\n\nfn main() {\n    let mut stack = Stack::new();\n\n    // Fill the stack\n    stack.push(5i32);\n    stack.push(8);\n    stack.push(9);\n\n    // Show the element at the top\n    println!(\"{}\", stack.peek().unwrap());\n    // Show the element we popped\n    println!(\"{}\", stack.pop().unwrap());\n    if stack.empty() {\n        println!(\"The stack is empty.\")\n    } else {\n        println!(\"The stack is not empty.\")\n    }\n}\n\n#[test]\nfn test_basic() {\n    let mut stack = Stack::new();\n\n    // The stack is empty\n    assert!(stack.empty());\n\n    // Fill the stack\n    stack.push(5i32);\n    stack.push(8);\n    stack.push(9);\n\n    // The stack is not empty\n    assert!(!stack.empty());\n\n    // The element at the top is 9\n    assert!(stack.peek().unwrap() == &9);\n\n    // Remove one element\n    stack.pop();\n\n    // The element at the top is now 8\n    assert!(stack.peek().unwrap() == &8);\n}\n",
    "path": "tasks/stack",
    "remote_code": "fn main() {\n    let mut stack = Vec::new();\n    stack.push(\"Element1\");\n    stack.push(\"Element2\");\n    stack.push(\"Element3\");\n\n    assert_eq!(Some(&\"Element3\"), stack.last());\n    assert_eq!(Some(\"Element3\"), stack.pop());\n    assert_eq!(Some(\"Element2\"), stack.pop());\n    assert_eq!(Some(\"Element1\"), stack.pop());\n    assert_eq!(None, stack.pop());\n}",
    "title": "Stack",
    "url": "http://rosettacode.org/wiki/Stack"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stack traces",
    "url": "http://rosettacode.org/wiki/Stack_traces"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn step_up() {\n\twhile !step() {\n\t\tstep_up();\n\t}\n}",
    "title": "Stair-climbing puzzle",
    "url": "http://rosettacode.org/wiki/Stair-climbing_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Start from a main routine",
    "url": "http://rosettacode.org/wiki/Start_from_a_main_routine"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "State name puzzle",
    "url": "http://rosettacode.org/wiki/State_name_puzzle"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::Standard;\nuse rand::prelude::*;\n\npub fn mean(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let sum: f32 = data.iter().sum();\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn variance(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let mean = mean(data).unwrap();\n        let mut sum = 0f32;\n        for &x in data {\n            sum += (x - mean).powi(2);\n        }\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn standard_deviation(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let variance = variance(data).unwrap();\n        Some(variance.sqrt())\n    }\n}\n\nfn print_histogram(width: u32, data: &[f32]) {\n    let mut histogram = [0; 10];\n    let len = histogram.len() as f32;\n    for &x in data {\n        histogram[(x * len) as usize] += 1;\n    }\n    let max_frequency = *histogram.iter().max().unwrap() as f32;\n    for (i, &frequency) in histogram.iter().enumerate() {\n        let bar_width = frequency as f32 * width as f32 / max_frequency;\n        print!(\"{:3.1}: \", i as f32 / len);\n        for _ in 0..bar_width as usize {\n            print!(\"*\");\n        }\n        println!();\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    for &number_of_samples in &[1000, 10_000, 1_000_000] {\n        let data = Standard\n            .sample_iter(&mut rng)\n            .take(number_of_samples)\n            .collect::<Vec<f32>>();\n        println!(\"  Statistics for sample size {}\", number_of_samples);\n        println!(\"Mean:               {:?}\", mean(&data));\n        println!(\"Variance:           {:?}\", variance(&data));\n        println!(\"Standard deviation: {:?}\", standard_deviation(&data));\n        print_histogram(40, &data);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{mean, standard_deviation, variance};\n    use std::f32;\n\n    fn approx(statistics: Option<f32>, value: f32) -> bool {\n        (statistics.unwrap() - value).abs() <= f32::EPSILON\n    }\n\n    #[test]\n    fn test_mean() {\n        let empty = vec![];\n        assert_eq!(mean(&empty), None);\n        assert!(approx(mean(&[1.0]), 1.0));\n        assert!(approx(mean(&[1.0, 3.0]), 2.0));\n        assert!(approx(mean(&[1.0, 2.0, 3.0]), 2.0));\n    }\n\n    #[test]\n    fn test_variance() {\n        let empty = vec![];\n        assert_eq!(variance(&empty), None);\n        assert!(approx(variance(&[0.0]), 0.0));\n        assert!(approx(variance(&[1.0, 1.0, 1.0]), 0.0));\n        assert!(approx(variance(&[1.0, 2.0, 3.0]), 2.0 / 3.0));\n    }\n\n    #[test]\n    fn test_standard_deviation() {\n        let empty = vec![];\n        assert_eq!(standard_deviation(&empty), None);\n        assert!(approx(standard_deviation(&[0.0]), 0.0));\n        assert!(approx(standard_deviation(&[1.0, 1.0, 1.0]), 0.0));\n        assert!(approx(\n            standard_deviation(&[1.0, 2.0, 3.0]),\n            (2f32 / 3f32).sqrt()\n        ));\n    }\n}\n",
    "path": "tasks/statistics/basic",
    "remote_code": "#![feature(iter_arith)]\nextern crate rand;\n\nuse rand::distributions::{IndependentSample, Range};\n\npub fn mean(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let sum: f32 = data.iter().sum();\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn variance(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let mean = mean(data).unwrap();\n        let mut sum = 0f32;\n        for &x in data {\n            sum += (x - mean).powi(2);\n        }\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn standard_deviation(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let variance = variance(data).unwrap();\n        Some(variance.sqrt())\n    }\n}\n\nfn print_histogram(width: u32, data: &[f32]) {\n    let mut histogram = [0; 10];\n    let len = histogram.len() as f32;\n    for &x in data {\n        histogram[(x * len) as usize] += 1;\n    }\n    let max_frequency = *histogram.iter().max().unwrap() as f32;\n    for (i, &frequency) in histogram.iter().enumerate() {\n        let bar_width = frequency as f32 * width as f32 / max_frequency;\n        print!(\"{:3.1}: \", i as f32 / len);\n        for _ in 0..bar_width as usize {\n            print!(\"*\");\n        }\n        println!(\"\");\n    }\n}\n\nfn main() {\n    let range = Range::new(0f32, 1f32);\n    let mut rng = rand::thread_rng();\n\n    for &number_of_samples in [1000, 10_000, 1_000_000].iter() {\n        let mut data = vec![];\n        for _ in 0..number_of_samples {\n            let x = range.ind_sample(&mut rng);\n            data.push(x);\n        }\n        println!(\"  Statistics for sample size {}\", number_of_samples);\n        println!(\"Mean:               {:?}\", mean(&data));\n        println!(\"Variance:           {:?}\", variance(&data));\n        println!(\"Standard deviation: {:?}\", standard_deviation(&data));\n        print_histogram(40, &data);\n    }\n}",
    "title": "Statistics/Basic",
    "url": "http://rosettacode.org/wiki/Statistics/Basic"
  },
  {
    "local_code": "//! Rust rosetta example for normal distribution\nuse math::{histogram::Histogram, traits::ToIterator};\n\nuse rand_distr::{Distribution, Normal};\n\n/// Returns the mean of the provided samples\n///\n/// ## Arguments\n/// * data -- reference to float32 array\nfn mean(data: &[f32]) -> Option<f32> {\n    let sum: f32 = data.iter().sum();\n    Some(sum / data.len() as f32)\n}\n\n/// Returns standard deviation of the provided samples\n///\n/// ## Arguments\n/// * data -- reference to float32 array\nfn standard_deviation(data: &[f32]) -> Option<f32> {\n    let mean = mean(data).expect(\"invalid mean\");\n    let sum = data.iter().fold(0.0, |acc, &x| acc + (x - mean).powi(2));\n    Some((sum / data.len() as f32).sqrt())\n}\n\n/// Prints a histogram in the shell\n///\n/// ## Arguments\n/// * data -- reference to float32 array\n/// * maxwidth -- the maxwidth of the histogram in # of characters\n/// * bincount -- number of bins in the histogram\n/// * ch -- character used to plot the graph\nfn print_histogram(data: &[f32], maxwidth: usize, bincount: usize, ch: char) {\n    let min_val = data.iter().cloned().fold(f32::NAN, f32::min);\n    let max_val = data.iter().cloned().fold(f32::NAN, f32::max);\n    let histogram = Histogram::new(Some(&data.to_vec()), bincount, min_val, max_val).unwrap();\n    let max_bin_value = histogram.get_counters().iter().max().unwrap();\n    println!();\n    for x in histogram.to_iter() {\n        let (bin_min, bin_max, freq) = x;\n        let bar_width = (((freq as f64) / (*max_bin_value as f64)) * (maxwidth as f64)) as u32;\n        let bar_as_string = (1..bar_width).fold(String::new(), |b, _| b + &ch.to_string());\n        println!(\n            \"({:>6},{:>6}) |{} {:.2}%\",\n            format!(\"{:.2}\", bin_min),\n            format!(\"{:.2}\", bin_max),\n            bar_as_string,\n            (freq as f64) * 100.0 / (data.len() as f64)\n        );\n    }\n    println!();\n}\n\n/// Runs the demo to generate normal distribution of three different sample sizes\nfn main() {\n    let expected_mean: f32 = 0.0;\n    let expected_std_deviation: f32 = 4.0;\n    let normal = Normal::new(expected_mean, expected_std_deviation).unwrap();\n\n    let mut rng = rand::thread_rng();\n    for &number_of_samples in &[1000, 10_000, 1_000_000] {\n        let data: Vec<f32> = normal\n            .sample_iter(&mut rng)\n            .take(number_of_samples)\n            .collect();\n        println!(\"Statistics for sample size {}:\", number_of_samples);\n        println!(\"\\tMean: {:?}\", mean(&data).expect(\"invalid mean\"));\n        println!(\n            \"\\tStandard deviation: {:?}\",\n            standard_deviation(&data).expect(\"invalid standard deviation\")\n        );\n        print_histogram(&data, 80, 40, '-');\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{mean, print_histogram, standard_deviation};\n    use std::f32;\n\n    fn approx(statistics: Option<f32>, value: f32) -> bool {\n        (statistics.unwrap() - value).abs() <= f32::EPSILON\n    }\n\n    #[test]\n    fn test_mean() {\n        assert!(approx(mean(&[1.0]), 1.0));\n        assert!(approx(mean(&[1.0, 3.0]), 2.0));\n        assert!(approx(mean(&[1.0, 2.0, 3.0]), 2.0));\n    }\n\n    #[test]\n    fn test_standard_deviation() {\n        assert!(approx(standard_deviation(&[0.0]), 0.0));\n        assert!(approx(standard_deviation(&[1.0, 1.0, 1.0]), 0.0));\n        assert!(approx(\n            standard_deviation(&[1.0, 2.0, 3.0]),\n            (2f32 / 3f32).sqrt()\n        ));\n    }\n\n    #[test]\n    fn test_print_histogram() {\n        print_histogram(&[0.0, 1.0, 2.0, 3.0], 10, 5, '-');\n    }\n}\n",
    "path": "tasks/statistics/normal-distribution",
    "remote_code": "//! Rust rosetta example for normal distribution\nuse math::{histogram::Histogram, traits::ToIterator};\nuse rand;\nuse rand_distr::{Distribution, Normal};\n\n/// Returns the mean of the provided samples\n///\n/// ## Arguments\n/// * data -- reference to float32 array\nfn mean(data: &[f32]) -> Option<f32> {\n    let sum: f32 = data.iter().sum();\n    Some(sum / data.len() as f32)\n}\n\n/// Returns standard deviation of the provided samples\n///\n/// ## Arguments\n/// * data -- reference to float32 array\nfn standard_deviation(data: &[f32]) -> Option<f32> {\n    let mean = mean(data).expect(\"invalid mean\");\n    let sum = data.iter().fold(0.0, |acc, &x| acc + (x - mean).powi(2));\n    Some((sum / data.len() as f32).sqrt())\n}\n\n/// Prints a histogram in the shell\n///\n/// ## Arguments\n/// * data -- reference to float32 array\n/// * maxwidth -- the maxwidth of the histogram in # of characters\n/// * bincount -- number of bins in the histogram\n/// * ch -- character used to plot the graph\nfn print_histogram(data: &[f32], maxwidth: usize, bincount: usize, ch: char) {\n    let min_val = data.iter().cloned().fold(f32::NAN, f32::min);\n    let max_val = data.iter().cloned().fold(f32::NAN, f32::max);\n    let histogram = Histogram::new(Some(&data.to_vec()), bincount, min_val, max_val).unwrap();\n    let max_bin_value = histogram.get_counters().iter().max().unwrap();\n    println!();\n    for x in histogram.to_iter() {\n        let (bin_min, bin_max, freq) = x;\n        let bar_width = (((freq as f64) / (*max_bin_value as f64)) * (maxwidth as f64)) as u32;\n        let bar_as_string = (1..bar_width).fold(String::new(), |b, _| b + &ch.to_string());\n        println!(\n            \"({:>6},{:>6}) |{} {:.2}%\",\n            format!(\"{:.2}\", bin_min),\n            format!(\"{:.2}\", bin_max),\n            bar_as_string,\n            (freq as f64) * 100.0 / (data.len() as f64)\n        );\n    }\n    println!();\n}\n\n/// Runs the demo to generate normal distribution of three different sample sizes\nfn main() {\n    let expected_mean: f32 = 0.0;\n    let expected_std_deviation: f32 = 4.0;\n    let normal = Normal::new(expected_mean, expected_std_deviation).unwrap();\n\n    let mut rng = rand::thread_rng();\n    for &number_of_samples in &[1000, 10_000, 1_000_000] {\n        let data: Vec<f32> = normal\n            .sample_iter(&mut rng)\n            .take(number_of_samples)\n            .collect();\n        println!(\"Statistics for sample size {}:\", number_of_samples);\n        println!(\"\\tMean: {:?}\", mean(&data).expect(\"invalid mean\"));\n        println!(\n            \"\\tStandard deviation: {:?}\",\n            standard_deviation(&data).expect(\"invalid standard deviation\")\n        );\n        print_histogram(&data, 80, 40, '-');\n    }\n}",
    "title": "Statistics/Normal distribution",
    "url": "http://rosettacode.org/wiki/Statistics/Normal_distribution"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stem-and-leaf plot",
    "url": "http://rosettacode.org/wiki/Stem-and-leaf_plot"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stern-Brocot sequence",
    "url": "http://rosettacode.org/wiki/Stern-Brocot_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stirling numbers of the first kind",
    "url": "http://rosettacode.org/wiki/Stirling_numbers_of_the_first_kind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stirling numbers of the second kind",
    "url": "http://rosettacode.org/wiki/Stirling_numbers_of_the_second_kind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Straddling checkerboard",
    "url": "http://rosettacode.org/wiki/Straddling_checkerboard"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strassen's algorithm",
    "url": "http://rosettacode.org/wiki/Strassen's_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stream merge",
    "url": "http://rosettacode.org/wiki/Stream_merge"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::ops::Add;\n\nfn main(){\n    let hello = String::from(\"Hello world\");\n    println!(\"{}\", hello.add(\"!!!!\"));\n}",
    "title": "String append",
    "url": "http://rosettacode.org/wiki/String_append"
  },
  {
    "local_code": "fn main() {\n    println!(\"{}\", \"jalapeño\".to_uppercase()); // JALAPEÑO\n    println!(\"{}\", \"JALAPEÑO\".to_lowercase()); // jalapeño\n}\n",
    "path": "tasks/string-case",
    "remote_code": "fn main() {\n    println!(\"{}\", \"jalapeño\".to_uppercase()); // JALAPEÑO\n    println!(\"{}\", \"JALAPEÑO\".to_lowercase()); // jalapeño\n}",
    "title": "String case",
    "url": "http://rosettacode.org/wiki/String_case"
  },
  {
    "local_code": "fn main() {\n    // only same types can be compared\n    // String and String or &str and &str\n    // exception: strict equality and inequality also work on &str and String\n    let a: &str = \"abc\";\n    let b: String = \"Bac\".to_owned();\n\n    // Strings are coerced to &str when borrowed and needed\n    if a == b {\n        println!(\"The strings are equal\")\n    }\n    if a != b {\n        println!(\"The strings are not equal\")\n    }\n    if a > &b {\n        println!(\"The first string is lexically after the second\")\n    }\n    if a < &b {\n        println!(\"The first string is lexically before the second\")\n    }\n    if a >= &b {\n        println!(\"The first string is not lexically before the second\")\n    }\n    if a <= &b {\n        println!(\"The first string is not lexically after the second\")\n    }\n\n    // case-insensitives:\n    // everything else, create owned Strings, then compare as above\n    let a2 = a.to_ascii_uppercase();\n    let b2 = b.to_ascii_uppercase();\n\n    // equality\n    // this avoids new allocations\n    if a.eq_ignore_ascii_case(&b) {\n        println!(\"Both strings are equal when ignoring case\")\n    }\n\n    if a2 == b2 {\n        println!(\"The strings are equal\")\n    }\n    if a2 != b2 {\n        println!(\"The strings are not equal\")\n    }\n    if a2 > b2 {\n        println!(\"The first string is lexically after the second\")\n    }\n    if a2 < b2 {\n        println!(\"The first string is lexically before the second\")\n    }\n    if a2 >= b2 {\n        println!(\"The first string is not lexically before the second\")\n    }\n    if a2 <= b2 {\n        println!(\"The first string is not lexically after the second\")\n    }\n}\n",
    "path": "tasks/string-comparison",
    "remote_code": "use std::ascii::AsciiExt; // for case insensitives only\n\nfn main() {\n    // only same types can be compared\n    // String and String or &str and &str\n    // exception: strict equality and inequality also work on &str and String\n    let a: &str = \"abc\";\n    let b: String = \"Bac\".to_owned();\n\n    // Strings are coerced to &str when borrowed and needed\n    if a == b { println!(\"The strings are equal\") }\n    if a != b { println!(\"The strings are not equal\") }\n    if a  > &b { println!(\"The first string is lexically after the second\") }\n    if a  < &b { println!(\"The first string is lexically before the second\") }\n    if a >= &b { println!(\"The first string is not lexically before the second\") }\n    if a <= &b { println!(\"The first string is not lexically after the second\") }\n\n    // case-insensitives:\n\n    // equality\n    // this avoids new allocations\n    if a.eq_ignore_ascii_case(&b) { println!(\"Both strings are equal when ignoring case\") }\n\n    // everything else, create owned Strings, then compare as above\n    let a2 = a.to_ascii_uppercase();\n    let b2 = b.to_ascii_uppercase();\n\n    // repeat checks\n}",
    "title": "String comparison",
    "url": "http://rosettacode.org/wiki/String_comparison"
  },
  {
    "local_code": "fn add_world(mut x: String) -> String {\n    // world is a &'a[u8]\n    let world = \" world\";\n    x.push_str(world);\n    x\n}\n\nfn main() {\n    // The call to_string() turns a &[u8] into a Vec<u8>.\n    // This is done because Vecs are growable but slices aren't.\n    let hello = \"hello\".to_string();\n    let hello_world = add_world(hello);\n    println!(\"{}\", hello_world);\n}\n\n#[test]\nfn test_string_concat() {\n    let super_hoverbear = \"super hoverbear\".to_string();\n    let super_hoverbear_world = add_world(super_hoverbear);\n    assert_eq!(super_hoverbear_world, \"super hoverbear world\".to_string());\n}\n",
    "path": "tasks/string-concatenation",
    "remote_code": "fn main() {\n    let s = \"hello\".to_owned();\n    println!(\"{}\", s);\n    \n    let s1 = s + \" world\";\n    println!(\"{}\", s1);\n}",
    "title": "String concatenation",
    "url": "http://rosettacode.org/wiki/String_concatenation"
  },
  {
    "local_code": "//! Rust has very powerful string interpolation. [Documentation here][doc]\n//!\n//! [doc]: https://doc.rust-lang.org/stable/std/fmt/\n\n#![allow(clippy::print_literal)]\n\nfn main() {\n    println!(\"Mary had a {} lamb\", \"little\");\n    // You can specify order\n    println!(\"{1} had a {0} lamb\", \"little\", \"Mary\");\n    // Or named arguments if you prefer\n    println!(\"{name} had a {adj} lamb\", adj = \"little\", name = \"Mary\");\n}\n",
    "path": "tasks/string-interpolation-included",
    "remote_code": "fn main() {\n    println!(\"Mary had a {} lamb\", \"little\");\n    // You can specify order\n    println!(\"{1} had a {0} lamb\", \"little\", \"Mary\");\n    // Or named arguments if you prefer\n    println!(\"{name} had a {adj} lamb\", adj=\"little\", name=\"Mary\");\n}",
    "title": "String interpolation (included)",
    "url": "http://rosettacode.org/wiki/String_interpolation_(included)"
  },
  {
    "local_code": "fn main() {\n    let name = String::from(\"møøse\");\n    println!(\"bytes count: {}\", name.len());\n    println!(\"character count: {}\", name.chars().count());\n}\n",
    "path": "tasks/string-length",
    "remote_code": "\nfn main() {\n    let s = \"文字化け\";  // UTF-8\n    println!(\"Character length: {}\", s.chars().count());\n}\n",
    "title": "String length",
    "url": "http://rosettacode.org/wiki/String_length"
  },
  {
    "local_code": "fn match_string(container: &str, target: &str) -> (bool, bool, bool) {\n    let starts = container.starts_with(target);\n    let ends = container.ends_with(target);\n    let contains = starts || ends || container.contains(target);\n\n    (starts, contains, ends)\n}\n\nfn print_info(container: &str, target: &str) {\n    println!(r#\"Matching \"{}\" in the string \"{}\"\"#, target, container);\n    let (starts, contains, ends) = match_string(container, target);\n\n    if starts {\n        println!(r#\"\"{}\" starts with \"{}\"\"#, container, target);\n    }\n    if contains {\n        println!(r#\"\"{}\" contains \"{}\"\"#, container, target);\n    }\n    if ends {\n        println!(r#\"\"{}\" ends with \"{}\"\"#, container, target);\n    }\n}\n\nfn main() {\n    print_info(\"abcd\", \"ab\");\n    print_info(\"abcd\", \"bc\");\n    print_info(\"abcd\", \"cd\");\n}\n\n#[test]\nfn test_match_string() {\n    assert_eq!(match_string(\"abcd\", \"ab\"), (true, true, false));\n    assert_eq!(match_string(\"abcd\", \"ba\"), (false, false, false));\n    assert_eq!(match_string(\"abcd\", \"bc\"), (false, true, false));\n    assert_eq!(match_string(\"abcd\", \"cd\"), (false, true, true));\n}\n",
    "path": "tasks/string-matching",
    "remote_code": "fn print_match(possible_match: Option<usize>) {\n    match possible_match {\n        Some(match_pos) => println!(\"Found match at pos {}\", match_pos),\n        None => println!(\"Did not find any matches\")\n    }\n}\n\nfn main() {\n    let s1 = \"abcd\";\n    let s2 = \"abab\";\n    let s3 = \"ab\";\n    \n    // Determining if the first string starts with second string\n    assert!(s1.starts_with(s3));\n    // Determining if the first string contains the second string at any location\n    assert!(s1.contains(s3));\n    // Print the location of the match \n    print_match(s1.find(s3)); // Found match at pos 0\n    print_match(s1.find(s2)); // Did not find any matches\n    // Determining if the first string ends with the second string\n    assert!(s2.ends_with(s3));\n}",
    "title": "String matching",
    "url": "http://rosettacode.org/wiki/String_matching"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet mut s = \"World\".to_string();\ns.insert_str(0, \"Hello \");\nprintln!(\"{}\", s);\n",
    "title": "String prepend",
    "url": "http://rosettacode.org/wiki/String_prepend"
  },
  {
    "local_code": "fn main() {\n    println!(\n        \"{}\",\n        strip_characters(\"She was a soul stripper. She took my heart!\", \"aei\")\n    );\n}\n\nfn strip_characters(original: &str, to_strip: &str) -> String {\n    original\n        .chars()\n        .filter(|&c| !to_strip.contains(c))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn correct_strip_characters() {\n        let test = \"She was a soul stripper. She took my heart!\";\n        let expected = \"Sh ws  soul strppr. Sh took my hrt!\";\n        assert_eq!(strip_characters(test, \"aei\"), expected);\n    }\n\n    #[test]\n    fn correct_strip_empty_string() {\n        assert_eq!(strip_characters(\"\", \"jkl\"), \"\");\n    }\n\n    #[test]\n    fn correct_strip_no_characters() {\n        assert_eq!(strip_characters(\"test string\", \"\"), \"test string\");\n    }\n}\n",
    "path": "tasks/strip-characters-from-a-string",
    "remote_code": "\nfn strip_characters(original : &str, to_strip : &str) -> String {\n    let mut result = String::new();\n    for c in original.chars() {\n        if !to_strip.contains(c) {\n           result.push(c);\n       }\n    }\n    result\n}\n",
    "title": "Strip a set of characters from a string",
    "url": "http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strip block comments",
    "url": "http://rosettacode.org/wiki/Strip_block_comments"
  },
  {
    "local_code": "fn strip_comments(s: &str) -> &str {\n    let markers = ['#', ';'];\n    s.find(&markers[..]).map_or(s, |i| &s[..i]).trim()\n}\n\n#[test]\nfn test_strip_comments() {\n    let inputs = [\n        \"apples, pears # and bananas\",\n        \"apples, pears ; and bananas\",\n        \"  apples, pears \",\n    ];\n    let output = \"apples, pears\";\n\n    for &input in &inputs {\n        assert_eq!(strip_comments(input), output)\n    }\n}\n\nfn main() {\n    let inputs = [\n        \"apples, pears # and bananas\",\n        \"apples, pears ; and bananas\",\n        \"  apples, pears \",\n    ];\n\n    for &input in &inputs {\n        println!(\"Input: {}\\nStripped: {}\", input, strip_comments(input))\n    }\n}\n",
    "path": "tasks/strip-comments-from-a-string",
    "remote_code": "fn strip_comment<'a>(input: &'a str, markers: &[char]) -> &'a str {\n    input\n        .find(markers)\n        .map(|idx| &input[..idx])\n        .unwrap_or(input)\n        .trim()\n}\n\nfn main() {\n    println!(\"{:?}\", strip_comment(\"apples, pears # and bananas\", &['#', ';']));\n    println!(\"{:?}\", strip_comment(\"apples, pears ; and bananas\", &['#', ';']));\n    println!(\"{:?}\", strip_comment(\"apples, pears and bananas \", &['#', ';']));\n}",
    "title": "Strip comments from a string",
    "url": "http://rosettacode.org/wiki/Strip_comments_from_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strip control codes and extended characters from a string",
    "url": "http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string"
  },
  {
    "local_code": "fn main() {\n    let string = \"String without spaces\";\n    let spaces = \" \\x0B\\t\\r\\n \\u{A0} \\u{2000} \\u{3000} \";\n    let string_with_spaces = spaces.to_string() + string + spaces;\n\n    assert_eq!(string_with_spaces.trim(), string);\n    assert_eq!(\n        string_with_spaces.trim_start().to_string(),\n        string.to_string() + spaces\n    );\n    assert_eq!(\n        string_with_spaces.trim_end().to_string(),\n        spaces.to_string() + string\n    );\n}\n",
    "path": "tasks/strip-whitespace-from-a-string/top-and-tail",
    "remote_code": "fn main() {\n    let spaces = \" \\t\\n\\x0B\\x0C\\r \\u{A0} \\u{2000}\\u{3000}\";\n    let string_with_spaces = spaces.to_owned() + \"String without spaces\" + spaces;\n\n    assert_eq!(string_with_spaces.trim(), \"String without spaces\");\n    assert_eq!(string_with_spaces.trim_left(), \"String without spaces\".to_owned() + spaces);\n    assert_eq!(string_with_spaces.trim_right(), spaces.to_owned() + \"String without spaces\");\n}",
    "title": "Strip whitespace from a string/Top and tail",
    "url": "http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: i32) -> bool {\n\tfor i in 2..n {\n\t\tif i * i > n {\n\t\t\treturn true;\n\t\t}\n\t\tif n % i == 0 {\n\t\t\treturn false;\n\t\t}\n\t}\n\tn > 1\n}\n\nfn next_prime(n: i32) -> i32 {\n\tfor i in (n+1).. {\n\t\tif is_prime(i) {\n\t\t\treturn i;\n\t\t}\n\t}\n\t0\n}\n\nfn main() {\n\tlet mut n = 0;\n\tlet mut prime_q = 5;\n\tlet mut prime_p = 3;\n\tlet mut prime_o = 2;\n\n\tprint!(\"First 36 strong primes: \");\n\twhile n < 36 {\n\t\tif prime_p > (prime_o + prime_q) / 2 {\n\t\t\tprint!(\"{} \",prime_p);\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"\");\n\n\twhile prime_p < 1000000 {\n\t\tif prime_p > (prime_o + prime_q) / 2 {\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"strong primes below 1,000,000: {}\", n);\n\n\twhile prime_p < 10000000 {\n\t\tif prime_p > (prime_o + prime_q) / 2 {\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"strong primes below 10,000,000: {}\", n);\n\n\tn = 0;\n\tprime_q = 5;\n\tprime_p = 3;\n\tprime_o = 2;\n\n\tprint!(\"First 36 weak primes: \");\n\twhile n < 36 {\n\t\tif prime_p < (prime_o + prime_q) / 2 {\n\t\t\tprint!(\"{} \",prime_p);\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"\");\n\n\twhile prime_p < 1000000 {\n\t\tif prime_p < (prime_o + prime_q) / 2 {\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"weak primes below 1,000,000: {}\", n);\n\n\twhile prime_p < 10000000 {\n\t\tif prime_p < (prime_o + prime_q) / 2 {\n\t\t\tn += 1;\n\t\t}\n\t\tprime_o = prime_p;\n\t\tprime_p = prime_q;\n\t\tprime_q = next_prime(prime_q);\n\t}\n\tprintln!(\"weak primes below 10,000,000: {}\", n);\n}",
    "title": "Strong and weak primes",
    "url": "http://rosettacode.org/wiki/Strong_and_weak_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Subleq",
    "url": "http://rosettacode.org/wiki/Subleq"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Substitution cipher",
    "url": "http://rosettacode.org/wiki/Substitution_cipher"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet s = \"abc文字化けdef\";\nlet n = 2;\nlet m = 3;\n\n    // Print 3 characters starting at index 2 (c文字)\nprintln!(\"{}\", s.chars().skip(n).take(m).collect::<String>());\n\n    // Print all characters starting at index 2 (c文字化けdef)\nprintln!(\"{}\", s.chars().skip(n).collect::<String>());\n\n    // Print all characters except the last (abc文字化けde)\nprintln!(\"{}\", s.chars().rev().skip(1).collect::<String>());\n\n    // Print 3 characters starting with 'b' (bc文)\nlet cpos = s.find('b').unwrap();\nprintln!(\"{}\", s[cpos..].chars().take(m).collect::<String>());\n\n    // Print 3 characters starting with \"けd\" (けde)\nlet spos = s.find(\"けd\").unwrap();\nprintln!(\"{}\", s[spos..].chars().take(m).collect::<String>());\n",
    "title": "Substring",
    "url": "http://rosettacode.org/wiki/Substring"
  },
  {
    "local_code": "fn main() {\n    let string = \"Hello World\";\n    assert_eq!(Some(\"ello World\"), string.get(1..));\n    assert_eq!(Some(\"Hello Wor\"), string.get(..(string.len() - 2)));\n    assert_eq!(Some(\"lo Wo\"), string.get(3..(string.len() - 3)));\n    assert_eq!(None, string.get(42..)); // out of bounds\n}\n",
    "path": "tasks/substring/top-and-tail",
    "remote_code": "fn main() {\n    let s = String::from(\"žluťoučký kůň\");\n\n    let mut modified = s.clone();\n    modified.remove(0);\n    println!(\"{}\", modified);\n\n    let mut modified = s.clone();\n    modified.pop();\n    println!(\"{}\", modified);\n\n    let mut modified = s;\n    modified.remove(0);\n    modified.pop();\n    println!(\"{}\", modified);\n}",
    "title": "Substring/Top and tail",
    "url": "http://rosettacode.org/wiki/Substring/Top_and_tail"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct SubtractiveGenerator {\n    /// m in the formula\n    modulo: i32,\n    /// i and j in the formula\n    offsets: (u32, u32),\n    /// r in the formula. It is used as a ring buffer.\n    state: Vec<i32>,\n    /// n in the formula\n    position: usize,\n}\n\nimpl SubtractiveGenerator {\n    fn new(modulo: i32, first_offset: u32, second_offset: u32) -> Self {\n        // The state size has to fit into a usize to index state properly\n        // without overflow.\n        let state_size: usize = first_offset.try_into().unwrap();\n\n        // Both offsets have to fit in i32 for the substractions to work\n        // without overflow.\n        assert!(first_offset <= i32::MAX as u32);\n        assert!(first_offset > second_offset);\n        SubtractiveGenerator {\n            modulo,\n            offsets: (first_offset, second_offset),\n            state: Vec::with_capacity(state_size),\n            position: 0,\n        }\n    }\n}\n\nimpl Iterator for SubtractiveGenerator {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<<Self as Iterator>::Item> {\n        let state_size = self.offsets.0 as usize;\n\n        assert_eq!(self.state.len(), state_size);\n\n        self.position = (self.position + 1) % self.offsets.0 as usize;\n\n        let i1 = (self.position as i32 - self.offsets.0 as i32).rem_euclid(state_size as i32);\n        let i2 = (self.position as i32 - self.offsets.1 as i32).rem_euclid(state_size as i32);\n\n        let p1 = self.state[i1 as usize];\n        let p2 = self.state[i2 as usize];\n\n        self.state[self.position] = (p1 - p2).rem_euclid(self.modulo);\n\n        Some(self.state[self.position])\n    }\n}\n\n/// Returns a pre-seeded subtractive generator, which generates the same\n/// sequences as Bentley's generator, as used in xpat2.\nfn get_seeded_xpat2_gen(seed: i32) -> SubtractiveGenerator {\n    let mut gen = SubtractiveGenerator::new(1_000_000_000, 55, 24);\n\n    let state_size = gen.offsets.0 as usize;\n\n    let mut pre_state = Vec::with_capacity(state_size);\n    pre_state.push(seed);\n    pre_state.push(1);\n    for i in 2..state_size {\n        pre_state.push((pre_state[i - 2] - pre_state[i - 1]).rem_euclid(gen.modulo));\n    }\n\n    for i in 0..state_size {\n        gen.state.push(pre_state[(34 * (i + 1)) % 55]);\n    }\n\n    gen.position = 54;\n    for _ in 0..165 {\n        gen.next();\n    }\n\n    gen\n}\n\nfn main() {\n    let gen = get_seeded_xpat2_gen(292929);\n\n    for n in gen.take(5) {\n        println!(\"{}\", n);\n    }\n}",
    "title": "Subtractive generator",
    "url": "http://rosettacode.org/wiki/Subtractive_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn is_prime(num: u32) -> bool {\n  match num {\n      x if x < 4 => x > 1,\n      x if x % 2 == 0 => false,\n      x => { let limit = (x as f32).sqrt().ceil() as u32;\n              (3..=limit).step_by(2).all(|a| x % a != 0)\n            }\n  } \n}\n\nfn primes_by_diffs(primes: &[u32], diffs: &[u32]) -> Vec<Vec<u32>> {\n\n  fn select(diffs: &[u32], prime_win: &[u32], acc: bool) -> bool {\n    if diffs.is_empty() || !acc {\n      acc\n    }\n    else {\n      let acc1 = prime_win[0] + diffs[0] == prime_win[1];\n      select(&diffs[1..], &prime_win[1..], acc1)\n    }\n  }\n  \n  primes.windows(diffs.len() + 1)\n        .filter(|&win| select(diffs, win, true))\n        .map(|win| win.to_vec())\n        .collect()\n}\n\nfn main() {\n  let limit = 1_000_000u32;\n  let start = std::time::Instant::now();\n  let primes = (2..).filter(|&i| is_prime(i));\n  let prime_list: Vec<u32> = primes.take_while(|&p| p <= limit).collect();\n  let duration = start.elapsed();\n  println!(\"primes time: {:?}\", duration);\n  for diffs in vec!(vec!(1), vec!(2), vec!(2,2), vec!(2,4), vec!(4,2), vec!(6,4,2), vec!(2,4,6)) {\n    let result_list = primes_by_diffs(&prime_list, &diffs);\n    let len = result_list.len();\n    println!(\"{:?} number: {}\\n\\tfirst: {:?}\", diffs, len, result_list[0]);\n    if len == 1 {\n      println!()\n    }\n    if len > 1 {\n      println!(\"\\tlast: {:?}\\n\", result_list.last().unwrap())\n    }\n  }\n}\n",
    "title": "Successive prime differences",
    "url": "http://rosettacode.org/wiki/Successive_prime_differences"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sudan function",
    "url": "http://rosettacode.org/wiki/Sudan_function"
  },
  {
    "local_code": "use std::fmt;\nuse std::str::FromStr;\n\nconst BOARD_WIDTH: usize = 9;\nconst BOARD_HEIGHT: usize = 9;\nconst GROUP_WIDTH: usize = 3;\nconst GROUP_HEIGHT: usize = 3;\nconst MAX_NUMBER: usize = 9;\n\ntype Bits = u16;\nconst MASK_ALL: Bits = 0x1ff;\nconst INVALID_CELL: u32 = !0;\n\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nstruct Sudoku {\n    map: [[Bits; BOARD_WIDTH]; BOARD_HEIGHT],\n}\n\nimpl Sudoku {\n    fn new() -> Sudoku {\n        Sudoku {\n            map: [[MASK_ALL; BOARD_WIDTH]; BOARD_HEIGHT],\n        }\n    }\n\n    fn get(&self, x: usize, y: usize) -> u32 {\n        match self.map[y][x].count_ones() {\n            0 => INVALID_CELL,\n            1 => self.map[y][x].trailing_zeros() + 1,\n            _ => 0,\n        }\n    }\n\n    fn set(&mut self, x: usize, y: usize, n: u32) {\n        self.map[y][x] = 1 << (n - 1);\n    }\n}\n\nimpl Default for Sudoku {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl FromStr for Sudoku {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Sudoku, ()> {\n        let mut sudoku = Sudoku::new();\n\n        for (y, line) in s.lines().filter(|l| !l.is_empty()).enumerate() {\n            let line = line.trim_matches(|c: char| c.is_whitespace());\n            for (x, c) in line.chars().enumerate() {\n                if let Some(d) = c.to_digit(10) {\n                    if d != 0 {\n                        sudoku.set(x, y, d);\n                    }\n                } else {\n                    return Err(());\n                }\n            }\n        }\n\n        Ok(sudoku)\n    }\n}\n\nimpl fmt::Display for Sudoku {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let hbar = \"+---+---+---+\";\n\n        for y in 0..BOARD_HEIGHT {\n            if y % GROUP_HEIGHT == 0 {\n                writeln!(f, \"{}\", hbar)?;\n            }\n\n            for x in 0..BOARD_WIDTH {\n                if x % GROUP_WIDTH == 0 {\n                    write!(f, \"|\")?;\n                }\n\n                match self.get(x, y) {\n                    INVALID_CELL => write!(f, \"!\")?,\n                    0 => write!(f, \" \")?,\n                    d => write!(f, \"{}\", d)?,\n                }\n            }\n            writeln!(f, \"|\")?;\n        }\n        writeln!(f, \"{}\", hbar)?;\n\n        Ok(())\n    }\n}\n\nfn solve_sudoku(mut puzzle: Sudoku) -> Vec<Sudoku> {\n    let idx_in_grp = [\n        (0, 0),\n        (0, 1),\n        (0, 2),\n        (1, 0),\n        (1, 1),\n        (1, 2),\n        (2, 0),\n        (2, 1),\n        (2, 2),\n    ];\n\n    loop {\n        let bkup = puzzle;\n\n        // If the number at cell (x, y) is uniquely determined, that number must\n        // not have appeared at the cells in the same row/column/group.\n        for y in 0..BOARD_HEIGHT {\n            for x in 0..BOARD_WIDTH {\n                if puzzle.map[y][x].count_ones() != 1 {\n                    continue;\n                }\n\n                let (x0, y0) = (\n                    (x / GROUP_WIDTH) * GROUP_WIDTH,\n                    (y / GROUP_HEIGHT) * GROUP_HEIGHT,\n                );\n\n                let row = (0..BOARD_WIDTH).map(|x| (x, y));\n                let col = (0..BOARD_HEIGHT).map(|y| (x, y));\n                let grp = idx_in_grp.iter().map(|&(dx, dy)| (x0 + dx, y0 + dy));\n\n                let it = row\n                    .chain(col)\n                    .chain(grp)\n                    .filter(|&pos: &(usize, usize)| pos != (x, y));\n\n                let mask = !puzzle.map[y][x] & MASK_ALL;\n                for (x, y) in it {\n                    puzzle.map[y][x] &= mask;\n                }\n            }\n        }\n\n        // If `n` appears only once at the cell in the row/column/group, the\n        // number of the cell must be `n`.\n        for n in 0..MAX_NUMBER {\n            let bit = 1 << n;\n\n            // Check each rows\n            for y in 0..BOARD_HEIGHT {\n                let next = {\n                    let mut it = (0..BOARD_WIDTH).filter(|&x| puzzle.map[y][x] & bit != 0);\n                    let next = it.next();\n                    if next.is_none() || it.next().is_some() {\n                        continue;\n                    }\n                    next\n                };\n                puzzle.map[y][next.unwrap()] = bit;\n            }\n\n            // Check each column\n            for x in 0..BOARD_WIDTH {\n                let next = {\n                    let mut it = (0..BOARD_HEIGHT).filter(|&y| puzzle.map[y][x] & bit != 0);\n                    let next = it.next();\n                    if next.is_none() || it.next().is_some() {\n                        continue;\n                    }\n                    next\n                };\n                puzzle.map[next.unwrap()][x] = bit;\n            }\n\n            // Check each group\n            for y0 in (0..BOARD_HEIGHT).step_by(GROUP_WIDTH) {\n                for x0 in (0..BOARD_WIDTH).step_by(GROUP_HEIGHT) {\n                    let next = {\n                        let mut it = idx_in_grp\n                            .iter()\n                            .map(|&(dx, dy)| (x0 + dx, y0 + dy))\n                            .filter(|&(x, y)| puzzle.map[y][x] & bit != 0);\n                        let next = it.next();\n                        if next.is_none() || it.next().is_some() {\n                            continue;\n                        }\n                        next\n                    };\n                    let (x, y) = next.unwrap();\n                    puzzle.map[y][x] = bit;\n                }\n            }\n        }\n\n        // Loop until no cell can be filled.\n        if puzzle == bkup {\n            break;\n        }\n    }\n\n    let it = (0..BOARD_HEIGHT * BOARD_WIDTH)\n        .map(|i| (i % BOARD_WIDTH, i / BOARD_WIDTH))\n        .map(|(x, y)| (x, y, puzzle.map[y][x].count_ones() as Bits))\n        .collect::<Vec<_>>();\n\n    // If some cells have no possible number, there is no answer.\n    if it.iter().any(|&(_x, _y, cnt)| cnt == 0) {\n        return vec![];\n    }\n\n    // If all cells have exact one possible number, this is a answer.\n    if it.iter().all(|&(_x, _y, cnt)| cnt == 1) {\n        return vec![puzzle];\n    }\n\n    // Find the first undetermined cell.\n    let (x, y, _cnt) = *it\n        .iter()\n        .filter(|&&(_x, _y, cnt)| cnt > 1)\n        .min_by_key(|&&(_x, _y, cnt)| cnt)\n        .unwrap();\n\n    let mut answers = vec![];\n    for n in 0..MAX_NUMBER {\n        let bit = 1 << n;\n        if puzzle.map[y][x] & bit == 0 {\n            continue;\n        }\n\n        // Assuming the number at (x, y) is `n`, try to solve the problem again.\n        // If some answers are found, append them to the `answers`.\n        let mut p2 = puzzle;\n        p2.map[y][x] = bit;\n        answers.extend(solve_sudoku(p2).into_iter());\n    }\n    answers\n}\n\nconst INPUT: &str = r\"\n    850002400\n    720000009\n    004000000\n    000107002\n    305000900\n    040000000\n    000080070\n    017000000\n    000036040\n\";\n\nfn main() {\n    let puzzle = INPUT.parse::<Sudoku>().unwrap();\n\n    println!(\"{}\", puzzle);\n\n    for answer in &solve_sudoku(puzzle) {\n        println!(\"{}\", answer);\n    }\n}\n\n#[cfg(test)]\nconst SOLUTION: &str = r\"\n    859612437\n    723854169\n    164379528\n    986147352\n    375268914\n    241593786\n    432981675\n    617425893\n    598736241\n\";\n\n#[test]\nfn solution() {\n    let puzzle = INPUT.parse::<Sudoku>().unwrap();\n    let answer = SOLUTION.parse::<Sudoku>().unwrap();\n    let solution = solve_sudoku(puzzle);\n    assert_eq!(solution, [answer]);\n}\n",
    "path": "tasks/sudoku",
    "remote_code": "type Sudoku = [u8; 81];\n\nfn is_valid(val: u8, x: usize, y: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (0..9).all(|i| sudoku_ar[y * 9 + i] != val && sudoku_ar[i * 9 + x] != val) && {\n        let (start_x, start_y) = ((x / 3) * 3, (y / 3) * 3);\n        (start_y..start_y + 3).all(|i| (start_x..start_x + 3).all(|j| sudoku_ar[i * 9 + j] != val))\n    }\n}\n\nfn place_number(pos: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (pos..81).find(|&p| sudoku_ar[p] == 0).map_or(true, |pos| {\n        let (x, y) = (pos % 9, pos / 9);\n        for n in 1..10 {\n            if is_valid(n, x, y, sudoku_ar) {\n                sudoku_ar[pos] = n;\n                if place_number(pos + 1, sudoku_ar) {\n                    return true;\n                }\n                sudoku_ar[pos] = 0;\n            }\n        }\n        false\n    })\n}\n\nfn pretty_print(sudoku_ar: Sudoku) {\n    let line_sep = \"------+-------+------\";\n    println!(\"{}\", line_sep);\n    for (i, e) in sudoku_ar.iter().enumerate() {\n        print!(\"{} \", e);\n        if (i + 1) % 3 == 0 && (i + 1) % 9 != 0 {\n            print!(\"| \");\n        }\n        if (i + 1) % 9 == 0 {\n            println!(\" \");\n        }\n        if (i + 1) % 27 == 0 {\n            println!(\"{}\", line_sep);\n        }\n    }\n}\n\nfn solve(sudoku_ar: &mut Sudoku) -> bool {\n    place_number(0, sudoku_ar)\n}\n\nfn main() {\n    let mut sudoku_ar: Sudoku = [\n        8, 5, 0, 0, 0, 2, 4, 0, 0,\n        7, 2, 0, 0, 0, 0, 0, 0, 9,\n        0, 0, 4, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 7, 0, 0, 2,\n        3, 0, 5, 0, 0, 0, 9, 0, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 0, 0, 7, 0,\n        0, 1, 7, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 3, 6, 0, 4, 0\n    ];\n    if solve(&mut sudoku_ar) {\n        pretty_print(sudoku_ar);\n    } else {\n        println!(\"Unsolvable\");\n    }\n}",
    "title": "Sudoku",
    "url": "http://rosettacode.org/wiki/Sudoku"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Suffixation of decimal numbers",
    "url": "http://rosettacode.org/wiki/Suffixation_of_decimal_numbers"
  },
  {
    "local_code": "#![allow(clippy::unnecessary_fold)]\n\nfn main() {\n    let arr: [i32; 9] = [1_i32, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // using fold\n    let sum = arr.iter().fold(0_i32, |a, &b| a + b);\n    let product = arr.iter().fold(1_i32, |a, &b| a * b);\n    println!(\"the sum is {} and the product is {}\", sum, product);\n\n    // or using sum and product\n    let sum = arr.iter().sum::<i32>();\n    let product = arr.iter().product::<i32>();\n    println!(\"the sum is {} and the product is {}\", sum, product);\n}\n",
    "path": "tasks/sum-and-product-of-an-array",
    "remote_code": "\n\nfn main() {\n    let arr = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // using fold\n    let sum = arr.iter().fold(0i32, |a, &b| a + b);\n    let product = arr.iter().fold(1i32, |a, &b| a * b);\n    println!(\"the sum is {} and the product is {}\", sum, product);\n\n    // or using sum and product\n    let sum = arr.iter().sum::<i32>();\n    let product = arr.iter().product::<i32>();\n    println!(\"the sum is {} and the product is {}\", sum, product);\n}\n",
    "title": "Sum and product of an array",
    "url": "http://rosettacode.org/wiki/Sum_and_product_of_an_array"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sum and product puzzle",
    "url": "http://rosettacode.org/wiki/Sum_and_product_puzzle"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Sum_digits_of_an_integer\n\nfn sum(n: usize, base: usize) -> usize {\n    let mut total = 0;\n    let mut n = n;\n    while n != 0 {\n        total += n % base;\n        n /= base\n    }\n    total\n}\n\n#[test]\nfn base_10() {\n    assert_eq!(sum(1, 10), 1);\n    assert_eq!(sum(1234, 10), 10);\n}\n\n#[test]\nfn base_16() {\n    assert_eq!(sum(0xfe, 16), 29);\n    assert_eq!(sum(0xf0e, 16), 29);\n}\n\nfn main() {\n    println!(\"{}\", sum(1234, 10));\n}\n",
    "path": "tasks/sum-digits-of-an-integer",
    "remote_code": "struct DigitIter(usize, usize);\n\nimpl Iterator for DigitIter {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.0 == 0 {\n            None\n        } else {\n            let ret = self.0 % self.1;\n            self.0 /= self.1;\n            Some(ret)\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", DigitIter(1234,10).sum::<usize>());\n}",
    "title": "Sum digits of an integer",
    "url": "http://rosettacode.org/wiki/Sum_digits_of_an_integer"
  },
  {
    "local_code": "fn sum35(lim: u64) -> u64 {\n    let mut sum: u64 = 0;\n    for i in 3..lim {\n        if i % 3 == 0 || i % 5 == 0 {\n            sum += i;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let limit = 10_000;\n    println!(\n        \"Sum of multiples of 3 and 5 from 0 till {} are: {}\",\n        limit,\n        sum35(limit)\n    );\n}\n\n#[test]\nfn test_sum35() {\n    assert_eq!(233_168, sum35(1000));\n    assert_eq!(35_553_600, sum35(12_345));\n}\n",
    "path": "tasks/sum-multiples-of-3-and-5",
    "remote_code": "\nextern crate rug;\n\nuse rug::Integer;\nuse rug::ops::Pow;\n\nfn main() {\n    for i in [3, 20, 100, 1_000].iter() {\n        let ten = Integer::from(10);\n        let mut limit = Integer::from(Integer::from(&ten.pow(*i as u32)) - 1);\n        let mut aux_3_1 = &limit.mod_u(3u32);\n        let mut aux_3_2 = Integer::from(&limit - aux_3_1);\n        let mut aux_3_3 = Integer::from(&aux_3_2/3);\n        let mut aux_3_4 = Integer::from(3 + aux_3_2);\n        let mut aux_3_5 = Integer::from(&aux_3_3*&aux_3_4);\n        let mut aux_3_6 = Integer::from(&aux_3_5/2);\n \n        let mut aux_5_1 = &limit.mod_u(5u32);\n        let mut aux_5_2 = Integer::from(&limit - aux_5_1); \n        let mut aux_5_3 = Integer::from(&aux_5_2/5);\n        let mut aux_5_4 = Integer::from(5 + aux_5_2); \n        let mut aux_5_5 = Integer::from(&aux_5_3*&aux_5_4);\n        let mut aux_5_6 = Integer::from(&aux_5_5/2); \n\n        let mut aux_15_1 = &limit.mod_u(15u32);\n        let mut aux_15_2 = Integer::from(&limit - aux_15_1); \n        let mut aux_15_3 = Integer::from(&aux_15_2/15);\n        let mut aux_15_4 = Integer::from(15 + aux_15_2);\n        let mut aux_15_5 = Integer::from(&aux_15_3*&aux_15_4);\n        let mut aux_15_6 = Integer::from(&aux_15_5/2); \n\n        let mut result_aux_1 = Integer::from(&aux_3_6 + &aux_5_6); \n        let mut result = Integer::from(&result_aux_1 - &aux_15_6);\n \n        println!(\"Sum for 10^{} : {}\",i,result);\n    }\n}\n",
    "title": "Sum multiples of 3 and 5",
    "url": "http://rosettacode.org/wiki/Sum_multiples_of_3_and_5"
  },
  {
    "local_code": "fn main() {\n    let sum: f64 = (1u64..=1000).fold(0., |sum, num| sum + 1. / (num * num) as f64);\n    println!(\"{}\", sum);\n}\n",
    "path": "tasks/sum-of-a-series",
    "remote_code": "const LOWER: i32 = 1;\nconst UPPER: i32 = 1000;\n\n// Because the rule for our series is simply adding one, the number of terms are the number of\n// digits between LOWER and UPPER\nconst NUMBER_OF_TERMS: i32 = (UPPER + 1) - LOWER;\nfn main() {\n    // Formulaic method\n    println!(\"{}\", (NUMBER_OF_TERMS * (LOWER + UPPER)) / 2);\n    // Naive method\n    println!(\"{}\", (LOWER..UPPER + 1).fold(0, |sum, x| sum + x));\n}\n",
    "title": "Sum of a series",
    "url": "http://rosettacode.org/wiki/Sum_of_a_series"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sum of elements below main diagonal of matrix",
    "url": "http://rosettacode.org/wiki/Sum_of_elements_below_main_diagonal_of_matrix"
  },
  {
    "local_code": "fn sq_sum(v: &[f64]) -> f64 {\n    v.iter().fold(0., |sum, &num| sum + num * num)\n}\n\nfn main() {\n    let v = vec![3.0, 1.0, 4.0, 1.0, 5.5, 9.7];\n    println!(\"{}\", sq_sum(&v));\n\n    let u: Vec<f64> = vec![];\n    println!(\"{}\", sq_sum(&u));\n}\n",
    "path": "tasks/sum-of-squares",
    "remote_code": "fn sq_sum(v: &[f64]) -> f64 {\n    v.iter().fold(0., |sum, &num| sum + num*num)\n}\n\nfn main() {\n    let v = vec![3.0, 1.0, 4.0, 1.0, 5.5, 9.7];\n    println!(\"{}\", sq_sum(&v));\n\n    let u : Vec<f64> = vec![];\n    println!(\"{}\", sq_sum(&u));\n}",
    "title": "Sum of squares",
    "url": "http://rosettacode.org/wiki/Sum_of_squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sum to 100",
    "url": "http://rosettacode.org/wiki/Sum_to_100"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Summarize and say sequence",
    "url": "http://rosettacode.org/wiki/Summarize_and_say_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n\nfn main() {\n    let limit = 1000;\n    let mut sum = 0;\n    println!(\"count  prime      sum\");\n    for (n, p) in primal::Sieve::new(limit)\n        .primes_from(2)\n        .take_while(|x| *x < limit)\n        .enumerate()\n    {\n        sum += p;\n        if primal::is_prime(sum as u64) {\n            println!(\"  {:>3}    {:>3}    {:>5}\", n + 1, p, sum);\n        }\n    }\n}",
    "title": "Summarize primes",
    "url": "http://rosettacode.org/wiki/Summarize_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.9\"\n\nfn print_super_d_numbers(d: u32, limit: u32) {\n    use rug::Assign;\n    use rug::Integer;\n\n    println!(\"First {} super-{} numbers:\", limit, d);\n    let digits = d.to_string().repeat(d as usize);\n    let mut count = 0;\n    let mut n = 1;\n    let mut s = Integer::new();\n    while count < limit {\n        s.assign(Integer::u_pow_u(n, d));\n        s *= d;\n        if s.to_string().contains(&digits) {\n            print!(\"{} \", n);\n            count += 1;\n        }\n        n += 1;\n    }\n    println!();\n}\n\nfn main() {\n    for d in 2..=9 {\n        print_super_d_numbers(d, 10);\n    }\n}",
    "title": "Super-d numbers",
    "url": "http://rosettacode.org/wiki/Super-d_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Superellipse",
    "url": "http://rosettacode.org/wiki/Superellipse"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Superpermutation minimisation",
    "url": "http://rosettacode.org/wiki/Superpermutation_minimisation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Debug, Clone)]\nstruct Polygon(Vec<Point>);\n\nfn is_inside(p: &Point, cp1: &Point, cp2: &Point) -> bool {\n    (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)\n}\n\nfn compute_intersection(cp1: &Point, cp2: &Point, s: &Point, e: &Point) -> Point {\n    let dc = Point {\n        x: cp1.x - cp2.x,\n        y: cp1.y - cp2.y,\n    };\n    let dp = Point {\n        x: s.x - e.x,\n        y: s.y - e.y,\n    };\n    let n1 = cp1.x * cp2.y - cp1.y * cp2.x;\n    let n2 = s.x * e.y - s.y * e.x;\n    let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);\n    Point {\n        x: (n1 * dp.x - n2 * dc.x) * n3,\n        y: (n1 * dp.y - n2 * dc.y) * n3,\n    }\n}\n\nfn sutherland_hodgman_clip(subject_polygon: &Polygon, clip_polygon: &Polygon) -> Polygon {\n    let mut result_ring = subject_polygon.0.clone();\n    let mut cp1 = clip_polygon.0.last().unwrap();\n    for cp2 in &clip_polygon.0 {\n        let input = result_ring;\n        let mut s = input.last().unwrap();\n        result_ring = vec![];\n        for e in &input {\n            if is_inside(e, cp1, cp2) {\n                if !is_inside(s, cp1, cp2) {\n                    result_ring.push(compute_intersection(cp1, cp2, s, e));\n                }\n                result_ring.push(e.clone());\n            } else if is_inside(s, cp1, cp2) {\n                result_ring.push(compute_intersection(cp1, cp2, s, e));\n            }\n            s = e;\n        }\n        cp1 = cp2;\n    }\n    Polygon(result_ring)\n}\n\nfn main() {\n    let _p = |x: f64, y: f64| Point { x, y };\n    let subject_polygon = Polygon(vec![\n        _p(50.0, 150.0), _p(200.0, 50.0), _p(350.0, 150.0), _p(350.0, 300.0), _p(250.0, 300.0),\n        _p(200.0, 250.0), _p(150.0, 350.0), _p(100.0, 250.0), _p(100.0, 200.0),\n    ]);\n    let clip_polygon = Polygon(vec![\n        _p(100.0, 100.0),_p(300.0, 100.0),_p(300.0, 300.0),_p(100.0, 300.0),\n    ]);\n    let result = sutherland_hodgman_clip(&subject_polygon, &clip_polygon);\n    println!(\"{:?}\", result);\n}",
    "title": "Sutherland-Hodgman polygon clipping",
    "url": "http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sylvester's sequence",
    "url": "http://rosettacode.org/wiki/Sylvester's_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashSet;\n\nfn main() {\n    let a: HashSet<_> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\n        .iter()\n        .collect();\n    let b = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\n        .iter()\n        .collect();\n\n    let diff = a.symmetric_difference(&b);\n    println!(\"{:?}\", diff);\n}\n",
    "title": "Symmetric difference",
    "url": "http://rosettacode.org/wiki/Symmetric_difference"
  },
  {
    "local_code": "//! Reader unit reads lines from input.txt, send lines one at a time to printer unit, which then\n//! prints lines, keeping track of lines printed. At the end of the file, the reader unit requests\n//! number of lines printed from the printer unit, and then prints them.\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::sync::mpsc::{channel, Receiver, Sender};\nuse std::thread;\n\nconst FILENAME: &str = \"resources/input.txt\";\n\nenum Message {\n    Line(String),\n    End,\n}\n\nfn printer(i_snd: &Sender<i32>, msg_rcv: &Receiver<Message>) {\n    let mut count = 0;\n    while let Message::Line(line) = msg_rcv.recv().unwrap() {\n        println!(\"{}\", line);\n        count += 1;\n    }\n    i_snd.send(count).unwrap();\n}\n\nfn reader(msg_snd: &Sender<Message>, i_rcv: &Receiver<i32>) {\n    let file = BufReader::new(File::open(FILENAME).unwrap());\n    for line in file.lines() {\n        msg_snd.send(Message::Line(line.unwrap())).unwrap();\n    }\n    msg_snd.send(Message::End).unwrap();\n    println!(\"Total Lines: {}\", i_rcv.recv().unwrap());\n}\n\nfn main() {\n    let (msg_snd, msg_rcv) = channel();\n    let (i_snd, i_rcv) = channel();\n\n    thread::spawn(move || printer(&i_snd, &msg_rcv));\n    thread::spawn(move || reader(&msg_snd, &i_rcv));\n}\n",
    "path": "tasks/synchronous-concurrency",
    "remote_code": "use std::fs::File;\nuse std::io::BufRead;\nuse std::io::BufReader;\n\nuse std::sync::mpsc::{channel, sync_channel};\nuse std::thread;\n\nfn main() {\n    // The reader sends lines to the writer via an async channel, so the reader is never blocked.\n    let (reader_send, writer_recv) = channel();\n\n    // The writer sends the final count via a blocking channel with bound 0,\n    // meaning the buffer is exactly the size of the result.\n    let (writer_send, reader_recv) = sync_channel(0);\n\n    // Define the work the reader will do.\n    let reader_work = move || {\n        let file = File::open(\"input.txt\").expect(\"Failed to open input.txt\");\n        let reader = BufReader::new(file);\n\n        for line in reader.lines() {\n            match line {\n                Ok(msg) => reader_send\n                    .send(msg)\n                    .expect(\"Failed to send via the channel\"),\n                Err(e) => println!(\"{}\", e),\n            }\n        }\n\n        // Dropping the sender disconnects it and tells the receiver the connection is closed.\n        drop(reader_send);\n\n        // Now that we've sent all the lines,\n        // block until the writer gives us the final count.\n        let count = reader_recv\n            .recv()\n            .expect(\"Failed to receive count from printer.\");\n\n        println!(\"{}\", count);\n    };\n\n    // Define the work the writer will do.\n    let writer_work = move || {\n        let mut line_count = 0;\n\n        loop {\n            match writer_recv.recv() {\n                Ok(msg) => {\n                    println!(\"{}\", msg);\n                    line_count += 1;\n                }\n                Err(_) => break, // indicates the connection has been closed by the sender.\n            }\n        }\n\n        // Send the final count back to the reader.\n        writer_send\n            .send(line_count)\n            .expect(\"Failed to send line count from writer.\");\n\n        drop(writer_send);\n    };\n\n    // Spawn each as a thread.\n    let reader_handle = thread::spawn(reader_work);\n    thread::spawn(writer_work);\n\n    reader_handle\n        .join()\n        .expect(\"Failed to join the reader thread.\");\n}",
    "title": "Synchronous concurrency",
    "url": "http://rosettacode.org/wiki/Synchronous_concurrency"
  },
  {
    "local_code": "use std::time::{SystemTime, UNIX_EPOCH};\n\nuse time::format_description::well_known::{Rfc2822, Rfc3339};\nuse time::macros::format_description;\nuse time::OffsetDateTime;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // The standard library contains rudimentary functions for determining the system time.\n    let now = SystemTime::now();\n    let duration_since_epoch = now.duration_since(UNIX_EPOCH)?;\n\n    // Prints the current time as a timespec containing the seconds\n    // and nanoseconds since 1970-01-01T00:00:00Z.\n    println!(\n        \"seconds: {} nanoseconds: {}\",\n        duration_since_epoch.as_secs(),\n        duration_since_epoch.subsec_nanos()\n    );\n\n    // To format the system time, we'll need to use an extern crate such as `time` or `chrono`.\n    let now = OffsetDateTime::from(now);\n\n    // Display time formatted according to RFC 2822,\n    // eg \"Wed, 29 Oct 2014 22:26:17 -0600\"\n    println!(\"rfc2822: {}\", now.format(&Rfc2822)?);\n\n    // Display time formatted according to RFC 3339/ISO8601\n    // eg \"2014-10-29T22:26:17+07:00\"\n    println!(\"rfc3339: {}\", now.format(&Rfc3339)?);\n\n    // Display time in a custom format (eg \"22:26:17\") using strftime\n    println!(\n        \"Custom: {}\",\n        now.format(&format_description!(\"[hour]:[minute]:[second]\"))?\n    );\n\n    Ok(())\n}\n",
    "path": "tasks/system-time",
    "remote_code": "// 20210210 Rust programming solution\n\nextern crate chrono;\nuse chrono::prelude::*;\n\nfn main() {\n   let utc: DateTime<Utc> = Utc::now();\n   println!(\"{}\", utc.format(\"%d/%m/%Y %T\"));\n}\n",
    "title": "System time",
    "url": "http://rosettacode.org/wiki/System_time"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Table creation/Postal addresses",
    "url": "http://rosettacode.org/wiki/Table_creation/Postal_addresses"
  },
  {
    "local_code": "extern crate chrono;\n\nuse std::env;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::io::{self, BufReader, BufWriter};\n\nconst FILENAME: &str = \"NOTES.TXT\";\n\nfn show_notes() -> Result<(), io::Error> {\n    // Create the file if not found.\n    let file = OpenOptions::new()\n        .read(true)\n        .create(true)\n        .write(true)\n        .open(FILENAME)?;\n    let mut buf_reader = BufReader::new(file);\n    let mut contents = String::new();\n    buf_reader.read_to_string(&mut contents)?;\n    println!(\"{}\", contents);\n    Ok(())\n}\n\nfn add_to_notes(note: &str) -> Result<(), io::Error> {\n    // Disable overwriting, instead write to the end of the file.\n    let file = OpenOptions::new()\n        .append(true)\n        .create(true)\n        .open(FILENAME)?;\n    let mut buf_writer = BufWriter::new(file);\n\n    let date_and_time = chrono::Local::now();\n    writeln!(buf_writer, \"{}\", date_and_time)?;\n\n    writeln!(buf_writer, \"\\t{}\", note)\n}\n\nfn main() {\n    let note = env::args().skip(1).collect::<Vec<_>>();\n\n    if note.is_empty() {\n        show_notes().expect(\"failed to print NOTES.TXT\");\n    } else {\n        add_to_notes(&note.join(\" \")).expect(\"failed to write to NOTES.TXT\");\n    }\n}\n",
    "path": "tasks/take-notes-on-the-command-line",
    "remote_code": "extern crate chrono;\n\nuse std::fs::OpenOptions;\nuse std::io::{self, BufReader, BufWriter};\nuse std::io::prelude::*;\nuse std::env;\n\nconst FILENAME: &str = \"NOTES.TXT\";\n\nfn show_notes() -> Result<(), io::Error> {\n    let file = OpenOptions::new()\n        .read(true)\n        .create(true) // create the file if not found\n        .write(true) // necessary to create the file\n        .open(FILENAME)?;\n    let mut buf_reader = BufReader::new(file);\n    let mut contents = String::new();\n    buf_reader.read_to_string(&mut contents)?;\n    println!(\"{}\", contents);\n    Ok(())\n}\n\nfn add_to_notes(note: &str) -> Result<(), io::Error> {\n    let file = OpenOptions::new()\n        .append(true) // disables overwriting, writes to the end of the file\n        .create(true)\n        .open(FILENAME)?;\n    let mut buf_writer = BufWriter::new(file);\n\n    let date_and_time = chrono::Local::now();\n    writeln!(buf_writer, \"{}\", date_and_time)?;\n\n    writeln!(buf_writer, \"\\t{}\", note)\n}\n\nfn main() {\n    let note = env::args().skip(1).collect::<Vec<_>>();\n\n    if note.is_empty() {\n        show_notes().expect(\"failed to print NOTES.TXT\");\n    } else {\n        add_to_notes(&note.join(\" \")).expect(\"failed to write to NOTES.TXT\");\n    }\n}",
    "title": "Take notes on the command line",
    "url": "http://rosettacode.org/wiki/Take_notes_on_the_command_line"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::{BTreeMap, BTreeSet};\n\n// Using a naked BTreeMap would not be very nice, so let's make a simple graph representation\n#[derive(Clone, Debug)]\npub struct Graph {\n    neighbors: BTreeMap<usize, BTreeSet<usize>>,\n}\n\nimpl Graph {\n    pub fn new(size: usize) -> Self {\n        Self {\n            neighbors: (0..size).fold(BTreeMap::new(), |mut acc, x| {\n                acc.insert(x, BTreeSet::new());\n                acc\n            }),\n        }\n    }\n\n    pub fn edges<'a>(&'a self, vertex: usize) -> impl Iterator<Item = usize> + 'a {\n        self.neighbors[&vertex].iter().cloned()\n    }\n\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        assert!(to < self.len());\n        self.neighbors.get_mut(&from).unwrap().insert(to);\n    }\n\n    pub fn add_edges(&mut self, from: usize, to: impl IntoIterator<Item = usize>) {\n        let limit = self.len();\n\n        self.neighbors\n            .get_mut(&from)\n            .unwrap()\n            .extend(to.into_iter().filter(|x| {\n                assert!(*x < limit);\n                true\n            }));\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.neighbors.is_empty()\n    }\n\n    pub fn len(&self) -> usize {\n        self.neighbors.len()\n    }\n}\n\n#[derive(Clone)]\nstruct VertexState {\n    index: usize,\n    low_link: usize,\n    on_stack: bool,\n}\n\n// The easy way not to fight with Rust's borrow checker is moving the state in\n// a structure and simply invoke methods on that structure.\n\npub struct Tarjan<'a> {\n    graph: &'a Graph,\n    index: usize,\n    stack: Vec<usize>,\n    state: Vec<VertexState>,\n    components: Vec<BTreeSet<usize>>,\n}\n\nimpl<'a> Tarjan<'a> {\n    // Having index: Option<usize> would look nicer, but requires just\n    // some unwraps and Vec has actual len limit isize::MAX anyway, so\n    // we can reserve this large value as the invalid one.\n    const INVALID_INDEX: usize = usize::MAX;\n\n    pub fn walk(graph: &'a Graph) -> Vec<BTreeSet<usize>> {\n        Self {\n            graph,\n            index: 0,\n            stack: Vec::new(),\n            state: vec![\n                VertexState {\n                    index: Self::INVALID_INDEX,\n                    low_link: Self::INVALID_INDEX,\n                    on_stack: false\n                };\n                graph.len()\n            ],\n            components: Vec::new(),\n        }\n        .visit_all()\n    }\n\n    fn visit_all(mut self) -> Vec<BTreeSet<usize>> {\n        for vertex in 0..self.graph.len() {\n            if self.state[vertex].index == Self::INVALID_INDEX {\n                self.visit(vertex);\n            }\n        }\n\n        self.components\n    }\n\n    fn visit(&mut self, v: usize) {\n        let v_ref = &mut self.state[v];\n        v_ref.index = self.index;\n        v_ref.low_link = self.index;\n        self.index += 1;\n        self.stack.push(v);\n        v_ref.on_stack = true;\n\n        for w in self.graph.edges(v) {\n            let w_ref = &self.state[w];\n            if w_ref.index == Self::INVALID_INDEX {\n                self.visit(w);\n                let w_low_link = self.state[w].low_link;\n                let v_ref = &mut self.state[v];\n                v_ref.low_link = v_ref.low_link.min(w_low_link);\n            } else if w_ref.on_stack {\n                let w_index = self.state[w].index;\n                let v_ref = &mut self.state[v];\n                v_ref.low_link = v_ref.low_link.min(w_index);\n            }\n        }\n\n        let v_ref = &self.state[v];\n        if v_ref.low_link == v_ref.index {\n            let mut component = BTreeSet::new();\n\n            loop {\n                let w = self.stack.pop().unwrap();\n                self.state[w].on_stack = false;\n                component.insert(w);\n                if w == v {\n                    break;\n                }\n            }\n\n            self.components.push(component);\n        }\n    }\n}\n\nfn main() {\n    let graph = {\n        let mut g = Graph::new(8);\n        g.add_edge(0, 1);\n        g.add_edge(2, 0);\n        g.add_edges(5, vec![2, 6]);\n        g.add_edge(6, 5);\n        g.add_edge(1, 2);\n        g.add_edges(3, vec![1, 2, 4]);\n        g.add_edges(4, vec![5, 3]);\n        g.add_edges(7, vec![4, 7, 6]);\n        g\n    };\n\n    for component in Tarjan::walk(&graph) {\n        println!(\"{:?}\", component);\n    }\n}",
    "title": "Tarjan",
    "url": "http://rosettacode.org/wiki/Tarjan"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// returns the highest power of i that is a factor of n,\n// and n divided by that power of i\nfn factor_exponent(n: i32, i: i32) -> (i32, i32) {\n\tif n % i == 0 {\n\t\tlet (a, b) = factor_exponent(n / i, i);\n\t\t(a + 1, b)\n\t} else {\n\t\t(0, n)\n\t}\n}\n\nfn tau(n: i32) -> i32 {\n\tfor i in 2..(n+1) {\n\t\tif n % i == 0 {\n\t\t\tlet (count, next) = factor_exponent(n, i);\n\t\t\treturn (count + 1) * tau(next);\n\t\t}\n\t}\n\treturn 1;\n}\n\nfn main() {\n\tfor i in 1..101 {\n\t\tprint!(\"{} \", tau(i));\n\t}\n}",
    "title": "Tau function",
    "url": "http://rosettacode.org/wiki/Tau_function"
  },
  {
    "local_code": "/// Gets all divisors of a number, including itself\nfn get_divisors(n: usize) -> Vec<usize> {\n    let mut results = Vec::new();\n\n    for i in 1..=(n / 2) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\nfn is_tau_number(i: usize) -> bool {\n    0 == i % get_divisors(i).len()\n}\n\nfn main() {\n    println!(\"\\nFirst 100 Tau numbers:\");\n    let mut counter: u32 = 0;\n    let mut i = 1;\n    while counter < 100 {\n        if is_tau_number(i) {\n            print!(\"{:>4}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 1;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_tau_number;\n\n    #[test]\n    fn test_is_tau_number() {\n        assert_eq!(is_tau_number(1), true);\n        assert_eq!(is_tau_number(3), false);\n        assert_eq!(is_tau_number(1096), true);\n    }\n}\n",
    "path": "tasks/tau-number",
    "remote_code": "\n/// Gets all divisors of a number, including itself\nfn get_divisors(n: u32) -> Vec<u32> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\nfn is_tau_number(i: u32) -> bool {\n    0 == i % get_divisors(i).len() as u32\n}\n\nfn main() {\n    println!(\"\\nFirst 100 Tau numbers:\");\n    let mut counter: u32 = 0;\n    let mut i: u32 = 1;\n    while counter < 100 {\n        if is_tau_number(i) {\n            print!(\"{:>4}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 1;\n    }\n}\n\n",
    "title": "Tau number",
    "url": "http://rosettacode.org/wiki/Tau_number"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Taxicab_numbers\n\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n/// A type to represent a pair-sum of cubes.\n/// value = a^3 + b^3\n#[derive(Copy, Clone, PartialEq, Eq)]\nstruct SumCubes {\n    a: u64,\n    b: u64,\n    value: u64,\n}\n\nimpl SumCubes {\n    fn new(a: u64, b: u64) -> SumCubes {\n        SumCubes {\n            value: a.pow(3) + b.pow(3),\n            a,\n            b,\n        }\n    }\n}\n\nimpl PartialOrd for SumCubes {\n    fn partial_cmp(&self, other: &SumCubes) -> Option<Ordering> {\n        // Comparison is reversed to make PriorityQueue behave like a min-heap\n        (other.value, other.a, other.b).partial_cmp(&(self.value, self.a, self.b))\n    }\n}\n\nimpl Ord for SumCubes {\n    fn cmp(&self, other: &SumCubes) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\n/// An iterator through all Taxicab numbers\nstruct TaxicabNumbers {\n    /// Use a BinaryHeap as a priority queue to iterate through sums of\n    /// cubes efficiently in increasing order\n    pq: BinaryHeap<SumCubes>,\n}\n\nimpl TaxicabNumbers {\n    fn new() -> TaxicabNumbers {\n        let mut res = TaxicabNumbers {\n            pq: BinaryHeap::new(),\n        };\n        res.pq.push(SumCubes::new(1, 1)); // Start with 1^3 + 1^3\n        res\n    }\n}\n\nimpl Default for TaxicabNumbers {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Iterator for TaxicabNumbers {\n    type Item = Vec<SumCubes>;\n\n    fn next(&mut self) -> Option<Vec<SumCubes>> {\n        let mut ways = Vec::new(); // All the ways we can express the current\n                                   // value as a sum of cubes\n        ways.push(SumCubes::new(0, 0)); // Just a sentinel value\n\n        loop {\n            let nxt = self.pq.pop().unwrap();\n            if nxt.value == ways[0].value {\n                // If the next sum is the same as the current one,\n                // then we found another way to express the current value\n                ways.push(nxt);\n            } else if ways.len() > 1 {\n                // If we can express the current value in more than one ways,\n                // then it's a Taxicab number\n                self.pq.push(nxt);\n                return Some(ways);\n            } else {\n                ways.clear();\n                ways.push(nxt);\n            }\n\n            // Populate the priority queue with more sums\n            self.pq.push(SumCubes::new(nxt.a + 1, nxt.b));\n            if nxt.a == nxt.b {\n                self.pq.push(SumCubes::new(nxt.a + 1, nxt.b + 1));\n            }\n        }\n    }\n}\n\nfn main() {\n    let numbers = TaxicabNumbers::new();\n    for (at, ways) in numbers\n        .take(2006)\n        .enumerate()\n        .filter(|&(at, _)| at < 25 || at + 1 >= 2000)\n    {\n        print!(\"{:>4}:{:>10}\", at + 1, ways[0].value);\n        for &SumCubes { a, b, .. } in &ways {\n            print!(\" = {:>4}^3 + {:>4}^3\", a, b);\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_taxicab_numbers() {\n    // A001235 on OEIS\n    let seq = [\n        1729u64, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808,\n        134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763,\n        373464, 402597, 439101, 443889, 513000, 513856, 515375, 525824, 558441, 593047, 684019,\n        704977,\n    ];\n\n    for (&expected, ways) in seq.iter().zip(TaxicabNumbers::new()) {\n        assert!(ways.len() > 1);\n        for &SumCubes { value, .. } in &ways {\n            assert_eq!(value, expected);\n        }\n    }\n}\n",
    "path": "tasks/taxicab-numbers",
    "remote_code": "\nuse std::collections::HashMap;\nuse itertools::Itertools;\n\nfn cubes(n: u64) -> Vec<u64> {\n\tlet mut cube_vector = Vec::new();\n\tfor i in 1..=n {\n\t\tcube_vector.push(i.pow(3));\n\t}\n\tcube_vector\n}\n\nfn main() {\n\tlet c = cubes(1201);\n\tlet it = c.iter().combinations(2);\n\tlet mut m = HashMap::new();\n\tfor x in it {\n\t\tlet sum = x[0] + x[1];\n\t\tm.entry(sum).or_insert(Vec::new()).push(x)\n\t} \n\t\n\tlet mut result = Vec::new();\n\t\n\tfor (k,v) in m.iter() {\n\t\tif v.len() > 1 {\n\t\t\tresult.push((k,v));\n\t\t}\n\t}\n\t\n\tresult.sort();\n\tfor f in result {\n\t\tprintln!(\"{:?}\", f);\n\t}\n}\n",
    "title": "Taxicab numbers",
    "url": "http://rosettacode.org/wiki/Taxicab_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::BTreeSet;\nuse std::collections::HashSet;\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::iter::FromIterator;\n\nfn load_dictionary(filename: &str) -> std::io::Result<BTreeSet<String>> {\n    let file = File::open(filename)?;\n    let mut dict = BTreeSet::new();\n    for line in io::BufReader::new(file).lines() {\n        let word = line?;\n        dict.insert(word);\n    }\n    Ok(dict)\n}\n\nfn find_teacup_words(dict: &BTreeSet<String>) {\n    let mut teacup_words: Vec<&String> = Vec::new();\n    let mut found: HashSet<&String> = HashSet::new();\n    for word in dict {\n        let len = word.len();\n        if len < 3 || found.contains(word) {\n            continue;\n        }\n        teacup_words.clear();\n        let mut is_teacup_word = true;\n        let mut chars: Vec<char> = word.chars().collect();\n        for _ in 1..len {\n            chars.rotate_left(1);\n            if let Some(w) = dict.get(&String::from_iter(&chars)) {\n                if !w.eq(word) && !teacup_words.contains(&w) {\n                    teacup_words.push(w);\n                }\n            } else {\n                is_teacup_word = false;\n                break;\n            }\n        }\n        if !is_teacup_word || teacup_words.is_empty() {\n            continue;\n        }\n        print!(\"{}\", word);\n        found.insert(word);\n        for w in &teacup_words {\n            found.insert(w);\n            print!(\" {}\", w);\n        }\n        println!();\n    }\n}\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: teacup dictionary\");\n        std::process::exit(1);\n    }\n    let dict = load_dictionary(&args[1]);\n    match dict {\n        Ok(dict) => find_teacup_words(&dict),\n        Err(error) => eprintln!(\"Cannot open file {}: {}\", &args[1], error),\n    }\n}",
    "title": "Teacup rim text",
    "url": "http://rosettacode.org/wiki/Teacup_rim_text"
  },
  {
    "local_code": "use std::env;\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let k: f64 = env::args()\n        .nth(1)\n        .ok_or(\"must supply a temperature\")?\n        .parse()?;\n\n    if k < 0.0 {\n        println!(\"{:2.2} K is below absolute zero\", k);\n    } else {\n        println!(\n            \"K {:2.2}\\nC {:2.2}\\nF {:2.2}\\nR {:2.2}\",\n            k,\n            kelvin_to_celsius(k),\n            kelvin_to_fahrenheit(k),\n            kelvin_to_rankine(k)\n        );\n    }\n\n    Ok(())\n}\n\nfn kelvin_to_celsius(k: f64) -> f64 {\n    k - 273.15\n}\n\nfn kelvin_to_fahrenheit(k: f64) -> f64 {\n    k * 1.8 - 459.67\n}\n\nfn kelvin_to_rankine(k: f64) -> f64 {\n    k * 1.8\n}\n\n#[allow(clippy::float_cmp)]\n#[test]\nfn test() {\n    let k = 21.0;\n    assert_eq!(kelvin_to_celsius(k), -252.14999999999998);\n    assert_eq!(kelvin_to_fahrenheit(k), -421.87);\n    assert_eq!(kelvin_to_rankine(k), 37.800000000000004);\n}\n",
    "path": "tasks/temperature-conversion",
    "remote_code": "fn main() -> std::io::Result<()> {\n    print!(\"Enter temperature in Kelvin to convert: \");\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input)?;\n    match input.trim().parse::<f32>() {\n        Ok(kelvin) => {\n            if kelvin < 0.0 {\n                println!(\"Negative Kelvin values are not acceptable.\");\n            } else {\n                println!(\"{} K\", kelvin);\n                println!(\"{} °C\", kelvin - 273.15);\n                println!(\"{} °F\", kelvin * 1.8 - 459.67);\n                println!(\"{} °R\", kelvin * 1.8);\n            }\n        }\n\n        _ => println!(\"Could not parse the input to a number.\"),\n    }\n\n    Ok(())\n}",
    "title": "Temperature conversion",
    "url": "http://rosettacode.org/wiki/Temperature_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "print!(\"\\x1B[2J\");",
    "title": "Terminal control/Clear the screen",
    "url": "http://rosettacode.org/wiki/Terminal_control/Clear_the_screen"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const ESC: &str = \"\\x1B[\";\nconst RESET: &str = \"\\x1B[0m\";\n\nfn main() {\n    println!(\"Foreground¦Background--------------------------------------------------------------\");\n    print!(\"          ¦\");\n    for i in 40..48 {\n        print!(\" ESC[{}m \", i);\n    }\n    println!(\"\\n----------¦------------------------------------------------------------------------\");\n    for i in 30..38 {\n        print!(\"{}ESC[{}m   ¦{}{1}m\", RESET, i, ESC);\n        for j in 40..48 {\n            print!(\"{}{}m Rosetta \", ESC, j);\n        }\n        println!(\"{}\", RESET);\n        print!(\"{}ESC[{};1m ¦{}{1};1m\", RESET, i, ESC);\n        for j in 40..48 {\n            print!(\"{}{}m Rosetta \", ESC, j);\n        }\n        println!(\"{}\", RESET);\n    }\n}",
    "title": "Terminal control/Coloured text",
    "url": "http://rosettacode.org/wiki/Terminal_control/Coloured_text"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Cursor movement",
    "url": "http://rosettacode.org/wiki/Terminal_control/Cursor_movement"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Cursor positioning",
    "url": "http://rosettacode.org/wiki/Terminal_control/Cursor_positioning"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Dimensions",
    "url": "http://rosettacode.org/wiki/Terminal_control/Dimensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Display an extended character",
    "url": "http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Hiding the cursor",
    "url": "http://rosettacode.org/wiki/Terminal_control/Hiding_the_cursor"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Inverse video",
    "url": "http://rosettacode.org/wiki/Terminal_control/Inverse_video"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Positional read",
    "url": "http://rosettacode.org/wiki/Terminal_control/Positional_read"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io::{stdout, Write};\nuse std::time::Duration;\n\nfn main() {\n    let mut output = stdout();\n\n    print!(\"\\x1b[?1049h\\x1b[H\");\n    println!(\"Alternate screen buffer\");\n\n    for i in (1..=5).rev() {\n        print!(\"\\rgoing back in {}...\", i);\n        output.flush().unwrap();\n        std::thread::sleep(Duration::from_secs(1));\n    }\n\n    print!(\"\\x1b[?1049l\");\n}",
    "title": "Terminal control/Preserve screen",
    "url": "http://rosettacode.org/wiki/Terminal_control/Preserve_screen"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    print!(\"\\x07\");\n}",
    "title": "Terminal control/Ringing the terminal bell",
    "url": "http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Unicode output",
    "url": "http://rosettacode.org/wiki/Terminal_control/Unicode_output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{ops, fmt};\n\n#[derive(Copy, Clone, Debug)]\nenum Trit {\n    True,\n    Maybe,\n    False,\n}\n\nimpl ops::Not for Trit {\n    type Output = Self;\n    fn not(self) -> Self {\n        match self {\n            Trit::True => Trit::False,\n            Trit::Maybe => Trit::Maybe,\n            Trit::False => Trit::True,\n        }\n    }\n}\n\nimpl ops::BitAnd for Trit {\n    type Output = Self;\n    fn bitand(self, other: Self) -> Self {\n        match (self, other) {\n            (Trit::True, Trit::True) => Trit::True,\n            (Trit::False, _) | (_, Trit::False) => Trit::False,\n            _ => Trit::Maybe,\n        }\n    }\n}\n\nimpl ops::BitOr for Trit {\n    type Output = Self;\n    fn bitor(self, other: Self) -> Self {\n        match (self, other) {\n            (Trit::True, _) | (_, Trit::True) => Trit::True,\n            (Trit::False, Trit::False) => Trit::False,\n            _ => Trit::Maybe,\n        }\n    }\n}\n\nimpl Trit {\n    fn imp(self, other: Self) -> Self {\n        match self {\n            Trit::True => other,\n            Trit::Maybe => {\n                if let Trit::True = other {\n                    Trit::True\n                } else {\n                    Trit::Maybe\n                }\n            }\n            Trit::False => Trit::True,\n        }\n    }\n\n    fn eqv(self, other: Self) -> Self {\n        match self {\n            Trit::True => other,\n            Trit::Maybe => Trit::Maybe,\n            Trit::False => !other,\n        }\n    }\n}\n\nimpl fmt::Display for Trit {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            match self {\n                Trit::True => 'T',\n                Trit::Maybe => 'M',\n                Trit::False => 'F',\n            }\n        )\n    }\n}\n\nstatic TRITS: [Trit; 3] = [Trit::True, Trit::Maybe, Trit::False];\n\nfn main() {\n    println!(\"not\");\n    println!(\"-------\");\n    for &t in &TRITS {\n        println!(\" {}  | {}\", t, !t);\n    }\n    \n    table(\"and\", |a, b| a & b);\n    table(\"or\", |a, b| a | b);\n    table(\"imp\", |a, b| a.imp(b));\n    table(\"eqv\", |a, b| a.eqv(b));\n}\n\nfn table(title: &str, f: impl Fn(Trit, Trit) -> Trit) {\n    println!();\n    println!(\"{:3} | T  M  F\", title);\n    println!(\"-------------\");\n    for &t1 in &TRITS {\n        print!(\" {}  | \", t1);\n        for &t2 in &TRITS {\n            print!(\"{}  \", f(t1, t2));\n        }\n        println!();\n    }\n}",
    "title": "Ternary logic",
    "url": "http://rosettacode.org/wiki/Ternary_logic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// Tests if the given string slice is a palindrome (with the respect to\n/// codepoints, not graphemes).\n///\n/// # Examples\n///\n/// ```\n/// # use playground::palindrome::is_palindrome;\n/// assert!(is_palindrome(\"abba\"));\n/// assert!(!is_palindrome(\"baa\"));\n/// ```\npub fn is_palindrome(s: &str) -> bool {\n    let half = s.len();\n    s.chars().take(half).eq(s.chars().rev().take(half))\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::is_palindrome;\n\n    #[test]\n    fn test_is_palindrome() {\n        assert!(is_palindrome(\"abba\"));\n    }\n}",
    "title": "Test a function",
    "url": "http://rosettacode.org/wiki/Test_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Test integerness",
    "url": "http://rosettacode.org/wiki/Test_integerness"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Text processing/1",
    "url": "http://rosettacode.org/wiki/Text_processing/1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Text processing/2",
    "url": "http://rosettacode.org/wiki/Text_processing/2"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "type Timestamp = String;\n\nfn compute_usage<R, S, E>(lines: R) -> Result<(u32, Vec<Timestamp>), E>\nwhere\n    S: AsRef<str>,\n    R: Iterator<Item = Result<S, E>>,\n{\n    let mut timestamps = Vec::new();\n    let mut current = 0;\n    let mut maximum = 0;\n\n    for line in lines {\n        let line = line?;\n        let line = line.as_ref();\n\n        if line.starts_with(\"License IN\") {\n            current -= 1;\n        } else if line.starts_with(\"License OUT\") {\n            current += 1;\n\n            if maximum <= current {\n                let date = line.split_whitespace().nth(3).unwrap().to_string();\n\n                if maximum < current {\n                    maximum = current;\n                    timestamps.clear();\n                }\n\n                timestamps.push(date);\n            }\n        }\n    }\n\n    Ok((maximum, timestamps))\n}\n\nfn main() -> std::io::Result<()> {\n    use std::io::{BufRead, BufReader};\n    let file = std::fs::OpenOptions::new().read(true).open(\"mlijobs.txt\")?;\n    let (max, timestamps) = compute_usage(BufReader::new(file).lines())?;\n    println!(\"Maximum licenses out: {}\", max);\n    println!(\"At time(s): {:?}\", timestamps);\n    Ok(())\n}",
    "title": "Text processing/Max licenses in use",
    "url": "http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufRead};\n\nfn text_char(ch: char) -> Option<char> {\n    match ch {\n        'a' | 'b' | 'c' => Some('2'),\n        'd' | 'e' | 'f' => Some('3'),\n        'g' | 'h' | 'i' => Some('4'),\n        'j' | 'k' | 'l' => Some('5'),\n        'm' | 'n' | 'o' => Some('6'),\n        'p' | 'q' | 'r' | 's' => Some('7'),\n        't' | 'u' | 'v' => Some('8'),\n        'w' | 'x' | 'y' | 'z' => Some('9'),\n        _ => None,\n    }\n}\n\nfn text_string(s: &str) -> Option<String> {\n    let mut text = String::with_capacity(s.len());\n    for c in s.chars() {\n        if let Some(t) = text_char(c) {\n            text.push(t);\n        } else {\n            return None;\n        }\n    }\n    Some(text)\n}\n\nfn print_top_words(textonyms: &Vec<(&String, &Vec<String>)>, top: usize) {\n    for (text, words) in textonyms.iter().take(top) {\n        println!(\"{} = {}\", text, words.join(\", \"));\n    }\n}\n\nfn find_textonyms(filename: &str) -> std::io::Result<()> {\n    let file = File::open(filename)?;\n    let mut table = HashMap::new();\n    let mut count = 0;\n\n    for line in io::BufReader::new(file).lines() {\n        let mut word = line?;\n        word.make_ascii_lowercase();\n        if let Some(text) = text_string(&word) {\n            let words = table.entry(text).or_insert(Vec::new());\n            words.push(word);\n            count += 1;\n        }\n    }\n\n    let mut textonyms: Vec<(&String, &Vec<String>)> =\n        table.iter().filter(|x| x.1.len() > 1).collect();\n\n    println!(\n        \"There are {} words in '{}' which can be represented by the digit key mapping.\",\n        count, filename\n    );\n    println!(\n        \"They require {} digit combinations to represent them.\",\n        table.len()\n    );\n    println!(\n        \"{} digit combinations represent Textonyms.\",\n        textonyms.len()\n    );\n\n    let top = std::cmp::min(5, textonyms.len());\n    textonyms.sort_by_key(|x| (std::cmp::Reverse(x.1.len()), x.0));\n    println!(\"\\nTop {} by number of words:\", top);\n    print_top_words(&textonyms, top);\n\n    textonyms.sort_by_key(|x| (std::cmp::Reverse(x.0.len()), x.0));\n    println!(\"\\nTop {} by length:\", top);\n    print_top_words(&textonyms, top);\n\n    Ok(())\n}\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"usage: {} word-list\", args[0]);\n        std::process::exit(1);\n    }\n    match find_textonyms(&args[1]) {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"{}: {}\", args[1], error),\n    }\n}",
    "title": "Textonyms",
    "url": "http://rosettacode.org/wiki/Textonyms"
  },
  {
    "local_code": "//! includes the XOR version of the encryption scheme\n\nuse std::num::Wrapping as w;\n\nconst MSG: &str = \"a Top Secret secret\";\nconst KEY: &str = \"this is my secret key\";\n\nfn main() {\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let encr = isaac.vernam(MSG.as_bytes());\n\n    println!(\"msg: {}\", MSG);\n    println!(\"key: {}\", KEY);\n    print!(\"XOR: \");\n    for a in &encr {\n        print!(\"{:02X}\", *a);\n    }\n\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let decr = isaac.vernam(&encr[..]);\n\n    print!(\"\\nXOR dcr: \");\n    println!(\"{}\", String::from_utf8(decr).unwrap())\n}\n\nmacro_rules! mix_v(\n   ($a:expr) => (\n   {\n       $a[0] ^= $a[1] << 11; $a[3] += $a[0]; $a[1] += $a[2];\n       $a[1] ^= $a[2] >> 2;  $a[4] += $a[1]; $a[2] += $a[3];\n       $a[2] ^= $a[3] << 8;  $a[5] += $a[2]; $a[3] += $a[4];\n       $a[3] ^= $a[4] >> 16; $a[6] += $a[3]; $a[4] += $a[5];\n       $a[4] ^= $a[5] << 10; $a[7] += $a[4]; $a[5] += $a[6];\n       $a[5] ^= $a[6] >> 4;  $a[0] += $a[5]; $a[6] += $a[7];\n       $a[6] ^= $a[7] << 8;  $a[1] += $a[6]; $a[7] += $a[0];\n       $a[7] ^= $a[0] >> 9;  $a[2] += $a[7]; $a[0] += $a[1];\n   } );\n);\n\nstruct Isaac {\n    mm: [w<u32>; 256],\n    aa: w<u32>,\n    bb: w<u32>,\n    cc: w<u32>,\n    rand_rsl: [w<u32>; 256],\n    rand_cnt: u32,\n}\n\nimpl Isaac {\n    fn new() -> Isaac {\n        Isaac {\n            mm: [w(0u32); 256],\n            aa: w(0),\n            bb: w(0),\n            cc: w(0),\n            rand_rsl: [w(0u32); 256],\n            rand_cnt: 0,\n        }\n    }\n\n    fn isaac(&mut self) {\n        self.cc += w(1);\n        self.bb += self.cc;\n\n        for i in 0..256 {\n            let w(x) = self.mm[i];\n            match i % 4 {\n                0 => self.aa ^= self.aa << 13,\n                1 => self.aa ^= self.aa >> 6,\n                2 => self.aa ^= self.aa << 2,\n                3 => self.aa ^= self.aa >> 16,\n                _ => unreachable!(),\n            }\n\n            self.aa += self.mm[((i + 128) % 256) as usize];\n            let w(y) = self.mm[((x >> 2) % 256) as usize] + self.aa + self.bb;\n            self.bb = self.mm[((y >> 10) % 256) as usize] + w(x);\n            self.rand_rsl[i] = self.bb;\n        }\n\n        self.rand_cnt = 0;\n    }\n\n    fn rand_init(&mut self, flag: bool) {\n        let mut a_v = [w(0x9e37_79b9u32); 8];\n\n        for _ in 0..4 {\n            // scramble it\n            mix_v!(a_v);\n        }\n\n        for i in (0..256).step_by(8) {\n            // fill in mm[] with messy stuff\n            if flag {\n                // use all the information in the seed\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.rand_rsl[i + j];\n                }\n            }\n            mix_v!(a_v);\n            for (j, value) in a_v.iter().enumerate().take(8) {\n                self.mm[i + j] = *value;\n            }\n        }\n\n        if flag {\n            // do a second pass to make all of the seed affect all of mm\n            for i in (0..256).step_by(8) {\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.mm[i + j];\n                }\n                mix_v!(a_v);\n                for (j, value) in a_v.iter().enumerate().take(8) {\n                    self.mm[i + j] = *value;\n                }\n            }\n        }\n\n        self.isaac(); // fill in the first set of results\n        self.rand_cnt = 0; // prepare to use the first set of results\n    }\n\n    /// Get a random 32-bit value\n    fn i_random(&mut self) -> u32 {\n        let r = self.rand_rsl[self.rand_cnt as usize];\n        self.rand_cnt += 1;\n        if self.rand_cnt > 255 {\n            self.isaac();\n            self.rand_cnt = 0;\n        }\n        r.0\n    }\n\n    /// Seed ISAAC with a string\n    fn seed(&mut self, seed: &str, flag: bool) {\n        for i in 0..256 {\n            self.mm[i] = w(0);\n        }\n        for i in 0..256 {\n            self.rand_rsl[i] = w(0);\n        }\n\n        for i in 0..seed.len() {\n            self.rand_rsl[i] = w(u32::from(seed.as_bytes()[i]));\n        }\n        // initialize ISAAC with seed\n        self.rand_init(flag);\n    }\n\n    /// Get a random character in printable ASCII range\n    fn i_rand_ascii(&mut self) -> u8 {\n        (self.i_random() % 95 + 32) as u8\n    }\n\n    /// XOR message\n    fn vernam(&mut self, msg: &[u8]) -> Vec<u8> {\n        msg.iter()\n            .map(|&b| (self.i_rand_ascii() ^ b))\n            .collect::<Vec<u8>>()\n    }\n}\n\nimpl Default for Isaac {\n    fn default() -> Self {\n        Isaac::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Isaac, KEY, MSG};\n    const ENCRIPTED: [u8; 19] = [\n        0x1C, 0x06, 0x36, 0x19, 0x0B, 0x12, 0x60, 0x23, 0x3B, 0x35, 0x12, 0x5F, 0x1E, 0x1D, 0x0E,\n        0x2F, 0x4C, 0x54, 0x22,\n    ];\n\n    #[test]\n    fn encrypt() {\n        let mut isaac = Isaac::new();\n        isaac.seed(KEY, true);\n        let encr = isaac.vernam(MSG.as_bytes());\n\n        for (a, b) in encr.iter().zip(ENCRIPTED.iter()) {\n            assert_eq!(a, b);\n        }\n    }\n\n    #[test]\n    fn decrypt() {\n        let expected = MSG;\n\n        let mut isaac = Isaac::new();\n        isaac.seed(KEY, true);\n        let decr = isaac.vernam(&ENCRIPTED[..]);\n\n        for (&a, b) in decr.iter().zip(expected.bytes()) {\n            assert_eq!(a, b);\n        }\n    }\n}\n",
    "path": "tasks/the-isaac-cipher",
    "remote_code": null,
    "title": "The ISAAC Cipher",
    "url": "http://rosettacode.org/wiki/The_ISAAC_Cipher"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n//! includes the XOR version of the encryption scheme\n\nuse std::num::Wrapping as w;\n\nconst MSG: &str = \"a Top Secret secret\";\nconst KEY: &str = \"this is my secret key\";\n\nfn main() {\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let encr = isaac.vernam(MSG.as_bytes());\n\n    println!(\"msg: {}\", MSG);\n    println!(\"key: {}\", KEY);\n    print!(\"XOR: \");\n    for a in &encr {\n        print!(\"{:02X}\", *a);\n    }\n\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let decr = isaac.vernam(&encr[..]);\n\n    print!(\"\\nXOR dcr: \");\n    println!(\"{}\", String::from_utf8(decr).unwrap())\n}\n\nmacro_rules! mix_v(\n   ($a:expr) => (\n   {\n       $a[0] ^= $a[1] << 11; $a[3] += $a[0]; $a[1] += $a[2];\n       $a[1] ^= $a[2] >> 2;  $a[4] += $a[1]; $a[2] += $a[3];\n       $a[2] ^= $a[3] << 8;  $a[5] += $a[2]; $a[3] += $a[4];\n       $a[3] ^= $a[4] >> 16; $a[6] += $a[3]; $a[4] += $a[5];\n       $a[4] ^= $a[5] << 10; $a[7] += $a[4]; $a[5] += $a[6];\n       $a[5] ^= $a[6] >> 4;  $a[0] += $a[5]; $a[6] += $a[7];\n       $a[6] ^= $a[7] << 8;  $a[1] += $a[6]; $a[7] += $a[0];\n       $a[7] ^= $a[0] >> 9;  $a[2] += $a[7]; $a[0] += $a[1];\n   } );\n);\n\nstruct Isaac {\n    mm: [w<u32>; 256],\n    aa: w<u32>,\n    bb: w<u32>,\n    cc: w<u32>,\n    rand_rsl: [w<u32>; 256],\n    rand_cnt: u32,\n}\n\nimpl Isaac {\n    fn new() -> Isaac {\n        Isaac {\n            mm: [w(0u32); 256],\n            aa: w(0),\n            bb: w(0),\n            cc: w(0),\n            rand_rsl: [w(0u32); 256],\n            rand_cnt: 0,\n        }\n    }\n\n    fn isaac(&mut self) {\n        self.cc += w(1);\n        self.bb += self.cc;\n\n        for i in 0..256 {\n            let w(x) = self.mm[i];\n            match i % 4 {\n                0 => self.aa ^= self.aa << 13,\n                1 => self.aa ^= self.aa >> 6,\n                2 => self.aa ^= self.aa << 2,\n                3 => self.aa ^= self.aa >> 16,\n                _ => unreachable!(),\n            }\n\n            self.aa += self.mm[((i + 128) % 256) as usize];\n            let w(y) = self.mm[((x >> 2) % 256) as usize] + self.aa + self.bb;\n            self.bb = self.mm[((y >> 10) % 256) as usize] + w(x);\n            self.rand_rsl[i] = self.bb;\n        }\n\n        self.rand_cnt = 0;\n    }\n\n    fn rand_init(&mut self, flag: bool) {\n        let mut a_v = [w(0x9e37_79b9u32); 8];\n\n        for _ in 0..4 {\n            // scramble it\n            mix_v!(a_v);\n        }\n\n        for i in (0..256).step_by(8) {\n            // fill in mm[] with messy stuff\n            if flag {\n                // use all the information in the seed\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.rand_rsl[i + j];\n                }\n            }\n            mix_v!(a_v);\n            for (j, value) in a_v.iter().enumerate().take(8) {\n                self.mm[i + j] = *value;\n            }\n        }\n\n        if flag {\n            // do a second pass to make all of the seed affect all of mm\n            for i in (0..256).step_by(8) {\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.mm[i + j];\n                }\n                mix_v!(a_v);\n                for (j, value) in a_v.iter().enumerate().take(8) {\n                    self.mm[i + j] = *value;\n                }\n            }\n        }\n\n        self.isaac(); // fill in the first set of results\n        self.rand_cnt = 0; // prepare to use the first set of results\n    }\n\n    /// Get a random 32-bit value\n    fn i_random(&mut self) -> u32 {\n        let r = self.rand_rsl[self.rand_cnt as usize];\n        self.rand_cnt += 1;\n        if self.rand_cnt > 255 {\n            self.isaac();\n            self.rand_cnt = 0;\n        }\n        r.0\n    }\n\n    /// Seed ISAAC with a string\n    fn seed(&mut self, seed: &str, flag: bool) {\n        for i in 0..256 {\n            self.mm[i] = w(0);\n        }\n        for i in 0..256 {\n            self.rand_rsl[i] = w(0);\n        }\n\n        for i in 0..seed.len() {\n            self.rand_rsl[i] = w(u32::from(seed.as_bytes()[i]));\n        }\n        // initialize ISAAC with seed\n        self.rand_init(flag);\n    }\n\n    /// Get a random character in printable ASCII range\n    fn i_rand_ascii(&mut self) -> u8 {\n        (self.i_random() % 95 + 32) as u8\n    }\n\n    /// XOR message\n    fn vernam(&mut self, msg: &[u8]) -> Vec<u8> {\n        msg.iter()\n            .map(|&b| (self.i_rand_ascii() ^ b))\n            .collect::<Vec<u8>>()\n    }\n}\n\nimpl Default for Isaac {\n    fn default() -> Self {\n        Isaac::new()\n    }\n}\n\n",
    "title": "The ISAAC cipher",
    "url": "http://rosettacode.org/wiki/The_ISAAC_cipher"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "The Name Game",
    "url": "http://rosettacode.org/wiki/The_Name_Game"
  },
  {
    "local_code": "fn main() {\n    let days = [\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n        \"tenth\", \"eleventh\", \"twelfth\",\n    ];\n\n    let gifts = [\n        \"A Partridge in a Pear Tree\",\n        \"Two Turtle Doves and\",\n        \"Three French Hens\",\n        \"Four Calling Birds\",\n        \"Five Golden Rings\",\n        \"Six Geese a Laying\",\n        \"Seven Swans a Swimming\",\n        \"Eight Maids a Milking\",\n        \"Nine Ladies Dancing\",\n        \"Ten Lords a Leaping\",\n        \"Eleven Pipers Piping\",\n        \"Twelve Drummers Drumming\",\n    ];\n\n    #[allow(clippy::needless_range_loop)]\n    for i in 0..12 {\n        println!(\"On the {} day of Christmas,\", days[i]);\n        println!(\"My true love gave to me:\");\n\n        for j in (0..i + 1).rev() {\n            println!(\"{}\", gifts[j]);\n        }\n        println!()\n    }\n}\n",
    "path": "tasks/the-twelve-days-of-christmas",
    "remote_code": "fn main() {\n    let days = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\",\n                \"ninth\", \"tenth\", \"eleventh\", \"twelfth\"];\n\n    let gifts = [\"A Patridge in a Pear Tree\",\n                 \"Two Turtle Doves and\",\n                 \"Three French Hens\",\n                 \"Four Calling Birds\",\n                 \"Five Golden Rings\",\n                 \"Six Geese a Laying\",\n                 \"Seven Swans a Swimming\",\n                 \"Eight Maids a Milking\",\n                 \"Nine Ladies Dancing\",\n                 \"Ten Lords a Leaping\",\n                 \"Eleven Pipers Piping\",\n                 \"Twelve Drummers Drumming\"];\n\n    for i in 0..12 {\n        println!(\"On the {} day of Christmas,\", days[i]);\n        println!(\"My true love gave to me:\");\n\n        for j in (0..i + 1).rev() {\n            println!(\"{}\", gifts[j]);\n        }\n        println!()\n    }\n}",
    "title": "The Twelve Days of Christmas",
    "url": "http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "The sieve of Sundaram",
    "url": "http://rosettacode.org/wiki/The_sieve_of_Sundaram"
  },
  {
    "local_code": "const N: usize = 32;\nconst STEP: f64 = 0.05;\n\nfn main() {\n    let x: Vec<f64> = (0..N).map(|i| i as f64 * STEP).collect();\n    let sin = x.iter().map(|x| x.sin()).collect::<Vec<_>>();\n    let cos = x.iter().map(|x| x.cos()).collect::<Vec<_>>();\n    let tan = x.iter().map(|x| x.tan()).collect::<Vec<_>>();\n\n    println!(\n        \"{}\\n{}\\n{}\",\n        6. * thiele(&sin, &x, 0.5),\n        3. * thiele(&cos, &x, 0.5),\n        4. * thiele(&tan, &x, 1.)\n    );\n}\n\nfn thiele(x: &[f64], y: &[f64], xin: f64) -> f64 {\n    let mut p: Vec<Vec<f64>> = (0..N).map(|i| (i..N).map(|_| 0.0).collect()).collect();\n\n    (0..N).for_each(|i| p[i][0] = y[i]);\n\n    (0..N - 1).for_each(|i| p[i][1] = (x[i] - x[i + 1]) / (p[i][0] - p[i + 1][0]));\n\n    (2..N).for_each(|i| {\n        (0..N - i).for_each(|j| {\n            p[j][i] = (x[j] - x[j + i]) / (p[j][i - 1] - p[j + 1][i - 1]) + p[j + 1][i - 2];\n        })\n    });\n\n    let mut a = 0.;\n    (2..N).rev().for_each(|i| {\n        a = (xin - x[i - 1]) / (p[0][i] - p[0][i - 2] + a);\n    });\n    y[0] + (xin - x[0]) / (p[0][1] + a)\n}\n",
    "path": "tasks/thieles-interpolation-formula",
    "remote_code": "\nconst N: usize = 32;\nconst STEP: f64 = 0.05;\n\nfn main() {\n    let x: Vec<f64> = (0..N).map(|i| i as f64 * STEP).collect();\n    let sin = x.iter().map(|x| x.sin()).collect::<Vec<_>>();\n    let cos = x.iter().map(|x| x.cos()).collect::<Vec<_>>();\n    let tan = x.iter().map(|x| x.tan()).collect::<Vec<_>>();\n\n    println!(\n        \"{}\\n{}\\n{}\",\n        6. * thiele(&sin, &x, 0.5),\n        3. * thiele(&cos, &x, 0.5),\n        4. * thiele(&tan, &x, 1.)\n    );\n}\n\nfn thiele(x: &[f64], y: &[f64], xin: f64) -> f64 {\n    let mut p: Vec<Vec<f64>> = (0..N).map(|i| (i..N).map(|_| 0.0).collect()).collect();\n\n    (0..N).for_each(|i| p[i][0] = y[i]);\n\n    (0..N - 1).for_each(|i| p[i][1] = (x[i] - x[i + 1]) / (p[i][0] - p[i + 1][0]));\n\n    (2..N).for_each(|i| {\n        (0..N - i).for_each(|j| {\n            p[j][i] = (x[j] - x[j + i]) / (p[j][i - 1] - p[j + 1][i - 1]) + p[j + 1][i - 2];\n        })\n    });\n\n    let mut a = 0.;\n    (2..N).rev().for_each(|i| {\n        a = (xin - x[i - 1]) / (p[0][i] - p[0][i - 2] + a);\n    });\n    y[0] + (xin - x[0]) / (p[0][1] + a)\n}\n\n",
    "title": "Thiele's interpolation formula",
    "url": "http://rosettacode.org/wiki/Thiele's_interpolation_formula"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const ITERATIONS: usize = 8;\n\nfn neg(sequence: &String) -> String {\n    sequence.chars()\n        .map(|ch| {\n            (1 - ch.to_digit(2).unwrap()).to_string()\n        })\n        .collect::<String>()\n}\n\nfn main() {\n    let mut sequence: String = String::from(\"0\");\n    for i in 0..ITERATIONS {\n        println!(\"{}: {}\", i + 1, sequence);\n        sequence = format!(\"{}{}\", sequence, neg(&sequence));\n    }\n}",
    "title": "Thue-Morse",
    "url": "http://rosettacode.org/wiki/Thue-Morse"
  },
  {
    "local_code": "extern crate rand;\n\nuse GameState::{ComputerWin, Draw, PlayerWin, Playing};\n\nuse rand::prelude::*;\n\n#[derive(PartialEq, Debug)]\nenum GameState {\n    PlayerWin,\n    ComputerWin,\n    Draw,\n    Playing,\n}\n\ntype Board = [[char; 3]; 3];\n\nfn main() {\n    let mut rng = StdRng::from_entropy();\n\n    let mut board: Board = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']];\n\n    draw_board(board);\n    loop {\n        player_turn(&mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        computer_turn(&mut rng, &mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        draw_board(board);\n    }\n\n    draw_board(board);\n    let announcement = match check_win(board) {\n        PlayerWin => \"The Player has won!\",\n        ComputerWin => \"The Computer has won!\",\n        Draw => \"Draw!\",\n        Playing => unreachable!(),\n    };\n    println!(\"{}\", announcement);\n}\n\nfn is_empty(cell: &char) -> bool {\n    *cell != 'X' && *cell != 'O'\n}\n\nfn check_win(board: Board) -> GameState {\n    // check for win\n    for (i, row) in board.iter().enumerate() {\n        if row[0] == row[1] && row[0] == row[2] {\n            return which_win(row[0]);\n        } else if board[0][i] == board[1][i] && board[0][i] == board[2][i] {\n            return which_win(board[0][i]);\n        }\n    }\n    if board[0][0] == board[1][1] && board[0][0] == board[2][2] {\n        return which_win(board[0][0]);\n    } else if board[0][2] == board[1][1] && board[0][2] == board[2][0] {\n        return which_win(board[0][2]);\n    }\n\n    // check if it's not a draw\n    let is_draw = board.iter().flatten().any(is_empty);\n    if is_draw {\n        Playing\n    } else {\n        Draw\n    }\n}\n\nfn which_win(s: char) -> GameState {\n    match s {\n        'X' => PlayerWin,\n        'O' => ComputerWin,\n        _ => unreachable!(),\n    }\n}\n\nfn player_turn(board: &mut Board) {\n    use std::io;\n\n    println!(\"Player, enter your field of choice!: \");\n    let mut ln = String::new();\n    io::stdin()\n        .read_line(&mut ln)\n        .expect(\"Failed to read stdin\");\n    let choice = ln.trim().parse::<usize>().expect(\"Failed to parse input\");\n    let row = (choice - 1) / 3;\n    let col = (choice - 1) % 3;\n\n    if board[row][col] == 'X' || board[row][col] == 'O' {\n        println!(\"Someone already took this field!\");\n        player_turn(board);\n    } else {\n        board[row][col] = 'X';\n    }\n}\n\nfn computer_turn<R: Rng>(rng: &mut R, board: &mut Board) {\n    let possible_choices: Vec<_> = board\n        .iter()\n        .flatten()\n        .enumerate()\n        .filter(|&(_, c)| is_empty(c))\n        .map(|(i, _)| i)\n        .collect();\n\n    let choice = possible_choices.choose(rng).unwrap();\n    println!(\"Computer chose: {}\", choice);\n    let row = choice / 3;\n    let col = choice % 3;\n    board[row][col] = 'O';\n}\n\nfn draw_board(board: Board) {\n    for row in &board {\n        println!(\"{} {} {}\", row[0], row[1], row[2]);\n    }\n}\n\n#[test]\nfn test_which_win() {\n    assert_eq!(which_win('X'), PlayerWin);\n    assert_eq!(which_win('O'), ComputerWin);\n}\n\n#[test]\nfn test_check_win() {\n    assert_eq!(\n        check_win([['X', 'X', 'X'], ['4', 'O', 'O'], ['7', '8', '9']]),\n        PlayerWin\n    );\n    assert_eq!(\n        check_win([['O', 'X', '3'], ['X', 'O', '6'], ['X', '8', 'O']]),\n        ComputerWin\n    );\n    assert_eq!(\n        check_win([['O', 'X', 'X'], ['X', 'O', 'O'], ['O', 'X', 'X']]),\n        Draw\n    );\n}\n",
    "path": "tasks/tic-tac-toe",
    "remote_code": "\nuse GameState::{ComputerWin, Draw, PlayerWin, Playing};\n\nuse rand::prelude::*;\n\n#[derive(PartialEq, Debug)]\nenum GameState {\n    PlayerWin,\n    ComputerWin,\n    Draw,\n    Playing,\n}\n\ntype Board = [[char; 3]; 3];\n\nfn main() {\n    let mut rng = StdRng::from_entropy();\n\n    let mut board: Board = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']];\n\n    draw_board(board);\n    loop {\n        player_turn(&mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        computer_turn(&mut rng, &mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        draw_board(board);\n    }\n\n    draw_board(board);\n    let announcement = match check_win(board) {\n        PlayerWin => \"The Player has won!\",\n        ComputerWin => \"The Computer has won!\",\n        Draw => \"Draw!\",\n        Playing => unreachable!(),\n    };\n    println!(\"{}\", announcement);\n}\n\nfn is_empty(cell: &char) -> bool {\n    *cell != 'X' && *cell != 'O'\n}\n\nfn check_win(board: Board) -> GameState {\n    // check for win\n    for (i, row) in board.iter().enumerate() {\n        if row[0] == row[1] && row[0] == row[2] {\n            return which_win(row[0]);\n        } else if board[0][i] == board[1][i] && board[0][i] == board[2][i] {\n            return which_win(board[0][i]);\n        }\n    }\n    if board[0][0] == board[1][1] && board[0][0] == board[2][2] {\n        return which_win(board[0][0]);\n    } else if board[0][2] == board[1][1] && board[0][2] == board[2][0] {\n        return which_win(board[0][2]);\n    }\n\n    // check if it's not a draw\n    let is_draw = board.iter().flatten().any(is_empty);\n    if is_draw {\n        Playing\n    } else {\n        Draw\n    }\n}\n\nfn which_win(s: char) -> GameState {\n    match s {\n        'X' => PlayerWin,\n        'O' => ComputerWin,\n        _ => unreachable!(),\n    }\n}\n\nfn player_turn(board: &mut Board) {\n    use std::io;\n\n    println!(\"Player, enter your field of choice!: \");\n    let mut ln = String::new();\n    io::stdin()\n        .read_line(&mut ln)\n        .expect(\"Failed to read stdin\");\n    let choice = ln.trim().parse::<usize>().expect(\"Failed to parse input\");\n    let row = (choice - 1) / 3;\n    let col = (choice - 1) % 3;\n\n    if board[row][col] == 'X' || board[row][col] == 'O' {\n        println!(\"Someone already took this field!\");\n        player_turn(board);\n    } else {\n        board[row][col] = 'X';\n    }\n}\n\nfn computer_turn<R: Rng>(rng: &mut R, board: &mut Board) {\n    let possible_choices: Vec<_> = board\n        .iter()\n        .flatten()\n        .enumerate()\n        .filter(|&(_, c)| is_empty(c))\n        .map(|(i, _)| i)\n        .collect();\n\n    let choice = possible_choices.choose(rng).unwrap();\n    println!(\"Computer chose: {}\", choice);\n    let row = choice / 3;\n    let col = choice % 3;\n    board[row][col] = 'O';\n}\n\nfn draw_board(board: Board) {\n    for row in &board {\n        println!(\"{} {} {}\", row[0], row[1], row[2]);\n    }\n}\n\n",
    "title": "Tic-tac-toe",
    "url": "http://rosettacode.org/wiki/Tic-tac-toe"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// 20210224 Rust programming solution\n\nuse rand::Rng;\nuse std::time::{Instant};\n\nfn custom_function() {\n \n   let mut i = 0;\n   let mut rng = rand::thread_rng();\n   let n1: f32 = rng.gen();\n\n   while i < ( 1000000 + 1000000 * ( n1.log10() as i32 ) ) {\n      i = i + 1;\n   }\n}\n\nfn main() {\n\n   let start = Instant::now();\n   custom_function();\n   let duration = start.elapsed();\n\n   println!(\"Time elapsed in the custom_function() is : {:?}\", duration);\n}\n",
    "title": "Time a function",
    "url": "http://rosettacode.org/wiki/Time_a_function"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Tokenize_a_string\n\nfn main() {\n    let s = \"Hello,How,Are,You,Today\";\n    let tokens: Vec<&str> = s.split(',').collect();\n    println!(\"{}\", tokens.join(\".\"));\n}\n",
    "path": "tasks/tokenize-a-string",
    "remote_code": "fn main() {\n    let s = \"Hello,How,Are,You,Today\";\n    let tokens: Vec<&str> = s.split(\",\").collect();\n    println!(\"{}\", tokens.join(\".\"));\n}",
    "title": "Tokenize a string",
    "url": "http://rosettacode.org/wiki/Tokenize_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const SEPARATOR: char = '|';\nconst ESCAPE: char = '^';\nconst STRING: &str = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n\nfn tokenize(string: &str) -> Vec<String> {\n    let mut token = String::new();\n    let mut tokens: Vec<String> = Vec::new();\n    let mut chars = string.chars();\n    while let Some(ch) = chars.next() {\n        match ch {\n            SEPARATOR => {\n                tokens.push(token);\n                token = String::new();\n            },\n            ESCAPE => {\n                if let Some(next) = chars.next() {\n                    token.push(next);\n                }\n            },\n            _ => token.push(ch),\n        }\n    }\n    tokens.push(token);\n    tokens\n}\n\nfn main() {\n    println!(\"{:#?}\", tokenize(STRING));\n}",
    "title": "Tokenize a string with escaping",
    "url": "http://rosettacode.org/wiki/Tokenize_a_string_with_escaping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Tonelli-Shanks algorithm",
    "url": "http://rosettacode.org/wiki/Tonelli-Shanks_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Debug)]\nstruct Employee<S> {\n    // Allow S to be any suitable string representation\n    id: S,\n    name: S,\n    department: S,\n    salary: u32,\n}\n\nimpl<S> Employee<S> {\n    fn new(name: S, id: S, salary: u32, department: S) -> Self {\n        Self {\n            id,\n            name,\n            department,\n            salary,\n        }\n    }\n}\n\n#[rustfmt::skip]\nfn load_data() -> Vec<Employee<&'static str>> {\n    vec![\n        Employee::new(\"Tyler Bennett\",    \"E10297\", 32000, \"D101\"),\n        Employee::new(\"John Rappl\",       \"E21437\", 47000, \"D050\"),\n        Employee::new(\"George Woltman\",   \"E00127\", 53500, \"D101\"),\n        Employee::new(\"Adam Smith\",       \"E63535\", 18000, \"D202\"),\n        Employee::new(\"Claire Buckman\",   \"E39876\", 27800, \"D202\"),\n        Employee::new(\"David McClellan\",  \"E04242\", 41500, \"D101\"),\n        Employee::new(\"Rich Holcomb\",     \"E01234\", 49500, \"D202\"),\n        Employee::new(\"Nathan Adams\",     \"E41298\", 21900, \"D050\"),\n        Employee::new(\"Richard Potter\",   \"E43128\", 15900, \"D101\"),\n        Employee::new(\"David Motsinger\",  \"E27002\", 19250, \"D202\"),\n        Employee::new(\"Tim Sampair\",      \"E03033\", 27000, \"D101\"),\n        Employee::new(\"Kim Arlich\",       \"E10001\", 57000, \"D190\"),\n        Employee::new(\"Timothy Grove\",    \"E16398\", 29900, \"D190\"),\n        // Added to demonstrate various tie situations\n        Employee::new(\"Kim Tie\",          \"E16400\", 57000, \"D190\"),\n        Employee::new(\"Timothy Tie\",      \"E16401\", 29900, \"D190\"),\n        Employee::new(\"Timothy Kim\",      \"E16401\", 19900, \"D190\"),\n    ]\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let n = {\n        println!(\"How many top salaries to list? \");\n        let mut buf = String::new();\n        std::io::stdin().read_line(&mut buf)?;\n        buf.trim().parse::<u32>()?\n    };\n\n    let mut employees = load_data();\n\n    // Reverse order, then just pick top N employees\n    employees.sort_by(|a, b| b.salary.cmp(&a.salary));\n\n    let sorted = employees\n        .into_iter()\n        .fold(std::collections::BTreeMap::new(), |mut acc, next| {\n            // We store the number of unique salaries as well to handle\n            // ties (and list always all employees with the same salary)\n            let mut bucket = acc\n                .entry(next.department)\n                .or_insert_with(|| (0, Vec::<Employee<_>>::new()));\n\n            match bucket.1.last().map(|e| e.salary) {\n                Some(last_salary) if last_salary == next.salary => {\n                    if bucket.0 <= n {\n                        bucket.1.push(next);\n                    }\n                }\n\n                _ => {\n                    if bucket.0 < n {\n                        bucket.0 += 1; // Next unique salary\n                        bucket.1.push(next);\n                    }\n                }\n            }\n\n            acc\n        });\n\n    for (department, (_, employees)) in sorted {\n        println!(\"{}\", department);\n\n        employees\n            .iter()\n            .for_each(|employee| println!(\"    {:?}\", employee));\n    }\n\n    Ok(())\n}",
    "title": "Top rank per group",
    "url": "http://rosettacode.org/wiki/Top_rank_per_group"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Topic variable",
    "url": "http://rosettacode.org/wiki/Topic_variable"
  },
  {
    "local_code": "use std::boxed::Box;\nuse std::collections::{HashMap, HashSet};\nuse std::env;\n\n/// model a VHDL library\n#[derive(Debug, PartialEq, Eq, Hash)]\nstruct Library<'a> {\n    name: &'a str,\n    children: Vec<&'a str>,\n    num_parents: usize,\n}\n\n/// transform raw input into a DAG structure for later sorting\nfn build_libraries(input: Vec<&str>) -> HashMap<&str, Box<Library>> {\n    let mut libraries: HashMap<&str, Box<Library>> = HashMap::new();\n\n    for input_line in input {\n        let line_split = input_line.split_whitespace().collect::<Vec<&str>>();\n        let name = line_split.get(0).unwrap();\n        let mut num_parents: usize = 0;\n        for parent in line_split.iter().skip(1) {\n            if parent == name {\n                continue;\n            }\n            if !libraries.contains_key(parent) {\n                libraries.insert(\n                    parent,\n                    Box::new(Library {\n                        name: parent,\n                        children: vec![name],\n                        num_parents: 0,\n                    }),\n                );\n            } else {\n                libraries.get_mut(parent).unwrap().children.push(name);\n            }\n            num_parents += 1;\n        }\n\n        if !libraries.contains_key(name) {\n            libraries.insert(\n                name,\n                Box::new(Library {\n                    name,\n                    children: Vec::new(),\n                    num_parents,\n                }),\n            );\n        } else {\n            libraries.get_mut(name).unwrap().num_parents = num_parents;\n        }\n    }\n    libraries\n}\n\n/// an implementation of Kahn's algorithm for topological sorting\n/// It will correctly detect cycles too.\nfn topological_sort<'a>(\n    mut libraries: HashMap<&'a str, Box<Library<'a>>>,\n) -> Result<Vec<&'a str>, String> {\n    let mut needs_processing = libraries\n        .iter()\n        .map(|(k, _v)| <&str>::clone(k))\n        .collect::<HashSet<&str>>();\n    let mut options: Vec<&str> = libraries\n        .iter()\n        .filter(|(_k, v)| v.num_parents == 0)\n        .map(|(k, _v)| *k)\n        .collect();\n    let mut sorted: Vec<&str> = Vec::new();\n    while !options.is_empty() {\n        let cur = options.pop().unwrap();\n        for children in libraries\n            .get_mut(cur)\n            .unwrap()\n            .children\n            .drain(0..)\n            .collect::<Vec<&str>>()\n        {\n            let child = libraries.get_mut(children).unwrap();\n            child.num_parents -= 1;\n            if child.num_parents == 0 {\n                options.push(child.name)\n            }\n        }\n        sorted.push(cur);\n        needs_processing.remove(cur);\n    }\n    match needs_processing.is_empty() {\n        true => Ok(sorted),\n        false => Err(format!(\"Cycle detected among {:?}\", needs_processing)),\n    }\n}\n\n/// Execute `cargo run` in your shell to print the sorted output.\n/// To run it with a cycle, execute `cargo run -- cycle`.\nfn main() {\n    // see if the user wants to see the sort detect a cycle\n    let add_cycle = env::args().nth(1).is_some();\n    let mut input: Vec<&str> = vec![\n        \"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\",\n        \"dw01             ieee dw01 dware gtech \\n\",\n        \"dw02             ieee dw02 dware\\n\",\n        \"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\",\n        \"dw04             dw04 ieee dw01 dware gtech\\n\",\n        \"dw05             dw05 ieee dware\\n\",\n        \"dw06             dw06 ieee dware\\n\",\n        \"dw07             ieee dware\\n\",\n        \"dware            ieee dware\\n\",\n        \"gtech            ieee gtech\\n\",\n        \"ramlib           std ieee\\n\",\n        \"std_cell_lib     ieee std_cell_lib\\n\",\n        \"synopsys\\n\",\n    ];\n    if add_cycle {\n        input[1] = \"dw01             ieee dw01 dware gtech dw04\\n\";\n    }\n\n    let libraries = build_libraries(input);\n    match topological_sort(libraries) {\n        Ok(sorted) => println!(\"{:?}\", sorted),\n        Err(msg) => println!(\"{:?}\", msg),\n    }\n}\n",
    "path": "tasks/sorting-algorithms/topological-sort",
    "remote_code": "use std::boxed::Box;\nuse std::collections::{HashMap, HashSet};\n\n#[derive(Debug, PartialEq, Eq, Hash)]\nstruct Library<'a> {\n    name: &'a str,\n    children: Vec<&'a str>,\n    num_parents: usize,\n}\n\nfn build_libraries(input: Vec<&str>) -> HashMap<&str, Box<Library>> {\n    let mut libraries: HashMap<&str, Box<Library>> = HashMap::new();\n\n    for input_line in input {\n        let line_split = input_line.split_whitespace().collect::<Vec<&str>>();\n        let name = line_split.get(0).unwrap();\n        let mut num_parents: usize = 0;\n        for parent in line_split.iter().skip(1) {\n            if parent == name {\n                continue;\n            }\n            if !libraries.contains_key(parent) {\n                libraries.insert(\n                    parent,\n                    Box::new(Library {\n                        name: parent,\n                        children: vec![name],\n                        num_parents: 0,\n                    }),\n                );\n            } else {\n                libraries.get_mut(parent).unwrap().children.push(name);\n            }\n            num_parents += 1;\n        }\n\n        if !libraries.contains_key(name) {\n            libraries.insert(\n                name,\n                Box::new(Library {\n                    name,\n                    children: Vec::new(),\n                    num_parents,\n                }),\n            );\n        } else {\n            libraries.get_mut(name).unwrap().num_parents = num_parents;\n        }\n    }\n    libraries\n}\n\nfn topological_sort<'a>(\n    mut libraries: HashMap<&'a str, Box<Library<'a>>>,\n) -> Result<Vec<&'a str>, String> {\n    let mut needs_processing = libraries\n        .iter()\n        .map(|(k, _v)| k.clone())\n        .collect::<HashSet<&str>>();\n    let mut options: Vec<&str> = libraries\n        .iter()\n        .filter(|(_k, v)| v.num_parents == 0)\n        .map(|(k, _v)| *k)\n        .collect();\n    let mut sorted: Vec<&str> = Vec::new();\n    while !options.is_empty() {\n        let cur = options.pop().unwrap();\n        for children in libraries\n            .get_mut(cur)\n            .unwrap()\n            .children\n            .drain(0..)\n            .collect::<Vec<&str>>()\n        {\n            let child = libraries.get_mut(children).unwrap();\n            child.num_parents -= 1;\n            if child.num_parents == 0 {\n                options.push(child.name)\n            }\n        }\n        sorted.push(cur);\n        needs_processing.remove(cur);\n    }\n    match needs_processing.is_empty() {\n        true => Ok(sorted),\n        false => Err(format!(\"Cycle detected among {:?}\", needs_processing)),\n    }\n}\n\nfn main() {\n    let input: Vec<&str> = vec![\n        \"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\",\n        \"dw01             ieee dw01 dware gtech dw04\\n\",\n        \"dw02             ieee dw02 dware\\n\",\n        \"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\",\n        \"dw04             dw04 ieee dw01 dware gtech\\n\",\n        \"dw05             dw05 ieee dware\\n\",\n        \"dw06             dw06 ieee dware\\n\",\n        \"dw07             ieee dware\\n\",\n        \"dware            ieee dware\\n\",\n        \"gtech            ieee gtech\\n\",\n        \"ramlib           std ieee\\n\",\n        \"std_cell_lib     ieee std_cell_lib\\n\",\n        \"synopsys\\n\",\n    ];\n\n    let libraries = build_libraries(input);\n    match topological_sort(libraries) {\n        Ok(sorted) => println!(\"{:?}\", sorted),\n        Err(msg) => println!(\"{:?}\", msg),\n    }\n}\n",
    "title": "Topological sort",
    "url": "http://rosettacode.org/wiki/Topological_sort"
  },
  {
    "local_code": "use itertools::Itertools;\n\nfn solve(deck: &[usize]) -> usize {\n    let mut counter = 0_usize;\n    let mut shuffle = deck.to_vec();\n    loop {\n        let p0 = shuffle[0];\n        if p0 == 1 {\n            break;\n        }\n        shuffle[..p0].reverse();\n        counter += 1;\n    }\n\n    counter\n}\n\n// this is a naive method which tries all permutations and works up to ~12 cards\nfn topswops(number: usize) -> usize {\n    (1..=number)\n        .permutations(number)\n        .fold(0_usize, |mut acc, p| {\n            let steps = solve(&p);\n            if steps > acc {\n                acc = steps;\n            }\n            acc\n        })\n}\nfn main() {\n    (1_usize..=10).for_each(|x| println!(\"{}: {}\", x, topswops(x)));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_topswops() {\n        assert_eq!(topswops(1), 0);\n        assert_eq!(topswops(9), 30);\n    }\n}\n",
    "path": "tasks/topswops",
    "remote_code": "\nuse itertools::Itertools;\n\nfn solve(deck: &[usize]) -> usize {\n    let mut counter = 0_usize;\n    let mut shuffle = deck.to_vec();\n    loop {\n        let p0 = shuffle[0];\n        if p0 == 1 {\n            break;\n        }\n        shuffle[..p0].reverse();\n        counter += 1;\n    }\n\n    counter\n}\n\n// this is a naive method which tries all permutations and works up to ~12 cards\nfn topswops(number: usize) -> usize {\n    (1..=number)\n        .permutations(number)\n        .fold(0_usize, |mut acc, p| {\n            let steps = solve(&p);\n            if steps > acc {\n                acc = steps;\n            }\n            acc\n        })\n}\nfn main() {\n    (1_usize..=10).for_each(|x| println!(\"{}: {}\", x, topswops(x)));\n}\n",
    "title": "Topswops",
    "url": "http://rosettacode.org/wiki/Topswops"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Total circles area",
    "url": "http://rosettacode.org/wiki/Total_circles_area"
  },
  {
    "local_code": "use num::integer::gcd;\n\nfn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, window| {\n            let (lower, upper) = (window[0], window[1]);\n            *acc += (lower..=upper).filter(is_prime).count();\n            Some((upper, *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}\n\nfn is_prime(n: &usize) -> bool {\n    phi(*n) == *n - 1\n}\n\nfn phi(n: usize) -> usize {\n    (1..=n).filter(|&x| gcd(n, x) == 1).count()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{is_prime, phi};\n\n    #[test]\n    fn test_totient_primes() {\n        let results = vec![\n            (1, 1, false),\n            (2, 1, true),\n            (3, 2, true),\n            (4, 2, false),\n            (5, 4, true),\n            (6, 2, false),\n            (7, 6, true),\n            (8, 4, false),\n            (9, 6, false),\n            (10, 4, false),\n            (11, 10, true),\n            (12, 4, false),\n            (13, 12, true),\n            (14, 6, false),\n            (15, 8, false),\n            (16, 8, false),\n            (17, 16, true),\n            (18, 6, false),\n            (19, 18, true),\n            (20, 8, false),\n            (21, 12, false),\n            (22, 10, false),\n            (23, 22, true),\n            (24, 8, false),\n            (25, 20, false),\n        ];\n        for n in 1..26 {\n            let phi_n = phi(n);\n            assert_eq!((n, phi_n, phi_n == n - 1), results[n - 1]);\n        }\n    }\n\n    #[test]\n    #[ignore]\n    fn test_totient_prime_list() {\n        let results: Vec<usize> = [1, 100, 1000, 10000, 100000]\n            .windows(2)\n            .scan(0, |acc, window| {\n                let (lower, upper) = (window[0], window[1]);\n                *acc += (lower..=upper).filter(is_prime).count();\n                Some(*acc)\n            })\n            .collect();\n\n        assert_eq!(results, vec![25, 168, 1229, 9592]);\n    }\n}\n",
    "path": "tasks/totient-function",
    "remote_code": "use num::integer::gcd;\n\nfn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, tuple| {\n            *acc += (tuple[0]..=tuple[1]).filter(is_prime).count();\n            Some((tuple[1], *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}\n\nfn is_prime(n: &usize) -> bool {\n    phi(*n) == *n - 1\n}\n\nfn phi(n: usize) -> usize {\n    (1..=n).filter(|&x| gcd(n, x) == 1).count()\n}",
    "title": "Totient function",
    "url": "http://rosettacode.org/wiki/Totient_function"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Towers_of_Hanoi\n\nfn play(n: i32, from: i32, to: i32, via: i32) {\n    if n > 0 {\n        play(n - 1, from, via, to);\n        println!(\"Move disk from pole {} to pole {}\", from, to);\n        play(n - 1, via, to, from);\n    }\n}\n\nfn main() {\n    play(4, 1, 2, 3);\n}\n",
    "path": "tasks/towers-of-hanoi",
    "remote_code": "fn move_(n: i32, from: i32, to: i32, via: i32) {\n    if n > 0 {\n        move_(n - 1, from, via, to);\n        println!(\"Move disk from pole {} to pole {}\", from, to);\n        move_(n - 1, via, to, from);\n    }\n}\n\nfn main() {\n    move_(4, 1,2,3);\n}",
    "title": "Towers of Hanoi",
    "url": "http://rosettacode.org/wiki/Towers_of_Hanoi"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::io::{self, BufRead};\n\nfn op(x: f32) -> Option<f32> {\n    let y = x.abs().sqrt() + 5.0 * x * x * x;\n    if y < 400.0 {\n        Some(y)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    println!(\"Please enter 11 numbers (one number per line)\");\n    let stdin = io::stdin();\n\n    let xs = stdin\n        .lock()\n        .lines()\n        .map(|ox| ox.unwrap().trim().to_string())\n        .flat_map(|s| str::parse::<f32>(&s))\n        .take(11)\n        .collect::<Vec<_>>();\n\n    for x in xs.into_iter().rev() {\n        match op(x) {\n            Some(y) => println!(\"{}\", y),\n            None => println!(\"overflow\"),\n        };\n    }\n}\n",
    "title": "Trabb Pardo–Knuth algorithm",
    "url": "http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Tree datastructures",
    "url": "http://rosettacode.org/wiki/Tree_datastructures"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Tree from nesting levels",
    "url": "http://rosettacode.org/wiki/Tree_from_nesting_levels"
  },
  {
    "local_code": "#![feature(box_syntax, box_patterns)]\n\nuse std::collections::VecDeque;\n\n#[derive(Debug)]\nstruct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\n#[allow(clippy::enum_variant_names)]\nenum TraversalMethod {\n    PreOrder,\n    InOrder,\n    PostOrder,\n    LevelOrder,\n}\n\nimpl<T> TreeNode<T> {\n    pub fn from_array(arr: &[[i8; 3]]) -> TreeNode<i8> {\n        let l = match arr[0][1] {\n            -1 => None,\n            i => Some(Box::new(TreeNode::<i8>::from_array(\n                &arr[(i - arr[0][0]) as usize..],\n            ))),\n        };\n        let r = match arr[0][2] {\n            -1 => None,\n            i => Some(Box::new(TreeNode::<i8>::from_array(\n                &arr[(i - arr[0][0]) as usize..],\n            ))),\n        };\n\n        TreeNode {\n            value: arr[0][0],\n            left: l,\n            right: r,\n        }\n    }\n\n    pub fn traverse(&self, tr: &TraversalMethod) -> Vec<&TreeNode<T>> {\n        match *tr {\n            TraversalMethod::PreOrder => self.iterative_preorder(),\n            TraversalMethod::InOrder => self.iterative_inorder(),\n            TraversalMethod::PostOrder => self.iterative_postorder(),\n            TraversalMethod::LevelOrder => self.iterative_levelorder(),\n        }\n    }\n\n    fn iterative_preorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        res\n    }\n\n    // Leftmost to rightmost\n    fn iterative_inorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n        let mut p = self;\n\n        loop {\n            // Stack parents and right children while left-descending\n            loop {\n                match p.right {\n                    None => {}\n                    Some(box ref n) => stack.push(n),\n                }\n                stack.push(p);\n                match p.left {\n                    None => break,\n                    Some(box ref n) => p = n,\n                }\n            }\n            // Visit the nodes with no right child\n            p = stack.pop().unwrap();\n            while !stack.is_empty() && p.right.is_none() {\n                res.push(p);\n                p = stack.pop().unwrap();\n            }\n            // First node that can potentially have a right child:\n            res.push(p);\n            if stack.is_empty() {\n                break;\n            } else {\n                p = stack.pop().unwrap();\n            }\n        }\n        res\n    }\n\n    // Left-to-right postorder is same sequence as right-to-left preorder, reversed\n    fn iterative_postorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        let rev_iter = res.iter().rev();\n        let mut rev: Vec<&TreeNode<T>> = Vec::new();\n        for elem in rev_iter {\n            rev.push(elem);\n        }\n        rev\n    }\n\n    fn iterative_levelorder(&self) -> Vec<&TreeNode<T>> {\n        let mut queue: VecDeque<&TreeNode<T>> = VecDeque::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        queue.push_back(self);\n        while !queue.is_empty() {\n            let node = queue.pop_front().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n        }\n        res\n    }\n}\n\nfn main() {\n    // Array representation of task tree\n    let arr_tree = [\n        [1, 2, 3],\n        [2, 4, 5],\n        [3, 6, -1],\n        [4, 7, -1],\n        [5, -1, -1],\n        [6, 8, 9],\n        [7, -1, -1],\n        [8, -1, -1],\n        [9, -1, -1],\n    ];\n\n    let root = TreeNode::<i8>::from_array(&arr_tree);\n\n    let method_labels = [\n        (TraversalMethod::PreOrder, \"pre-order:\"),\n        (TraversalMethod::InOrder, \"in-order:\"),\n        (TraversalMethod::PostOrder, \"post-order:\"),\n        (TraversalMethod::LevelOrder, \"level-order:\"),\n    ];\n\n    for method_label in &method_labels {\n        print!(\"{}\\t\", method_label.1);\n        for n in root.traverse(&method_label.0) {\n            print!(\" {}\", n.value);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{TraversalMethod, TreeNode};\n\n    macro_rules! trav_values {\n        ($x:expr) => {\n            $x.iter().map(|n| n.value).collect();\n        };\n    }\n\n    #[test]\n    fn test_traversals() {\n        let arr_tree = [\n            [1, 2, 3],\n            [2, 4, 5],\n            [3, 6, -1],\n            [4, 7, -1],\n            [5, -1, -1],\n            [6, 8, 9],\n            [7, -1, -1],\n            [8, -1, -1],\n            [9, -1, -1],\n        ];\n        let root = TreeNode::<i8>::from_array(&arr_tree);\n\n        let mut res: Vec<i8> = trav_values!(root.traverse(&TraversalMethod::PreOrder));\n        assert_eq!(res.as_slice(), &[1, 2, 4, 7, 5, 3, 6, 8, 9]);\n        res = trav_values!(root.traverse(&TraversalMethod::InOrder));\n        assert_eq!(res.as_slice(), &[7, 4, 2, 5, 1, 8, 6, 9, 3]);\n        res = trav_values!(root.traverse(&TraversalMethod::PostOrder));\n        assert_eq!(res.as_slice(), &[7, 4, 5, 2, 8, 9, 6, 3, 1]);\n        res = trav_values!(root.traverse(&TraversalMethod::LevelOrder));\n        assert_eq!(res.as_slice(), &[1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    }\n}\n",
    "path": "tasks/tree-traversal",
    "remote_code": "\n#![feature(box_syntax, box_patterns)]\n\nuse std::collections::VecDeque;\n\n#[derive(Debug)]\nstruct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\nenum TraversalMethod {\n    PreOrder,\n    InOrder,\n    PostOrder,\n    LevelOrder,\n}\n\nimpl<T> TreeNode<T> {\n    pub fn new(arr: &[[i8; 3]]) -> TreeNode<i8> {\n\n        let l = match arr[0][1] {\n            -1 => None,\n            i @ _ => Some(Box::new(TreeNode::<i8>::new(&arr[(i - arr[0][0]) as usize..]))),\n        };\n        let r = match arr[0][2] {\n            -1 => None,\n            i @ _ => Some(Box::new(TreeNode::<i8>::new(&arr[(i - arr[0][0]) as usize..]))),\n        };\n\n        TreeNode {\n            value: arr[0][0],\n            left: l,\n            right: r,\n        }\n    }\n\n    pub fn traverse(&self, tr: &TraversalMethod) -> Vec<&TreeNode<T>> {\n        match tr {\n            &TraversalMethod::PreOrder => self.iterative_preorder(),\n            &TraversalMethod::InOrder => self.iterative_inorder(),\n            &TraversalMethod::PostOrder => self.iterative_postorder(),\n            &TraversalMethod::LevelOrder => self.iterative_levelorder(),\n        }\n    }\n\n    fn iterative_preorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        res\n    }\n\n    // Leftmost to rightmost\n    fn iterative_inorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n        let mut p = self;\n\n        loop {\n            // Stack parents and right children while left-descending\n            loop {\n                match p.right {\n                    None => {}\n                    Some(box ref n) => stack.push(n),\n                }\n                stack.push(p);\n                match p.left {\n                    None => break,\n                    Some(box ref n) => p = n,\n                }\n            }\n            // Visit the nodes with no right child\n            p = stack.pop().unwrap();\n            while !stack.is_empty() && p.right.is_none() {\n                res.push(p);\n                p = stack.pop().unwrap();\n            }\n            // First node that can potentially have a right child:\n            res.push(p);\n            if stack.is_empty() {\n                break;\n            } else {\n                p = stack.pop().unwrap();\n            }\n        }\n        res\n    }\n\n    // Left-to-right postorder is same sequence as right-to-left preorder, reversed\n    fn iterative_postorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        let rev_iter = res.iter().rev();\n        let mut rev: Vec<&TreeNode<T>> = Vec::new();\n        for elem in rev_iter {\n            rev.push(elem);\n        }\n        rev\n    }\n\n    fn iterative_levelorder(&self) -> Vec<&TreeNode<T>> {\n        let mut queue: VecDeque<&TreeNode<T>> = VecDeque::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        queue.push_back(self);\n        while !queue.is_empty() {\n            let node = queue.pop_front().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n        }\n        res\n    }\n}\n\nfn main() {\n    // Array representation of task tree\n    let arr_tree = [[1, 2, 3],\n                    [2, 4, 5],\n                    [3, 6, -1],\n                    [4, 7, -1],\n                    [5, -1, -1],\n                    [6, 8, 9],\n                    [7, -1, -1],\n                    [8, -1, -1],\n                    [9, -1, -1]];\n\n    let root = TreeNode::<i8>::new(&arr_tree);\n\n    for method_label in [(TraversalMethod::PreOrder, \"pre-order:\"),\n                         (TraversalMethod::InOrder, \"in-order:\"),\n                         (TraversalMethod::PostOrder, \"post-order:\"),\n                         (TraversalMethod::LevelOrder, \"level-order:\")]\n                            .iter() {\n        print!(\"{}\\t\", method_label.1);\n        for n in root.traverse(&method_label.0) {\n            print!(\" {}\", n.value);\n        }\n        print!(\"\\n\");\n    }\n}\n",
    "title": "Tree traversal",
    "url": "http://rosettacode.org/wiki/Tree_traversal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// 20210221 Rust programming solution\n\nuse std::f64::consts::PI;\n\nfn main() {\n   let angle_radians: f64 = PI/4.0;\n   let angle_degrees: f64 = 45.0;\n\n   println!(\"{} {}\", angle_radians.sin(), angle_degrees.to_radians().sin());\n   println!(\"{} {}\", angle_radians.cos(), angle_degrees.to_radians().cos());\n   println!(\"{} {}\", angle_radians.tan(), angle_degrees.to_radians().tan());\n\n   let asin = angle_radians.sin().asin();\n   println!(\"{} {}\", asin, asin.to_degrees());\n   let acos = angle_radians.cos().acos();\n   println!(\"{} {}\", acos, acos.to_degrees());\n   let atan = angle_radians.tan().atan();\n   println!(\"{} {}\", atan, atan.to_degrees());\n}",
    "title": "Trigonometric functions",
    "url": "http://rosettacode.org/wiki/Trigonometric_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn is_left_truncatable(p: u32) -> bool {\n    let mut n = 10;\n    let mut q = p;\n    while p > n {\n        if !is_prime(p % n) || q == p % n {\n            return false;\n        }\n        q = p % n;\n        n *= 10;\n    }\n    true\n}\n\nfn is_right_truncatable(p: u32) -> bool {\n    let mut q = p / 10;\n    while q > 0 {\n        if !is_prime(q) {\n            return false;\n        }\n        q /= 10;\n    }\n    true\n}\n\nfn main() {\n    let limit = 1000000;\n    let mut largest_left = 0;\n    let mut largest_right = 0;\n    let mut p = limit;\n    while p >= 2 {\n        if is_prime(p) && is_left_truncatable(p) {\n            largest_left = p;\n            break;\n        }\n        p -= 1;\n    }\n    println!(\"Largest left truncatable prime is {}\", largest_left);\n    p = limit;\n    while p >= 2 {\n        if is_prime(p) && is_right_truncatable(p) {\n            largest_right = p;\n            break;\n        }\n        p -= 1;\n    }\n    println!(\"Largest right truncatable prime is {}\", largest_right);\n}",
    "title": "Truncatable primes",
    "url": "http://rosettacode.org/wiki/Truncatable_primes"
  },
  {
    "local_code": "use std::env;\nuse std::fs::OpenOptions;\nuse std::str::FromStr;\n\nfn main() {\n    if env::args().count() != 3 {\n        println!(\"Usage: {} <filename> <size>\", env::args().next().unwrap());\n    } else {\n        let filename = env::args().nth(1).unwrap();\n        let size = env::args().nth(2).unwrap();\n        match u64::from_str(&size) {\n            Ok(integer_size) => {\n                let file = OpenOptions::new().write(true).open(filename).unwrap();\n                let _ = file.set_len(integer_size);\n            }\n            Err(_) => println!(\"Invalid size\"),\n        }\n    }\n}\n",
    "path": "tasks/truncate-a-file",
    "remote_code": "use std::path::Path;\nuse std::fs;\n\nfn truncate_file<P: AsRef<Path>>(filename: P, filesize: usize) -> Result<(), Error> {\n    use Error::*;\n    let file = fs::read(&filename).or(Err(NotFound))?;\n\n    if filesize > file.len() {\n        return Err(FilesizeTooSmall)\n    }\n\n    fs::write(&filename, &file[..filesize]).or(Err(UnableToWrite))?;\n    Ok(())\n}\n\n#[derive(Debug)]\nenum Error {\n    /// File not found\n    NotFound,\n    /// Truncated size would be larger than the current size\n    FilesizeTooSmall,\n    /// Likely due to having read but not write permissions\n    UnableToWrite,\n}",
    "title": "Truncate a file",
    "url": "http://rosettacode.org/wiki/Truncate_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    collections::HashMap,\n    fmt::{Display, Formatter},\n    iter::FromIterator,\n};\n\n// Generic expression evaluation automaton and expression formatting support\n\n#[derive(Clone, Debug)]\npub enum EvaluationError<T> {\n    NoResults,\n    TooManyResults,\n    OperatorFailed(T),\n}\n\npub trait Operator<T> {\n    type Err;\n\n    fn execute(&self, stack: &mut Vec<T>) -> Result<(), Self::Err>;\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Element<O> {\n    Operator(O),\n    Variable(usize),\n}\n\n#[derive(Clone, Debug)]\npub struct Expression<O> {\n    elements: Vec<Element<O>>,\n    symbols: Vec<String>,\n}\n\nimpl<O> Expression<O> {\n    pub fn evaluate<T>(\n        &self,\n        mut bindings: impl FnMut(usize) -> T,\n    ) -> Result<T, EvaluationError<O::Err>>\n    where\n        O: Operator<T>,\n    {\n        let mut stack = Vec::new();\n\n        for element in self.elements.iter() {\n            match element {\n                Element::Variable(index) => stack.push(bindings(*index)),\n                Element::Operator(op) => op\n                    .execute(&mut stack)\n                    .map_err(EvaluationError::OperatorFailed)?,\n            }\n        }\n\n        match stack.pop() {\n            Some(result) if stack.is_empty() => Ok(result),\n            Some(_) => Err(EvaluationError::TooManyResults),\n            None => Err(EvaluationError::NoResults),\n        }\n    }\n\n    pub fn symbols(&self) -> &[String] {\n        &self.symbols\n    }\n\n    pub fn formatted(&self) -> Result<String, EvaluationError<O::Err>>\n    where\n        O: Operator<Formatted>,\n    {\n        self.evaluate(|index| Formatted(self.symbols[index].clone()))\n            .map(|formatted| formatted.0)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct Formatted(pub String);\n\nimpl Display for Formatted {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl<O> Display for Expression<O>\nwhere\n    O: Operator<Formatted>,\n{\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        match self.formatted() {\n            Ok(result) => write!(f, \"{}\", result),\n            Err(_) => write!(f, \"<malformed expression>\"),\n        }\n    }\n}\n\n// Generic parts of the parsing machinery\n\n#[derive(Clone, Copy, Debug)]\npub enum Token<'a, O> {\n    LBrace,\n    RBrace,\n    Operator(O),\n    Variable(&'a str),\n    Malformed(&'a str),\n}\n\npub type Symbol<'a, O> = (&'a str, bool, Token<'a, O>);\n\n#[derive(Debug)]\npub struct Tokens<'a, O> {\n    source: &'a str,\n    symbols: &'a [Symbol<'a, O>],\n}\n\nimpl<'a, O> Tokens<'a, O> {\n    pub fn new(source: &'a str, symbols: &'a [Symbol<'a, O>]) -> Self {\n        Self { source, symbols }\n    }\n}\n\nimpl<'a, O: Clone> Iterator for Tokens<'a, O> {\n    type Item = Token<'a, O>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.source = self.source.trim_start();\n\n        let symbol = self.symbols.iter().find_map(|(symbol, word, token)| {\n            if self.source.starts_with(symbol) {\n                let end = symbol.len();\n\n                if *word {\n                    match &self.source[end..].chars().next() {\n                        Some(c) if !c.is_whitespace() => return None,\n                        _ => (),\n                    }\n                }\n\n                Some((token, end))\n            } else {\n                None\n            }\n        });\n\n        if let Some((token, end)) = symbol {\n            self.source = &self.source[end..];\n            Some(token.clone())\n        } else {\n            match self.source.chars().next() {\n                Some(c) if c.is_alphabetic() => {\n                    let end = self\n                        .source\n                        .char_indices()\n                        .find_map(|(i, c)| Some(i).filter(|_| !c.is_alphanumeric()))\n                        .unwrap_or_else(|| self.source.len());\n\n                    let result = &self.source[0..end];\n                    self.source = &self.source[end..];\n                    Some(Token::Variable(result))\n                }\n\n                Some(c) => {\n                    let end = c.len_utf8();\n                    let result = &self.source[0..end];\n                    self.source = &self.source[end..];\n                    Some(Token::Malformed(result))\n                }\n\n                None => None,\n            }\n        }\n    }\n}\n\npub trait WithPriority {\n    type Priority;\n\n    fn priority(&self) -> Self::Priority;\n}\n\nimpl<'a, O> FromIterator<Token<'a, O>> for Result<Expression<O>, Token<'a, O>>\nwhere\n    O: WithPriority,\n    O::Priority: Ord,\n{\n    fn from_iter<T: IntoIterator<Item = Token<'a, O>>>(tokens: T) -> Self {\n        let mut token_stack = Vec::new();\n        let mut indices = HashMap::new();\n        let mut symbols = Vec::new();\n        let mut elements = Vec::new();\n\n        'outer: for token in tokens {\n            match token {\n                Token::Malformed(_) => return Err(token),\n                Token::LBrace => token_stack.push(token),\n                Token::RBrace => {\n                    // Flush all operators to the matching LBrace\n                    while let Some(token) = token_stack.pop() {\n                        match token {\n                            Token::LBrace => continue 'outer,\n                            Token::Operator(op) => elements.push(Element::Operator(op)),\n                            _ => return Err(token),\n                        }\n                    }\n                }\n\n                Token::Variable(name) => {\n                    let index = indices.len();\n                    let symbol = name.to_string();\n                    let index = *indices.entry(symbol.clone()).or_insert_with(|| {\n                        symbols.push(symbol);\n                        index\n                    });\n\n                    elements.push(Element::Variable(index));\n                }\n\n                Token::Operator(ref op) => {\n                    while let Some(token) = token_stack.pop() {\n                        match token {\n                            Token::Operator(pop) if op.priority() < pop.priority() => {\n                                elements.push(Element::Operator(pop));\n                            }\n\n                            Token::Operator(pop) => {\n                                token_stack.push(Token::Operator(pop));\n                                break;\n                            }\n\n                            _ => {\n                                token_stack.push(token);\n                                break;\n                            }\n                        }\n                    }\n\n                    token_stack.push(token);\n                }\n            }\n        }\n\n        // Handle leftovers\n        while let Some(token) = token_stack.pop() {\n            match token {\n                Token::Operator(op) => elements.push(Element::Operator(op)),\n                _ => return Err(token),\n            }\n        }\n\n        Ok(Expression { elements, symbols })\n    }\n}\n\n// Definition of Boolean operators\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Boolean {\n    Or,\n    Xor,\n    And,\n    Not,\n}\n\nimpl Display for Boolean {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        let s = match self {\n            Self::Or => \"∨\",\n            Self::And => \"∧\",\n            Self::Not => \"¬\",\n            Self::Xor => \"⩛\",\n        };\n\n        write!(f, \"{}\", s)\n    }\n}\n\nimpl WithPriority for Boolean {\n    type Priority = u8;\n\n    fn priority(&self) -> u8 {\n        match self {\n            Self::Or => 0,\n            Self::Xor => 1,\n            Self::And => 2,\n            Self::Not => 3,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum BooleanError {\n    StackUnderflow,\n}\n\nimpl Operator<bool> for Boolean {\n    type Err = BooleanError;\n\n    fn execute(&self, stack: &mut Vec<bool>) -> Result<(), Self::Err> {\n        let mut pop = || stack.pop().ok_or(BooleanError::StackUnderflow);\n\n        let result = match self {\n            Boolean::Or => pop()? | pop()?,\n            Boolean::And => pop()? & pop()?,\n            Boolean::Xor => pop()? ^ pop()?,\n            Boolean::Not => !pop()?,\n        };\n\n        stack.push(result);\n        Ok(())\n    }\n}\n\nimpl Operator<Formatted> for Boolean {\n    type Err = BooleanError;\n\n    fn execute(&self, stack: &mut Vec<Formatted>) -> Result<(), Self::Err> {\n        let mut pop = || stack.pop().ok_or(BooleanError::StackUnderflow);\n\n        let result = match self {\n            Boolean::Not => format!(\"{}{}\", Boolean::Not, pop()?),\n\n            binary_operator => {\n                // The stack orders the operands backwards, so to format them\n                // properly, we have to count with the reversed popping order\n                let b = pop()?;\n                let a = pop()?;\n                format!(\"({} {} {})\", a, binary_operator, b)\n            }\n        };\n\n        stack.push(Formatted(result));\n        Ok(())\n    }\n}\n\nimpl Boolean {\n    // It is important for the tokens to be ordered by their parsing priority (if\n    // some operator was a prefix of another operator, the prefix must come later)\n    const SYMBOLS: [Symbol<'static, Boolean>; 18] = [\n        (\"(\", false, Token::LBrace),\n        (\")\", false, Token::RBrace),\n        (\"|\", false, Token::Operator(Boolean::Or)),\n        (\"∨\", false, Token::Operator(Boolean::Or)),\n        (\"or\", true, Token::Operator(Boolean::Or)),\n        (\"OR\", true, Token::Operator(Boolean::Or)),\n        (\"&\", false, Token::Operator(Boolean::And)),\n        (\"∧\", false, Token::Operator(Boolean::And)),\n        (\"and\", true, Token::Operator(Boolean::And)),\n        (\"AND\", true, Token::Operator(Boolean::And)),\n        (\"!\", false, Token::Operator(Boolean::Not)),\n        (\"¬\", false, Token::Operator(Boolean::Not)),\n        (\"not\", true, Token::Operator(Boolean::Not)),\n        (\"NOT\", true, Token::Operator(Boolean::Not)),\n        (\"^\", false, Token::Operator(Boolean::Xor)),\n        (\"⩛\", false, Token::Operator(Boolean::Xor)),\n        (\"xor\", true, Token::Operator(Boolean::Xor)),\n        (\"XOR\", true, Token::Operator(Boolean::Xor)),\n    ];\n\n    pub fn tokenize(s: &str) -> Tokens<'_, Boolean> {\n        Tokens::new(s, &Self::SYMBOLS)\n    }\n\n    pub fn parse<'a>(s: &'a str) -> Result<Expression<Boolean>, Token<'a, Boolean>> {\n        Self::tokenize(s).collect()\n    }\n}\n\n// Finally the table printing\n\nfn print_truth_table(s: &str) -> Result<(), std::borrow::Cow<'_, str>> {\n    let expression = Boolean::parse(s).map_err(|e| format!(\"Parsing failed at token {:?}\", e))?;\n\n    let formatted = expression\n        .formatted()\n        .map_err(|_| \"Malformed expression detected.\")?;\n\n    let var_count = expression.symbols().len();\n    if var_count > 64 {\n        return Err(\"Too many variables to list.\".into());\n    }\n\n    let column_widths = {\n        // Print header and compute the widths of columns\n        let mut widths = Vec::with_capacity(var_count);\n\n        for symbol in expression.symbols() {\n            print!(\"{}  \", symbol);\n            widths.push(symbol.chars().count() + 2); // Include spacing\n        }\n\n        println!(\"{}\", formatted);\n        let width = widths.iter().sum::<usize>() + formatted.chars().count();\n        (0..width).for_each(|_| print!(\"-\"));\n        println!();\n\n        widths\n    };\n\n    // Choose the bit extraction order for the more traditional table ordering\n    let var_value = |input, index| (input >> (var_count - 1 - index)) & 1 ^ 1;\n    // Use counter to enumerate all bit combinations\n    for var_values in 0u64..(1 << var_count) {\n        for (var_index, width) in column_widths.iter().enumerate() {\n            let value = var_value(var_values, var_index);\n            print!(\"{:<width$}\", value, width = width);\n        }\n\n        match expression.evaluate(|var_index| var_value(var_values, var_index) == 1) {\n            Ok(result) => println!(\"{}\", if result { \"1\" } else { \"0\" }),\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n\n    println!();\n    Ok(())\n}\n\nfn main() {\n    loop {\n        let input = {\n            println!(\"Enter the expression to parse (or nothing to quit):\");\n            let mut input = String::new();\n            std::io::stdin().read_line(&mut input).unwrap();\n            println!();\n            input\n        };\n\n        if input.trim().is_empty() {\n            break;\n        }\n\n        if let Err(e) = print_truth_table(&input) {\n            eprintln!(\"{}\\n\", e);\n        }\n    }\n}",
    "title": "Truth table",
    "url": "http://rosettacode.org/wiki/Truth_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Twelve statements",
    "url": "http://rosettacode.org/wiki/Twelve_statements"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// num-format = \"0.4\"\n\nuse num_format::{Locale, ToFormattedString};\n\nfn twin_prime_count_for_powers_of_ten(max_power: u32) {\n    let mut count = 0;\n    let mut previous = 0;\n    let mut power = 1;\n    let mut limit = 10;\n    for prime in primal::Primes::all() {\n        if prime > limit {\n            println!(\n                \"Number of twin prime pairs less than {} is {}\",\n                limit.to_formatted_string(&Locale::en),\n                count.to_formatted_string(&Locale::en)\n            );\n            limit *= 10;\n            power += 1;\n            if power > max_power {\n                break;\n            }\n        }\n        if previous > 0 && prime == previous + 2 {\n            count += 1;\n        }\n        previous = prime;\n    }\n}\n\nfn twin_prime_count(limit: usize) {\n    let mut count = 0;\n    let mut previous = 0;\n    for prime in primal::Primes::all().take_while(|x| *x < limit) {\n        if previous > 0 && prime == previous + 2 {\n            count += 1;\n        }\n        previous = prime;\n    }\n    println!(\n        \"Number of twin prime pairs less than {} is {}\",\n        limit.to_formatted_string(&Locale::en),\n        count.to_formatted_string(&Locale::en)\n    );\n}\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() > 1 {\n        for i in 1..args.len() {\n            if let Ok(limit) = args[i].parse::<usize>() {\n                twin_prime_count(limit);\n            } else {\n                eprintln!(\"Cannot parse limit from string {}\", args[i]);\n            }\n        }\n    } else {\n        twin_prime_count_for_powers_of_ten(10);\n    }\n}",
    "title": "Twin primes",
    "url": "http://rosettacode.org/wiki/Twin_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Two bullet roulette",
    "url": "http://rosettacode.org/wiki/Two_bullet_roulette"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Two's complement",
    "url": "http://rosettacode.org/wiki/Two's_complement"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "UPC",
    "url": "http://rosettacode.org/wiki/UPC"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const INPUT1: &str = \"http%3A%2F%2Ffoo%20bar%2F\";\nconst INPUT2: &str = \"google.com/search?q=%60Abdu%27l-Bah%C3%A1\";\n\nfn append_frag(text: &mut String, frag: &mut String) {\n    if !frag.is_empty() {\n        let encoded = frag.chars()\n            .collect::<Vec<char>>()\n            .chunks(2)\n            .map(|ch| {\n                u8::from_str_radix(&ch.iter().collect::<String>(), 16).unwrap()\n            }).collect::<Vec<u8>>();\n        text.push_str(&std::str::from_utf8(&encoded).unwrap());\n        frag.clear();\n    }\n}\n\nfn decode(text: &str) -> String {\n    let mut output = String::new();\n    let mut encoded_ch = String::new();\n    let mut iter = text.chars();\n    while let Some(ch) = iter.next() {\n        if ch == '%' {\n            encoded_ch.push_str(&format!(\"{}{}\", iter.next().unwrap(), iter.next().unwrap()));\n        } else {\n            append_frag(&mut output, &mut encoded_ch);\n            output.push(ch);\n        }\n    }\n    append_frag(&mut output, &mut encoded_ch);\n    output\n}\n\nfn main() {\n    println!(\"{}\", decode(INPUT1));\n    println!(\"{}\", decode(INPUT2));\n}",
    "title": "URL decoding",
    "url": "http://rosettacode.org/wiki/URL_decoding"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const INPUT: &str = \"http://foo bar/\";\nconst MAX_CHAR_VAL: u32 = std::char::MAX as u32;\n \nfn main() {\n    let mut buff = [0; 4];\n    println!(\"{}\", INPUT.chars()\n        .map(|ch| {\n            match ch as u32 {\n                0 ..= 47 | 58 ..= 64 | 91 ..= 96 | 123 ..= MAX_CHAR_VAL => {\n                    ch.encode_utf8(&mut buff);\n                    buff[0..ch.len_utf8()].iter().map(|&byte| format!(\"%{:X}\", byte)).collect::<String>()\n                },\n                _ => ch.to_string(),\n            }\n        })\n        .collect::<String>()\n    );\n}",
    "title": "URL encoding",
    "url": "http://rosettacode.org/wiki/URL_encoding"
  },
  {
    "local_code": "extern crate url;\n\nuse url::Url;\n\nfn print_url(url: &Url) {\n    println!(\"scheme:      {:?}\", url.scheme());\n    if let Some(ref host) = url.host() {\n        println!(\"domain:      {:?}\", host);\n    }\n    if let Some(ref port) = url.port() {\n        println!(\"port:        {:?}\", port);\n    }\n    println!(\"path:        {:?}\", url.path());\n    if let Some(query) = url.query() {\n        println!(\"query:       {:?}\", query);\n    }\n    if let Some(fragment) = url.fragment() {\n        println!(\"fragment:    {:?}\", fragment);\n    }\n}\n\nfn main() {\n    let urls = vec![\n        \"foo://example.com:8042/over/there?name=ferret#nose\",\n        \"urn:example:animal:ferret:nose\",\n        \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n        \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n        \"http://www.ietf.org/rfc/rfc2396.txt#header1\",\n        \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n        \"mailto:John.Doe@example.com\",\n        \"news:comp.infosystems.www.servers.unix\",\n        \"tel:+1-816-555-1212\",\n        \"telnet://192.0.2.16:80/\",\n        \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        \"ssh://alice@example.com\",\n        \"https://bob:pass@example.com/place\",\n        \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\",\n    ];\n    for url in urls {\n        println!(\"URL: {}\", url);\n        print_url(&Url::parse(url).unwrap());\n        println!();\n    }\n}\n",
    "path": "tasks/url-parser",
    "remote_code": "use url::Url;\n\nfn print_fields(url: Url) -> () {\n    println!(\"scheme: {}\", url.scheme());\n    println!(\"username: {}\", url.username());\n\n    if let Some(password) = url.password() {\n        println!(\"password: {}\", password);\n    }\n\n    if let Some(domain) = url.domain() {\n        println!(\"domain: {}\", domain);\n    }\n\n    if let Some(port) = url.port() {\n        println!(\"port: {}\", port);\n    }\n    println!(\"path: {}\", url.path());\n\n    if let Some(query) = url.query() {\n        println!(\"query: {}\", query);\n    }\n\n    if let Some(fragment) = url.fragment() {\n        println!(\"fragment: {}\", fragment);\n    }\n}\nfn main() {\n    let urls = vec![\n        \"foo://example.com:8042/over/there?name=ferret#nose\",\n        \"urn:example:animal:ferret:nose\",\n        \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n        \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n        \"http://www.ietf.org/rfc/rfc2396.txt#header1\",\n        \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n        \"mailto:John.Doe@example.com\",\n        \"news:comp.infosystems.www.servers.unix\",\n        \"tel:+1-816-555-1212\",\n        \"telnet://192.0.2.16:80/\",\n        \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        \"ssh://alice@example.com\",\n        \"https://bob:pass@example.com/place\",\n        \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\",\n    ];\n\n    for url in urls {\n        println!(\"Parsing {}\", url);\n        match Url::parse(url) {\n            Ok(valid_url) => {\n                print_fields(valid_url);\n                println!();\n            }\n            Err(e) => println!(\"Error Parsing url - {:?}\", e),\n        }\n    }\n}\n",
    "title": "URL parser",
    "url": "http://rosettacode.org/wiki/URL_parser"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let chars = vec!('A', 'ö', 'Ж', '€', '𝄞');\n    chars.iter().for_each(|c| {\n        let mut encoded = vec![0; c.len_utf8()];\n        c.encode_utf8(&mut encoded);\n        let decoded = String::from_utf8(encoded.to_vec()).unwrap();\n        let encoded_string = encoded.iter().fold(String::new(), |acc, val| format!(\"{}{:X}\", acc, val));\n        println!(\"Character: {}, Unicode:{}, UTF-8 encoded:{}, Decoded: {}\", c, c.escape_unicode(), encoded_string , decoded);\n    });\n}\n",
    "title": "UTF-8 encode and decode",
    "url": "http://rosettacode.org/wiki/UTF-8_encode_and_decode"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ukkonen’s suffix tree construction",
    "url": "http://rosettacode.org/wiki/Ukkonen%E2%80%99s_suffix_tree_construction"
  },
  {
    "local_code": "use std::fmt;\n\nenum Direction {\n    Right,\n    Up,\n    Left,\n    Down,\n}\nuse Direction::*;\n\nfn is_prime(a: u32) -> bool {\n    match a {\n        2 => true,\n        x if x <= 1 || x % 2 == 0 => false,\n        _ => {\n            let max = f64::from(a).sqrt() as u32;\n            for x in (3..max).step_by(2) {\n                if a % x == 0 {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n}\n\nstruct Ulam {\n    u: Vec<Vec<String>>,\n}\n\nimpl fmt::Display for Ulam {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.u {\n            let pretty = format!(\"{:?}\", row).replace('\\\"', \"\").replace(\", \", \"\");\n            writeln!(f, \"{}\", pretty)?;\n        }\n        writeln!(f)\n    }\n}\n\n#[allow(clippy::many_single_char_names)]\nfn generate(n: u32, s: u32, c: char) -> Ulam {\n    let mut spiral = vec![vec![\"\".to_string(); n as usize]; n as usize];\n    let mut dir = Right;\n    let mut y = (n / 2) as usize;\n    let mut x = if n % 2 == 0 { y - 1 } else { y }; // shift left for even n's\n    for j in s..n * n + s {\n        spiral[y][x] = if is_prime(j) {\n            if c == '\\0' {\n                format!(\"{:4}\", j)\n            } else {\n                format!(\"  {} \", c)\n            }\n        } else {\n            \" ---\".to_string()\n        };\n\n        match dir {\n            Right => {\n                if (x as u32) < n && spiral[y - 1][x].is_empty() && j > s {\n                    dir = Up;\n                }\n            }\n            Up => {\n                if spiral[y][x - 1].is_empty() {\n                    dir = Left;\n                }\n            }\n            Left => {\n                if x == 0 || spiral[y + 1][x].is_empty() {\n                    dir = Down;\n                }\n            }\n            Down => {\n                if spiral[y][x + 1].is_empty() {\n                    dir = Right;\n                }\n            }\n        };\n\n        match dir {\n            Right => x += 1,\n            Up => y -= 1,\n            Left => x -= 1,\n            Down => y += 1,\n        };\n    }\n    Ulam { u: spiral }\n}\n\n// Program entry point.\nfn main() {\n    print!(\"{}\", generate(9, 1, '\\0'));\n    print!(\"{}\", generate(9, 1, '*'));\n}\n",
    "path": "tasks/ulam-spiral-for-primes",
    "remote_code": "use std::fmt;\n\nenum Direction { RIGHT, UP, LEFT, DOWN }\nuse ulam::Direction::*;\n\n/// Indicates whether an integer is a prime number or not.\nfn is_prime(a: u32) -> bool {\n    match a {\n        2 => true,\n        x if x <= 1 || x % 2 == 0 => false,\n        _ => {\n            let max = f64::sqrt(a as f64) as u32;\n            let mut x =  3;\n            while x <= max {\n                if a % x == 0 { return false; }\n                x += 2;\n            }\n            true\n        }\n    }\n}\n\npub struct Ulam { u : Vec<Vec<String>> }\n\nimpl Ulam {\n    /// Generates one `Ulam` object.\n    pub fn new(n: u32, s: u32, c: char) -> Ulam {\n        let mut spiral = vec![vec![String::new(); n as usize]; n as usize];\n        let mut dir = RIGHT;\n        let mut y = (n / 2) as usize;\n        let mut x = if n % 2 == 0 { y - 1 } else { y }; // shift left for even n's\n        for j in s..n * n + s {\n            spiral[y][x] = if is_prime(j) {\n                if c == '\\0' { format!(\"{:4}\", j) } else { format!(\"  {} \", c) }\n            }\n            else { String::from(\" ---\") };\n\n            match dir {\n                RIGHT => if x as u32 <= n - 1 && spiral[y - 1][x].is_empty() && j > s { dir = UP; },\n                UP => if spiral[y][x - 1].is_empty() { dir = LEFT; },\n                LEFT => if x == 0 || spiral[y + 1][x].is_empty() { dir = DOWN; },\n                DOWN => if spiral[y][x + 1].is_empty() { dir = RIGHT; }\n            };\n\n            match dir { RIGHT => x += 1, UP => y -= 1, LEFT => x -= 1, DOWN => y += 1 };\n        }\n        Ulam { u: spiral }\n    }\n}\n\nimpl fmt::Display for Ulam {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.u {\n            writeln!(f, \"{}\", format!(\"{:?}\", row).replace(\"\\\"\", \"\").replace(\", \", \"\"));\n        };\n        writeln!(f, \"\")\n    }\n}",
    "title": "Ulam spiral (for primes)",
    "url": "http://rosettacode.org/wiki/Ulam_spiral_(for_primes)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ultra useful primes",
    "url": "http://rosettacode.org/wiki/Ultra_useful_primes"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::prelude::*;\n\nfn rand_n<R: Rng>(rng: &mut R, n: u32) -> usize {\n    (rng.gen_range(0, n) == 0) as usize // maps `false` to 0 and `true` to 1\n}\n\nfn unbiased<R: Rng>(rng: &mut R, n: u32) -> usize {\n    let mut bit = rand_n(rng, n);\n    while bit == rand_n(rng, n) {\n        bit = rand_n(rng, n);\n    }\n    bit\n}\n\nfn main() {\n    const SAMPLES: usize = 100_000;\n    let mut rng = thread_rng();\n\n    println!(\" Bias    rand_n  unbiased\");\n    for n in 3..=6 {\n        let mut count_biased = 0;\n        let mut count_unbiased = 0;\n        for _ in 0..SAMPLES {\n            count_biased += rand_n(&mut rng, n);\n            count_unbiased += unbiased(&mut rng, n);\n        }\n\n        let b_percentage = 100.0 * count_biased as f64 / SAMPLES as f64;\n        let ub_percentage = 100.0 * count_unbiased as f64 / SAMPLES as f64;\n        println!(\n            \"bias {}:  {:0.2}%   {:0.2}%\",\n            n, b_percentage, ub_percentage\n        );\n    }\n}\n\n#[test]\nfn test_unbiased() {\n    let mut rng = thread_rng();\n    const SAMPLES: usize = 10_000;\n\n    for n in 3..=6 {\n        let mut count = 0;\n        for _ in 0..SAMPLES {\n            count += unbiased(&mut rng, n);\n        }\n\n        let ratio = 1000 * count / SAMPLES;\n        assert!(ratio > 450 && ratio < 550, \"{}\", ratio);\n    }\n}\n",
    "path": "tasks/unbias-a-random-generator",
    "remote_code": "#![feature(inclusive_range_syntax)]\n\nextern crate rand;\n\nuse rand::Rng;\n\nfn rand_n<R: Rng>(rng: &mut R, n: u32) -> usize {\n    rng.gen_weighted_bool(n) as usize // maps `false` to 0 and `true` to 1\n}\n\nfn unbiased<R: Rng>(rng: &mut R, n: u32) -> usize {\n    let mut bit = rand_n(rng, n);\n    while bit == rand_n(rng, n) {\n        bit = rand_n(rng, n);\n    }\n    bit\n}\n\nfn main() {\n    const SAMPLES: usize = 100_000;\n    let mut rng = rand::weak_rng();\n\n    println!(\" Bias    rand_n  unbiased\");\n    for n in 3..=6 {\n        let mut count_biased = 0;\n        let mut count_unbiased = 0;\n        for _ in 0..SAMPLES {\n            count_biased += rand_n(&mut rng, n);\n            count_unbiased += unbiased(&mut rng, n);\n        }\n\n        let b_percentage = 100.0 * count_biased as f64 / SAMPLES as f64;\n        let ub_percentage = 100.0 * count_unbiased as f64 / SAMPLES as f64;\n        println!(\n            \"bias {}:  {:0.2}%   {:0.2}%\",\n            n, b_percentage, ub_percentage\n        );\n    }\n}",
    "title": "Unbias a random generator",
    "url": "http://rosettacode.org/wiki/Unbias_a_random_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::ptr;\n\nlet p: *const i32 = ptr::null();\nassert!(p.is_null());",
    "title": "Undefined values",
    "url": "http://rosettacode.org/wiki/Undefined_values"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Unicode strings",
    "url": "http://rosettacode.org/wiki/Unicode_strings"
  },
  {
    "local_code": "// Rust warns about non-snake-case variable names by default, and will suggest `δ` as the variable\n// name instead.\n#[allow(non_snake_case)]\nfn main() {\n    let mut Δ: i32 = 1;\n    Δ += 1;\n    println!(\"{}\", Δ);\n}\n",
    "path": "tasks/unicode-variable-names",
    "remote_code": "#![feature(non_ascii_idents)]\n#![allow(non_snake_case)]\n\nfn main() {\n    let mut Δ: i32 = 1;\n    Δ += 1;\n    println!(\"{}\", Δ);\n}",
    "title": "Unicode variable names",
    "url": "http://rosettacode.org/wiki/Unicode_variable_names"
  },
  {
    "local_code": "mod direction;\nmod rule;\nmod tm;\n\npub use direction::*;\npub use rule::*;\npub use tm::*;\nuse universal_turing_machine::{Direction, Rule, TM};\n\nfn main() {\n    println!(\"Simple incrementer\");\n    let mut tm_si = TM::new(\n        vec![\"q0\", \"qf\"],\n        \"q0\",\n        vec![\"qf\"],\n        vec!['B', '1'],\n        'B',\n        vec![\n            Rule::new(\"q0\", '1', '1', Direction::Right, \"q0\"),\n            Rule::new(\"q0\", 'B', '1', Direction::Stay, \"qf\"),\n        ],\n        \"111\",\n    );\n    while !tm_si.is_done() {\n        println!(\"{}\", tm_si);\n        tm_si.step();\n    }\n\n    println!(\"___________________\");\n    println!(\"Three-state busy beaver\");\n    let mut tm_bb3 = TM::new(\n        vec![\"a\", \"b\", \"c\", \"halt\"],\n        \"a\",\n        vec![\"halt\"],\n        vec!['0', '1'],\n        '0',\n        vec![\n            Rule::new(\"a\", '0', '1', Direction::Right, \"b\"),\n            Rule::new(\"a\", '1', '1', Direction::Left, \"c\"),\n            Rule::new(\"b\", '0', '1', Direction::Left, \"a\"),\n            Rule::new(\"b\", '1', '1', Direction::Right, \"b\"),\n            Rule::new(\"c\", '0', '1', Direction::Left, \"b\"),\n            Rule::new(\"c\", '1', '1', Direction::Stay, \"halt\"),\n        ],\n        \"0\",\n    );\n    while !tm_bb3.is_done() {\n        println!(\"{}\", tm_bb3);\n        tm_bb3.step();\n    }\n    println!(\"{}\", tm_bb3);\n\n    println!(\"___________________\");\n    println!(\"Five-state busy beaver\");\n    let mut tm_bb5 = TM::new(\n        vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"H\"],\n        \"A\",\n        vec![\"H\"],\n        vec!['0', '1'],\n        '0',\n        vec![\n            Rule::new(\"A\", '0', '1', Direction::Right, \"B\"),\n            Rule::new(\"A\", '1', '1', Direction::Left, \"C\"),\n            Rule::new(\"B\", '0', '1', Direction::Right, \"C\"),\n            Rule::new(\"B\", '1', '1', Direction::Right, \"B\"),\n            Rule::new(\"C\", '0', '1', Direction::Right, \"D\"),\n            Rule::new(\"C\", '1', '0', Direction::Left, \"E\"),\n            Rule::new(\"D\", '0', '1', Direction::Left, \"A\"),\n            Rule::new(\"D\", '1', '1', Direction::Left, \"D\"),\n            Rule::new(\"E\", '0', '1', Direction::Stay, \"H\"),\n            Rule::new(\"E\", '1', '0', Direction::Left, \"A\"),\n        ],\n        \"0\",\n    );\n    let mut steps = 0;\n    while !tm_bb5.is_done() {\n        tm_bb5.step();\n        steps += 1;\n    }\n    println!(\"Steps: {}\", steps);\n    println!(\"Band length: {}\", tm_bb5.band().len());\n}\nuse std::{\n    collections::VecDeque,\n    fmt::{Display, Formatter, Result},\n};\n\nuse crate::{Direction, Rule};\n\npub struct TM<'a> {\n    state: &'a str,\n    terminating_states: Vec<&'a str>,\n    rules: Vec<Rule<'a>>,\n    band: VecDeque<char>,\n    head: usize,\n    blank: char,\n}\n\nimpl<'a> TM<'a> {\n    pub fn new(\n        _states: Vec<&'a str>,\n        initial_state: &'a str,\n        terminating_states: Vec<&'a str>,\n        _permissible_symbols: Vec<char>,\n        blank: char,\n        rules: Vec<Rule<'a>>,\n        input: &str,\n    ) -> Self {\n        Self {\n            state: initial_state,\n            terminating_states,\n            rules,\n            band: input.chars().collect::<VecDeque<_>>(),\n            head: 0,\n            blank,\n        }\n    }\n\n    pub fn is_done(&self) -> bool {\n        self.terminating_states.contains(&self.state)\n    }\n\n    pub fn step(&mut self) {\n        let field = self.band.get(self.head).unwrap();\n        let rule = self\n            .rules\n            .iter()\n            .find(|rule| rule.state == self.state && &rule.read == field)\n            .unwrap();\n        let field = self.band.get_mut(self.head).unwrap();\n        *field = rule.write;\n        self.state = rule.new_state;\n        match rule.dir {\n            Direction::Left => {\n                if self.head == 0 {\n                    self.band.push_front(self.blank)\n                } else {\n                    self.head -= 1;\n                }\n            }\n            Direction::Right => {\n                if self.head == self.band.len() - 1 {\n                    self.band.push_back(self.blank)\n                }\n                self.head += 1;\n            }\n            Direction::Stay => {}\n        }\n    }\n\n    pub fn band(&self) -> &VecDeque<char> {\n        &self.band\n    }\n}\n\nimpl<'a> Display for TM<'a> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let band = self\n            .band\n            .iter()\n            .enumerate()\n            .map(|(i, c)| {\n                if i == self.head {\n                    format!(\"[{}]\", c)\n                } else {\n                    format!(\" {} \", c)\n                }\n            })\n            .fold(String::new(), |acc, val| acc + &val);\n        write!(f, \"{}\\t{}\", self.state, band)\n    }\n}\nuse crate::Direction;\n\npub struct Rule<'a> {\n    pub state: &'a str,\n    pub read: char,\n    pub write: char,\n    pub dir: Direction,\n    pub new_state: &'a str,\n}\n\nimpl<'a> Rule<'a> {\n    pub fn new(\n        state: &'a str,\n        read: char,\n        write: char,\n        dir: Direction,\n        new_state: &'a str,\n    ) -> Self {\n        Self {\n            state,\n            read,\n            write,\n            dir,\n            new_state,\n        }\n    }\n}\npub enum Direction {\n    Left,\n    Right,\n    Stay,\n}\n",
    "path": "tasks/universal-turing-machine",
    "remote_code": "use std::collections::VecDeque;\nuse std::fmt::{Display, Formatter, Result};\n\nfn main() {\n    println!(\"Simple incrementer\");\n    let rules_si = vec!(\n        Rule::new(\"q0\", '1', '1', Direction::Right, \"q0\"),\n        Rule::new(\"q0\", 'B', '1', Direction::Stay, \"qf\")\n    );\n    let states_si = vec!(\"q0\", \"qf\");\n    let terminating_states_si = vec!(\"qf\");\n    let permissible_symbols_si = vec!('B', '1');\n    let mut tm_si = TM::new(states_si, \"q0\", terminating_states_si, permissible_symbols_si, 'B', rules_si, \"111\");\n    while !tm_si.is_done() {\n        println!(\"{}\", tm_si);\n        tm_si.step();\n    }\n\n    println!(\"___________________\");\n    println!(\"Three-state busy beaver\");\n    let rules_bb3 = vec!(\n        Rule::new(\"a\", '0', '1', Direction::Right, \"b\"), \n        Rule::new(\"a\", '1', '1', Direction::Left, \"c\"),\n        Rule::new(\"b\", '0', '1', Direction::Left, \"a\"),\n        Rule::new(\"b\", '1', '1', Direction::Right, \"b\"),\n        Rule::new(\"c\", '0', '1', Direction::Left, \"b\"),\n        Rule::new(\"c\", '1', '1', Direction::Stay, \"halt\"),\n    );\n    let states_bb3 = vec!(\"a\", \"b\", \"c\", \"halt\");\n    let terminating_states_bb3 = vec!(\"halt\");\n    let permissible_symbols_bb3 = vec!('0', '1');\n    let mut tm_bb3 = TM::new(states_bb3 ,\"a\", terminating_states_bb3, permissible_symbols_bb3, '0', rules_bb3, \"0\");\n    while !tm_bb3.is_done() {\n        println!(\"{}\", tm_bb3);\n        tm_bb3.step();\n    }\n    println!(\"{}\", tm_bb3);\n\n    println!(\"___________________\");\n    println!(\"Five-state busy beaver\");\n    let rules_bb5 = vec!(\n        Rule::new(\"A\", '0', '1', Direction::Right, \"B\"), \n        Rule::new(\"A\", '1', '1', Direction::Left, \"C\"),\n        Rule::new(\"B\", '0', '1', Direction::Right, \"C\"),\n        Rule::new(\"B\", '1', '1', Direction::Right, \"B\"),\n        Rule::new(\"C\", '0', '1', Direction::Right, \"D\"),\n        Rule::new(\"C\", '1', '0', Direction::Left, \"E\"),\n        Rule::new(\"D\", '0', '1', Direction::Left, \"A\"),\n        Rule::new(\"D\", '1', '1', Direction::Left, \"D\"),\n        Rule::new(\"E\", '0', '1', Direction::Stay, \"H\"),\n        Rule::new(\"E\", '1', '0', Direction::Left, \"A\"),\n    );\n    let states_bb5 = vec!(\"A\", \"B\", \"C\", \"D\", \"E\", \"H\");\n    let terminating_states_bb5 = vec!(\"H\");\n    let permissible_symbols_bb5 = vec!('0', '1');\n    let mut tm_bb5 = TM::new(states_bb5 ,\"A\", terminating_states_bb5, permissible_symbols_bb5, '0', rules_bb5, \"0\");\n    let mut steps = 0;\n    while !tm_bb5.is_done() {\n        tm_bb5.step();\n        steps += 1;\n    }\n    println!(\"Steps: {}\", steps);\n    println!(\"Band lenght: {}\", tm_bb5.band.len());\n}\n\nstruct TM<'a> {\n    state: &'a str,\n    terminating_states: Vec<&'a str>,\n    rules: Vec<Rule<'a>>,\n    band: VecDeque<char>,\n    head: usize,\n    blank: char,\n}\n\nstruct Rule<'a> {\n    state: &'a str,\n    read: char,\n    write: char,\n    dir: Direction,\n    new_state: &'a str,\n}\n\nenum Direction{\n    Left,\n    Right,\n    Stay,\n}\n\nimpl<'a> TM<'a> {\n\n    fn new(_states: Vec<&'a str>, initial_state: &'a str, terminating_states: Vec<&'a str>, _permissible_symbols: Vec<char>, blank: char, rules: Vec<Rule<'a>>, input: &str) -> Self {\n        Self { state: initial_state, terminating_states, rules, band: input.chars().collect::<VecDeque<_>>(), head: 0, blank }\n    }\n\n    fn is_done(&self) -> bool {\n        self.terminating_states.contains(&self.state)\n    }\n    \n    fn step(&mut self) {\n        let field = self.band.get(self.head).unwrap();\n        let rule = self.rules.iter().find(|rule| rule.state == self.state && &rule.read == field).unwrap();\n        let field = self.band.get_mut(self.head).unwrap();\n        *field = rule.write;\n        self.state = rule.new_state;\n        match rule.dir {\n            Direction::Left => {\n                if self.head == 0 {\n                    self.band.push_front(self.blank)\n                } else {\n                    self.head -= 1;\n                }\n            },\n            Direction::Right => {\n                if self.head == self.band.len() - 1 {\n                    self.band.push_back(self.blank)\n                }\n                self.head += 1;\n            },\n            Direction::Stay => {},\n        }\n    }\n}\n\nimpl<'a> Display for TM<'a> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let band = self.band.iter().enumerate().map(|(i, c)| { \n            if i == self.head {\n                format!(\"[{}]\", c)\n            } else {\n                format!(\" {} \", c)\n            }\n        }).fold(String::new(), |acc, val| acc + &val);\n        write!(f, \"{}\\t{}\", self.state, band)\n    }\n}\n\n\nimpl<'a> Rule<'a> {\n    fn new(state: &'a str, read: char, write: char, dir: Direction, new_state: &'a str) -> Self {\n        Self { state, read, write, dir, new_state }\n    }\n}\n",
    "title": "Universal Turing machine",
    "url": "http://rosettacode.org/wiki/Universal_Turing_machine"
  },
  {
    "local_code": "//! Works only with correct paths or no arguments at all\n\nuse std::path::Path;\nuse std::{env, fs};\n\nfn main() -> Result<(), std::io::Error> {\n    // ignoring all arguments except the 1st\n    if let Some(path) = env::args().nth(1) {\n        // check if the program received an argument\n        print_files(Path::new(&path))?;\n    } else {\n        // note that current_dir value might be invalid, so it's a Result\n        print_files(&env::current_dir()?)?;\n    };\n    Ok(())\n}\n\nfn print_files(path: &Path) -> std::io::Result<()> {\n    // flatten entries to avoid calling .unwrap()\n    let mut entries: Vec<_> = fs::read_dir(path)?\n        .flat_map(|entry| entry.ok().map(|f| f.file_name()))\n        .collect();\n    // read_dir does not guarantee order\n    entries.sort();\n    entries.iter().for_each(|f| {\n        println!(\"{}\", f.to_string_lossy());\n    });\n    Ok(())\n}\n",
    "path": "tasks/unix/ls",
    "remote_code": "use std::{env, fmt, fs, process};\nuse std::io::{self, Write};\nuse std::path::Path;\n\nfn main() {\n    let cur = env::current_dir().unwrap_or_else(|e| exit_err(e, 1));\n    let arg = env::args().nth(1);\n    print_files(arg.as_ref().map_or(cur.as_path(), |p| Path::new(p)))\n        .unwrap_or_else(|e| exit_err(e, 2));\n}\n\n#[inline]\nfn print_files(path: &Path) -> io::Result<()> {\n    for x in try!(fs::read_dir(path)) {\n        println!(\"{}\", try!(x).file_name().to_string_lossy());\n    }\n    Ok(())\n}\n\n#[inline]\nfn exit_err<T>(msg: T, code: i32) -> ! where T: fmt::Display {\n    writeln!(&mut io::stderr(), \"{}\", msg).expect(\"Could not write to stderr\");\n    process::exit(code)\n}",
    "title": "Unix/ls",
    "url": "http://rosettacode.org/wiki/Unix/ls"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// main.rs\nmod bit_array;\nmod prime_sieve;\n\nuse prime_sieve::PrimeSieve;\n\n// return number of decimal digits\nfn count_digits(mut n: u32) -> u32 {\n    let mut digits = 0;\n    while n > 0 {\n        n /= 10;\n        digits += 1;\n    }\n    digits\n}\n\n// return the number with one digit replaced\nfn change_digit(mut n: u32, mut index: u32, new_digit: u32) -> u32 {\n    let mut p = 1;\n    let mut changed = 0;\n    while index > 0 {\n        changed += p * (n % 10);\n        p *= 10;\n        n /= 10;\n        index -= 1;\n    }\n    changed += (10 * (n / 10) + new_digit) * p;\n    changed\n}\n\nfn unprimeable(sieve: &PrimeSieve, n: u32) -> bool {\n    if sieve.is_prime(n as usize) {\n        return false;\n    }\n    let d = count_digits(n);\n    for i in 0..d {\n        for j in 0..10 {\n            let m = change_digit(n, i, j);\n            if m != n && sieve.is_prime(m as usize) {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let mut count = 0;\n    let mut n = 100;\n    let mut lowest = vec![0; 10];\n    let mut found = 0;\n    let sieve = PrimeSieve::new(10000000);\n    println!(\"First 35 unprimeable numbers:\");\n    while count < 600 || found < 10 {\n        if unprimeable(&sieve, n) {\n            if count < 35 {\n                if count > 0 {\n                    print!(\", \");\n                }\n                print!(\"{}\", n);\n            }\n            count += 1;\n            if count == 600 {\n                println!(\"\\n600th unprimeable number: {}\", n);\n            }\n            let last_digit = n as usize % 10;\n            if lowest[last_digit] == 0 {\n                lowest[last_digit] = n;\n                found += 1;\n            }\n        }\n        n += 1;\n    }\n    for i in 0..10 {\n        println!(\"Least unprimeable number ending in {}: {}\", i, lowest[i]);\n    }\n}",
    "title": "Unprimeable numbers",
    "url": "http://rosettacode.org/wiki/Unprimeable_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Untouchable numbers",
    "url": "http://rosettacode.org/wiki/Untouchable_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Update a configuration file",
    "url": "http://rosettacode.org/wiki/Update_a_configuration_file"
  },
  {
    "local_code": "//! In order to run this task, you will need to compile the C program locating in the task linked\n//! above. The C program will need to be linked with the library produced by this file.\n//!\n//! 1. Compile this library:\n//!\n//!     ```bash\n//!     $ cargo build --release\n//!     ```\n//!\n//! 2. Copy the C program into query.c.\n//! 3. Compile and link the C program with the produced library:\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library gcc query.c -o query -Wall -Werror libquery\n//!     ```\n//! 4. Run the resulting binary.\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library ./query\n//!     Here am I\n//!     ```\n\n#![crate_type = \"cdylib\"]\n\nextern crate libc;\n\nuse std::ffi::CString;\n\nuse libc::{c_char, c_int, size_t};\n\n#[no_mangle]\n#[allow(non_snake_case)]\n#[allow(clippy::missing_safety_doc)]\npub unsafe extern \"C\" fn Query(data: *mut c_char, length: *mut size_t) -> c_int {\n    let string = \"Here am I\";\n    if *length + 1 < string.len() {\n        0\n    } else {\n        let c_string = CString::new(string).unwrap();\n        libc::strcpy(data, c_string.as_ptr());\n        *length = string.len();\n        1\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Query;\n\n    #[test]\n    fn buffer_too_small() {\n        unsafe {\n            let mut buf_size = 3;\n            let mut buffer = vec![0; buf_size];\n            assert_eq!(0, Query(buffer.as_mut_ptr(), &mut buf_size));\n        }\n    }\n\n    #[test]\n    fn buffer_contains_data() {\n        use std::ffi::{CStr, CString};\n\n        unsafe {\n            let mut buf_size = 1024;\n            let mut buffer = vec![0; buf_size];\n            assert_eq!(1, Query(buffer.as_mut_ptr(), &mut buf_size));\n            assert_eq!(\n                CString::new(\"Here am I\").unwrap(),\n                CStr::from_ptr(buffer.as_ptr()).to_owned()\n            );\n            assert_eq!(buf_size, 9);\n        }\n    }\n}\n",
    "path": "tasks/use-another-language-to-call-a-function",
    "remote_code": "\n//! In order to run this task, you will need to compile the C program locating in the task linked\n//! above. The C program will need to be linked with the library produced by this file.\n//!\n//! 1. Compile this library:\n//!\n//!     ```bash\n//!     $ cargo build --release\n//!     ```\n//!\n//! 2. Copy the C program into query.c.\n//! 3. Compile and link the C program with the produced library:\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library gcc query.c -o query -Wall -Werror libquery\n//!     ```\n//! 4. Run the resulting binary.\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library ./query\n//!     Here am I\n//!     ```\n\n#![crate_type = \"cdylib\"]\n\nextern crate libc;\n\nuse std::ffi::CString;\n\nuse libc::{c_char, c_int, size_t};\n\n#[no_mangle]\n#[allow(non_snake_case)]\n#[allow(clippy::missing_safety_doc)]\npub unsafe extern \"C\" fn Query(data: *mut c_char, length: *mut size_t) -> c_int {\n    let string = \"Here am I\";\n    if *length + 1 < string.len() {\n        0\n    } else {\n        let c_string = CString::new(string).unwrap();\n        libc::strcpy(data, c_string.as_ptr());\n        *length = string.len();\n        1\n    }\n}\n\n",
    "title": "Use another language to call a function",
    "url": "http://rosettacode.org/wiki/Use_another_language_to_call_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "User input/Graphical",
    "url": "http://rosettacode.org/wiki/User_input/Graphical"
  },
  {
    "local_code": "//! This program demonstrates proper error handling.\n\nuse std::fmt::Display;\nuse std::io::{self, Write};\nuse std::process;\n\nfn grab_input(msg: &str) -> io::Result<String> {\n    let mut buf = String::new();\n    print!(\"{}: \", msg);\n    io::stdout().flush()?;\n\n    io::stdin().read_line(&mut buf)?;\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", msg);\n    process::exit(code)\n}\n\nfn main() {\n    let s = grab_input(\"Give me a string\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    println!(\"You entered: {}\", s.trim());\n\n    let n: i32 = grab_input(\"Give me an integer\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)))\n        .trim()\n        .parse()\n        .unwrap_or_else(|e| exit_err(&e, 2));\n\n    println!(\"You entered: {}\", n);\n}\n",
    "path": "tasks/user-input/text",
    "remote_code": "use std::io::{self, Write};\nuse std::fmt::Display;\nuse std::process;\n\nfn main() {\n    let s = grab_input(\"Give me a string\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    println!(\"You entered: {}\", s.trim());\n\n    let n: i32 = grab_input(\"Give me an integer\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)))\n        .trim()\n        .parse()\n        .unwrap_or_else(|e| exit_err(&e, 2));\n\n    println!(\"You entered: {}\", n);\n}\n\nfn grab_input(msg: &str) -> io::Result<String> {\n    let mut buf = String::new();\n    print!(\"{}: \", msg);\n    try!(io::stdout().flush());\n\n    try!(io::stdin().read_line(&mut buf));\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", msg);\n    process::exit(code)\n}",
    "title": "User input/Text",
    "url": "http://rosettacode.org/wiki/User_input/Text"
  },
  {
    "local_code": "extern crate luhn_test_of_credit_card_numbers;\n\nuse luhn_test_of_credit_card_numbers::luhn_test;\n\npub fn validate_isin(isin: &str) -> bool {\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len() != 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes\n        .iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            } else {\n                (c + 10 - (b'A')).to_string().into_bytes()\n            }\n        })\n        .collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<u64>().unwrap();\n\n    luhn_test(number as u64)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::validate_isin;\n\n    #[test]\n    fn test_validate_isin() {\n        assert_eq!(validate_isin(\"US0378331005\"), true);\n        assert_eq!(validate_isin(\"US0373831005\"), false);\n        assert_eq!(validate_isin(\"U50378331005\"), false);\n        assert_eq!(validate_isin(\"US03378331005\"), false);\n        assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n        assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n        assert_eq!(validate_isin(\"FR0000988040\"), true);\n    }\n}\n",
    "path": "tasks/validate-isin",
    "remote_code": "extern crate luhn_cc;\n\nuse luhn_cc::compute_luhn;\n\nfn main() {\n    assert_eq!(validate_isin(\"US0378331005\"), true);\n    assert_eq!(validate_isin(\"US0373831005\"), false);\n    assert_eq!(validate_isin(\"U50378331005\"), false);\n    assert_eq!(validate_isin(\"US03378331005\"), false);\n    assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n    assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n    assert_eq!(validate_isin(\"FR0000988040\"), true);\n}\n\nfn validate_isin(isin: &str) -> bool {\n    // Preliminary checks to avoid working on non-ASCII stuff\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len() != 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    // Converts the alphanumeric string in a numeric-only string\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes.iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            }\n            else {\n                (c + 10 - ('A' as u8)).to_string().into_bytes()\n            }\n        }).collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<usize>().unwrap();\n\n    return compute_luhn(number);\n}\n",
    "title": "Validate International Securities Identification Number",
    "url": "http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number"
  },
  {
    "local_code": "use std::cmp::{max, min};\n\nstatic TENS: [u64; 20] = [\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000,\n    10000000000,\n    100000000000,\n    1000000000000,\n    10000000000000,\n    100000000000000,\n    1000000000000000,\n    10000000000000000,\n    100000000000000000,\n    1000000000000000000,\n    10000000000000000000,\n];\n\n/// Get the number of digits present in x\nfn ndigits(mut x: u64) -> u64 {\n    let mut n = 0;\n\n    while x != 0 {\n        n += 1;\n        x /= 10;\n    }\n\n    n\n}\n\nfn dtally(mut x: u64) -> u64 {\n    let mut t = 0;\n\n    while x != 0 {\n        t += 1 << ((x % 10) * 6);\n        x /= 10;\n    }\n\n    t\n}\n\n/// Get a list of all fangs of x. Get only the first divider of each fang. The second one can be found simply with x / fang.\nfn fangs(x: u64) -> Vec<u64> {\n    let mut nd = ndigits(x) as usize;\n\n    let mut fangs = vec![];\n\n    if nd & 1 != 1 {\n        nd /= 2;\n\n        let lo = max(TENS[nd - 1], (x + TENS[nd] - 2) / (TENS[nd] - 1));\n        let hi = min(x / lo, (x as f64).sqrt() as u64);\n\n        let t = dtally(x);\n\n        for a in lo..(hi + 1) {\n            let b = x / a;\n            if a * b == x && ((a % 10) > 0 || b % 10 > 0) && t == dtally(a) + dtally(b) {\n                fangs.push(a);\n            }\n        }\n    }\n\n    fangs\n}\n\n/// Pretty print the fangs of x\nfn print_fangs(x: u64, fangs: Vec<u64>) {\n    print!(\"{} = \", x);\n\n    if fangs.is_empty() {\n        print!(\"is not vampiric\");\n    } else {\n        for fang in fangs {\n            print!(\"{} x {}, \", fang, x / fang);\n        }\n    }\n    println!();\n}\n\nfn main() {\n    println!(\"The first 25 vampire numbers are :\");\n\n    let mut nfangs = 0;\n    let mut x = 1;\n\n    while nfangs < 25 {\n        let fangs = fangs(x);\n        if !fangs.is_empty() {\n            nfangs += 1;\n            print_fangs(x, fangs);\n        }\n\n        x += 1;\n    }\n\n    println!(\"\\nSpecial requests :\");\n\n    print_fangs(16758243290880, fangs(16758243290880));\n    print_fangs(24959017348650, fangs(24959017348650));\n    print_fangs(14593825548650, fangs(14593825548650));\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        fangs(16758243290880),\n        vec![1982736, 2123856, 2751840, 2817360]\n    );\n\n    assert_eq!(\n        fangs(24959017348650),\n        vec![2947050, 2949705, 4125870, 4129587, 4230765]\n    );\n\n    assert_eq!(fangs(14593825548650), vec![]);\n}\n",
    "path": "tasks/vampire-number",
    "remote_code": "use std::cmp::{max, min};\n\nstatic TENS: [u64; 20] = [\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000,\n    10000000000,\n    100000000000,\n    1000000000000,\n    10000000000000,\n    100000000000000,\n    1000000000000000,\n    10000000000000000,\n    100000000000000000,\n    1000000000000000000,\n    10000000000000000000,\n];\n\n/// Get the number of digits present in x\nfn ndigits(mut x: u64) -> u64 {\n    let mut n = 0;\n\n    while x != 0 {\n        n += 1;\n        x /= 10;\n    }\n\n    n\n}\n\nfn dtally(mut x: u64) -> u64 {\n    let mut t = 0;\n\n    while x != 0 {\n        t += 1 << ((x % 10) * 6);\n        x /= 10;\n    }\n\n    t\n}\n\n/// Get a list of all fangs of x. Get only the first divider of each fang. The second one can be found simply with x / fang.\nfn fangs(x: u64) -> Vec<u64> {\n    let mut nd = ndigits(x) as usize;\n\n    let mut fangs = vec![];\n\n    if nd & 1 != 1 {\n        nd /= 2;\n\n        let lo = max(TENS[nd - 1], (x + TENS[nd] - 2) / (TENS[nd] - 1));\n        let hi = min(x / lo, (x as f64).sqrt() as u64);\n\n        let t = dtally(x);\n\n        for a in lo..(hi + 1) {\n            let b = x / a;\n            if a * b == x && ((a % 10) > 0 || b % 10 > 0) && t == dtally(a) + dtally(b) {\n                fangs.push(a);\n            }\n        }\n    }\n\n    fangs\n}\n\n/// Pretty print the fangs of x\nfn print_fangs(x: u64, fangs: Vec<u64>) {\n    print!(\"{} = \", x);\n\n    if fangs.is_empty() {\n        print!(\"is not vampiric\");\n    } else {\n        for fang in fangs {\n            print!(\"{} x {}, \", fang, x / fang);\n        }\n    }\n    print!(\"\\n\");\n}\n\nfn main() {\n    println!(\"The first 25 vampire numbers are :\");\n\n    let mut nfangs = 0;\n    let mut x = 1;\n\n    while nfangs < 25 {\n        let fangs = fangs(x);\n        if !fangs.is_empty() {\n            nfangs += 1;\n            print_fangs(x, fangs);\n        }\n\n        x += 1;\n    }\n\n    println!(\"\\nSpecial requests :\");\n\n    print_fangs(16758243290880, fangs(16758243290880));\n    print_fangs(24959017348650, fangs(24959017348650));\n    print_fangs(14593825548650, fangs(14593825548650));\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        fangs(16758243290880),\n        vec![1982736, 2123856, 2751840, 2817360]\n    );\n\n    assert_eq!(\n        fangs(24959017348650),\n        vec![2947050, 2949705, 4125870, 4129587, 4230765]\n    );\n\n    assert_eq!(fangs(14593825548650), vec![]);\n}",
    "title": "Vampire number",
    "url": "http://rosettacode.org/wiki/Vampire_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn van_eck_sequence() -> impl std::iter::Iterator<Item = i32> {\n    let mut index = 0;\n    let mut last_term = 0;\n    let mut last_pos = std::collections::HashMap::new();\n    std::iter::from_fn(move || {\n        let result = last_term;\n        let mut next_term = 0;\n        if let Some(v) = last_pos.get_mut(&last_term) {\n            next_term = index - *v;\n            *v = index;\n        } else {\n            last_pos.insert(last_term, index);\n        }\n        last_term = next_term;\n        index += 1;\n        Some(result)\n    })\n}\n\nfn main() {\n    let mut v = van_eck_sequence().take(1000);\n    println!(\"First 10 terms of the Van Eck sequence:\");\n    for n in v.by_ref().take(10) {\n        print!(\"{} \", n);\n    }\n    println!(\"\\nTerms 991 to 1000 of the Van Eck sequence:\");\n    for n in v.skip(980) {\n        print!(\"{} \", n);\n    }\n    println!();\n}",
    "title": "Van Eck sequence",
    "url": "http://rosettacode.org/wiki/Van_Eck_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n/// Van der Corput sequence for any base, based on C languange example from Wikipedia.\npub fn corput(nth: usize, base: usize) -> f64 {\n    let mut n = nth;\n    let mut q: f64 = 0.0;\n    let mut bk: f64 = 1.0 / (base as f64);\n\n    while n > 0_usize {\n      q += ((n % base) as f64)*bk;\n      n /= base;\n      bk /= base as f64;\n    }\n    q\n}\n\nfn main() {\n  for base in 2_usize..=5_usize {\n    print!(\"Base {}:\", base);\n    for i in 1_usize..=10_usize {\n      let c = corput(i, base);\n      print!(\"  {:.6}\", c)\n    }\n    println!(\"\");\n  }\n}\n\n",
    "title": "Van der Corput sequence",
    "url": "http://rosettacode.org/wiki/Van_der_Corput_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable declaration reset",
    "url": "http://rosettacode.org/wiki/Variable_declaration_reset"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::mem;\n\nfn main() {\n    // Specify type\n    assert_eq!(4, mem::size_of::<i32>());\n    \n    // Provide a value\n    let arr: [u16; 3] = [1, 2, 3];\n    assert_eq!(6, mem::size_of_val(&arr));\n}\n",
    "title": "Variable size/Get",
    "url": "http://rosettacode.org/wiki/Variable_size/Get"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable size/Set",
    "url": "http://rosettacode.org/wiki/Variable_size/Set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable-length quantity",
    "url": "http://rosettacode.org/wiki/Variable-length_quantity"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variables",
    "url": "http://rosettacode.org/wiki/Variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// 20220106 Rust programming solution\n\nmacro_rules! print_all {\n   ($($args:expr),*) => { $( println!(\"{}\", $args); )* } \n}\n\nfn main() {\n   print_all!(\"Rosetta\", \"Code\", \"Is\", \"Awesome!\");\n}",
    "title": "Variadic function",
    "url": "http://rosettacode.org/wiki/Variadic_function"
  },
  {
    "local_code": "mod vector;\n\nuse std::f64::consts::PI;\nuse vector::Vector;\n\nfn main() {\n    println!(\"{:?}\", Vector::new(4, 5));\n    println!(\"{:.4}\", Vector::from_polar(3.0, PI / 3 as f64));\n    println!(\"{}\", Vector::new(2, 3) + Vector::new(4, 6));\n    println!(\"{:.4}\", Vector::new(5.6, 1.3) - Vector::new(4.2, 6.1));\n    println!(\"{:.4}\", Vector::new(3.0, 4.2) * 2.3);\n    println!(\"{:.4}\", Vector::new(3.0, 4.2) / 2.3);\n    println!(\"{}\", Vector::new(3, 4) / 2);\n}\nuse std::fmt;\nuse std::ops;\n\n#[derive(Copy, Clone, Debug)]\npub struct Vector<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Vector<T> {\n    pub fn new(x: T, y: T) -> Self {\n        Vector { x, y }\n    }\n}\n\nimpl Vector<f64> {\n    pub fn from_polar(r: f64, theta: f64) -> Self {\n        Vector {\n            x: r * theta.cos(),\n            y: r * theta.sin(),\n        }\n    }\n}\n\nimpl<T> fmt::Display for Vector<T>\nwhere\n    T: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(precision) = f.precision() {\n            write!(f, \"[{:.*}, {:.*}]\", precision, self.x, precision, self.y)\n        } else {\n            write!(f, \"[{}, {}]\", self.x, self.y)\n        }\n    }\n}\n\nimpl<T> ops::Add for Vector<T>\nwhere\n    T: ops::Add<Output = T>,\n{\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self::Output {\n        Vector {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nimpl<T> ops::Sub for Vector<T>\nwhere\n    T: ops::Sub<Output = T>,\n{\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self::Output {\n        Vector {\n            x: self.x - other.x,\n            y: self.y - other.y,\n        }\n    }\n}\n\nimpl<T> ops::Mul<T> for Vector<T>\nwhere\n    T: ops::Mul<Output = T> + Copy,\n{\n    type Output = Self;\n\n    fn mul(self, scalar: T) -> Self::Output {\n        Vector {\n            x: self.x * scalar,\n            y: self.y * scalar,\n        }\n    }\n}\n\nimpl<T> ops::Div<T> for Vector<T>\nwhere\n    T: ops::Div<Output = T> + Copy,\n{\n    type Output = Self;\n\n    fn div(self, scalar: T) -> Self::Output {\n        Vector {\n            x: self.x / scalar,\n            y: self.y / scalar,\n        }\n    }\n}\n",
    "path": "tasks/vector",
    "remote_code": "use std::fmt;\nuse std::ops::{Add, Div, Mul, Sub};\n\n#[derive(Copy, Clone, Debug)]\npub struct Vector<T> {\n    pub x: T,\n    pub y: T,\n}\n\nimpl<T> fmt::Display for Vector<T>\nwhere\n    T: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(prec) = f.precision() {\n            write!(f, \"[{:.*}, {:.*}]\", prec, self.x, prec, self.y)\n        } else {\n            write!(f, \"[{}, {}]\", self.x, self.y)\n        }\n    }\n}\n\nimpl<T> Vector<T> {\n    pub fn new(x: T, y: T) -> Self {\n        Vector { x, y }\n    }\n}\n\nimpl Vector<f64> {\n    pub fn from_polar(r: f64, theta: f64) -> Self {\n        Vector {\n            x: r * theta.cos(),\n            y: r * theta.sin(),\n        }\n    }\n}\n\nimpl<T> Add for Vector<T>\nwhere\n    T: Add<Output = T>,\n{\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self::Output {\n        Vector {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nimpl<T> Sub for Vector<T>\nwhere\n    T: Sub<Output = T>,\n{\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self::Output {\n        Vector {\n            x: self.x - other.x,\n            y: self.y - other.y,\n        }\n    }\n}\n\nimpl<T> Mul<T> for Vector<T>\nwhere\n    T: Mul<Output = T> + Copy,\n{\n    type Output = Self;\n\n    fn mul(self, scalar: T) -> Self::Output {\n        Vector {\n            x: self.x * scalar,\n            y: self.y * scalar,\n        }\n    }\n}\n\nimpl<T> Div<T> for Vector<T>\nwhere\n    T: Div<Output = T> + Copy,\n{\n    type Output = Self;\n\n    fn div(self, scalar: T) -> Self::Output {\n        Vector {\n            x: self.x / scalar,\n            y: self.y / scalar,\n        }\n    }\n}\n\nfn main() {\n    use std::f64::consts::FRAC_PI_3;\n\n    println!(\"{:?}\", Vector::new(4, 5));\n    println!(\"{:.4}\", Vector::from_polar(3.0, FRAC_PI_3));\n    println!(\"{}\", Vector::new(2, 3) + Vector::new(4, 6));\n    println!(\"{:.4}\", Vector::new(5.6, 1.3) - Vector::new(4.2, 6.1));\n    println!(\"{:.4}\", Vector::new(3.0, 4.2) * 2.3);\n    println!(\"{:.4}\", Vector::new(3.0, 4.2) / 2.3);\n    println!(\"{}\", Vector::new(3, 4) / 2);\n}",
    "title": "Vector",
    "url": "http://rosettacode.org/wiki/Vector"
  },
  {
    "local_code": "#[derive(Clone, Copy, PartialEq, Debug)]\nstruct Vector {\n    x: f32,\n    y: f32,\n    z: f32,\n}\n\nimpl Vector {\n    fn new(x: f32, y: f32, z: f32) -> Vector {\n        Vector { x, y, z }\n    }\n}\n\nfn dot(a: Vector, b: Vector) -> f32 {\n    a.x * b.x + a.y * b.y + a.z * b.z\n}\n\nfn cross(a: Vector, b: Vector) -> Vector {\n    Vector {\n        x: { a.y * b.z - a.z * b.y },\n        y: { a.z * b.x - a.x * b.z },\n        z: { a.x * b.y - a.y * b.x },\n    }\n}\n\nfn scalar3(a: Vector, b: Vector, c: Vector) -> f32 {\n    dot(a, cross(b, c))\n}\n\nfn vector3(a: Vector, b: Vector, c: Vector) -> Vector {\n    cross(a, cross(b, c))\n}\n\nfn main() {\n    let a = Vector::new(3.0, 4.0, 5.0);\n    let b = Vector::new(4.0, 3.0, 5.0);\n    let c = Vector::new(-5.0, -12.0, -13.0);\n\n    println!(\"Dot product: {}\", dot(a, b));\n    println!(\"Cross product: {:?}\", cross(a, b));\n    println!(\"Scalar triple product: {}\", scalar3(a, b, c));\n    println!(\"Vector triple product: {:?}\", vector3(a, b, c));\n}\n\n#[allow(clippy::float_cmp)]\n#[test]\nfn vector_dot_product() {\n    let a = Vector::new(1.0, 3.0, -5.0);\n    let b = Vector::new(4.0, -2.0, -1.0);\n    assert_eq!(dot(a, b), 3.0);\n}\n\n#[test]\nfn vector_cross_product() {\n    let a = Vector::new(2.0, 3.0, 4.0);\n    let b = Vector::new(5.0, 6.0, 7.0);\n    assert_eq!(\n        cross(a, b),\n        Vector {\n            x: -3.0,\n            y: 6.0,\n            z: -3.0,\n        }\n    );\n}\n",
    "path": "tasks/vector-products",
    "remote_code": "#[derive(Debug)]\nstruct Vector {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nimpl Vector {\n    fn new(x: f64, y: f64, z: f64) -> Self {\n        Vector {\n            x: x,\n            y: y,\n            z: z,\n        }\n    }\n\n    fn dot_product(&self, other: &Vector) -> f64 {\n        (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n    }\n\n    fn cross_product(&self, other: &Vector) -> Vector {\n        Vector::new(self.y * other.z - self.z * other.y,\n                    self.z * other.x - self.x * other.z,\n                    self.x * other.y - self.y * other.x)\n    }\n\n    fn scalar_triple_product(&self, b: &Vector, c: &Vector) -> f64 {\n        self.dot_product(&b.cross_product(&c))\n    }\n\n    fn vector_triple_product(&self, b: &Vector, c: &Vector) -> Vector {\n        self.cross_product(&b.cross_product(&c))\n    }\n}\n\nfn main(){\n    let a = Vector::new(3.0, 4.0, 5.0);\n    let b = Vector::new(4.0, 3.0, 5.0);\n    let c = Vector::new(-5.0, -12.0, -13.0);\n\n    println!(\"a . b = {}\", a.dot_product(&b));\n    println!(\"a x b = {:?}\", a.cross_product(&b));\n    println!(\"a . (b x c) = {}\", a.scalar_triple_product(&b, &c));\n    println!(\"a x (b x c) = {:?}\", a.vector_triple_product(&b, &c));\n}",
    "title": "Vector products",
    "url": "http://rosettacode.org/wiki/Vector_products"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Verhoeff algorithm",
    "url": "http://rosettacode.org/wiki/Verhoeff_algorithm"
  },
  {
    "local_code": "use statrs::function::gamma::gamma_li;\n\n#[allow(clippy::cast_precision_loss)]\nfn chi_distance(dataset: &[u32]) -> f64 {\n    let expected = f64::from(dataset.iter().sum::<u32>()) / dataset.len() as f64;\n    dataset\n        .iter()\n        .fold(0., |acc, &elt| acc + (f64::from(elt) - expected).powf(2.))\n        / expected\n}\n\nfn chi2_probability(dof: f64, distance: f64) -> f64 {\n    1. - gamma_li(dof * 0.5, distance * 0.5)\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn chi2_uniform(dataset: &[u32], significance: f64) -> bool {\n    let d = chi_distance(dataset);\n    chi2_probability(dataset.len() as f64 - 1., d) > significance\n}\n\n#[allow(clippy::cast_precision_loss)]\nfn main() {\n    let dsets = vec![\n        vec![199_809, 200_665, 199_607, 200_270, 199_649],\n        vec![522_573, 244_456, 139_979, 71_531, 21_461],\n    ];\n\n    for ds in dsets {\n        println!(\"Data set: {:?}\", ds);\n        let d = chi_distance(&ds);\n        print!(\"Distance: {:.6} \", d);\n        print!(\n            \"Chi2 probability: {:.6} \",\n            chi2_probability(ds.len() as f64 - 1., d)\n        );\n        println!(\"Uniform? {}\", chi2_uniform(&ds, 0.05));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{chi2_probability, chi_distance};\n    use assert_approx_eq::assert_approx_eq;\n\n    #[test]\n    fn test_chi_probability() {\n        let input: Vec<u32> = vec![199809, 200665, 199607, 200270, 199649];\n        assert_approx_eq!(chi_distance(&input), 4.146280);\n\n        assert_approx_eq!(\n            chi2_probability(input.len() as f64 - 1., chi_distance(&input)),\n            0.386571\n        );\n    }\n}\n",
    "path": "tasks/chi-squared-test",
    "remote_code": "\nuse statrs::function::gamma::gamma_li;\n\nfn chi_distance(dataset: &[u32]) -> f64 {\n    let expected = f64::from(dataset.iter().sum::<u32>()) / dataset.len() as f64;\n    dataset\n        .iter()\n        .fold(0., |acc, &elt| acc + (elt as f64 - expected).powf(2.))\n        / expected\n}\n\nfn chi2_probability(dof: f64, distance: f64) -> f64 {\n    1. - gamma_li(dof * 0.5, distance * 0.5)\n}\n\nfn chi2_uniform(dataset: &[u32], significance: f64) -> bool {\n    let d = chi_distance(&dataset);\n    chi2_probability(dataset.len() as f64 - 1., d) > significance\n}\n\nfn main() {\n    let dsets = vec![\n        vec![199809, 200665, 199607, 200270, 199649],\n        vec![522573, 244456, 139979, 71531, 21461],\n    ];\n\n    for ds in dsets {\n        println!(\"Data set: {:?}\", ds);\n        let d = chi_distance(&ds);\n        print!(\"Distance: {:.6} \", d);\n        print!(\n            \"Chi2 probability: {:.6} \",\n            chi2_probability(ds.len() as f64 - 1., d)\n        );\n        print!(\"Uniform? {}\\n\", chi2_uniform(&ds, 0.05));\n    }\n}\n\n",
    "title": "Verify distribution uniformity/Chi-squared test",
    "url": "http://rosettacode.org/wiki/Verify_distribution_uniformity/Chi-squared_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Verify distribution uniformity/Naive",
    "url": "http://rosettacode.org/wiki/Verify_distribution_uniformity/Naive"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Video display modes",
    "url": "http://rosettacode.org/wiki/Video_display_modes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Soundex",
    "url": "http://rosettacode.org/wiki/Soundex"
  },
  {
    "local_code": "const ASCII_A: u8 = b'A';\n\nfn main() {\n    let msg = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    let enc = vigenere(msg, key, true);\n    let dec = vigenere(&enc, key, false);\n\n    println!(\"msg: {}\", msg);\n    println!(\"key: {}\", key);\n    println!(\"enc: {}\", enc);\n    println!(\"dec: {}\", dec);\n}\n\nfn vigenere(plaintext: &str, key: &str, encrypt: bool) -> String {\n    let plaintext_bytes = to_sanitized_bytes(plaintext);\n    let key_bytes = to_sanitized_bytes(key);\n    let key_len = key_bytes.len();\n    let mut output = String::with_capacity(plaintext_bytes.len());\n\n    for (i, byte) in plaintext_bytes.iter().enumerate() {\n        let c = *byte;\n        let b = key_bytes[i % key_len];\n\n        let output_byte = if encrypt {\n            enc_byte(c, b)\n        } else {\n            dec_byte(c, b)\n        };\n\n        output.push(output_byte as char);\n    }\n    output\n}\n\nfn to_sanitized_bytes(string: &str) -> Vec<u8> {\n    string\n        .chars()\n        .filter(|&c| c.is_alphabetic())\n        .map(|c| c.to_ascii_uppercase() as u8)\n        .collect::<Vec<u8>>()\n}\n\nfn enc_byte(m: u8, k: u8) -> u8 {\n    ASCII_A + (m.wrapping_add(k).wrapping_sub(2 * (ASCII_A))) % 26\n}\n\nfn dec_byte(c: u8, k: u8) -> u8 {\n    ASCII_A + (c.wrapping_sub(k).wrapping_add(26)) % 26\n}\n\n#[test]\nfn test_enc_dec() {\n    let plaintext = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    let enc = vigenere(plaintext, key, true);\n    assert_eq!(\n        \"WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\",\n        enc\n    );\n    let dec = vigenere(&enc, key, false);\n    assert_eq!(\n        \"BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\",\n        dec\n    );\n}\n\n#[test]\nfn test_equal_len_key_and_plaintext() {\n    let plaintext = \"VIGENERECIPHER\";\n    let key = \"REHPICERENEGIV\";\n    // to be sure nobody breaks this test\n    assert_eq!(plaintext.len(), key.len());\n\n    let enc = vigenere(plaintext, key, true);\n    assert_eq!(\"MMNTVGVVGVTNMM\", enc);\n    let dec = vigenere(&enc, key, false);\n    assert_eq!(plaintext, dec);\n}\n\n#[test]\nfn test_empty_string_enc_dec() {\n    let enc = vigenere(\"\", \"\", true);\n    assert_eq!(\"\", enc);\n    let dec = vigenere(\"\", \"\", false);\n    assert_eq!(\"\", dec);\n}\n",
    "path": "tasks/vigenere-cipher",
    "remote_code": "use std::ascii::AsciiExt;\n\nstatic A: u8 = 'A' as u8;\n\nfn uppercase_and_filter(input: &str) -> Vec<u8> {\n    let alphabet = b\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut result = Vec::new();\n\n    for c in input.chars() {\n        // Ignore anything that is not in our short list of chars. We can then safely cast to u8.\n        if alphabet.iter().any(|&x| x as char == c) {\n            result.push(c.to_ascii_uppercase() as u8);\n        }\n    }\n\n    return result;\n}\n\nfn vigenere(key: &str, text: &str, is_encoding: bool) -> String {\n\n    let key_bytes = uppercase_and_filter(key);\n    let text_bytes = uppercase_and_filter(text);\n\n    let mut result_bytes = Vec::new();\n\n    for (i, c) in text_bytes.iter().enumerate() {\n        let c2 = if is_encoding {\n            (c + key_bytes[i % key_bytes.len()] - 2 * A) % 26 + A\n        } else {\n            (c + 26 - key_bytes[i % key_bytes.len()]) % 26 + A\n        };\n        result_bytes.push(c2);\n    }\n\n    String::from_utf8(result_bytes).unwrap()\n}\n\nfn main() {\n    let text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    println!(\"Text: {}\", text);\n    println!(\"Key:  {}\", key);\n\n    let encoded = vigenere(key, text, true);\n    println!(\"Code: {}\", encoded);\n    let decoded = vigenere(key, &encoded, false);\n    println!(\"Back: {}\", decoded);\n}",
    "title": "Vigenère cipher",
    "url": "http://rosettacode.org/wiki/Vigen%C3%A8re_cipher"
  },
  {
    "local_code": "const FREQ: [f64; 26] = [\n    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966, 0.00153,\n    0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056,\n    0.02758, 0.00978, 0.02360, 0.00150, 0.01974, 0.00074,\n];\n\nconst ENCODED: &str = r##\"\nMOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\nVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\nITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\nFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\nALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\nILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\nJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\nLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\nMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\nQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\nRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\nTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\nSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\nZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\nBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\nBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\nFWAML ZZRXJ EKAHV FASMU LVVUT TGK\n\"##;\n\nconst ASCII_A: u8 = b'A';\n\nfn best_match(a: &[f64]) -> u8 {\n    let sum: f64 = a.iter().sum();\n    let mut best_fit = 1E100;\n    let mut best_rotate = 0;\n    (0..26).for_each(|rotate| {\n        let mut fit = 0.0;\n        (0..26).for_each(|i| {\n            let d = a[(i + rotate) % 26] / sum - FREQ[i];\n            fit += d * d / FREQ[i];\n        });\n        if fit < best_fit {\n            best_fit = fit;\n            best_rotate = rotate as u8;\n        }\n    });\n\n    best_rotate\n}\n\nfn freq_every_nth(msg: &[u8], interval: usize) -> (f64, Vec<char>) {\n    let len = msg.len();\n    let mut key = vec!['?'; interval];\n    let mut out = [0.0; 26];\n    let mut accu = [0.0; 26];\n    (0..interval).for_each(|j| {\n        out = [0.0; 26];\n        (j..len)\n            .step_by(interval)\n            .for_each(|i| out[(msg[i] - ASCII_A) as usize] += 1.0);\n        let rot = best_match(&out);\n        key[j] = (rot + ASCII_A) as char;\n        (0..26).for_each(|i| {\n            accu[i] += out[(i + rot as usize) % 26];\n        })\n    });\n\n    let sum: f64 = accu.iter().sum();\n    let mut ret = 0.0;\n    (0..26).for_each(|i| {\n        let d = accu[i] / sum - FREQ[i];\n        ret += d * d / FREQ[i];\n    });\n\n    (ret, key)\n}\n\nfn main() {\n    let mut best_fit = 1E100;\n    let mut best_key = String::new();\n\n    let sanitized_encoded = to_sanitized_bytes(ENCODED);\n    (1..=26).for_each(|j| {\n        let (fit, key) = freq_every_nth(&sanitized_encoded, j);\n        if fit < best_fit {\n            best_fit = fit;\n            best_key = key.iter().collect();\n        }\n    });\n    println!(\"Best key: {}\", &best_key);\n    println!(\"Decrypted text:\\n{}\", vigenere(ENCODED, &best_key, false));\n}\n\nfn vigenere(plaintext: &str, key: &str, encrypt: bool) -> String {\n    let plaintext_bytes = to_sanitized_bytes(plaintext);\n    let key_bytes = to_sanitized_bytes(key);\n    let key_len = key_bytes.len();\n    let mut output = String::with_capacity(plaintext_bytes.len());\n\n    for (i, byte) in plaintext_bytes.iter().enumerate() {\n        let c = *byte;\n        let b = key_bytes[i % key_len];\n\n        let output_byte = if encrypt {\n            enc_byte(c, b)\n        } else {\n            dec_byte(c, b)\n        };\n\n        output.push(output_byte as char);\n    }\n    output\n}\n\nfn to_sanitized_bytes(string: &str) -> Vec<u8> {\n    string\n        .chars()\n        .filter(|&c| c.is_alphabetic())\n        .map(|c| c.to_ascii_uppercase() as u8)\n        .collect::<Vec<u8>>()\n}\n\nfn enc_byte(m: u8, k: u8) -> u8 {\n    ASCII_A + (m.wrapping_add(k).wrapping_sub(2 * (ASCII_A))) % 26\n}\n\nfn dec_byte(c: u8, k: u8) -> u8 {\n    ASCII_A + (c.wrapping_sub(k).wrapping_add(26)) % 26\n}\n",
    "path": "tasks/vigenere-cipher-cryptanalysis",
    "remote_code": "\nuse std::iter::FromIterator;\n\nconst CRYPTOGRAM: &str = \"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\nVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\nITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\nFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\nALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\nILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\nJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\nLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\nMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\nQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\nRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\nTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\nSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\nZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\nBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\nBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\nFWAML ZZRXJ EKAHV FASMU LVVUT TGK\";\n\nconst FREQUENCIES: [f32; 26] = [\n    0.08167, 0.01492, 0.02202, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966, 0.00153,\n    0.01292, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09356,\n    0.02758, 0.00978, 0.02560, 0.00150, 0.01994, 0.00077,\n];\n\nfn best_match(a: &[f32]) -> u8 {\n    let sum: f32 = a.iter().sum();\n    let mut best_fit = std::f32::MAX;\n    let mut best_rotate = 0;\n    for rotate in 0..=25 {\n        let mut fit = 0.;\n        for i in 0..=25 {\n            let char_freq = FREQUENCIES[i];\n            let idx = (i + rotate as usize) % 26 as usize;\n            let d = a[idx] / sum - char_freq;\n            fit += d * d / char_freq;\n        }\n        if fit < best_fit {\n            best_fit = fit;\n            best_rotate = rotate;\n        }\n    }\n\n    best_rotate\n}\n\nfn freq_every_nth(msg: &[u8], key: &mut [char]) -> f32 {\n    let len = msg.len();\n    let interval = key.len();\n    let mut accu = [0.; 26];\n    for j in 0..interval {\n        let mut out = [0.; 26];\n        for i in (j..len).step_by(interval) {\n            let idx = msg[i] as usize;\n            out[idx] += 1.;\n        }\n        let rot = best_match(&out);\n        key[j] = char::from(rot + b'A');\n        for i in 0..=25 {\n            let idx: usize = (i + rot as usize) % 26;\n            accu[i] += out[idx];\n        }\n    }\n    let sum: f32 = accu.iter().sum();\n    let mut ret = 0.;\n    for i in 0..=25 {\n        let char_freq = FREQUENCIES[i];\n        let d = accu[i] / sum - char_freq;\n        ret += d * d / char_freq;\n    }\n    ret\n}\n\nfn decrypt(text: &str, key: &str) -> String {\n    let key_chars_cycle = key.as_bytes().iter().map(|b| *b as i32).cycle();\n    let is_ascii_uppercase = |c: &u8| (b'A'..=b'Z').contains(c);\n    text.as_bytes()\n        .iter()\n        .filter(|c| is_ascii_uppercase(c))\n        .map(|b| *b as i32)\n        .zip(key_chars_cycle)\n        .fold(String::new(), |mut acc, (c, key_char)| {\n            let ci: u8 = ((c - key_char + 26) % 26) as u8;\n            acc.push(char::from(b'A' + ci));\n            acc\n        })\n}\nfn main() {\n    let enc = CRYPTOGRAM\n        .split_ascii_whitespace()\n        .collect::<Vec<_>>()\n        .join(\"\");\n    let cryptogram: Vec<u8> = enc.as_bytes().iter().map(|b| u8::from(b - b'A')).collect();\n    let mut best_fit = std::f32::MAX;\n    let mut best_key = String::new();\n    for j in 1..=26 {\n        let mut key = vec!['\\0'; j];\n        let fit = freq_every_nth(&cryptogram, &mut key);\n        let s_key = String::from_iter(key); // 'from_iter' is imported from std::iter::FromIterator;\n        if fit < best_fit {\n            best_fit = fit;\n            best_key = s_key;\n        }\n    }\n\n    println!(\"best key: {}\", &best_key);\n    println!(\"\\nDecrypted text:\\n{}\", decrypt(&enc, &best_key));\n}\n",
    "title": "Vigenère cipher/Cryptanalysis",
    "url": "http://rosettacode.org/wiki/Vigen%C3%A8re_cipher/Cryptanalysis"
  },
  {
    "local_code": "#[macro_use]\nextern crate serde_derive;\n\nextern crate rand;\nextern crate serde;\nextern crate serde_json;\nextern crate term_painter;\n\nuse std::cmp::Ordering;\nuse std::env;\nuse std::fmt::{Debug, Display, Formatter, Result};\n\nuse rand::distributions::Uniform;\nuse rand::Rng;\nuse term_painter::Color::*;\nuse term_painter::ToStyle;\n\ntype NodePtr = Option<usize>;\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum Side {\n    Left,\n    Right,\n    Up,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum DisplayElement {\n    TrunkSpace,\n    SpaceLeft,\n    SpaceRight,\n    SpaceSpace,\n    Root,\n}\n\nimpl DisplayElement {\n    fn string(&self) -> String {\n        let x = match *self {\n            DisplayElement::TrunkSpace => \"    │   \",\n            DisplayElement::SpaceRight => \"    ┌───\",\n            DisplayElement::SpaceLeft => \"    └───\",\n            DisplayElement::SpaceSpace => \"        \",\n            DisplayElement::Root => \"├──\",\n        };\n        x.to_string()\n    }\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize)]\nstruct Node<K, V> {\n    key: K,\n    value: V,\n    left: NodePtr,\n    right: NodePtr,\n    up: NodePtr,\n}\n\nimpl<K: Ord + Copy, V: Copy> Node<K, V> {\n    pub fn new(k: K, v: V) -> Node<K, V> {\n        Node {\n            key: k,\n            value: v,\n            left: None,\n            right: None,\n            up: None,\n        }\n    }\n\n    pub fn set_ptr(&mut self, side: Side, to: NodePtr) {\n        let field = match side {\n            Side::Up => &mut self.up,\n            Side::Left => &mut self.left,\n            _ => &mut self.right,\n        };\n        *field = to;\n    }\n\n    pub fn get_ptr(&self, side: Side) -> NodePtr {\n        match side {\n            Side::Up => self.up,\n            Side::Left => self.left,\n            _ => self.right,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Tree<K, V> {\n    root: NodePtr,\n    store: Vec<Node<K, V>>,\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Tree<K, V> {\n    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {\n        assert!(np.is_some());\n        self.store[np.unwrap()]\n    }\n\n    pub fn get_key(&self, np: NodePtr) -> K {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key\n    }\n\n    pub fn _get_value(&self, np: NodePtr) -> V {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value\n    }\n\n    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {\n        assert!(np.is_some());\n        self.store[np.unwrap()].get_ptr(side)\n    }\n\n    pub fn set_pointer(&mut self, np: NodePtr, side: Side, to: NodePtr) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].set_ptr(side, to);\n    }\n\n    pub fn new() -> Self {\n        Tree {\n            root: None,\n            store: Vec::<Node<K, V>>::with_capacity(128),\n        }\n    }\n\n    pub fn insert(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        let mut n = Node::new(k, v);\n\n        if self.root.is_none() {\n            assert!(self.store.is_empty());\n            self.store.push(n);\n            self.root = Some(0);\n            return Some(n);\n        }\n\n        let mut p = self.root; // Possibly None\n        let mut prev = p;\n        let mut side = Side::Left;\n        while p.is_some() {\n            prev = p;\n            match n.key.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Equal => {\n                    // Key exists\n                    return None;\n                }\n            }\n        }\n        // Set child's pointer\n        n.up = prev;\n        // Stow the node\n        self.store.push(n);\n        // Set parent's pointer\n        let ptr = Some(self.store.len() - 1);\n        self.set_pointer(prev, side, ptr);\n        Some(n)\n    }\n\n    // Prints the tree with root p.  The idea is to do an in-order traversal\n    // (reverse in-order in this case, where right is on top), and print nodes as they\n    // are visited, one per line. Each invocation of display() gets its own copy\n    // of the display element vector e, which is grown with either whitespace or\n    // a trunk element, then modified in its last and possibly second-to-last\n    // characters in context.\n    fn display(&self, p: NodePtr, side: Side, e: &[DisplayElement], f: &mut Formatter) {\n        if p.is_none() {\n            return;\n        }\n\n        let mut elems = e.to_vec();\n        let node = self.get_node(p);\n        let mut tail = DisplayElement::SpaceSpace;\n        if node.up != self.root {\n            // If the direction is switching, I need the trunk element to appear in the lines\n            // printed before that node is visited.\n            if side == Side::Left && node.right.is_some() {\n                elems.push(DisplayElement::TrunkSpace);\n            } else {\n                elems.push(DisplayElement::SpaceSpace);\n            }\n        }\n        let hindex = elems.len() - 1;\n        self.display(node.right, Side::Right, &elems, f);\n\n        if p == self.root {\n            elems[hindex] = DisplayElement::Root;\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Right {\n            // Right subtree finished\n            elems[hindex] = DisplayElement::SpaceRight;\n            // Prepare trunk element in case there is a left subtree\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Left {\n            elems[hindex] = DisplayElement::SpaceLeft;\n            let parent = self.get_node(node.up);\n            if parent.up.is_some() && self.get_pointer(parent.up, Side::Right) == node.up {\n                // Direction switched, need trunk element starting with this node/line\n                elems[hindex - 1] = DisplayElement::TrunkSpace;\n            }\n        }\n\n        // Visit node => print accumulated elements. Each node gets a line and each line gets a\n        // node.\n        for e in elems.clone() {\n            let _ = write!(f, \"{}\", e.string());\n        }\n        let _ = write!(\n            f,\n            \"{key:>width$} \",\n            key = Green.bold().paint(node.key),\n            width = 2\n        );\n        let _ = write!(\n            f,\n            \"{value:>width$}\",\n            value = Blue.bold().paint(format!(\"{:.*}\", 2, node.value)),\n            width = 4\n        );\n        let _ = writeln!(f);\n\n        // Overwrite last element before continuing traversal\n        elems[hindex] = tail;\n\n        self.display(node.left, Side::Left, &elems, f);\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for Tree<K, V> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if self.root.is_none() {\n            write!(f, \"[empty]\")\n        } else {\n            let v: Vec<DisplayElement> = vec![];\n            self.display(self.root, Side::Up, &v, f);\n            Ok(())\n        }\n    }\n}\n\nfn random_tree(n: u32) -> Tree<i32, f32> {\n    let mut tree: Tree<i32, f32> = Tree::new();\n    let mut rng = rand::thread_rng();\n    // Use `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let key_range = Uniform::new(-(n as i32) / 2, (n as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert(0, rng.sample(value_range));\n    for _ in 0..n - 1 {\n        tree.insert(rng.sample(key_range), rng.sample(value_range));\n    }\n    tree\n}\n\n/// Prints json representation of tree as well, useful for shorter code listings.\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut r_nodes: u32 = 20;\n\n    match args.len() {\n        1 => {}\n        2 => {\n            r_nodes = args[1].parse::<u32>().unwrap();\n        }\n        _ => {\n            println!(\"visualize_a_tree <no. of nodes>\");\n            return;\n        }\n    }\n\n    let tree = random_tree(r_nodes);\n    let encoded = serde_json::to_string(&tree).unwrap();\n\n    println!(\"{}\", tree);\n    println!(\"{}\", encoded);\n\n    println!(\"\\nCanned tree, decoded:\");\n    _main_for_rosetta()\n}\n\n/// Decodes and prints a previously generated tree.  Presenting this with display(), the fmt()\n/// overload, and the struct & enum definitions is sufficient for this demonstration.\nfn _main_for_rosetta() {\n    let encoded = r#\"{\"root\":0,\"store\":[{\"key\":0,\"value\":0.45,\"left\":1,\"right\":3,\n        \"up\":null},{\"key\":-8,\"value\":-0.94,\"left\":7,\"right\":2,\"up\":0}, {\"key\":-1,\n        \"value\":0.15,\"left\":8,\"right\":null,\"up\":1},{\"key\":7, \"value\":-0.29,\"left\":4,\n        \"right\":9,\"up\":0},{\"key\":5,\"value\":0.80,\"left\":5,\"right\":null,\"up\":3},\n        {\"key\":4,\"value\":-0.85,\"left\":6,\"right\":null,\"up\":4},{\"key\":3,\"value\":-0.46,\n        \"left\":null,\"right\":null,\"up\":5},{\"key\":-10,\"value\":-0.85,\"left\":null,\n        \"right\":13,\"up\":1},{\"key\":-6,\"value\":-0.42,\"left\":null,\"right\":10,\"up\":2},\n        {\"key\":9,\"value\":0.63,\"left\":12,\"right\":null,\"up\":3},{\"key\":-3,\"value\":-0.83,\n        \"left\":null,\"right\":11,\"up\":8},{\"key\":-2,\"value\":0.75,\"left\":null,\"right\":null,\n        \"up\":10},{\"key\":8,\"value\":-0.48,\"left\":null,\"right\":null,\"up\":9},{\"key\":-9,\n        \"value\":0.53,\"left\":null,\"right\":null,\"up\":7}]}\"#;\n    let tree: Tree<i32, f32> = serde_json::from_str(encoded).unwrap();\n    println!(\"{}\", tree);\n}\n\n#[allow(clippy::float_cmp)]\n#[cfg(test)]\nmod tests {\n    use random_tree;\n    use serde_json;\n\n    use super::{Side, Tree};\n\n    #[test]\n    fn test_insert() {\n        let mut tree: Tree<i32, f32> = Tree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        assert_eq!(\n            tree._get_value(tree.get_pointer(tree.root, Side::Left)),\n            -8.8\n        );\n        assert_eq!(\n            tree._get_value(\n                tree.get_pointer(tree.get_pointer(tree.root, Side::Right), Side::Right)\n            ),\n            12.12\n        );\n        assert_eq!(\n            tree.get_pointer(\n                tree.get_pointer(tree.get_pointer(tree.root, Side::Right), Side::Right),\n                Side::Left\n            ),\n            None\n        );\n\n        tree = random_tree(100);\n        assert!(!tree.store.is_empty());\n    }\n\n    #[test]\n    fn test_decode() {\n        let encoded = r#\"{\"root\":0,\"store\":[{\"key\":0,\"value\":0.45,\"left\":1,\"right\":3,\n            \"up\":null},{\"key\":-8,\"value\":-0.94,\"left\":7,\"right\":2,\"up\":0}, {\"key\":-1,\n            \"value\":0.15,\"left\":8,\"right\":null,\"up\":1},{\"key\":7, \"value\":-0.29,\"left\":4,\n            \"right\":9,\"up\":0},{\"key\":5,\"value\":0.80,\"left\":5,\"right\":null,\"up\":3},\n            {\"key\":4,\"value\":-0.85,\"left\":6,\"right\":null,\"up\":4},{\"key\":3,\"value\":-0.46,\n            \"left\":null,\"right\":null,\"up\":5},{\"key\":-10,\"value\":-0.85,\"left\":null,\n            \"right\":13,\"up\":1},{\"key\":-6,\"value\":-0.42,\"left\":null,\"right\":10,\"up\":2},\n            {\"key\":9,\"value\":0.63,\"left\":12,\"right\":null,\"up\":3},{\"key\":-3,\"value\":-0.83,\n            \"left\":null,\"right\":11,\"up\":8},{\"key\":-2,\"value\":0.75,\"left\":null,\"right\":null,\n            \"up\":10},{\"key\":8,\"value\":-0.48,\"left\":null,\"right\":null,\"up\":9},{\"key\":-9,\n            \"value\":0.53,\"left\":null,\"right\":null,\"up\":7}]}\"#;\n        let tree: Tree<i32, f32> = serde_json::from_str(encoded).unwrap();\n        assert_eq!(tree.root, Some(0));\n        assert_eq!(tree.store[4].key, 5);\n        assert_eq!(tree.store[4].value, 0.80);\n        assert_eq!(tree.store[4].right, None);\n        assert_eq!(tree.store[12].up, Some(9));\n        assert_eq!(tree.store[9].left, Some(12));\n    }\n}\n",
    "path": "tasks/visualize-a-tree",
    "remote_code": "\nextern crate rustc_serialize;\nextern crate term_painter;\n\nuse rustc_serialize::json;\nuse std::fmt::{Debug, Display, Formatter, Result};\nuse term_painter::ToStyle;\nuse term_painter::Color::*;\n\ntype NodePtr = Option<usize>;\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum Side {\n    Left,\n    Right,\n    Up,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum DisplayElement {\n    TrunkSpace,\n    SpaceLeft,\n    SpaceRight,\n    SpaceSpace,\n    Root,\n}\n\nimpl DisplayElement {\n    fn string(&self) -> String {\n        match *self {\n            DisplayElement::TrunkSpace => \"    │   \".to_string(),\n            DisplayElement::SpaceRight => \"    ┌───\".to_string(),\n            DisplayElement::SpaceLeft => \"    └───\".to_string(),\n            DisplayElement::SpaceSpace => \"        \".to_string(),\n            DisplayElement::Root => \"├──\".to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, RustcDecodable, RustcEncodable)]\nstruct Node<K, V> {\n    key: K,\n    value: V,\n    left: NodePtr,\n    right: NodePtr,\n    up: NodePtr,\n}\n\nimpl<K: Ord + Copy, V: Copy> Node<K, V> {\n    pub fn get_ptr(&self, side: Side) -> NodePtr {\n        match side {\n            Side::Up => self.up,\n            Side::Left => self.left,\n            _ => self.right,\n        }\n    }\n}\n\n#[derive(Debug, RustcDecodable, RustcEncodable)]\nstruct Tree<K, V> {\n    root: NodePtr,\n    store: Vec<Node<K, V>>,\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Tree<K, V> {\n    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {\n        assert!(np.is_some());\n        self.store[np.unwrap()]\n    }\n\n    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {\n        assert!(np.is_some());\n        self.store[np.unwrap()].get_ptr(side)\n    }\n\n    // Prints the tree with root p.  The idea is to do an in-order traversal\n    // (reverse in-order in this case, where right is on top), and print nodes as they\n    // are visited, one per line. Each invocation of display() gets its own copy\n    // of the display element vector e, which is grown with either whitespace or\n    // a trunk element, then modified in its last and possibly second-to-last\n    // characters in context.\n    fn display(&self, p: NodePtr, side: Side, e: &Vec<DisplayElement>, f: &mut Formatter) {\n        if p.is_none() {\n            return;\n        }\n\n        let mut elems = e.clone();\n        let node = self.get_node(p);\n        let mut tail = DisplayElement::SpaceSpace;\n        if node.up != self.root {\n            // If the direction is switching, I need the trunk element to appear in the lines\n            // printed before that node is visited.\n            if side == Side::Left && node.right.is_some() {\n                elems.push(DisplayElement::TrunkSpace);\n            } else {\n                elems.push(DisplayElement::SpaceSpace);\n            }\n        }\n        let hindex = elems.len() - 1;\n        self.display(node.right, Side::Right, &elems, f);\n\n        if p == self.root {\n            elems[hindex] = DisplayElement::Root;\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Right {\n            // Right subtree finished\n            elems[hindex] = DisplayElement::SpaceRight;\n            // Prepare trunk element in case there is a left subtree\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Left {\n            elems[hindex] = DisplayElement::SpaceLeft;\n            let parent = self.get_node(node.up);\n            if parent.up.is_some() && self.get_pointer(parent.up, Side::Right) == node.up {\n                // Direction switched, need trunk element starting with this node/line\n                elems[hindex - 1] = DisplayElement::TrunkSpace;\n            }\n        }\n\n        // Visit node => print accumulated elements. Each node gets a line and each line gets a\n        // node.\n        for e in elems.clone() {\n            let _ = write!(f, \"{}\", e.string());\n        }\n        let _ = write!(f,\n                       \"{key:>width$} \",\n                       key = Green.bold().paint(node.key),\n                       width = 2);\n        let _ = write!(f,\n                       \"{value:>width$}\\n\",\n                       value = Blue.bold().paint(format!(\"{:.*}\", 2, node.value)),\n                       width = 4);\n\n        // Overwrite last element before continuing traversal\n        elems[hindex] = tail;\n\n        self.display(node.left, Side::Left, &elems, f);\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for Tree<K, V> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if self.root.is_none() {\n            write!(f, \"[empty]\")\n        } else {\n            let mut v: Vec<DisplayElement> = Vec::new();\n            self.display(self.root, Side::Up, &mut v, f);\n            Ok(())\n        }\n    }\n}\n\n/// Decodes and prints a previously generated tree.\nfn main() {\n    let encoded = r#\"{\"root\":0,\"store\":[{\"key\":0,\"value\":0.45,\"left\":1,\"right\":3,\n        \"up\":null},{\"key\":-8,\"value\":-0.94,\"left\":7,\"right\":2,\"up\":0}, {\"key\":-1,\n        \"value\":0.15,\"left\":8,\"right\":null,\"up\":1},{\"key\":7, \"value\":-0.29,\"left\":4,\n        \"right\":9,\"up\":0},{\"key\":5,\"value\":0.80,\"left\":5,\"right\":null,\"up\":3},\n        {\"key\":4,\"value\":-0.85,\"left\":6,\"right\":null,\"up\":4},{\"key\":3,\"value\":-0.46,\n        \"left\":null,\"right\":null,\"up\":5},{\"key\":-10,\"value\":-0.85,\"left\":null,\n        \"right\":13,\"up\":1},{\"key\":-6,\"value\":-0.42,\"left\":null,\"right\":10,\"up\":2},\n        {\"key\":9,\"value\":0.63,\"left\":12,\"right\":null,\"up\":3},{\"key\":-3,\"value\":-0.83,\n        \"left\":null,\"right\":11,\"up\":8},{\"key\":-2,\"value\":0.75,\"left\":null,\"right\":null,\n        \"up\":10},{\"key\":8,\"value\":-0.48,\"left\":null,\"right\":null,\"up\":9},{\"key\":-9,\n        \"value\":0.53,\"left\":null,\"right\":null,\"up\":7}]}\"#;\n    let tree: Tree<i32, f32> = json::decode(&encoded).unwrap();\n    println!(\"{}\", tree);\n}\n",
    "title": "Visualize a tree",
    "url": "http://rosettacode.org/wiki/Visualize_a_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Vogel's approximation method",
    "url": "http://rosettacode.org/wiki/Vogel's_approximation_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate piston;\nextern crate opengl_graphics;\nextern crate graphics;\nextern crate touch_visualizer;\n\n#[cfg(feature = \"include_sdl2\")]\nextern crate sdl2_window;\n\nextern crate getopts;\nextern crate voronoi;\nextern crate rand;\n\nuse touch_visualizer::TouchVisualizer;\nuse opengl_graphics::{ GlGraphics, OpenGL };\nuse graphics::{ Context, Graphics };\nuse piston::window::{ Window, WindowSettings };\nuse piston::input::*;\nuse piston::event_loop::*;\n#[cfg(feature = \"include_sdl2\")]\nuse sdl2_window::Sdl2Window as AppWindow;\nuse voronoi::{voronoi, Point, make_polygons};\nuse rand::Rng;\n\nstatic DEFAULT_WINDOW_HEIGHT: u32 = 600;\nstatic DEFAULT_WINDOW_WIDTH:  u32 = 600;\n\nstruct Settings {\n    lines_only: bool,\n    random_count: usize\n}\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let mut opts = getopts::Options::new();\n    opts.optflag(\"l\", \"lines_only\", \"Don't color polygons, just outline them\");\n    opts.optopt(\"r\", \"random_count\", \"On keypress \\\"R\\\", put this many random points on-screen\", \"RANDOMCOUNT\");\n    let matches = opts.parse(&args[1..]).expect(\"Failed to parse args\");\n\n    let settings = Settings{\n        lines_only: matches.opt_present(\"l\"),\n        random_count: match matches.opt_str(\"r\") {\n            None => { 50 },\n            Some(s) => { s.parse().expect(\"Random count of bad format\") }\n        }\n    };\n\n    event_loop(&settings);\n\n}\n\nfn random_point() -> [f64; 2] {\n    [rand::thread_rng().gen_range(0., DEFAULT_WINDOW_HEIGHT as f64), rand::thread_rng().gen_range(0., DEFAULT_WINDOW_WIDTH as f64)]\n}\n\nfn random_color() -> [f32; 4] {\n    [rand::random::<f32>(), rand::random::<f32>(), rand::random::<f32>(), 1.0]\n}\n\nfn random_voronoi(dots: &mut Vec<[f64;2]>, colors: &mut Vec<[f32;4]>, num: usize) {\n    dots.clear();\n    colors.clear();\n\n    for _ in 0..num {\n        dots.push(random_point());\n        colors.push(random_color());\n    }\n}\n\nfn event_loop(settings: &Settings) {\n    let opengl = OpenGL::V3_2;\n    let mut window: AppWindow = WindowSettings::new(\"Interactive Voronoi\", [DEFAULT_WINDOW_HEIGHT, DEFAULT_WINDOW_WIDTH])\n        .exit_on_esc(true).opengl(opengl).build().unwrap();\n\n    let ref mut gl = GlGraphics::new(opengl);\n    let mut touch_visualizer = TouchVisualizer::new();\n    let mut events = Events::new(EventSettings::new().lazy(true));\n    let mut dots = Vec::new();\n    let mut colors = Vec::new();\n\n    let mut mx = 0.0;\n    let mut my = 0.0;\n\n    while let Some(e) = events.next(&mut window) {\n        touch_visualizer.event(window.size(), &e);\n        if let Some(button) = e.release_args() {\n            match button {\n                Button::Keyboard(key) => {\n                    if key == piston::input::keyboard::Key::N { dots.clear(); colors.clear(); }\n                    if key == piston::input::keyboard::Key::R { random_voronoi(&mut dots, &mut colors, settings.random_count); }\n                }\n                Button::Mouse(_) => {\n                    dots.push([mx, my]);\n                    colors.push(random_color());\n                },\n                _ => ()\n            }\n        };\n        e.mouse_cursor(|x, y| {\n            mx = x;\n            my = y;\n        });\n        if let Some(args) = e.render_args() {\n            gl.draw(args.viewport(), |c, g| {\n                graphics::clear([1.0; 4], g);\n                let mut vor_pts = Vec::new();\n                for d in &dots {\n                    vor_pts.push(Point::new(d[0], d[1]));\n                }\n                if vor_pts.len() > 0 {\n                    let vor_diagram = voronoi(vor_pts, DEFAULT_WINDOW_WIDTH as f64);\n                    let vor_polys = make_polygons(&vor_diagram);\n                    for (i, poly) in vor_polys.iter().enumerate() {\n                        if settings.lines_only {\n                            draw_lines_in_polygon(poly, &c, g);\n                        } else {\n                            draw_polygon(poly, &c, g, colors[i]);\n                        }\n                    }\n                }\n                for d in &dots {\n                    draw_ellipse(&d, &c, g);\n                }\n            });\n        }\n    } \n\n}\n\nfn draw_lines_in_polygon<G: Graphics>(\n    poly: &Vec<Point>,\n    c: &Context,\n    g: &mut G,\n)\n{\n    let color = [0.0, 0.0, 1.0, 1.0];\n\n    for i in 0..poly.len()-1 {\n        graphics::line(\n            color,\n            2.0,\n            [poly[i].x.into(), poly[i].y.into(), poly[i+1].x.into(), poly[i+1].y.into()],\n            c.transform,\n            g\n        )\n    }\n}\n\nfn draw_polygon<G: Graphics>(\n    poly: &Vec<Point>,\n    c: &Context,\n    g: &mut G,\n    color: [f32; 4]\n) {\n    let mut polygon_points: Vec<[f64; 2]> = Vec::new();\n\n    for p in poly {\n        polygon_points.push([p.x.into(), p.y.into()]);\n    }\n\n    graphics::polygon(\n        color,\n        polygon_points.as_slice(),\n        c.transform,\n        g\n    )\n}\n\nfn draw_ellipse<G: Graphics>(\n    cursor: &[f64; 2],\n    c: &Context,\n    g: &mut G,\n) {\n    let color = [0.0, 0.0, 0.0, 1.0];\n    graphics::ellipse(\n        color,\n        graphics::ellipse::circle(cursor[0], cursor[1], 4.0),\n        c.transform,\n        g\n    );\n}\n",
    "title": "Voronoi diagram",
    "url": "http://rosettacode.org/wiki/Voronoi_diagram"
  },
  {
    "local_code": "extern crate regex;\nextern crate structopt;\n\nuse regex::Regex;\nuse structopt::StructOpt;\n\n/// Walks the directory tree, starting with the current working directory. Print filenames matching\n/// the regular expression `PATTERN`.\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Regular expression pattern\n    #[structopt(name = \"PATTERN\")]\n    pattern: Regex,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n    let paths = std::fs::read_dir(\".\").unwrap();\n\n    for path in paths {\n        let path = path.unwrap().path();\n        let path = path.to_str().unwrap();\n\n        if opt.pattern.is_match(path) {\n            println!(\"{}\", path);\n        }\n    }\n}\n",
    "path": "tasks/walk-a-directory/non-recursively",
    "remote_code": "extern crate docopt;\nextern crate regex;\nextern crate rustc_serialize;\n\nuse docopt::Docopt;\nuse regex::Regex;\n\nconst USAGE: &'static str = \"\nUsage: rosetta <pattern>\n\nWalks the directory tree starting with the current working directory and\nprint filenames matching <pattern>.\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_pattern: String,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.decode())\n        .unwrap_or_else(|e| e.exit());\n\n    let re = Regex::new(&args.arg_pattern).unwrap();\n    let paths = std::fs::read_dir(\".\").unwrap();\n\n    for path in paths {\n        let path = path.unwrap().path();\n        let path = path.to_str().unwrap();\n\n        if re.is_match(path) {\n            println!(\"{}\", path);\n        }\n    }\n}",
    "title": "Walk a directory/Non-recursively",
    "url": "http://rosettacode.org/wiki/Walk_a_directory/Non-recursively"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Walk_a_directory/Recursively\nextern crate regex;\n\nuse regex::Regex;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::path::Path;\n\nfn walk<P>(pth: P, regex: &Regex)\nwhere\n    P: AsRef<Path>,\n{\n    let result = match fs::read_dir(pth) {\n        Ok(result) => result,\n        Err(_) => return,\n    };\n\n    for subp in result.into_iter().flatten() {\n        if let Ok(filename) = subp.path().into_os_string().into_string() {\n            if regex.is_match(&filename) {\n                println!(\"{}\", filename);\n            }\n            walk(filename, regex);\n        }\n    }\n}\n\nfn main() {\n    walk(\".\", &Regex::new(r\".*\\.rs\").unwrap());\n}\n",
    "path": "tasks/walk-a-directory/recursively",
    "remote_code": "#![feature(fs_walk)]\n\nuse std::fs;\nuse std::path::Path;\n\nfn main() {\n    for f in fs::walk_dir(&Path::new(\"/home/pavel/Music\")).unwrap() {\n        let p = f.unwrap().path();\n        if p.extension().unwrap_or(\"\".as_ref()) == \"mp3\" {\n            println!(\"{:?}\", p);\n        }\n    }\n}",
    "title": "Walk a directory/Recursively",
    "url": "http://rosettacode.org/wiki/Walk_a_directory/Recursively"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "War card game",
    "url": "http://rosettacode.org/wiki/War_card_game"
  },
  {
    "local_code": "use std::cmp::min;\n\nfn getfill(pattern: &[usize]) -> usize {\n    let mut total = 0;\n    for (idx, val) in pattern.iter().enumerate() {\n        let l_peak = pattern[..idx].iter().max();\n        let r_peak = pattern[idx + 1..].iter().max();\n        if let (Some(l_peak), Some(r_peak)) = (l_peak, r_peak) {\n            let peak = min(l_peak, r_peak);\n            if peak > val {\n                total += peak - val;\n            }\n        }\n    }\n    total\n}\n\nfn main() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    for pattern in patterns {\n        println!(\"pattern: {:?}, fill: {}\", &pattern, getfill(&pattern));\n    }\n}\n\n#[test]\nfn test_getfill() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    let answers = vec![2, 14, 35, 0, 0, 0, 0];\n\n    for (idx, pattern) in patterns.iter().enumerate() {\n        assert_eq!(answers[idx], getfill(pattern));\n    }\n}\n",
    "path": "tasks/water-collected-between-towers",
    "remote_code": "\nuse std::cmp::min;\n\nfn getfill(pattern: &[usize]) -> usize {\n    let mut total = 0;\n    for (idx, val) in pattern.iter().enumerate() {\n        let l_peak = pattern[..idx].iter().max();\n        let r_peak = pattern[idx + 1..].iter().max();\n        if l_peak.is_some() && r_peak.is_some() {\n            let peak = min(l_peak.unwrap(), r_peak.unwrap());\n            if peak > val {\n                total += peak - val;\n            }\n        }\n    }\n    total\n}\n\nfn main() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    for pattern in patterns {\n        println!(\"pattern: {:?}, fill: {}\", &pattern, getfill(&pattern));\n    }\n}\n",
    "title": "Water collected between towers",
    "url": "http://rosettacode.org/wiki/Water_collected_between_towers"
  },
  {
    "local_code": "use regex::Regex;\nuse std::error::Error;\n/// Create a program that downloads the time from this URL: http://tycho.usno.navy.mil/cgi-bin/timer.pl\n/// and then prints the current UTC time by extracting just the UTC time from the web page's HTML.\n/// For an introduction to the ecosystem of web scraping in Rust,\n/// read https://kadekillary.work/post/webscraping-rust/\n\nconst A_URL: &str = \"http://tycho.usno.navy.mil/cgi-bin/timer.pl\";\nfn extract_timestamp(raw_html: &str) -> Option<regex::Match> {\n    let pattern = Regex::new(r\"<BR>(?P<time>.*) UTC\").unwrap();\n    pattern.captures(raw_html).unwrap().name(\"time\")\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let raw_html: String = reqwest::blocking::get(A_URL)?.text()?;\n    if let Some(timestamp) = extract_timestamp(&raw_html) {\n        print!(\"{}\", timestamp.as_str());\n    } else {\n        eprint!(\"Error: Could not parse URL for getting current time.\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::extract_timestamp;\n\n    #[test]\n    fn test_extract_timestamp() {\n        let body = r#\"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final\"//EN>\n            <html>\n            <body>\n            <TITLE>What time is it?</TITLE>\n            <H2> US Naval Observatory Master Clock Time</H2> <H3><PRE>\n            <BR>Aug. 12, 23:55:08 UTC\t\tUniversal Time\n            <BR>Aug. 12, 07:55:08 PM EDT\t\tEastern Time\n            <BR>Aug. 12, 06:55:08 PM CDT\t\tCentral Time\n            <BR>Aug. 12, 05:55:08 PM MDT\t\tMountain Time\n            <BR>Aug. 12, 04:55:08 PM PDT\t\tPacific Time\n            <BR>Aug. 12, 03:55:08 PM AKDT\tAlaska Time\n            <BR>Aug. 12, 01:55:08 PM HAST\tHawaii-Aleutian Time\n            </PRE></H3><P><A HREF=\"http://www.usno.navy.mil\"> US Naval Observatory</A>\n\n            </body></html>\n            \"#;\n        assert_eq!(\n            extract_timestamp(body).unwrap().as_str(),\n            \"Aug. 12, 23:55:08\"\n        );\n    }\n}\n",
    "path": "tasks/web-scraping",
    "remote_code": "// 202100302 Rust programming solution\n\nuse std::io::Read;\nuse regex::Regex;\n\nfn main() {\n\n   let client   = reqwest::blocking::Client::new();\n   let site     = \"https://www.utctime.net/\";\n   let mut res  = client.get(site).send().unwrap();\n   let mut body = String::new();\n\n   res.read_to_string(&mut body).unwrap();\n\n   let re   = Regex::new(r#\"<td>UTC</td><td>(.*Z)</td>\"#).unwrap();\n   let caps = re.captures(&body).unwrap();\n\n   println!(\"Result : {:?}\", caps.get(1).unwrap().as_str());\n}",
    "title": "Web scraping",
    "url": "http://rosettacode.org/wiki/Web_scraping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Weird numbers",
    "url": "http://rosettacode.org/wiki/Weird_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// primal = \"0.3\"\n// mod_exp = \"1.0\"\n\nfn wieferich_primes(limit: usize) -> impl std::iter::Iterator<Item = usize> {\n    primal::Primes::all()\n        .take_while(move |x| *x < limit)\n        .filter(|x| mod_exp::mod_exp(2, *x - 1, *x * *x) == 1)\n}\n\nfn main() {\n    let limit = 5000;\n    println!(\"Wieferich primes less than {}:\", limit);\n    for p in wieferich_primes(limit) {\n        println!(\"{}\", p);\n    }\n}",
    "title": "Wieferich primes",
    "url": "http://rosettacode.org/wiki/Wieferich_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// rug = \"1.13.0\"\n\nuse rug::Integer;\n\nfn generate_primes(limit: usize) -> Vec<usize> {\n    let mut sieve = vec![true; limit >> 1];\n    let mut p = 3;\n    let mut sq = p * p;\n    while sq < limit {\n        if sieve[p >> 1] {\n            let mut q = sq;\n            while q < limit {\n                sieve[q >> 1] = false;\n                q += p << 1;\n            }\n        }\n        sq += (p + 1) << 2;\n        p += 2;\n    }\n    let mut primes = Vec::new();\n    if limit > 2 {\n        primes.push(2);\n    }\n    for i in 1..sieve.len() {\n        if sieve[i] {\n            primes.push((i << 1) + 1);\n        }\n    }\n    primes\n}\n\nfn factorials(limit: usize) -> Vec<Integer> {\n    let mut f = vec![Integer::from(1)];\n    let mut factorial = Integer::from(1);\n    f.reserve(limit);\n    for i in 1..limit {\n        factorial *= i as u64;\n        f.push(factorial.clone());\n    }\n    f\n}\n\nfn main() {\n    let limit = 11000;\n    let f = factorials(limit);\n    let primes = generate_primes(limit);\n    println!(\" n | Wilson primes\\n--------------------\");\n    let mut s = -1;\n    for n in 1..=11 {\n        print!(\"{:2} |\", n);\n        for p in &primes {\n            if *p >= n {\n                let mut num = Integer::from(&f[n - 1] * &f[*p - n]);\n                num -= s;\n                if num % ((p * p) as u64) == 0 {\n                    print!(\" {}\", p);\n                }\n            }\n        }\n        println!();\n        s = -s;\n    }\n}",
    "title": "Wilson primes of order n",
    "url": "http://rosettacode.org/wiki/Wilson_primes_of_order_n"
  },
  {
    "local_code": "use winit::{\n    event::{Event, WindowEvent},\n    event_loop::{ControlFlow, EventLoop},\n    window::WindowBuilder,\n};\n\nfn main() {\n    let event_loop = EventLoop::new();\n    let window = WindowBuilder::new()\n        .with_title(\"Window\")\n        .build(&event_loop)\n        .unwrap();\n\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Wait;\n\n        match event {\n            Event::WindowEvent {\n                event: WindowEvent::CloseRequested,\n                window_id,\n            } if window_id == window.id() => *control_flow = ControlFlow::Exit,\n            _ => (),\n        }\n    });\n}\n",
    "path": "tasks/window-creation",
    "remote_code": "use winit::event::{Event, WindowEvent};  // winit 0.24\nuse winit::event_loop::{ControlFlow, EventLoop};\nuse winit::window::WindowBuilder;\n\nfn main() {\n    let event_loop = EventLoop::new();\n    let _win = WindowBuilder::new()\n        .with_title(\"Window\")\n        .build(&event_loop).unwrap();\n\n    event_loop.run(move |ev, _, flow| {\n        match ev {\n            Event::WindowEvent {\n                event: WindowEvent::CloseRequested, ..\n            } => {\n                *flow = ControlFlow::Exit;\n            }\n            _ => {}\n        }\n    });\n}",
    "title": "Window creation",
    "url": "http://rosettacode.org/wiki/Window_creation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Window creation/X11",
    "url": "http://rosettacode.org/wiki/Window_creation/X11"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Window management",
    "url": "http://rosettacode.org/wiki/Window_management"
  },
  {
    "local_code": "use std::mem;\nuse std::thread;\nuse std::time::Duration;\n\n#[derive(Copy, Clone)]\nenum Cell {\n    Empty(char),\n    Head,\n    Tail,\n    Conductor,\n}\n\nimpl Cell {\n    fn from_char(c: char) -> Cell {\n        match c {\n            '.' => Cell::Conductor,\n            'H' => Cell::Head,\n            't' => Cell::Tail,\n            c => Cell::Empty(c),\n        }\n    }\n    fn to_char(self) -> char {\n        match self {\n            Cell::Conductor => '.',\n            Cell::Head => 'H',\n            Cell::Tail => 't',\n            Cell::Empty(c) => c,\n        }\n    }\n}\n\nfn next_world(input: &[Cell], output: &mut [Cell], w: usize, h: usize) {\n    for i in 0..(w * h) {\n        match input[i] {\n            Cell::Empty(c) => output[i] = Cell::Empty(c),\n            Cell::Tail => output[i] = Cell::Conductor,\n            Cell::Head => output[i] = Cell::Tail,\n            Cell::Conductor => {\n                let nc = vec![\n                    input.get(i - w - 1),\n                    input.get(i - w),\n                    input.get(i - w + 1),\n                    input.get(i - 1),\n                    input.get(i + 1),\n                    input.get(i + w - 1),\n                    input.get(i + w),\n                    input.get(i + w + 1),\n                ]\n                .iter()\n                .fold(0, |sum, &o| {\n                    if let Some(&Cell::Head) = o {\n                        sum + 1\n                    } else {\n                        sum\n                    }\n                });\n                output[i] = if nc == 1 || nc == 2 {\n                    Cell::Head\n                } else {\n                    Cell::Conductor\n                };\n            }\n        }\n    }\n}\n\nfn main() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|tH.........|\n|.   .      |\n|   ...     |\n|.   .      |\n|Ht.. ......|\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    loop {\n        for cell in &world {\n            print!(\"{}\", cell.to_char());\n        }\n        println!();\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n\n        // Use VT100 cursor control sequences to animate in-place\n        print!(\"\\x1b[8A\");\n        print!(\"\\x1b[14D\");\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n\n#[test]\nfn test() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|tH.........|\n|.   .      |\n|   ...     |\n|.   .      |\n|Ht.. ......|\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    for _ in 0..10 {\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n    }\n\n    let result: String = world.iter().map(|c| c.to_char()).collect();\n    let correct = r\"\n+-----------+\n|.tH.tH.tH.t|\n|H   t      |\n|   HHH     |\n|H   .      |\n|t.tH ......|\n+-----------+\n\";\n    assert_eq!(result, correct);\n}\n",
    "path": "tasks/wireworld",
    "remote_code": "use std::str::FromStr;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum State {\n    Empty,\n    Conductor,\n    ElectronTail,\n    ElectronHead,\n}\n\nimpl State {\n    fn next(&self, e_nearby: usize) -> State {\n        match self {\n            State::Empty => State::Empty,\n            State::Conductor => {\n                if e_nearby == 1 || e_nearby == 2 {\n                    State::ElectronHead\n                } else {\n                    State::Conductor\n                }\n            }\n            State::ElectronTail => State::Conductor,\n            State::ElectronHead => State::ElectronTail,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct WireWorld {\n    pub width: usize,\n    pub height: usize,\n    pub data: Vec<State>,\n}\n\nimpl WireWorld {\n    pub fn new(width: usize, height: usize) -> Self {\n        WireWorld {\n            width,\n            height,\n            data: vec![State::Empty; width * height],\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> Option<State> {\n        if x >= self.width || y >= self.height {\n            None\n        } else {\n            self.data.get(y * self.width + x).copied()\n        }\n    }\n\n    pub fn set(&mut self, x: usize, y: usize, state: State) {\n        self.data[y * self.width + x] = state;\n    }\n\n    fn neighbors<F>(&self, x: usize, y: usize, mut f: F) -> usize \n        where F: FnMut(State) -> bool\n    {\n        let (x, y) = (x as i32, y as i32);\n        let neighbors = [(x-1,y-1),(x-1,y),(x-1,y+1),(x,y-1),(x,y+1),(x+1,y-1),(x+1,y),(x+1,y+1)];\n\n        neighbors.iter().filter_map(|&(x, y)| self.get(x as usize, y as usize)).filter(|&s| f(s)).count()\n    }\n\n    pub fn next(&mut self) {\n        let mut next_state = vec![];\n        for y in 0..self.height {\n            for x in 0..self.width {\n                let e_count = self.neighbors(x, y, |e| e == State::ElectronHead);\n                next_state.push(self.get(x, y).unwrap().next(e_count));\n            }\n        }\n        self.data = next_state;\n    }\n}\n\nimpl FromStr for WireWorld {\n    type Err = ();\n    fn from_str(s: &str) -> Result<WireWorld, ()> {\n        let s = s.trim();\n        let height = s.lines().count();\n        let width = s.lines().map(|l| l.trim_end().len()).max().unwrap_or(0);\n        let mut world = WireWorld::new(width, height);\n\n        for (y, line) in s.lines().enumerate() {\n            for (x, ch) in line.trim_end().chars().enumerate() {\n                let state = match ch {\n                    '.' => State::Conductor,\n                    't' => State::ElectronTail,\n                    'H' => State::ElectronHead,\n                    _ => State::Empty,\n                };\n                world.set(x, y, state);\n            }\n        }\n        Ok(world)\n    }\n}",
    "title": "Wireworld",
    "url": "http://rosettacode.org/wiki/Wireworld"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp::Reverse;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nextern crate regex;\nuse regex::Regex;\n\nfn word_count(file: File, n: usize) {\n    let word_regex = Regex::new(\"(?i)[a-z']+\").unwrap();\n\n    let mut words = HashMap::new();\n    for line in BufReader::new(file).lines() {\n        word_regex\n            .find_iter(&line.expect(\"Read error\"))\n            .map(|m| m.as_str())\n            .for_each(|word| {\n                *words.entry(word.to_lowercase()).or_insert(0) += 1;\n            });\n    }\n\n    let mut words: Vec<_> = words.iter().collect();\n    words.sort_unstable_by_key(|&(word, count)| (Reverse(count), word));\n\n    for (word, count) in words.iter().take(n) {\n        println!(\"{:8} {:>8}\", word, count);\n    }\n}\n\nfn main() {\n    word_count(File::open(\"135-0.txt\").expect(\"File open error\"), 10)\n}",
    "title": "Word frequency",
    "url": "http://rosettacode.org/wiki/Word_frequency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Word ladder",
    "url": "http://rosettacode.org/wiki/Word_ladder"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Word search",
    "url": "http://rosettacode.org/wiki/Word_search"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Word wheel",
    "url": "http://rosettacode.org/wiki/Word_wheel"
  },
  {
    "local_code": "//! Using the [minimum length greedy algorithm].\n//!\n//! Implemented as a lazy `String` iterator, returning a wrapped line each time.\n//!\n//! [minimum length greedy algorithm]: http://en.wikipedia.org/wiki/Word_wrap#Minimum_length\nuse std::mem::swap;\nuse std::str::SplitWhitespace;\n\npub struct WordWrap<'a> {\n    words: SplitWhitespace<'a>,\n    line_length: usize,\n    next_line: String,\n}\n\nimpl<'a> WordWrap<'a> {\n    fn new(text: &'a str, line_length: usize) -> WordWrap {\n        WordWrap {\n            words: text.split_whitespace(),\n            line_length,\n            next_line: String::new(),\n        }\n    }\n}\n\nimpl<'a> Iterator for WordWrap<'a> {\n    type Item = String;\n\n    #[allow(clippy::while_let_on_iterator)]\n    fn next(&mut self) -> Option<String> {\n        // Move anything left over from last run to this_line\n        let mut this_line = String::new();\n        swap(&mut self.next_line, &mut this_line);\n\n        let mut space_left = self.line_length - this_line.chars().count();\n        const SPACE_WIDTH: usize = 1;\n\n        // Loop, adding words until we run out of words or hit the line length\n        while let Some(word) = self.words.next() {\n            let word_length = word.chars().count();\n\n            // If not the first word for this line\n            if space_left != self.line_length {\n                if word_length + SPACE_WIDTH > space_left {\n                    // Out of space, save word for next line\n                    self.next_line.push_str(word);\n                    break;\n                } else {\n                    // Add a space and keep going\n                    this_line.push(' ');\n                    space_left -= SPACE_WIDTH;\n                }\n            }\n\n            // Add word to this line\n            this_line.push_str(word);\n            space_left -= word_length;\n        }\n\n        if this_line.is_empty() {\n            None\n        } else {\n            Some(this_line)\n        }\n    }\n}\n\nfn main() {\n    let text = \"In olden times when wishing still helped one, there lived a king whose daughters \\\n                were all beautiful, but the youngest was so beautiful that the sun itself, which \\\n                has seen so much, was astonished whenever it shone in her face.  Close by the \\\n                king's castle lay a great dark forest, and under an old lime tree in the forest \\\n                was a well, and when the day was very warm, the king's child went out into the \\\n                forest and sat down by the side of the cool fountain, and when she was bored she \\\n                took a golden ball, and threw it up on high and caught it, and this ball was her \\\n                favorite plaything.\";\n\n    for length in 72..81 {\n        println!(\"Text wrapped at {}\", length);\n        for line in WordWrap::new(text, length) {\n            println!(\"{}\", line);\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_empty_string() {\n    assert_eq!(WordWrap::new(\"\", 80).next(), None);\n}\n\n#[test]\nfn test_single_word_shorter_than_line() {\n    assert_eq!(WordWrap::new(\"Hello\", 80).next().unwrap(), \"Hello\");\n}\n\n#[test]\nfn test_two_words_shorter_than_line() {\n    assert_eq!(\n        WordWrap::new(\"Hello world\", 80).next().unwrap(),\n        \"Hello world\"\n    );\n}\n\n#[test]\nfn test_wrap_second_word() {\n    let mut w = WordWrap::new(\"Hello world\", 10);\n    assert_eq!(w.next().unwrap(), \"Hello\");\n    assert_eq!(w.next().unwrap(), \"world\");\n}\n\n#[test]\nfn test_wrap_punctuation() {\n    let mut w = WordWrap::new(\"Hello, world\", 6);\n    assert_eq!(w.next().unwrap(), \"Hello,\");\n    assert_eq!(w.next().unwrap(), \"world\");\n}\n\n#[test]\nfn test_squash_multiple_spaces() {\n    let mut w = WordWrap::new(\" Hello  to the    world    \", 10);\n    assert_eq!(w.next().unwrap(), \"Hello to\");\n    assert_eq!(w.next().unwrap(), \"the world\");\n    assert_eq!(w.next(), None);\n}\n\n#[test]\nfn test_unicode() {\n    let mut w = WordWrap::new(\"Nous étions à l'Étude, quand le Proviseur entra\", 11);\n    assert_eq!(w.next().unwrap(), \"Nous étions\");\n    assert_eq!(w.next().unwrap(), \"à l'Étude,\");\n    assert_eq!(w.next().unwrap(), \"quand le\");\n    assert_eq!(w.next().unwrap(), \"Proviseur\");\n    assert_eq!(w.next().unwrap(), \"entra\");\n}\n",
    "path": "tasks/word-wrap",
    "remote_code": "#[derive(Clone, Debug)]\npub struct LineComposer<I> {\n    words: I,\n    width: usize,\n    current: Option<String>,\n}\n\nimpl<I> LineComposer<I> {\n    pub(crate) fn new<S>(words: I, width: usize) -> Self\n    where\n        I: Iterator<Item = S>,\n        S: AsRef<str>,\n    {\n        LineComposer {\n            words,\n            width,\n            current: None,\n        }\n    }\n}\n\nimpl<I, S> Iterator for LineComposer<I>\nwhere\n    I: Iterator<Item = S>,\n    S: AsRef<str>,\n{\n    type Item = String;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let mut next = match self.words.next() {\n            None => return self.current.take(),\n            Some(value) => value,\n        };\n\n        let mut current = self.current.take().unwrap_or_else(String::new);\n\n        loop {\n            let word = next.as_ref();\n            if self.width <= current.len() + word.len() {\n                self.current = Some(String::from(word));\n                // If the first word itself is too long, avoid producing an\n                // empty line. Continue instead with the next word.\n                if !current.is_empty() {\n                    return Some(current);\n                }\n            }\n\n            if !current.is_empty() {\n                current.push_str(\" \")\n            }\n\n            current.push_str(word);\n\n            match self.words.next() {\n                None => return Some(current), // Last line, current remains None\n                Some(word) => next = word,\n            }\n        }\n    }\n}\n\n// This part is just to extend all suitable iterators with LineComposer\n\npub trait ComposeLines: Iterator {\n    fn compose_lines(self, width: usize) -> LineComposer<Self>\n    where\n        Self: Sized,\n        Self::Item: AsRef<str>,\n    {\n        LineComposer::new(self, width)\n    }\n}\n\nimpl<T, S> ComposeLines for T\nwhere\n    T: Iterator<Item = S>,\n    S: AsRef<str>,\n{\n}\n\nfn main() {\n    let text = r\"\n        In olden times when wishing still helped one, there lived a king whose\n        daughters were all beautiful, but the youngest was so beautiful that the\n        sun itself, which has seen so much, was astonished whenever it shone in\n        her face. Close by the king's castle lay a great dark forest, and under\n        an old lime tree in the forest was a well, and when the day was very\n        warm, the king's child went out into the forest and sat down by the side\n        of the cool fountain, and when she was bored she took a golden ball, and\n        threw it up on high and caught it, and this ball was her favorite\n        plaything.\";\n\n    text.split_whitespace()\n        .compose_lines(80)\n        .for_each(|line| println!(\"{}\", line));\n}\n",
    "title": "Word wrap",
    "url": "http://rosettacode.org/wiki/Word_wrap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Wordiff",
    "url": "http://rosettacode.org/wiki/Wordiff"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "World Cup group stage",
    "url": "http://rosettacode.org/wiki/World_Cup_group_stage"
  },
  {
    "local_code": "use std::fs::OpenOptions;\nuse std::io::prelude::*;\n\nfn main() {\n    let contents = r\"(Over)write a file so that it contains a string.\n\nThe reverse of Read entire file-for when you want to update or\ncreate a file which you would read in its entirety all at once.\";\n\n    let mut output = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(\"output.txt\")\n        .unwrap();\n    output.write_all(contents.as_bytes()).unwrap();\n}\n",
    "path": "tasks/write-entire-file",
    "remote_code": "use std::fs::File;\nuse std::io::Write;\n\nfn main() -> std::io::Result<()> {\n    let data = \"Sample text.\";\n    let mut file = File::create(\"filename.txt\")?;\n    write!(file, \"{}\", data)?;\n    Ok(())\n}",
    "title": "Write entire file",
    "url": "http://rosettacode.org/wiki/Write_entire_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Write float arrays to a text file",
    "url": "http://rosettacode.org/wiki/Write_float_arrays_to_a_text_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub fn char_from_id(id: u8) -> char {\n    [' ', '#', '/', '_', 'L', '|', '\\n'][id as usize]\n}\n\nconst ID_BITS: u8 = 3;\n\npub fn decode(code: &[u8]) -> String {\n    let mut ret = String::new();\n    let mut carry = 0;\n    let mut carry_bits = 0;\n    for &b in code {\n        let mut bit_pos = ID_BITS - carry_bits;\n        let mut cur = b >> bit_pos;\n        let mask = (1 << bit_pos) - 1;\n        let id = carry | (b & mask) << carry_bits;\n        ret.push(char_from_id(id));\n        while bit_pos + ID_BITS < 8 {\n            ret.push(char_from_id(cur & ((1 << ID_BITS) - 1)));\n            cur >>= ID_BITS;\n            bit_pos += ID_BITS;\n        }\n        carry = cur;\n        carry_bits = 8 - bit_pos;\n    }\n    ret\n}\n\nfn main() {\n    let code = [\n        72, 146, 36, 0, 0, 0, 0, 0, 0, 0, 128, 196, 74, 182, 41, 1, 0, 0, 0, 0, 0, 0, 160, 196, 77, 0,\n        52, 1, 18, 0, 9, 144, 36, 9, 146, 36, 113, 147, 36, 9, 160, 4, 80, 130, 100, 155, 160, 41, 145,\n        155, 108, 74, 128, 38, 64, 19, 41, 73, 2, 160, 137, 155, 0, 84, 130, 38, 64, 19, 112, 155, 18,\n        160, 137, 155, 0, 160, 18, 42, 73, 18, 36, 73, 2, 128, 74, 76, 1, 0, 40, 128, 219, 38, 104, 219,\n        4, 0, 160, 0\n    ];\n\n    println!(\"{}\", decode(&code));\n}",
    "title": "Write language name in 3D ASCII",
    "url": "http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII"
  },
  {
    "local_code": "#![feature(maybe_uninit_as_bytes)]\n\n#[cfg(windows)]\nuse std::ffi::CString;\n#[cfg(windows)]\nuse std::ptr;\n\n#[cfg(windows)]\nuse windows::{\n    core::*,\n    Win32::{\n        Foundation::{ERROR_INSUFFICIENT_BUFFER, HANDLE, WIN32_ERROR},\n        Security::{GetTokenInformation, TokenUser, TOKEN_QUERY, TOKEN_USER},\n        System::{\n            EventLog::{EventSourceHandle, OpenEventLogA, ReportEventA, EVENTLOG_WARNING_TYPE},\n            Threading::{GetCurrentProcess, OpenProcessToken},\n        },\n    },\n};\n\n#[cfg(windows)]\nfn main() -> Result<()> {\n    let ph = unsafe { GetCurrentProcess() };\n    let mut th: HANDLE = HANDLE(0);\n    unsafe { OpenProcessToken(ph, TOKEN_QUERY, &mut th) }.ok()?;\n\n    // Determine the required buffer size for the TOKEN_USER. This buffer must also include\n    // data that the TOKEN_USER points to, so we can't just pass a MaybeUninit<TOKEN_USER>.\n    // Instead, we first call GetTokenInformation with a zero-sized buffer to determine the\n    // required buffer size.\n    let mut token_user: *mut TOKEN_USER = ptr::null_mut();\n    let mut length = 0;\n\n    let err = unsafe { GetTokenInformation(th, TokenUser, token_user as _, 0, &mut length) }\n        .ok()\n        .unwrap_err();\n    assert!(WIN32_ERROR::from_error(&err) == Some(ERROR_INSUFFICIENT_BUFFER));\n\n    // Retrieve the user token.\n    let mut token_buffer = vec![0; length as usize];\n    unsafe {\n        GetTokenInformation(\n            th,\n            TokenUser,\n            token_buffer.as_mut_ptr() as _,\n            token_buffer.len() as u32,\n            &mut length,\n        )\n    }\n    .ok()?;\n    token_user = token_buffer.as_mut_ptr() as *mut TOKEN_USER;\n\n    // Extract the pointer to the user SID.\n    let user_sid = unsafe { *token_user }.User.Sid;\n\n    // use the Application event log\n    let event_log_handle = unsafe { OpenEventLogA(PCSTR::default(), \"Application\") }?;\n\n    let message = CString::new(\"Hello in the event log\").unwrap();\n    let message = PSTR(message.as_ptr() as _);\n\n    let category = 5; // \"Shell\"\n    unsafe {\n        ReportEventA(\n            EventSourceHandle(event_log_handle.0),\n            EVENTLOG_WARNING_TYPE,\n            category,\n            1,\n            user_sid,\n            0,\n            &[message],\n            ptr::null_mut(),\n        )\n    }\n    .ok()?;\n\n    Ok(())\n}\n\n#[cfg(not(windows))]\nfn main() {\n    println!(\"Not implemented\");\n}\n",
    "path": "tasks/write-to-a-windows-event-log",
    "remote_code": "\n#[cfg(windows)]\nmod bindings {\n    ::windows::include_bindings!();\n}\n\n#[cfg(windows)]\nuse bindings::{\n    Windows::Win32::Security::{\n        GetTokenInformation, OpenProcessToken, PSID, TOKEN_ACCESS_MASK, TOKEN_INFORMATION_CLASS,\n        TOKEN_USER,\n    },\n    Windows::Win32::SystemServices::{\n        GetCurrentProcess, OpenEventLogA, ReportEventA, ReportEvent_wType, HANDLE, PSTR,\n    },\n};\n\n#[cfg(windows)]\nfn main() -> windows::Result<()> {\n    let ph = unsafe { GetCurrentProcess() };\n    let mut th: HANDLE = HANDLE(0);\n    unsafe { OpenProcessToken(ph, TOKEN_ACCESS_MASK::TOKEN_QUERY, &mut th) }.ok()?;\n\n    // Determine the required buffer size, ignore ERROR_INSUFFICIENT_BUFFER\n    let mut length = 0_u32;\n    unsafe {\n        GetTokenInformation(\n            th,\n            TOKEN_INFORMATION_CLASS::TokenUser,\n            std::ptr::null_mut(),\n            0,\n            &mut length,\n        )\n    }\n    .ok()\n    .unwrap_err();\n\n    // Retrieve the user token.\n    let mut token_user_bytes = vec![0u8; length as usize];\n    unsafe {\n        GetTokenInformation(\n            th,\n            TOKEN_INFORMATION_CLASS::TokenUser,\n            token_user_bytes.as_mut_ptr().cast(),\n            length,\n            &mut length,\n        )\n    }\n    .ok()?;\n\n    // Extract the pointer to the user SID.\n    let user_sid: PSID = unsafe { (*token_user_bytes.as_ptr().cast::<TOKEN_USER>()).User.Sid };\n\n    // use the Application event log\n    let event_log_handle = unsafe { OpenEventLogA(PSTR::default(), \"Application\") };\n\n    let mut event_msg = PSTR(b\"Hello in the event log\\0\".as_ptr() as _);\n    unsafe {\n        ReportEventA(\n            HANDLE(event_log_handle.0),               //h_event_log: T0__,\n            ReportEvent_wType::EVENTLOG_WARNING_TYPE, // for type use EVENTLOG_WARNING_TYPE w_type: u16,\n            5,                                        // for category use \"Shell\" w_category: u16,\n            1,                                        // for ID use 1  dw_event_id: u32,\n            user_sid,                                 // lp_user_sid: *mut c_void,\n            1,                                        // w_num_strings: u16,\n            0,                                        // dw_data_size: u32,\n            &mut event_msg,                           // lp_strings: *mut PSTR,\n            std::ptr::null_mut(),                     // lp_raw_data: *mut c_void,\n        )\n    }\n    .ok()?;\n\n    Ok(())\n}\n\n#[cfg(not(windows))]\nfn main() {\n    println!(\"Not implemented\");\n}\n",
    "title": "Write to Windows event log",
    "url": "http://rosettacode.org/wiki/Write_to_Windows_event_log"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "XML/DOM serialization",
    "url": "http://rosettacode.org/wiki/XML/DOM_serialization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate xml; // provided by the xml-rs crate\nuse xml::{name::OwnedName, reader::EventReader, reader::XmlEvent};\n\nconst DOCUMENT: &str = r#\"\n<Students>\n  <Student Name=\"April\" Gender=\"F\" DateOfBirth=\"1989-01-02\" />\n  <Student Name=\"Bob\" Gender=\"M\"  DateOfBirth=\"1990-03-04\" />\n  <Student Name=\"Chad\" Gender=\"M\"  DateOfBirth=\"1991-05-06\" />\n  <Student Name=\"Dave\" Gender=\"M\"  DateOfBirth=\"1992-07-08\">\n    <Pet Type=\"dog\" Name=\"Rover\" />\n  </Student>\n  <Student DateOfBirth=\"1993-09-10\" Gender=\"F\" Name=\"&#x00C9;mily\" />\n</Students>\n\"#;\n\nfn main() -> Result<(), xml::reader::Error> {\n    let parser = EventReader::new(DOCUMENT.as_bytes());\n\n    let tag_name = OwnedName::local(\"Student\");\n    let attribute_name = OwnedName::local(\"Name\");\n\n    for event in parser {\n        match event? {\n            XmlEvent::StartElement {\n                name,\n                attributes,\n                ..\n            } if name == tag_name => {\n                if let Some(attribute) = attributes.iter().find(|&attr| attr.name == attribute_name) {\n                    println!(\"{}\", attribute.value);\n                }\n            }\n            _ => (),\n        }\n    }\n    Ok(())\n}",
    "title": "XML/Input",
    "url": "http://rosettacode.org/wiki/XML/Input"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::hash::BuildHasher;\nuse xml::writer::{EmitterConfig, XmlEvent};\n\n/// # Panics\n///  In case itt cannot write to the xml\n#[must_use]\npub fn characters_to_xml<S: BuildHasher>(characters: &HashMap<String, String, S>) -> String {\n    let mut output = Vec::new();\n    let mut writer = EmitterConfig::new()\n        .perform_indent(true)\n        .create_writer(&mut output);\n\n    writer\n        .write(XmlEvent::start_element(\"CharacterRemarks\"))\n        .unwrap();\n\n    for (character, line) in characters {\n        let element = XmlEvent::start_element(\"Character\").attr(\"name\", character);\n        writer.write(element).unwrap();\n        writer.write(XmlEvent::characters(line)).unwrap();\n        writer.write(XmlEvent::end_element()).unwrap();\n    }\n\n    writer.write(XmlEvent::end_element()).unwrap();\n    String::from_utf8(output).unwrap()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::characters_to_xml;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_xml_output() {\n        let mut input = HashMap::new();\n        input.insert(\n            \"April\".to_string(),\n            \"Bubbly: I'm > Tam and <= Emily\".to_string(),\n        );\n        input.insert(\n            \"Tam O'Shanter\".to_string(),\n            // Using raw string literals let's us use double quotes without escaping\n            r#\"Burns: \"When chapman billies leave the street ...\"\"#.to_string(),\n        );\n        input.insert(\"Emily\".to_string(), \"Short & shrift\".to_string());\n\n        let output = characters_to_xml(&input);\n\n        println!(\"{}\", output);\n        assert!(output.contains(\n            \"<Character name=\\\"Tam O&apos;Shanter\\\">Burns: \\\"When chapman \\\n             billies leave the street ...\\\"</Character>\"\n        ));\n        assert!(output\n            .contains(r#\"<Character name=\"April\">Bubbly: I'm > Tam and &lt;= Emily</Character>\"#));\n        assert!(output.contains(r#\"<Character name=\"Emily\">Short &amp; shrift</Character>\"#));\n    }\n}\n",
    "path": "tasks/xml-output",
    "remote_code": "extern crate xml;\n\nuse std::collections::HashMap;\nuse std::str;\n\nuse xml::writer::{EmitterConfig, XmlEvent};\n\nfn characters_to_xml(characters: HashMap<String, String>) -> String {\n    let mut output: Vec<u8> = Vec::new();\n    let mut writer = EmitterConfig::new()\n        .perform_indent(true)\n        .create_writer(&mut output);\n\n    writer\n        .write(XmlEvent::start_element(\"CharacterRemarks\"))\n        .unwrap();\n\n    for (character, line) in &characters {\n        let element = XmlEvent::start_element(\"Character\").attr(\"name\", character);\n        writer.write(element).unwrap();\n        writer.write(XmlEvent::characters(line)).unwrap();\n        writer.write(XmlEvent::end_element()).unwrap();\n    }\n\n    writer.write(XmlEvent::end_element()).unwrap();\n    str::from_utf8(&output).unwrap().to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::characters_to_xml;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_xml_output() {\n        let mut input = HashMap::new();\n        input.insert(\n            \"April\".to_string(),\n            \"Bubbly: I'm > Tam and <= Emily\".to_string(),\n        );\n        input.insert(\n            \"Tam O'Shanter\".to_string(),\n            \"Burns: \\\"When chapman billies leave the street ...\\\"\".to_string(),\n        );\n        input.insert(\"Emily\".to_string(), \"Short & shrift\".to_string());\n\n        let output = characters_to_xml(input);\n\n        println!(\"{}\", output);\n        assert!(output.contains(\n            \"<Character name=\\\"Tam O&apos;Shanter\\\">Burns: \\\"When chapman \\\n             billies leave the street ...\\\"</Character>\"\n        ));\n        assert!(output\n            .contains(\"<Character name=\\\"April\\\">Bubbly: I'm > Tam and &lt;= Emily</Character>\"));\n        assert!(output.contains(\"<Character name=\\\"Emily\\\">Short &amp; shrift</Character>\"));\n    }\n}",
    "title": "XML/Output",
    "url": "http://rosettacode.org/wiki/XML/Output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "XML/XPath",
    "url": "http://rosettacode.org/wiki/XML/XPath"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Xiaolin Wu's line algorithm",
    "url": "http://rosettacode.org/wiki/Xiaolin_Wu's_line_algorithm"
  },
  {
    "local_code": "#![allow(clippy::double_parens)]\n#![allow(clippy::type_complexity)]\n\nuse std::sync::Arc;\n\n// Arc<Box<Closure>>\nmacro_rules! abc {\n    ($x:expr) => {\n        Arc::new(Box::new($x))\n    };\n}\n\n#[derive(Clone)]\nenum Mu<T> {\n    Roll(Arc<Box<dyn Fn(Mu<T>) -> T>>),\n}\n\nfn unroll<T>(Mu::Roll(f): Mu<T>) -> Arc<Box<dyn Fn(Mu<T>) -> T>> {\n    Arc::clone(&f)\n}\n\npub type Func<A> = Arc<Box<dyn Fn(A) -> A>>;\npub type RecFunc<A> = Arc<Box<dyn Fn(Func<A>) -> Func<A>>>;\n\npub fn y<A: 'static>(f: RecFunc<A>) -> Func<A> {\n    let g: Arc<Box<dyn Fn(Mu<Func<A>>) -> Func<A>>> = abc!(move |x: Mu<Func<A>>| -> Func<A> {\n        let f = Arc::clone(&f);\n        abc!(move |a: A| -> A {\n            let f = Arc::clone(&f);\n            f(unroll(x.clone())(x.clone()))(a)\n        })\n    });\n    g(Mu::Roll(Arc::clone(&g)))\n}\n\n#[macro_export]\nmacro_rules! y {\n    (| $name:ident | $fun:tt) => {\n        y(abc!(|$name| abc!($fun)))\n    };\n}\n\nfn fac(n: u32) -> u32 {\n    let fn_: Func<u32> = y!(|f| (move |x| if x == 0 { 1 } else { f(x - 1) * x }));\n    fn_(n)\n}\n\nfn fib(n: u32) -> u32 {\n    let fn_: Func<u32> = y!(|f| (move |x| if x < 2 { x } else { f(x - 1) + f(x - 2) }));\n    fn_(n)\n}\n\nfn main() {\n    println!(\"{}\", fac(10));\n    println!(\"{}\", fib(10))\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn fac() {\n        assert_eq!(super::fac(10), 3628800);\n    }\n\n    #[test]\n    fn fib() {\n        assert_eq!(super::fib(10), 55);\n    }\n}\n",
    "path": "tasks/y-combinator",
    "remote_code": "\n//! A simple implementation of the Y Combinator:\n//! λf.(λx.xx)(λx.f(xx))\n//! <=> λf.(λx.f(xx))(λx.f(xx))\n\n/// A function type that takes its own type as an input is an infinite recursive type.\n/// We introduce the \"Apply\" trait, which will allow us to have an input with the same type as self, and break the recursion.\n/// The input is going to be a trait object that implements the desired function in the interface.\ntrait Apply<T, R> {\n    fn apply(&self, f: &dyn Apply<T, R>, t: T) -> R;\n}\n\n/// If we were to pass in self as f, we get:\n/// λf.λt.sft\n/// => λs.λt.sst [s/f]\n/// => λs.ss\nimpl<T, R, F> Apply<T, R> for F where F: Fn(&dyn Apply<T, R>, T) -> R {\n    fn apply(&self, f: &dyn Apply<T, R>, t: T) -> R {\n        self(f, t)\n    }\n}\n\n/// (λt(λx.(λy.xxy))(λx.(λy.f(λz.xxz)y)))t\n/// => (λx.xx)(λx.f(xx))\n/// => Yf\nfn y<T, R>(f: impl Fn(&dyn Fn(T) -> R, T) -> R) -> impl Fn(T) -> R {\n    move |t| (&|x: &dyn Apply<T, R>, y| x.apply(x, y))\n             (&|x: &dyn Apply<T, R>, y| f(&|z| x.apply(x, z), y), t)\n}\n\n/// Factorial of n.\nfn fac(n: usize) -> usize {\n    let almost_fac = |f: &dyn Fn(usize) -> usize, x| if x == 0 { 1 } else { x * f(x - 1) };\n    y(almost_fac)(n)\n}\n\n/// nth Fibonacci number.\nfn fib(n: usize) -> usize {\n    let almost_fib = |f: &dyn Fn((usize, usize, usize)) -> usize, (a0, a1, x)|\n        match x {\n            0 => a0,\n            1 => a1,\n            _ => f((a1, a0 + a1, x - 1)),\n        };\n\n    y(almost_fib)((1, 1, n))\n}\n\n/// Driver function.\nfn main() {\n    let n = 10;\n    println!(\"fac({}) = {}\", n, fac(n));\n    println!(\"fib({}) = {}\", n, fib(n));\n}\n\n",
    "title": "Y combinator",
    "url": "http://rosettacode.org/wiki/Y_combinator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Yahoo! search interface",
    "url": "http://rosettacode.org/wiki/Yahoo!_search_interface"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// [dependencies]\n// num = \"0.3\"\n// plotters = \"^0.2.15\"\n\nuse num::integer::gcd;\nuse plotters::prelude::*;\nuse std::collections::HashSet;\n\nfn yellowstone_sequence() -> impl std::iter::Iterator<Item = u32> {\n    let mut sequence: HashSet<u32> = HashSet::new();\n    let mut min = 1;\n    let mut n = 0;\n    let mut n1 = 0;\n    let mut n2 = 0;\n    std::iter::from_fn(move || {\n        n2 = n1;\n        n1 = n;\n        if n < 3 {\n            n += 1;\n        } else {\n            n = min;\n            while !(!sequence.contains(&n) && gcd(n1, n) == 1 && gcd(n2, n) > 1) {\n                n += 1;\n            }\n        }\n        sequence.insert(n);\n        while sequence.contains(&min) {\n            sequence.remove(&min);\n            min += 1;\n        }\n        Some(n)\n    })\n}\n\n// Based on the example in the \"Quick Start\" section of the README file for\n// the plotters library.\nfn plot_yellowstone(filename: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let root = BitMapBackend::new(filename, (800, 600)).into_drawing_area();\n    root.fill(&WHITE)?;\n    let mut chart = ChartBuilder::on(&root)\n        .caption(\"Yellowstone Sequence\", (\"sans-serif\", 24).into_font())\n        .margin(10)\n        .x_label_area_size(20)\n        .y_label_area_size(20)\n        .build_ranged(0usize..100usize, 0u32..180u32)?;\n    chart.configure_mesh().draw()?;\n    chart.draw_series(LineSeries::new(\n        yellowstone_sequence().take(100).enumerate(),\n        &BLUE,\n    ))?;\n    Ok(())\n}\n\nfn main() {\n    println!(\"First 30 Yellowstone numbers:\");\n    for y in yellowstone_sequence().take(30) {\n        print!(\"{} \", y);\n    }\n    println!();\n    match plot_yellowstone(\"yellowstone.png\") {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"Error: {}\", error),\n    }\n}",
    "title": "Yellowstone sequence",
    "url": "http://rosettacode.org/wiki/Yellowstone_sequence"
  },
  {
    "local_code": "// Creates a yin_yang.svg file. Rust version 1.58.0 or higher required\n\nuse svg::node::element::Path;\n\nfn main() {\n    let doc = svg::Document::new()\n        .add(yin_yang(15.0, 1.0).set(\"transform\", \"translate(20,20)\"))\n        .add(yin_yang(6.0, 1.0).set(\"transform\", \"translate(50,11)\"));\n    svg::save(\"yin_yang.svg\", &doc).unwrap();\n}\n/// th - the thickness of the outline around yang\nfn yin_yang(r: f32, th: f32) -> Path {\n    let (cr, cw, ccw) = (\",0,1,1,.1,0z\", \",0,0,1,0,\", \",0,0,0,0,\");\n    let d = format!(\"M0,{0} a{0},{0}{cr} M0,{1} \", r + th, -r / 3.0)\n        + &format!(\"a{0},{0}{cr} m0,{r} a{0},{0}{cr} M0,0 \", r / 6.0)\n        + &format!(\"A{0},{0}{ccw}{r} A{r},{r}{cw}-{r} A{0},{0}{cw}0\", r / 2.0); // main_circle + eyes + yang\n    Path::new().set(\"d\", d).set(\"fill-rule\", \"evenodd\")\n}\n",
    "path": "tasks/yin-and-yang",
    "remote_code": null,
    "title": "Yin and yang",
    "url": "http://rosettacode.org/wiki/Yin_and_yang"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zebra puzzle",
    "url": "http://rosettacode.org/wiki/Zebra_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zeckendorf arithmetic",
    "url": "http://rosettacode.org/wiki/Zeckendorf_arithmetic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zeckendorf number representation",
    "url": "http://rosettacode.org/wiki/Zeckendorf_number_representation"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Zero_to_the_zero_power\nfn main() {\n    println!(\"0 ^ 0 = {}\", 0i64.pow(0));\n}\n",
    "path": "tasks/zero-to-the-zero-power",
    "remote_code": "fn main() {\n    println!(\"{}\",0u32.pow(0));\n}",
    "title": "Zero to the zero power",
    "url": "http://rosettacode.org/wiki/Zero_to_the_zero_power"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zhang-Suen thinning algorithm",
    "url": "http://rosettacode.org/wiki/Zhang-Suen_thinning_algorithm"
  },
  {
    "local_code": "//! Implements with the sorting indexes algorithm explained in the [discussion page].\n//!\n//! [discussion page]:http://rosettacode.org/wiki/Talk:Zig-zag_matrix\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::iter::repeat;\n\n#[derive(Debug, PartialEq, Eq)]\nstruct SortIndex {\n    x: usize,\n    y: usize,\n}\n\nimpl SortIndex {\n    fn new(x: usize, y: usize) -> SortIndex {\n        SortIndex { x, y }\n    }\n}\n\nimpl PartialOrd for SortIndex {\n    fn partial_cmp(&self, other: &SortIndex) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SortIndex {\n    fn cmp(&self, other: &SortIndex) -> Ordering {\n        let lower = if self.x + self.y == other.x + other.y {\n            if (self.x + self.y) % 2 == 0 {\n                self.x < other.x\n            } else {\n                self.y < other.y\n            }\n        } else {\n            (self.x + self.y) < (other.x + other.y)\n        };\n\n        if lower {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\nfn zigzag(n: usize) -> Vec<Vec<usize>> {\n    let mut l: Vec<SortIndex> = (0..n * n).map(|i| SortIndex::new(i % n, i / n)).collect();\n    l.sort();\n\n    let init_vec = vec![0; n];\n    let mut result: Vec<Vec<usize>> = repeat(init_vec).take(n).collect();\n    for (i, &SortIndex { x, y }) in l.iter().enumerate() {\n        result[y][x] = i\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", zigzag(5));\n}\n\n#[test]\nfn result() {\n    let exp = vec![\n        vec![0, 1, 5, 6, 14],\n        vec![2, 4, 7, 13, 15],\n        vec![3, 8, 12, 16, 21],\n        vec![9, 11, 17, 20, 22],\n        vec![10, 18, 19, 23, 24],\n    ];\n    assert_eq!(zigzag(5), exp);\n}\n",
    "path": "tasks/zig-zag-matrix",
    "remote_code": "\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::iter::repeat;\n\n#[derive(Debug, PartialEq, Eq)]\nstruct SortIndex {\n    x: usize,\n    y: usize,\n}\n\nimpl SortIndex {\n    fn new(x: usize, y: usize) -> SortIndex {\n        SortIndex { x, y }\n    }\n}\n\nimpl PartialOrd for SortIndex {\n    fn partial_cmp(&self, other: &SortIndex) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SortIndex {\n    fn cmp(&self, other: &SortIndex) -> Ordering {\n        let lower = if self.x + self.y == other.x + other.y {\n            if (self.x + self.y) % 2 == 0 {\n                self.x < other.x\n            } else {\n                self.y < other.y\n            }\n        } else {\n            (self.x + self.y) < (other.x + other.y)\n        };\n\n        if lower {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\nfn zigzag(n: usize) -> Vec<Vec<usize>> {\n    let mut l: Vec<SortIndex> = (0..n * n).map(|i| SortIndex::new(i % n, i / n)).collect();\n    l.sort();\n\n    let init_vec = vec![0; n];\n    let mut result: Vec<Vec<usize>> = repeat(init_vec).take(n).collect();\n    for (i, &SortIndex { x, y }) in l.iter().enumerate() {\n        result[y][x] = i\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", zigzag(5));\n}\n\n",
    "title": "Zig-zag matrix",
    "url": "http://rosettacode.org/wiki/Zig-zag_matrix"
  },
  {
    "local_code": "use std::convert::TryInto;\n\n/// Gets all divisors of a number, including itself\nfn get_divisors(n: u32) -> Vec<u32> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\n/// Calculates whether the divisors can be partitioned into two disjoint\n/// sets that sum to the same value\nfn is_summable(x: i32, divisors: &[u32]) -> bool {\n    if !divisors.is_empty() {\n        if divisors.contains(&(x as u32)) {\n            return true;\n        } else if let Some((first, t)) = divisors.split_first() {\n            return is_summable(x - *first as i32, t) || is_summable(x, t);\n        }\n    }\n    false\n}\n\n/// Calculates whether the number is a Zumkeller number\n/// Zumkeller numbers are the set of numbers whose divisors can be partitioned\n/// into two disjoint sets that sum to the same value. Each sum must contain\n/// divisor values that are not in the other sum, and all of the divisors must\n/// be in one or the other.\nfn is_zumkeller_number(number: u32) -> bool {\n    if number % 18 == 6 || number % 18 == 12 {\n        return true;\n    }\n\n    let div = get_divisors(number);\n    let divisor_sum: u32 = div.iter().sum();\n    if divisor_sum == 0 {\n        return false;\n    }\n    if divisor_sum % 2 == 1 {\n        return false;\n    }\n\n    // numbers where n is odd and the abundance is even are Zumkeller numbers\n    let abundance = divisor_sum as i32 - 2 * number as i32;\n    if number % 2 == 1 && abundance > 0 && abundance % 2 == 0 {\n        return true;\n    }\n\n    let half = divisor_sum / 2;\n    return div.contains(&half)\n        || (div.iter().filter(|&&d| d < half).count() > 0\n            && is_summable(half.try_into().unwrap(), &div));\n}\n\nfn main() {\n    println!(\"\\nFirst 220 Zumkeller numbers:\");\n    let mut counter: u32 = 0;\n    let mut i: u32 = 0;\n    while counter < 220 {\n        if is_zumkeller_number(i) {\n            print!(\"{:>3}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 1;\n    }\n\n    println!(\"\\nFirst 40 odd Zumkeller numbers:\");\n    let mut counter: u32 = 0;\n    let mut i: u32 = 3;\n    while counter < 40 {\n        if is_zumkeller_number(i) {\n            print!(\"{:>5}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 2;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::is_zumkeller_number;\n\n    #[test]\n    fn test_is_zumkeller() {\n        assert_eq!(is_zumkeller_number(0), false);\n        assert_eq!(is_zumkeller_number(6), true);\n        assert_eq!(is_zumkeller_number(20), true);\n        assert_eq!(is_zumkeller_number(21), false);\n        assert_eq!(is_zumkeller_number(198), true);\n    }\n}\n",
    "path": "tasks/zumkeller-numbers",
    "remote_code": "\nuse std::convert::TryInto;\n\n/// Gets all divisors of a number, including itself\nfn get_divisors(n: u32) -> Vec<u32> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results.push(n);\n    results\n}\n\n/// Calculates whether the divisors can be partitioned into two disjoint\n/// sets that sum to the same value\nfn is_summable(x: i32, divisors: &[u32]) -> bool {\n    if !divisors.is_empty() {\n        if divisors.contains(&(x as u32)) {\n            return true;\n        } else if let Some((first, t)) = divisors.split_first() {\n            return is_summable(x - *first as i32, &t) || is_summable(x, &t);\n        }\n    }\n    false\n}\n\n/// Calculates whether the number is a Zumkeller number\n/// Zumkeller numbers are the set of numbers whose divisors can be partitioned\n/// into two disjoint sets that sum to the same value. Each sum must contain\n/// divisor values that are not in the other sum, and all of the divisors must\n/// be in one or the other.\nfn is_zumkeller_number(number: u32) -> bool {\n    if number % 18 == 6 || number % 18 == 12 {\n        return true;\n    }\n\n    let div = get_divisors(number);\n    let divisor_sum: u32 = div.iter().sum();\n    if divisor_sum == 0 {\n        return false;\n    }\n    if divisor_sum % 2 == 1 {\n        return false;\n    }\n\n    // numbers where n is odd and the abundance is even are Zumkeller numbers\n    let abundance = divisor_sum as i32 - 2 * number as i32;\n    if number % 2 == 1 && abundance > 0 && abundance % 2 == 0 {\n        return true;\n    }\n\n    let half = divisor_sum / 2;\n    return div.contains(&half)\n        || (div.iter().filter(|&&d| d < half).count() > 0\n            && is_summable(half.try_into().unwrap(), &div));\n}\n\nfn main() {\n    println!(\"\\nFirst 220 Zumkeller numbers:\");\n    let mut counter: u32 = 0;\n    let mut i: u32 = 0;\n    while counter < 220 {\n        if is_zumkeller_number(i) {\n            print!(\"{:>3}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 1;\n    }\n\n    println!(\"\\nFirst 40 odd Zumkeller numbers:\");\n    let mut counter: u32 = 0;\n    let mut i: u32 = 3;\n    while counter < 40 {\n        if is_zumkeller_number(i) {\n            print!(\"{:>5}\", i);\n            counter += 1;\n            print!(\"{}\", if counter % 20 == 0 { \"\\n\" } else { \",\" });\n        }\n        i += 2;\n    }\n}\n",
    "title": "Zumkeller numbers",
    "url": "http://rosettacode.org/wiki/Zumkeller_numbers"
  }
]